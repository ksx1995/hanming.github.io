<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="纳兰寒明的博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->

<meta name="keywords" content="Android" />


<meta name="description" content="1. ViewStub的应用&emsp;&emsp;在不显示布局时我们会使用 View.GONE 和 View.VISIBLE 属性去控制View的布局显示，但是在该使用过程中，该View的对象..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    Android学习笔记 |
    
    纳兰寒明的博客
</title>

<link rel="alternate" href="/atom.xml" title="纳兰寒明的博客" type="application/atom+xml">


<link rel="icon" href="/avatar.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 5.4.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='纳兰寒明'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <h2>
                我有一个梦想
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">
                        纳兰寒明的博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/前端/"><i class="fa "></i>
                                前端</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/后端/"><i class="fa "></i>
                                后端</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/移动端/"><i class="fa "></i>
                                移动端</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/随笔/"><i class="fa "></i>
                                随笔</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时光轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Android学习笔记">
            
            Android学习笔记
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-none-link" href="/tags/Android/" rel="tag">Android</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2019/05/24</span>
    </span>
    
    
</div>
        
        
        <p class="fa fa-exclamation-triangle warning">
            本文于<strong>
                762</strong>
            天之前发表，文中内容可能已经过时。
        </p>
        
    </div>
    
    <div class="post-body post-content">
        <h2 id="1-ViewStub的应用"><a href="#1-ViewStub的应用" class="headerlink" title="1. ViewStub的应用"></a>1. ViewStub的应用</h2><p>&emsp;&emsp;在不显示布局时我们会使用<font color=#00099> <em>View.GONE</em> </font>和<font color=#00099> <em>View.VISIBLE</em> </font>属性去控制View的布局显示，但是在该使用过程中，该View的对象还是会被建立（只要通过inflate就会创建对象），被实例化，所以会耗费内存。</p>
<p>&emsp;&emsp;这时候就会引入ViewStub这个控件，该控件是一个轻量级的View，它是一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。</p>
<p>&emsp;&emsp;其原理就是通过控制ViewStub来控制View的对象的创建和渲染</p>
<p>特点：</p>
<ol>
<li>ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了。</li>
<li><p>ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。</p>
<p>因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。</p>
<p>所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。ViewStub是能被使用一次。一旦被指定infate后，其存在的特性就会消失。</p>
</li>
</ol>
<h2 id="2-SurfaveView控件的理解"><a href="#2-SurfaveView控件的理解" class="headerlink" title="2. SurfaveView控件的理解"></a>2. SurfaveView控件的理解</h2><h2 id="3-AOSP-Android-OPen-Source-Project-Android开源工程"><a href="#3-AOSP-Android-OPen-Source-Project-Android开源工程" class="headerlink" title="3. AOSP(Android OPen Source Project)Android开源工程"></a>3. AOSP(Android OPen Source Project)Android开源工程</h2><h2 id="4-内存泄露："><a href="#4-内存泄露：" class="headerlink" title="4.内存泄露："></a>4.内存泄露：</h2><p> <strong>static所修饰的方法和变量拥有和app一样长的生命周期</strong></p>
<ul>
<li>静态变量导致的内存泄漏：<br>静态变量（方法）中对context的使用，导致Activity不能被回收</li>
<li>单例模式导致的内存泄露：<br>单例中同样使用了static方法，对context的使用不能被释放</li>
</ul>
<p>上述两种的解决方法都为传入context.getApplicationContext()，其存在的生命周期和app生命周期一样长。</p>
<ul>
<li>非静态内部类持有外部引用导致的内存泄漏：（非静态内部类和外部类相互绑定，而静态内部类与外部类相互分离）<br>内部类持有外部类的引用，外部类无法正常回收（将其改为静态内部类）<br>  Handler引起的内存泄漏：<ol>
<li>静态内部类+弱引用：<br>static  +   WeakReference&lt;&gt;()</li>
<li>Handler.Callback的方式</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  Handler mHandler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">                mTV_incloud_merge.setText((String) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>流文件打开后要close()，动画要cancel()，数据库的使用要关闭</li>
<li>Listview的优化，ViewHolder对item的复用</li>
<li>Bitmap的三级缓存和压缩技术</li>
</ul>
<h2 id="5-Android进阶——Android消息机制之Looper、Handler、MessageQueen"><a href="#5-Android进阶——Android消息机制之Looper、Handler、MessageQueen" class="headerlink" title="5. Android进阶——Android消息机制之Looper、Handler、MessageQueen"></a>5. <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30379689/article/details/53394061">Android进阶——Android消息机制之Looper、Handler、MessageQueen</a></h2><p><img src="/img/handler.png" alt="最好的流程图"></p>
<h4 id="1-Handler涉及哪些类，各自功能是什么？"><a href="#1-Handler涉及哪些类，各自功能是什么？" class="headerlink" title="1. Handler涉及哪些类，各自功能是什么？"></a>1. Handler涉及哪些类，各自功能是什么？</h4><ul>
<li>Handler：将Message对象发送到MessageQueue中去，同时将自己的引用赋值给Message#target.</li>
<li>Lopper：将Message对象从MessageQueue中取出来，并交给Handler#dispatchMessage(Message)方法，不是调用Handler#handleMessage(Message)方法</li>
<li>MessageQueue：负责插入和取出Message</li>
<li>Message：所传递的信息的载体</li>
<li>ThreadLocal:</li>
</ul>
<h4 id="2-发送消息的方式"><a href="#2-发送消息的方式" class="headerlink" title="2. 发送消息的方式"></a>2. 发送消息的方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//常用</span><br><span class="line">sendMessage(Message msg)</span><br><span class="line">sendMessageDelayed(Message msg, long uptimeMillis)</span><br><span class="line">post(Runnable r)</span><br><span class="line">postDelayed(Runnable r, long uptimeMillis)</span><br><span class="line">sendMessageAtTime(Message msg,long when)</span><br><span class="line">//不常用</span><br><span class="line">sendEmptyMessage(int what)</span><br><span class="line">sendEmptyMessageDelayed(int what, long uptimeMillis)</span><br><span class="line">sendEmptyMessageAtTime(int what, long when)</span><br></pre></td></tr></table></figure>
<h4 id="3-MessageQueue中的Message是有序的吗？根据什么排序"><a href="#3-MessageQueue中的Message是有序的吗？根据什么排序" class="headerlink" title="3. MessageQueue中的Message是有序的吗？根据什么排序?"></a>3. MessageQueue中的Message是有序的吗？根据什么排序?</h4><ul>
<li>是有序的，根据Message#when排序的</li>
<li>Message#when是一个时间，用于表示Message期望被分发的时间，该值是SystemClock#uptimeMillis()与delayMillis之和</li>
<li>因为System.currentTimemillis()可以被修改，所以不用此表示</li>
</ul>
<h4 id="4-子线程可以创建Handler对象吗？"><a href="#4-子线程可以创建Handler对象吗？" class="headerlink" title="4. 子线程可以创建Handler对象吗？"></a>4. 子线程可以创建Handler对象吗？</h4><p> 不能直接调用Handler的无参构造方法</p>
<ul>
<li>先要调用Looper.prepare()在当前线程初始化一个Looper</li>
<li>通过构造方法传入一个Looper</li>
<li>主线程调用Handler的无参构造会存在一个自动绑定的过程</li>
</ul>
<h4 id="5-Looper是如何与Thread关联的"><a href="#5-Looper是如何与Thread关联的" class="headerlink" title="5. Looper是如何与Thread关联的?"></a>5. Looper是如何与Thread关联的?</h4><p>通过ThreadLocal关联的</p>
<h4 id="6-Handler有哪些构造方法"><a href="#6-Handler有哪些构造方法" class="headerlink" title="6.Handler有哪些构造方法"></a>6.Handler有哪些构造方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">    this(null, false);</span><br><span class="line">&#125;</span><br><span class="line">public Handler(Callback callback) &#123;</span><br><span class="line">    this(callback, false);</span><br><span class="line">&#125;</span><br><span class="line">public Handler(Looper looper) &#123;</span><br><span class="line">    this(looper, null, false);</span><br><span class="line">&#125;</span><br><span class="line">public Handler(Looper looper, Callback callback) &#123;</span><br><span class="line">    this(looper, callback, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-子线程如何获取当前线程的Looper"><a href="#7-子线程如何获取当前线程的Looper" class="headerlink" title="7. 子线程如何获取当前线程的Looper"></a>7. 子线程如何获取当前线程的Looper</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.myLooper()</span><br></pre></td></tr></table></figure>
<p>内部原理就是同过上面提到的sThreadLocal#get()来获取Looper</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Looper.java:203</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-如何在任意先成获取主线程的Looper"><a href="#8-如何在任意先成获取主线程的Looper" class="headerlink" title="8. 如何在任意先成获取主线程的Looper"></a>8. 如何在任意先成获取主线程的Looper</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper()</span><br></pre></td></tr></table></figure>
<h4 id="9-如何判断当前线程是不是主线程"><a href="#9-如何判断当前线程是不是主线程" class="headerlink" title="9. 如何判断当前线程是不是主线程"></a>9. 如何判断当前线程是不是主线程</h4><p>方法一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.myLooper() == Looper.getMainLooper()</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().getThread() == Thread.currentThread()</span><br></pre></td></tr></table></figure>
<p>方法三： 方法二的简化版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().isCurrentThread()</span><br></pre></td></tr></table></figure>
<h4 id="10-Looper-loop-会退出吗？"><a href="#10-Looper-loop-会退出吗？" class="headerlink" title="10. Looper.loop()会退出吗？"></a>10. Looper.loop()会退出吗？</h4><p>不会自动推出，通过调用Looper#quit()或者Looper#quitSafely()让他退出</p>
<p>两个方法都是调用了 MessageQueue#quit(boolean) 方法，当 MessageQueue#next() 方法发现已经调用过  MessageQueue#quit(boolean)  时会 return null 结束当前调用，否则的话即使 MessageQueue 已经是空的了也会阻塞等待。</p>
<h4 id="11-Looper-loop-方法是一个死循环为什么不会阻塞APP"><a href="#11-Looper-loop-方法是一个死循环为什么不会阻塞APP" class="headerlink" title="11. Looper.loop() 方法是一个死循环为什么不会阻塞APP"></a>11. Looper.loop() 方法是一个死循环为什么不会阻塞APP</h4><h2 id="6-Http协议"><a href="#6-Http协议" class="headerlink" title="6. Http协议"></a>6. Http协议</h2><blockquote>
<ul>
<li>HTTP 0.9 这个版本只有GET方法</li>
<li>1.0 这个版本有GET HEAD POST这三个方法</li>
<li>HTTP 1.1 这个版本是当前版本，包含GET HEAD POST OPTIONS PUT DELETE TRACE CONNECT这8个方法</li>
</ul>
</blockquote>
<ul>
<li>报文：HTTP应用程序之间发送的数据块（起始行，首部，主体）</li>
</ul>
<p>Http请求所经历的过程</p>
<p>建立tcp连接（三次握手） &gt;&gt; 客户端向服务端发送请求命令 &gt;&gt; 客户端发送请求头信息 &gt;&gt; 服务器应答 &gt;&gt; 服务器应答头信息 &gt;&gt; 服务器向客户端发送数据 &gt;&gt; 服务器关闭tcp连接</p>
<p><img src="/img/tcp.png" alt=""></p>
<ul>
<li><p>请求方法（Method）：GET和POST、 不常用的有PUT，DELETE、HEAD、options</p>
<p>HEAD 与 GET 的使用方式完全相同。<br>区别在于，HEAD 请求的返回响应中没有 Body<br>用途：比如下载需求，返回的 Headers 中有下载内容的大小，可以用于显示进度。</p>
</li>
</ul>
<p>GET、PUT、DELETE 都是幂等操作，POST不是幂等的，不安全</p>
<p>PUT、DELETE除第一种方法外，只能通过先在服务端重写HTTP请求方法（自定义HttpMessageHandler来实现），然后再在客户端请求报文头指定“X-HTTP-Method-Override”值为PUT或DELETE来实现；</p>
<p>PUT 请求，客户端方法与POST方法相同，只是TYPE指定为：PUT；服务器端与POST方法相同；</p>
<p>DELETE请求，客户端方法与GET方法相同，只是TYPE指定为：DELETE；服务器端与GET方法相</p>
<h3 id="PUT和POST的区别"><a href="#PUT和POST的区别" class="headerlink" title="PUT和POST的区别"></a>PUT和POST的区别</h3><p>1、PUT请求时，如果用相同参数访问二次接口，Post 仅会产生一条记录</p>
<p>使用场合例如：</p>
<p>用户的账户二维码只和用户关联，而且是一一对应的关系，此时这个api就可以用PUT</p>
<p>2、POST请求时，如果用相同参数访问二次接口，Post 会产生多条记录</p>
<p>使用场合例如：</p>
<p>在我们的支付系统中，一个api的功能是创建收款金额二维码，它和金额相关，每个用户可以有多个二维码，如果连续调用则会创建新的二维码，这个时候就用POST</p>
<h3 id="Get请求添加body请求吗？"><a href="#Get请求添加body请求吗？" class="headerlink" title="Get请求添加body请求吗？"></a>Get请求添加body请求吗？</h3><p>在规定 HTTP 语义及内容的 RFC 7231 中，并未限制 GET 请求中是否允许携带交互数据！所以，有些 HTTP 服务允许这种行为，而另外一些（特别是缓存代理）则不允许这种行为。</p>
<p>Apache Http Client 和  OkHttpClient 都不支持  GET 请求发送 Body 数据，而 AsyncHttpClient 是可以的。</p>
<p>所以一般情况下，get请求不使用body进行数据传输，一般是拼接到url中实现</p>
<h3 id="options的主要用途"><a href="#options的主要用途" class="headerlink" title="options的主要用途"></a>options的主要用途</h3><p>OPTIONS请求方法的主要用途有两个：</p>
<p>1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。</p>
<p>2、用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。</p>
<h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>TRACE方法被用于激发一个远程的，应用层的请求消息回路（译注：TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路，）。最后的接收者或者是接收请求里Max-Forwards头域值为0源服务器或者是代理服务器或者是网关。TRACE请求不能包含一个实体。</p>
<p>TRACE方法允许客户端知道请求链的另一端接收什么，并且利用那些数据去测试或诊断。Via头域值（见14.45）有特殊的用途，因为它可以作为请求链的跟踪信息。利用Max-Forwards头域允许客户端限制请求链的长度去测试一串代理服务器是否在无限回路里转发消息。</p>
<p>如果请求是有效的，响应应该在响应实体主体里包含整个请求消息，并且响应应该包含一个Content-Type头域值为”message/http”的头域。TRACE方法的响应不能不缓存。</p>
<h3 id="CONNECT（连接）"><a href="#CONNECT（连接）" class="headerlink" title="CONNECT（连接）"></a>CONNECT（连接）</h3><p>HTTP1.1协议规范保留了CONNECT方法，此方法是为了能用于能动态切换到隧道的代理服务器（proxy，译注：可以为代理，也可以是代理服务器）。</p>
<ul>
<li>状态码：</li>
</ul>
<p>1xx:临时性消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100：继续发送</span><br><span class="line">101：正在切换协议</span><br></pre></td></tr></table></figure>
<p>2xx:成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200：OK (最常见) </span><br><span class="line">201：创建成功</span><br></pre></td></tr></table></figure>
<p>3xx:重定向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">301：域名永久移动</span><br><span class="line">302：暂时移动</span><br><span class="line">304：内容未改变，请求被重定向到客户端本地缓存</span><br></pre></td></tr></table></figure>
<p>4xx:客户端错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">400：客户端请求错误，服务器不理解请求的语法。</span><br><span class="line">401：未授权，要求进行身份验证。</span><br><span class="line">403：被禁止，服务器拒绝请求。</span><br><span class="line">404：找不到内容，服务器找不到请求的网页。(最常见)</span><br></pre></td></tr></table></figure>
<p>5xx:服务器错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">500：服务器内部错误 (最常见)</span><br><span class="line">503：服务不可用</span><br></pre></td></tr></table></figure>
<p>http协议osi七层协议和TCP/IP五层协议<br><img src="/img/https.png" alt=""></p>
<blockquote>
<p>HTTP使用80端口 <br/><br>HTTPS使用443端口</p>
</blockquote>
<h2 id="7-Https协议"><a href="#7-Https协议" class="headerlink" title="7.Https协议"></a>7.Https协议</h2><h4 id="协议过程，中间人攻击"><a href="#协议过程，中间人攻击" class="headerlink" title="协议过程，中间人攻击"></a>协议过程，中间人攻击</h4><p>缺点：</p>
<blockquote>
<p>证书费用高 <br/> 访问速度慢</p>
</blockquote>
<p>Hypertext Transfer Protocol Secure  缩写：HTTPS<br>Https经Http进行通信，但利用SSL/TLS来加密数据包</p>
<p><img src="/img/https1.png" alt=""></p>
<p>TLS/SSL协议主要依赖于三类基本算法：散列函数Hash、对称加密和非对称加密。</p>
<blockquote>
<p>非对称加密：身份认证和密钥协商（RSA）<br>  对称加密：对数据进行加密（AES） <br> 散列函数加密：验证信息的完整性（MD5,SHA1,SHA256）</p>
</blockquote>
<p><img src="/img/tts.png" alt=""></p>
<p>CA证书验证机制，解决中间人攻击的方式</p>
<p><img src="/img/ca.png" alt=""></p>
<p>https的SSL/TSL密钥是在应用层和传输层之间的<br><img src="/img/encode.png" alt=""></p>
<ul>
<li>申请证书不需要提供私钥，<strong>确保私钥永远只能服务器掌握</strong></li>
<li>证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名</li>
<li>内置CA对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书</li>
<li><strong>证书=公钥+申请者与颁发者信息+签名</strong></li>
<li><strong>公钥放在数字证书中。只有证书是可信的，公钥就是可信的。</strong></li>
</ul>
<p><img src="/img/ca1.png" alt=""></p>
<ul>
<li>服务器证书server.pem的签发者为中间证书机构inter，inter根据证书inter.pem验证server.pem确实为自己签发的有效证书</li>
<li>中间证书inter.pem的签发CA为root,root根据root.pem验证inter.pem为自己签发的合法证书</li>
<li>客户端内置新人CA的root.pem证书，因此服务器证书server.pem的被信任</li>
</ul>
<p>https的加密过程<br><img src="/img/https-encode.png" alt=""></p>
<h2 id="8-Gradle"><a href="#8-Gradle" class="headerlink" title="8.Gradle"></a>8.Gradle</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ant: 长江后浪推前浪，前浪已经over了</span><br><span class="line">|---编译、测试、打包</span><br><span class="line"></span><br><span class="line">Maven:使用xml标记构建脚本</span><br><span class="line">|---依赖管理、编译、测试、打包、发布</span><br><span class="line"></span><br><span class="line">Gradle:使用Groovy语言构建脚本</span><br><span class="line">|---依赖管理、编译、测试、打包、发布、灵活的脚本</span><br></pre></td></tr></table></figure>
<p>Gradle：是一个基于Groovy语言的开源项目自动化构建工具</p>
<p>Groovy: 基于java虚拟机的动态语言、面向对象/脚本，完全兼容Java语法</p>
<p><img src="/img/gradle.png" alt="构建的生命周期"></p>
<h2 id="9-ClassLoader"><a href="#9-ClassLoader" class="headerlink" title="9. ClassLoader"></a>9. ClassLoader</h2><h3 id="插件化技术的核心"><a href="#插件化技术的核心" class="headerlink" title="插件化技术的核心"></a>插件化技术的核心</h3><ol>
<li>作用：<br>Android虚拟机运行的Dex字节码（将Class文件合并优化生成的产物），ClassLoader用来加载dex文件。</li>
<li>委托双亲机制：顶层（父类）无法加载这个类，则由由自己加载，如果还加载不到，则会报ClassNotFound错误。（可以用爸爸的钱就绝对不用自己的钱，如果爸爸没有钱，再用自己的， 如果自己还是没有钱，那么就classnotfound异常）</li>
</ol>
<h2 id="10-Android原生与js交互"><a href="#10-Android原生与js交互" class="headerlink" title="10. Android原生与js交互"></a>10. Android原生与js交互</h2><h3 id="一、js调用Android方法"><a href="#一、js调用Android方法" class="headerlink" title="一、js调用Android方法"></a>一、js调用Android方法</h3><h4 id="方法一：通过-Webview-的-addJavascriptInterface-进行对象映射"><a href="#方法一：通过-Webview-的-addJavascriptInterface-进行对象映射" class="headerlink" title="方法一：通过 Webview 的 addJavascriptInterface() 进行对象映射"></a>方法一：通过 Webview 的 addJavascriptInterface() 进行对象映射</h4><blockquote>
<p>优点：使用简单，仅将Android对象和JS对象映射即可 <br> 缺点：存在漏洞问题</p>
</blockquote>
<p>1）允许WebView加载JS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.getSettings().setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure>
<p>2）编写JS接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class JsInterface &#123;</span><br><span class="line">    private static final String TAG = &quot;JsInterface&quot;;</span><br><span class="line">    private JsBridge jsBridge;</span><br><span class="line">    public JsInterface(JsBridge jsBridge) &#123;</span><br><span class="line">        this.jsBridge = jsBridge;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 这个方法由 JS 调用， 不在主线程执行</span><br><span class="line">     *</span><br><span class="line">     * @param value</span><br><span class="line">     */</span><br><span class="line">    @JavascriptInterface</span><br><span class="line">    public void callAndroid(String value) &#123;</span><br><span class="line">        Log.i(TAG, &quot;value = &quot; + value);</span><br><span class="line">        jsBridge.setTextValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3）给WebView添加JS接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">webView.addJavascriptInterface(new JsInterface(this), &quot;launcher&quot;);// 此处的 launcher 可以自定义，最终是 JS 中要使用的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4）js代码中调用java方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (window.launcher)&#123; // 判断 launcher 对象是否存在</span><br><span class="line">	// 此处的 launcher 要和 第3步中定义的 launcher 保持一致</span><br><span class="line">    // JS 调用 Android 的方法</span><br><span class="line">    launcher.callAndroid(str);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    alert(&quot;launcher not found!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="方法二：通过-WebViewClient-的-shouldOverrideUrlLoading-方法回调拦截-url"><a href="#方法二：通过-WebViewClient-的-shouldOverrideUrlLoading-方法回调拦截-url" class="headerlink" title="方法二：通过 WebViewClient 的 shouldOverrideUrlLoading() 方法回调拦截 url"></a>方法二：通过 WebViewClient 的 shouldOverrideUrlLoading() 方法回调拦截 url</h4><blockquote>
<p>优点：不存在方式一的漏洞 <br> 缺点：JS获取Android方法的返回值复杂</p>
</blockquote>
<p>1）JS代码中，约定协议</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function callAndroid()&#123;</span><br><span class="line">    // 约定的 url 协议为：js://webview?arg1=111&amp;arg2=222</span><br><span class="line">    document.location = &quot;js://webview?arg1=&quot;+inputEle.value+&quot;&amp;arg2=222&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2）Android 代码中，通过设置 WebViewClient 对协议进行拦截处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">        // 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span><br><span class="line">        // 例如：url = &quot;js://webview?arg1=111&amp;arg2=222&quot;</span><br><span class="line">        Uri uri = Uri.parse(url);</span><br><span class="line">        // 如果url的协议 = 预先约定的 js 协议</span><br><span class="line">        if (uri.getScheme().equals(&quot;js&quot;)) &#123;</span><br><span class="line">            // 拦截url,下面JS开始调用Android需要的方法</span><br><span class="line">            if (uri.getAuthority().equals(&quot;webview&quot;)) &#123;</span><br><span class="line">                // 执行JS所需要调用的逻辑</span><br><span class="line">                Log.e(&quot;TAG&quot;, &quot;JS 调用了 Android 的方法&quot;);</span><br><span class="line">                Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">                Iterator&lt;String&gt; it = collection.iterator();</span><br><span class="line">                String result = &quot;&quot;;</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    result += uri.getQueryParameter(it.next()) + &quot;,&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                tv_result.setText(result);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.shouldOverrideUrlLoading(view, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="方法三：通过-WebChromeClient-的-onJsAlert-、-onJsConfirm-、-onJsPrompt（）方法回调拦截-JS-对话框-alert-、-confirm-、-prompt（）-消息"><a href="#方法三：通过-WebChromeClient-的-onJsAlert-、-onJsConfirm-、-onJsPrompt（）方法回调拦截-JS-对话框-alert-、-confirm-、-prompt（）-消息" class="headerlink" title="方法三：通过 WebChromeClient 的 onJsAlert() 、 onJsConfirm() 、 onJsPrompt（）方法回调拦截 JS 对话框 alert() 、 confirm() 、 prompt（） 消息"></a>方法三：通过 WebChromeClient 的 onJsAlert() 、 onJsConfirm() 、 onJsPrompt（）方法回调拦截 JS 对话框 alert() 、 confirm() 、 prompt（） 消息</h4><p>1）JS代码中，约定协议</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 调用 prompt()</span><br><span class="line">var result=prompt(&quot;js://prompt?arg1=&quot;+inputEle.value+&quot;&amp;arg2=222&quot;);</span><br><span class="line">alert(&quot;prompt：&quot; + result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2）Android 代码中，通过设置 WebChromeClient 对协议进行拦截处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebChromeClient(new WebChromeClient() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;</span><br><span class="line">        // 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span><br><span class="line">        // 例如：url = &quot;js://webview?arg1=111&amp;arg2=222&quot;</span><br><span class="line">        Uri uri = Uri.parse(message);</span><br><span class="line">        Log.e(&quot;TAG&quot;, &quot;----onJsPrompt---&gt;&gt;&quot; + url + &quot;,&quot; + message);</span><br><span class="line">        // 如果url的协议 = 预先约定的 js 协议</span><br><span class="line">        if (uri.getScheme().equals(&quot;js&quot;)) &#123;</span><br><span class="line">            // 拦截url,下面JS开始调用Android需要的方法</span><br><span class="line">            if (uri.getAuthority().equals(&quot;prompt&quot;)) &#123;</span><br><span class="line">                // 执行JS所需要调用的逻辑</span><br><span class="line">                Log.e(&quot;TAG&quot;, &quot;JS 调用了 Android 的方法&quot;);</span><br><span class="line">                Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">                Iterator&lt;String&gt; it = collection.iterator();</span><br><span class="line">                String result2 = &quot;&quot;;</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    result2 += uri.getQueryParameter(it.next()) + &quot;,&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                tv_result.setText(result2);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onJsPrompt(view, url, message, defaultValue, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123;</span><br><span class="line">        Log.e(&quot;TAG&quot;, &quot;----onJsAlert---&gt;&gt;&quot; + url+ &quot;,&quot; + message);</span><br><span class="line">        return super.onJsAlert(view, url, message, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123;</span><br><span class="line">        Log.e(&quot;TAG&quot;, &quot;----onJsConfirm---&gt;&gt;&quot; + url+ &quot;,&quot; + message);</span><br><span class="line">        return super.onJsConfirm(view, url, message, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二、Android调用JS方法"><a href="#二、Android调用JS方法" class="headerlink" title="二、Android调用JS方法"></a>二、Android调用JS方法</h3><h4 id="方法一：通过WebView的loadUrl"><a href="#方法一：通过WebView的loadUrl" class="headerlink" title="方法一：通过WebView的loadUrl()"></a>方法一：通过WebView的loadUrl()</h4><p>1）编写JS方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var callJS = function(str)&#123;</span><br><span class="line">    inputEle.value = str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2）使用webView.loadUrl()调用JS方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Android 调用 JS 方法</span><br><span class="line">webView.loadUrl(&quot;javascript:if(window.callJS)&#123;window.callJS(&#x27;&quot; + str + &quot;&#x27;);&#125;&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法二：-通过-WebView-的-evaluateJavascript"><a href="#方法二：-通过-WebView-的-evaluateJavascript" class="headerlink" title="方法二： 通过 WebView 的 evaluateJavascript()"></a>方法二： 通过 WebView 的 evaluateJavascript()</h3><blockquote>
<ul>
<li>该方法比第一种方法效率更高，使用更简洁；</li>
<li>该方法执行不会刷新页面，而第一种方法（ loadUrl ）则会；</li>
<li>Android 4.4 以后才能使用。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    webView.evaluateJavascript(&quot;javascript:if(window.callJS)&#123;window.callJS(&#x27;&quot; + str + &quot;&#x27;);&#125;&quot;, new ValueCallback&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onReceiveValue(String value) &#123;</span><br><span class="line">            Log.e(&quot;TAG&quot;, &quot;---------&gt;&gt;&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="11-RecyclerView缓存机制"><a href="#11-RecyclerView缓存机制" class="headerlink" title="11.RecyclerView缓存机制"></a>11.<a target="_blank" rel="noopener" href="https://juejin.im/post/5c696ba9e51d457f136d24ff?utm_source=gold_browser_extension#heading-6">RecyclerView缓存机制</a></h2><h4 id="缓存优先级（从高到低）"><a href="#缓存优先级（从高到低）" class="headerlink" title="缓存优先级（从高到低）"></a>缓存优先级（从高到低）</h4><ul>
<li>mAttachedScrap获取</li>
<li>mCachedViews获取</li>
<li>mRecyclerPool获取</li>
</ul>
<ol>
<li>在RecyclerView中，并不是每次绘制表项，都会重新创建ViewHolder对象，也不是每次都会重新绑定ViewHolder数据</li>
<li>RecyclerView通过Recycler获得下一个待绘制表项</li>
<li>Recycler有4个层次用于缓存ViewHolder对象、优先级从高到低依次为ArrayList<ViewHolder> mAttachedScrap、ArrayList<ViewHolder> mCachedViews、ViewCacheExtension mViewCacheExtension、RecycledViewPool mRecyclerPool。如果四层缓存都未命中，则重新创建饼绑定ViewHolder对象</li>
<li>RecyclerViewPool对ViewHolder按viewType分类存储（通过SparseArray），同类ViewHolder存储在默认大小为5的ArrayList中</li>
<li>葱mRecyclerPool中复用的ViewHolder需要重新绑定数据，从mAttachedScrap中复用的ViewHolder不需要重新创建也不需要重新绑定数据。</li>
</ol>
<h2 id="12-性能优化"><a href="#12-性能优化" class="headerlink" title="12.性能优化"></a>12.性能优化</h2><ul>
<li>启动速度</li>
</ul>
<p><img src="/img/speed.png" alt=""></p>
<ul>
<li>页面显示速度<br>优化原因（即 页面显示速度慢的原因） a. 页面需绘制的内容（布局 &amp; 控件）太多，从而导致页面测量时间过长 b. 绘制效率过低，从而导致绘制时间过长</li>
</ul>
<ol>
<li>降低onDraw()方法的复杂度</li>
<li>避免过度绘制(Overdraw)</li>
<li>避免嵌套布局，复杂布局，简化布局，使用 &lt; viewStub/&gt; &lt; include/&gt; &lt; merge/&gt;等标签布局</li>
<li>布局属性 wrap_content 会增加布局测量时计算成本，应尽可能少用</li>
</ol>
<ul>
<li>响应速度</li>
</ul>
<blockquote>
<p>优化方案：使用多线程，将大量 &amp; 耗时操作放在工作线程中执行</p>
</blockquote>
<ol>
<li>多线程的方式 包括：AsyncTask、继承 Thread类、实现 Runnable接口、Handler消息机制、HandlerThread等</li>
<li>注：实际开发中，当一个进程发生了ANR后，系统会在 /data/anr目录下创建一个文件 traces.txt，通过分析该文件可定位出ANR的原因</li>
</ol>
<p><img src="/img/thread.png" alt=""></p>
<ul>
<li>稳定性<br><img src="/img/android1.png" alt="稳定性的性能优化"></li>
<li>内存优化          <ol>
<li>优化原因 避免因不正确使用内存 &amp; 缺乏管理，从而出现 内存泄露（ML）、内存溢出（OOM）、内存空间占用过大 等问题，最终导致应用程序崩溃（Crash）</li>
</ol>
</li>
</ul>
<p><img src="/img/android2.png" alt="">   </p>
<ol start="2">
<li>内存回收策略<br><img src="/img/android3.png" alt=""></li>
<li>内存分配策略</li>
</ol>
<p><img src="/img/android4.png" alt=""></p>
<p>注：用1个实例讲解 内存分配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;    </span><br><span class="line">    // 该类的实例对象的成员变量s1、mSample1 &amp; 指向对象存放在堆内存中</span><br><span class="line">    int s1 = 0;</span><br><span class="line">    Sample mSample1 = new Sample();   </span><br><span class="line"></span><br><span class="line">    // 方法中的局部变量s2、mSample2存放在 栈内存</span><br><span class="line">    // 变量mSample2所指向的对象实例存放在 堆内存</span><br><span class="line">    public void method() &#123;        </span><br><span class="line">        int s2 = 0;</span><br><span class="line">        Sample mSample2 = new Sample();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    // 变量mSample3的引用存放在栈内存中</span><br><span class="line">    // 变量mSample3所指向的对象实例存放在堆内存</span><br><span class="line">    // 该实例的成员变量s1、mSample1也存放在堆内存中</span><br><span class="line">    Sample mSample3 = new Sample();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>内存回收策略</li>
</ol>
<p>GC垃圾回收机制</p>
<p><img src="/img/gc1.png" alt=""></p>
<ul>
<li>常见问题<br>bitmap图片资源<br><img src="/img/gc2.png" alt=""></li>
</ul>
<p><img src="/img/gc3.png" alt=""></p>
<p>内存抖动</p>
<p><img src="/img/gc4.png" alt=""></p>
<p>优化方案： 尽量避免频繁创建大量、临时的小对象</p>
<p>代码质量&amp;数量</p>
<p><img src="/img/gc5.png" alt=""></p>
<p>常见内存问题</p>
<p><img src="/img/gc6.png" alt=""></p>
<p>总结</p>
<p><img src="/img/gc7.png" alt=""></p>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2019/05/29/%E5%89%8D%E7%AB%AF/flask%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/" class="pre-post btn btn-default" title='flask项目使用'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            flask项目使用</span>
    </a>
    
    
    <a href="/2019/05/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF/flutter/flutter-listview%E5%92%8Cadapter/" class="next-post btn btn-default" title='flutter listview和adapter'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            flutter listview和adapter</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    

<div id="vcomments" class="valine"></div>

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

<script>
new Valine({
    av: AV,
    el: '#vcomments',
    appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
    appKey: 'erIpQac4azoCmgfBB7Dl9maa',
    placeholder: '说点什么吧',
    notify: false,
    verify: true,
    avatar: 'mm',
    meta: 'nick,mail'.split(','),
    pageSize: '10',
    path: window.location.pathname,
    lang: 'zh-CN'.toLowerCase()
})
</script>


</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ViewStub%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">1. ViewStub的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SurfaveView%E6%8E%A7%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">2. SurfaveView控件的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-AOSP-Android-OPen-Source-Project-Android%E5%BC%80%E6%BA%90%E5%B7%A5%E7%A8%8B"><span class="toc-text">3. AOSP(Android OPen Source Project)Android开源工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9A"><span class="toc-text">4.内存泄露：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Android%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E4%B9%8BLooper%E3%80%81Handler%E3%80%81MessageQueen"><span class="toc-text">5. Android进阶——Android消息机制之Looper、Handler、MessageQueen</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Handler%E6%B6%89%E5%8F%8A%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%8C%E5%90%84%E8%87%AA%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1. Handler涉及哪些类，各自功能是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 发送消息的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-MessageQueue%E4%B8%AD%E7%9A%84Message%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F%E6%A0%B9%E6%8D%AE%E4%BB%80%E4%B9%88%E6%8E%92%E5%BA%8F"><span class="toc-text">3. MessageQueue中的Message是有序的吗？根据什么排序?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BAHandler%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F"><span class="toc-text">4. 子线程可以创建Handler对象吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Looper%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%8EThread%E5%85%B3%E8%81%94%E7%9A%84"><span class="toc-text">5. Looper是如何与Thread关联的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Handler%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">6.Handler有哪些构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%9A%84Looper"><span class="toc-text">7. 子线程如何获取当前线程的Looper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%BB%E6%84%8F%E5%85%88%E6%88%90%E8%8E%B7%E5%8F%96%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%9A%84Looper"><span class="toc-text">8. 如何在任意先成获取主线程的Looper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-text">9. 如何判断当前线程是不是主线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Looper-loop-%E4%BC%9A%E9%80%80%E5%87%BA%E5%90%97%EF%BC%9F"><span class="toc-text">10. Looper.loop()会退出吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-Looper-loop-%E6%96%B9%E6%B3%95%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E9%98%BB%E5%A1%9EAPP"><span class="toc-text">11. Looper.loop() 方法是一个死循环为什么不会阻塞APP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Http%E5%8D%8F%E8%AE%AE"><span class="toc-text">6. Http协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PUT%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">PUT和POST的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Get%E8%AF%B7%E6%B1%82%E6%B7%BB%E5%8A%A0body%E8%AF%B7%E6%B1%82%E5%90%97%EF%BC%9F"><span class="toc-text">Get请求添加body请求吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#options%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94"><span class="toc-text">options的主要用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TRACE"><span class="toc-text">TRACE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONNECT%EF%BC%88%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-text">CONNECT（连接）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Https%E5%8D%8F%E8%AE%AE"><span class="toc-text">7.Https协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-text">协议过程，中间人攻击</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Gradle"><span class="toc-text">8.Gradle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-ClassLoader"><span class="toc-text">9. ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8A%80%E6%9C%AF%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-text">插件化技术的核心</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Android%E5%8E%9F%E7%94%9F%E4%B8%8Ejs%E4%BA%A4%E4%BA%92"><span class="toc-text">10. Android原生与js交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81js%E8%B0%83%E7%94%A8Android%E6%96%B9%E6%B3%95"><span class="toc-text">一、js调用Android方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%9A%E8%BF%87-Webview-%E7%9A%84-addJavascriptInterface-%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84"><span class="toc-text">方法一：通过 Webview 的 addJavascriptInterface() 进行对象映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%9A%E8%BF%87-WebViewClient-%E7%9A%84-shouldOverrideUrlLoading-%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83%E6%8B%A6%E6%88%AA-url"><span class="toc-text">方法二：通过 WebViewClient 的 shouldOverrideUrlLoading() 方法回调拦截 url</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E9%80%9A%E8%BF%87-WebChromeClient-%E7%9A%84-onJsAlert-%E3%80%81-onJsConfirm-%E3%80%81-onJsPrompt%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83%E6%8B%A6%E6%88%AA-JS-%E5%AF%B9%E8%AF%9D%E6%A1%86-alert-%E3%80%81-confirm-%E3%80%81-prompt%EF%BC%88%EF%BC%89-%E6%B6%88%E6%81%AF"><span class="toc-text">方法三：通过 WebChromeClient 的 onJsAlert() 、 onJsConfirm() 、 onJsPrompt（）方法回调拦截 JS 对话框 alert() 、 confirm() 、 prompt（） 消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Android%E8%B0%83%E7%94%A8JS%E6%96%B9%E6%B3%95"><span class="toc-text">二、Android调用JS方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%9A%E8%BF%87WebView%E7%9A%84loadUrl"><span class="toc-text">方法一：通过WebView的loadUrl()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A-%E9%80%9A%E8%BF%87-WebView-%E7%9A%84-evaluateJavascript"><span class="toc-text">方法二： 通过 WebView 的 evaluateJavascript()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">11.RecyclerView缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88%E4%BB%8E%E9%AB%98%E5%88%B0%E4%BD%8E%EF%BC%89"><span class="toc-text">缓存优先级（从高到低）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">12.性能优化</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/assets/tagcanvas.min.js?rev=2.9.js"></script>

<script>
var tagOption = {
    textColour: '#444', // 字体颜色
    outlineMethod: 'block', // 选中模式
    outlineColour: '#FFDAB9', // 选中模式的颜色
    interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
    textHeight: 13,
    outlineRadius: 3,
    freezeActive: true || '', // 选中的标签是否继续滚动
    frontSelect: true || '', // 不选标签云后部的标签
    initial: [0.1, -0.1],
    depth: 0.5,
    decel: 0.95,
    maxSpeed: 0.03,
    reverse: true || '', // 是否反向触发
    fadeIn: 500, // 进入动画时间
    wheelZoom: false || '' // 是否启用鼠标滚轮
}
TagCanvas.Start('tag-cloud-3d', '', tagOption);
</script>



<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>