<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>纳兰寒明的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-31T13:08:42.826Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>纳兰寒明</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin初探</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Kotlin%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2021/05/31/移动端/Android原生/Kotlin初探/</id>
    <published>2021-05-31T13:08:21.000Z</published>
    <updated>2021-05-31T13:08:42.826Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>以.kt结尾的程序文件</p><p>优点：</p><ul><li>简洁：大大减少样板代码的数量</li><li>安全：避免空指针异常等整个类的错误</li><li>互操作性：充分利用JVM、Android和游览器的现有库</li><li>工具友好：可用任何Java IDE或者使用命令行构建</li></ul><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * a:入参   b:入参</span></span><br><span class="line"><span class="comment"> * 返回：Int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;   <span class="comment">// Int 参数，返回值 Int</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum2</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b</span><br></pre></td></tr></table></figure><h4 id="可变长参数函数（vararg）"><a href="#可变长参数函数（vararg）" class="headerlink" title="可变长参数函数（vararg）"></a>可变长参数函数（vararg）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个Int参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">vars</span><span class="params">(<span class="keyword">vararg</span> v:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vt <span class="keyword">in</span> v)&#123;</span><br><span class="line">        print(<span class="string">&quot;----<span class="variable">$vt</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main :   </span><br><span class="line">vars(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sumLambda:(<span class="built_in">Int</span>,<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;a,b -&gt;a+b&#125;</span><br><span class="line">println(sumLambda(<span class="number">1</span>,<span class="number">2</span>))  <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><h4 id="val"><a href="#val" class="headerlink" title="val"></a>val</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修饰不可变的变量，类似于 final，只可被赋值一次</span></span><br><span class="line"><span class="keyword">val</span> &lt;标识符&gt; ：&lt;类型&gt; = &lt;初始化值&gt;</span><br></pre></td></tr></table></figure><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修饰可变的变量，声明时可不指定类型，由编译器判断</span></span><br><span class="line"><span class="keyword">var</span> &lt;标识符&gt; ：&lt;类型&gt; = &lt;初始化值&gt;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">1</span>       <span class="comment">// 系统自动推断变量类型为Int</span></span><br><span class="line"><span class="keyword">val</span> c: <span class="built_in">Int</span>      <span class="comment">// 如果不在声明时初始化则必须提供变量类型</span></span><br><span class="line">c = <span class="number">1</span>           <span class="comment">// 明确赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>        <span class="comment">// 系统自动推断变量类型为Int</span></span><br><span class="line">x += <span class="number">1</span>           <span class="comment">// 变量可修改</span></span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin中块注释的级联使用，其实个人觉得块注释的嵌套使用的意义不大，不过从视觉上确实能给人一种层次感</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一层块注释</span></span><br><span class="line"><span class="comment">    <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="comment">        第二层块注释</span></span></span><br><span class="line"><span class="comment"><span class="comment">        /*</span></span></span><br><span class="line"><span class="comment"><span class="comment">            第三层快注释</span></span></span><br><span class="line"><span class="comment"><span class="comment">            这种注释方式在java中是不支持的，但是在kotlin中是支持的。算是一个亮点吧（貌似意义不大）。</span></span></span><br><span class="line"><span class="comment"><span class="comment">         */</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="字符串模版"><a href="#字符串模版" class="headerlink" title="字符串模版"></a>字符串模版</h4><p>$ 表示一个变量名或者变量值<br>$varName 表示变量值<br>${varName.fun()} 表示变量的方法返回值:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// 模板中的简单名称：</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="string">&quot;a is <span class="variable">$a</span>&quot;</span> </span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="comment">// 模板中的任意表达式：</span></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="string">&quot;<span class="subst">$&#123;s1.replace(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;was&quot;</span>)&#125;</span>, but now is <span class="variable">$a</span>&quot;</span></span><br></pre></td></tr></table></figure><h4 id="NULL检查机制"><a href="#NULL检查机制" class="headerlink" title="NULL检查机制"></a>NULL检查机制</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型后面加?表示可为空</span></span><br><span class="line"><span class="keyword">var</span> age: String? = <span class="string">&quot;23&quot;</span> </span><br><span class="line"><span class="comment">//抛出空指针异常</span></span><br><span class="line"><span class="keyword">val</span> ages = age!!.toInt()</span><br><span class="line"><span class="comment">//不做处理返回 null</span></span><br><span class="line"><span class="keyword">val</span> ages1 = age?.toInt()</span><br><span class="line"><span class="comment">//age为空返回-1</span></span><br><span class="line"><span class="keyword">val</span> ages2 = age?.toInt() ?: -<span class="number">1</span></span><br><span class="line"><span class="comment">//当 str 中的字符串内容不是一个整数时, 返回 null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型检测及自动类型转换"><a href="#类型检测及自动类型转换" class="headerlink" title="类型检测及自动类型转换"></a>类型检测及自动类型转换</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">    <span class="comment">// 做过类型判断以后，obj会被系统自动转换为String类型</span></span><br><span class="line">    <span class="keyword">return</span> obj.length </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在这里还有一种方法，与Java中instanceof不同，使用!is</span></span><br><span class="line">  <span class="comment">// if (obj !is String)&#123;</span></span><br><span class="line">  <span class="comment">//   // XXX</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的obj仍然是Any类型的引用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>) print(i) <span class="comment">// 输出“1234”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4.</span><span class="number">.1</span>) print(i) <span class="comment">// 什么都不输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123; <span class="comment">// 等同于 1 &lt;= i &amp;&amp; i &lt;= 10</span></span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 step 指定步长</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span> step <span class="number">2</span>) print(i) <span class="comment">// 输出“13”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">// 输出“42”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 until 函数排除结束元素</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">10</span>) &#123;   <span class="comment">// i in [1, 10) 排除了 10</span></span><br><span class="line">     println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table><thead><tr><th>类型</th><th>位宽度</th></tr></thead><tbody><tr><td>Double</td><td>64</td></tr><tr><td>Float</td><td>32</td></tr><tr><td>Long</td><td>64</td></tr><tr><td>Int</td><td>32</td></tr><tr><td>Short</td><td>16</td></tr><tr><td>Byte</td><td>8</td></tr></tbody></table><ul><li>十进制：123</li><li>长整型以大写的 L 结尾：123L</li><li>16 进制以 0x 开头：0x0F</li><li>2 进制以 0b 开头：0b00001011</li><li>Doubles 默认写法: <code>123.5</code>, <code>123.5e10</code></li><li>Floats 使用 f 或者 F 后缀：<code>123.5f</code></li></ul><blockquote><p> 注意：8进制不支持</p></blockquote><p>可以使用下划线使数字常量更易读:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234_5678_9012_3456L</span></span><br><span class="line"><span class="keyword">val</span> socialSecurityNumber = <span class="number">999_99_9999L</span></span><br><span class="line"><span class="keyword">val</span> hexBytes = <span class="number">0xFF_EC_DE_5E</span></span><br><span class="line"><span class="keyword">val</span> bytes = <span class="number">0b11010010_01101001_10010100_10010010</span></span><br></pre></td></tr></table></figure><h4 id="比较两个数字"><a href="#比较两个数字" class="headerlink" title="比较两个数字"></a>比较两个数字</h4><blockquote><p>Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。</p></blockquote><p>三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, 字面值是静态检测的</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt() <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">toByte(): <span class="built_in">Byte</span></span><br><span class="line">toShort(): <span class="built_in">Short</span></span><br><span class="line">toInt(): <span class="built_in">Int</span></span><br><span class="line">toLong(): <span class="built_in">Long</span></span><br><span class="line">toFloat(): <span class="built_in">Float</span></span><br><span class="line">toDouble(): <span class="built_in">Double</span></span><br><span class="line">toChar(): <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shl(bits) – 左移位 (Java’s &lt;&lt;)</span><br><span class="line">shr(bits) – 右移位 (Java’s &gt;&gt;)</span><br><span class="line">ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)</span><br><span class="line">and(bits) – 与</span><br><span class="line">or(bits) – 或</span><br><span class="line">xor(bits) – 异或</span><br><span class="line">inv() – 反向</span><br></pre></td></tr></table></figure><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>Char：使用单引号<code>&#39;</code>包含起来的</p><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>Boolean：true和false</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|| – 短路逻辑或</span><br><span class="line">&amp;&amp; – 短路逻辑与</span><br><span class="line">! - 逻辑非</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote><p>注意: 与 Java 不同的是，Kotlin 中数组是不协变的（invariant）。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//[1,2,3]</span></span><br><span class="line">    <span class="keyword">val</span> a = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//[0,2,4]</span></span><br><span class="line">    <span class="keyword">val</span> b = Array(<span class="number">3</span>, &#123; i -&gt; (i * <span class="number">2</span>) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数组内容</span></span><br><span class="line">    println(a[<span class="number">0</span>])    <span class="comment">// 输出结果：1</span></span><br><span class="line">    println(b[<span class="number">1</span>])    <span class="comment">// 输出结果：2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>和 Java 一样，String 是不可变的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">    println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    多行字符串</span></span><br><span class="line"><span class="string">    多行字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    println(text)   <span class="comment">// 输出有一些前置空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 可以通过 trimMargin() 方法来删除多余的空白。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    |多行字符串</span></span><br><span class="line"><span class="string">    |菜鸟教程</span></span><br><span class="line"><span class="string">    |多行字符串</span></span><br><span class="line"><span class="string">    |Runoob</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimMargin()</span><br><span class="line">    println(text)    <span class="comment">// 前置空格删除了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(&quot;&gt;&quot;)。</span></span><br></pre></td></tr></table></figure><h4 id="字符串模版表达式"><a href="#字符串模版表达式" class="headerlink" title="字符串模版表达式"></a>字符串模版表达式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">&quot;i = <span class="variable">$i</span>&quot;</span> <span class="comment">// 求值结果为 &quot;i = 10&quot;</span></span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">&quot;runoob&quot;</span></span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;<span class="variable">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>&quot;</span> <span class="comment">// 求值结果为 &quot;runoob.length is 6&quot;</span></span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> price = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;<span class="string">&#x27;$&#x27;</span>&#125;</span>9.99</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    println(price)  <span class="comment">// 求值结果为 $9.99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a>When表达式</h4><p>类似于其他语言的switch，else类似于default</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">&quot;x == 1&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">&quot;x == 2&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">        print(<span class="string">&quot;x 不是 1 ，也不是 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> site = Runoob() <span class="comment">// Kotlin 中没有 new 关键字</span></span><br></pre></td></tr></table></figure><p>主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。</p><p>类也可以有二级构造函数，需要加前缀 constructor</p><p>类默认是不可变的，即是被final修饰的，使用open后，去除final</p><p>内部类使用 inner 关键字来表示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span>    <span class="comment">// 抽象类  </span></span><br><span class="line"><span class="keyword">final</span>       <span class="comment">// 类不可继承，默认属性</span></span><br><span class="line"><span class="keyword">enum</span>        <span class="comment">// 枚举类</span></span><br><span class="line"><span class="keyword">open</span>        <span class="comment">// 类可继承，类默认是final的</span></span><br><span class="line"><span class="keyword">annotation</span>  <span class="comment">// 注解类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>    <span class="comment">// 仅在同一个文件中可见</span></span><br><span class="line"><span class="keyword">protected</span>  <span class="comment">// 同一个文件中或子类可见</span></span><br><span class="line"><span class="keyword">public</span>     <span class="comment">// 所有调用的地方都可见</span></span><br><span class="line"><span class="keyword">internal</span>   <span class="comment">// 同一个模块中可见</span></span><br><span class="line"></span><br><span class="line">模块：</span><br><span class="line">一个 IntelliJ IDEA 模块；</span><br><span class="line">一个 Maven 项目；</span><br><span class="line">一个 Gradle 源集（例外是 test 源集可以访问 main 的 <span class="keyword">internal</span> 声明）；</span><br><span class="line">一次 &lt;kotlinc&gt; Ant 任务执行所编译的一套文件。</span><br></pre></td></tr></table></figure><h4 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> name:String)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**扩展函数**/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    print(<span class="string">&quot;用户名 <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = User(<span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">    user.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><h4 id="关键字整理"><a href="#关键字整理" class="headerlink" title="关键字整理"></a>关键字整理</h4><p><img src="https://img-blog.csdnimg.cn/20200603150606240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdlcmxvdmV4aWFvamll,size_16,color_FFFFFF,t_70" alt="img"></p><ol><li>lateinit：延迟初始化</li></ol><p>​    作用：<strong>具体来讲，这个关键字告诉编译器，我无法声明的时候就初始化，但是我保证我在使用前一定会初始化，你就别给我检查了。</strong></p><ol start="2"><li>apply：用于对象配置，类似于构造者模式（Builder），调用某对象的apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象</li><li>with：返回是最后一行，然后可以直接调用对象的方法，感觉像是let和apply的结合。</li><li>let：默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return</li><li>also：调用某对象的also函数，则该对象为函数的参数。在函数块内可以通过 it 指代该对象。返回值为该对象自己。</li><li>run：run函数和apply函数很像，只不过run函数是使用最后一行的返回，apply返回当前自己的对象。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;以.kt结尾的程序文件&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁：大大减少样板代码的数量&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>内存优化</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/05/31/移动端/Android原生/内存优化/</id>
    <published>2021-05-31T13:02:06.000Z</published>
    <updated>2021-05-31T13:02:24.279Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>2895</p><h2 id="为什么要做内存优化？"><a href="#为什么要做内存优化？" class="headerlink" title="为什么要做内存优化？"></a>为什么要做内存优化？</h2><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTQ4OTY2OS8yMDE4MTAvMTQ4OTY2OS0yMDE4MTAwOTE4NTUyNzMxNi0xNzA4NzkwOTc0LnBuZw" alt="image"></p><ul><li>虚拟机栈（<strong>线程私有</strong>）：局部变量表、操作数栈、动态链接、方法出口等信息</li><li>堆（<strong>线程共享</strong>）：实例对象</li><li>方法区（<strong>线程共享</strong>）：类信息，常量，即时编译器编译后的代码</li><li>程序计数器（<strong>线程私有</strong>）：字节码行号指示器，记录当前线程执行到多少行</li><li>本地方法栈（<strong>线程私有</strong>）：和虚拟机栈类似，两者的区别就是虚拟机栈是为虚拟机执行java方法服务，本地方法栈为虚拟机执行native方法服务 。</li></ul><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>线程计数器中如果正在执行java方法，计数器记录的是当前指令的地址，<br>如果是Native方法，计数器记录为空</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆内存 = 新生代(1) + 老年代(2)</p><ul><li>新生代：复制算法</li><li>老年代：标记整理算法</li></ul><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>也叫“永久代”，1.8以后将方法区去除了，将方法区移动到直接内存</p><blockquote><p>内存回收主要考虑<strong>堆区</strong>和<strong>方法区</strong>的回收，其他部分会根据线程的产生和消亡</p></blockquote><h5 id="个版本区别"><a href="#个版本区别" class="headerlink" title="个版本区别"></a>个版本区别</h5><p><img src="https://img-blog.csdnimg.cn/20200608093848129.png" alt="image"><br><img src="https://img-blog.csdnimg.cn/20200608093926325.png" alt="image"><br><img src="https://img-blog.csdnimg.cn/20200608093956636.png" alt="image"></p><ul><li>1.6：运行常量池在方法区</li><li>1.7：运行常量池在堆中</li><li>1.8：删除方法区，引入直接内存，元空间概念，方法区中的静态变量被转移到堆中，只有class元数据在元空间。</li></ul><blockquote><p>堆中的老年代和方法区（永久代）是绑定的，无论哪一方满了，都会触发双方的GC回收</p></blockquote><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><ol><li><p>堆和栈的区别：</p><ol><li>栈：基本数据类型变量（int、short、long、byte、float、double、boolean、char）以及对象的引用变量</li></ol><p>堆：存储java对象</p><ol start="2"><li>堆中的对象对所有线程可见，栈内存只属于一个线程</li><li>堆的内存空间远远大于栈</li></ol></li><li>为什么删除方法区？<ol><li>启动大小固定，很难调优，容易发生OOM</li><li>元空间在本地内存中分配，本地内存足够就不会溢出</li></ol></li></ol><h4 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h4><h5 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h5><ol><li>引用计数算法（缺点：循环引用，技数永远不为0）</li><li>可达性算法（二叉树中向下搜索，不存在引用链则对象不可用）</li></ol><h5 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h5><ol><li><p>标记清除算法：标记完后对对象进行回收，使用在<strong>老年代</strong></p><p>缺点：</p><ol><li>效率不高，标记和清除效率不高</li><li>差生大量碎片空间，导致空间浪费</li></ol></li><li><p>复制算法：将可用对象复制到新的连续空间，删除之前的空间</p><p>缺点：</p><ol><li>浪费50%的内存，复制长生存期的对象效率低下，所以该算法使用在<strong>新生代</strong></li></ol></li><li><p>标记整理算法：前期使用标记清除算法，后续使用整理算法，使对象排列称联系空间，使用在<strong>老年代</strong></p></li><li>分代收集算法：对数据进行分代，每一代执行不同的回收算法<br><img src="https://user-gold-cdn.xitu.io/2020/3/19/170f0726be006da5" alt="image"></li></ol><p>年轻代分为eden、s0、s1区，分别为8：1：1，年轻代和老年代为1：2</p><ol start="5"><li>元空间的gc：元空间中的类加载器存活，则元空间中元数据也存活</li></ol><blockquote><p>Minor GC ： 清理年轻代</p><p>Major GC ： 清理老年代</p><p>Full GC ： 清理整个堆空间，包括年轻代和永久代</p></blockquote><h4 id="四大引用介绍"><a href="#四大引用介绍" class="headerlink" title="四大引用介绍"></a>四大引用介绍</h4><h5 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h5><ul><li>强引用：Strong Reference，通常使用的对象方式，gc不会回收</li><li>软引用：SoftReference，当内存不足时进行回收</li><li>弱引用：WeakReference，下一次gc时回收</li><li>虚引用：PhantomReference，任何时候可回收</li></ul><blockquote><p>在内存泄露问题处理上，使用最多的是弱引用，许多源码、框架都是用<br>eg：</p><ol><li>ThreadLocalMap中存储以ThreadLocal的弱引用为键，具体内容为value</li><li>Glide中缓存使用activeResource，存储的是图片的弱引用</li><li>解决Handler的内存泄漏使用弱引用</li></ol></blockquote><h5 id="Reference理解"><a href="#Reference理解" class="headerlink" title="Reference理解"></a>Reference理解</h5><p>所有的引用都是继承自Reference，以下以WeakReference为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new weak reference that refers to the given object.  The new</span></span><br><span class="line"><span class="comment">     * reference is not registered with any queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent object the new weak reference will refer to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new weak reference that refers to the given object and is</span></span><br><span class="line"><span class="comment">     * registered with the given queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent object the new weak reference will refer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中存在两种构造方法，区别在于是否传入引用队列，如果不传入引用队列，说明只存在一种引用，不需要引用队列成链存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> disableIntrinsic = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> slowPathEnabled = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//引用的对象，由垃圾回收器控制其引用</span></span><br><span class="line">    <span class="keyword">volatile</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br><span class="line">    <span class="keyword">final</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;</span><br><span class="line">    Reference queueNext;</span><br><span class="line">    Reference&lt;?&gt; pendingNext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getReferent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FastNative</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">native</span> T <span class="title">getReferent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clearReferent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FastNative</span></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">clearReferent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnqueued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Contrary to what the documentation says, this method returns false</span></span><br><span class="line">        <span class="comment">// after this reference object has been removed from its queue</span></span><br><span class="line">        <span class="comment">// (b/26647823). ReferenceQueue.isEnqueued preserves this historically</span></span><br><span class="line">        <span class="comment">// incorrect behavior.</span></span><br><span class="line">        <span class="keyword">return</span> queue != <span class="keyword">null</span> &amp;&amp; queue.isEnqueued(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> queue != <span class="keyword">null</span> &amp;&amp; queue.enqueue(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -- Constructors -- */</span></span><br><span class="line"></span><br><span class="line">    Reference(T referent) &#123;</span><br><span class="line">        <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.referent = referent;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类很简短，可以看出一个关键点，Reference是一个节点，保存next的引用，方法调用都是使用ReferenceQueue方法，直接进入：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> Reference&lt;? extends T&gt; head = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">private</span> Reference&lt;? extends T&gt; tail = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends T&gt; reference)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">           <span class="keyword">if</span> (enqueueLocked(reference)) &#123;</span><br><span class="line">               lock.notifyAll();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueLocked</span><span class="params">(Reference&lt;? extends T&gt; r)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">           Cleaner cl = (sun.misc.Cleaner) r;</span><br><span class="line">           cl.clean();</span><br><span class="line">           r.queueNext = sQueueNextUnenqueued;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">           head = r;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           tail.queueNext = r;</span><br><span class="line">       &#125;</span><br><span class="line">       tail = r;</span><br><span class="line">       tail.queueNext = r;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>入队方法中，</p><ol><li>使用synchronized添加锁，入队结束后释放锁，在ReferenceQueue中并不是标准的队列，使用的是Reference节点成链，行成单链表，类似于MessageQueue.</li><li>如果是Cleaner类，创建一个虚引用节点，即不如队。Cleaner是用来释放非堆内存，所以做特殊处理</li></ol><p>SoftReference<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//时间戳，由gc更新</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">long</span> clock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoftReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent);</span><br><span class="line">        <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new soft reference that refers to the given object and is</span></span><br><span class="line"><span class="comment">     * registered with the given queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent object the new soft reference will refer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoftReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">        <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T o = <span class="keyword">super</span>.get();</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.timestamp != clock)</span><br><span class="line">            <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由gc管理时间戳</p><ul><li>clock：上一次gc时间</li><li>timestamp：访问get时最近一次的gc时间</li></ul><p>回收条件为：clock - timestamp &lt;= free_heap * ms_per_mb</p><ul><li>free_heep为堆空间空闲大小</li><li>ms_per_mb是保留软引用时间/MB</li></ul><p>PhantomReference<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虚引用的get方法返回null，不做gc保留</p><blockquote><p>虚引用通过构造方法可以查看是<strong>持有对象引用</strong>的</p></blockquote><p>总结：所有引用都是继承自Reference基类的，该类是一个链表节点，ReferenceQueue通过这点形成单链表，称之为队列，进行引用管理，所有引用都可以通过Reference的isEnqueue方法判断引用是否存在。</p><h5 id="FinalizerReference理解"><a href="#FinalizerReference理解" class="headerlink" title="FinalizerReference理解"></a>FinalizerReference理解</h5><p>java堆中创建对象时，如果java类定义了finalize方法，就会新建一个FinalizerReference类，指向这个新建的对象</p><h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><ul><li>内存泄漏：内存没有按照预期在gc时回收</li><li>内存溢出：内存大小超出指定大小，导致OOM</li><li>内存抖动：短时间创建大量内存对象，然后回收，导致内存发生锯齿形抖动，内存空间不连续加上碎片会导致更大的空间，最终OOM</li></ul><h3 id="内存优化意义"><a href="#内存优化意义" class="headerlink" title="内存优化意义"></a>内存优化意义</h3><ul><li>减少OOM，提高系统稳定性</li><li>减少卡顿，提高流畅度</li><li>减少内存占用，提高应用存活率</li><li>减少异常发生和代码逻辑隐患</li></ul><h3 id="Android内存泄漏"><a href="#Android内存泄漏" class="headerlink" title="Android内存泄漏"></a>Android内存泄漏</h3><h4 id="常见内存泄漏"><a href="#常见内存泄漏" class="headerlink" title="常见内存泄漏"></a>常见内存泄漏</h4><ol><li>匿名内部类持有外部类引用，导致外部类内存泄漏（Handler）</li><li>单例传入Context导致调用单例方无法被回收。</li><li>非静态内部类创建静态实例</li><li>注册与反注册</li><li>资源对象关闭</li><li>集和及时清理</li></ol><h4 id="内存泄漏检测"><a href="#内存泄漏检测" class="headerlink" title="内存泄漏检测"></a>内存泄漏检测</h4><ol><li>Profiler,Memory Analyzer(MAT)</li></ol><p>Android studio自带内存、cpu、网络的变化，可以根据内存变化做具体分析</p><ol start="2"><li>LeakCanary</li></ol><p>框架集成，自动检测内存泄漏，生成app，提供内存泄漏栈堆情况</p><p>原理：绑定生命周期，对Activity和Fragment来说，在onDestory时将对象放入弱引用队列进行存储，触发gc后，如果还存在，则发生内存泄漏</p><ol start="3"><li>StrictMode（很少用）</li></ol><p>一款比较老的工具，ThreadPolicy可以检测主线程是否网络访问，是否读写。VMPolicy检测内存，Activity，Fragment是否泄漏，资源是否正确关闭</p><h3 id="内存优化空间"><a href="#内存优化空间" class="headerlink" title="内存优化空间"></a>内存优化空间</h3><ol><li>不必要的自动装箱</li></ol><p>自动装箱就是将基础数据类型转化为对应的复杂类型，在HashMap的增删改查中充满了自动装箱问题，所以尽量避免这中问题，如将HashMap替换为SparseArray和ArrayMap</p><ol start="2"><li>内存复用</li></ol><ul><li>资源复用：通用字符串，颜色，布局</li><li>视图复用：类似于RecyclerView的优化复用</li><li>对象池：创建对象池，不用重复创建对象，类似于线程池，messae享元模式</li><li>Bitmap对象复用：使用inBitmap属性可以告知Bitmap解码器尝试使用已经存在的内存区域，新解码的bitmap会尝试使用之前那张bitmap在heap中占据的pixel data内存区域。</li></ul><ol start="3"><li><p>在App可用内存过低时主动释放内存<br>在App退到后台内存紧张即将被Kill掉时选择重写Application中 onTrimMemory/onLowMemory 方法去释放掉图片缓存、静态缓存来自保。</p></li><li><p>其他场景优化</p><ol><li>item被回收不可见时释放掉对图片的引用<ul><li><strong>ListView</strong>：因此每次item被回收后再次利用都会重新绑定数据，只需在ImageView onDetachFromWindow的时候释放掉图片引用即可。</li><li><strong>RecyclerView</strong>：因为被回收不可见时第一选择是放进mCacheView中，这里item被复用并不会只需bindViewHolder来重新绑定数据，只有被回收进mRecyclePool中后拿出来复用才会重新绑定数据，因此重写Recycler.Adapter中的onViewRecycled()方法来使item被回收进RecyclePool的时候去释放图片引用。</li></ul></li><li>如果使用字符串拼接，尽量使用StringBuilder、StringBuffer（内存抖动）</li><li>自定义view减少onDraw的耗时和执行次数</li><li>尽量使用静态内部类</li><li>尽量使用基础数据类型</li><li>合适的时候使用软/弱引用</li></ol></li></ol><h3 id="线上监控方案"><a href="#线上监控方案" class="headerlink" title="线上监控方案"></a>线上监控方案</h3><ol><li><p>常规监测</p><ol><li>当内存使用超过80%，使用 <strong>Debug.dumpHprofData(String fileName)</strong><br>获取dump文件回传至服务器，而后手动分析</li><li>LeakCanary集成并带到线上</li></ol></li><li><p>Probe线上监测工具</p></li><li>LeakInspector</li><li>ResourceCanary</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;2895&lt;/p&gt;
&lt;h2 id=&quot;为什么要做内存优化？&quot;&gt;&lt;a href=&quot;#为什么要做内存优化？&quot; class=&quot;headerlink&quot; title=&quot;为什么要做内存优化？&quot;&gt;&lt;/a&gt;为什么要做内存优化？&lt;/h2&gt;&lt;h3 id=&quot;Java虚拟机&quot;
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>包体优化</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%8C%85%E4%BD%93%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/05/31/移动端/Android原生/包体优化/</id>
    <published>2021-05-31T13:01:25.000Z</published>
    <updated>2021-06-10T05:46:06.790Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="优化好处"><a href="#优化好处" class="headerlink" title="优化好处"></a>优化好处</h3><ol><li>包体积减小，易于升级</li><li>多市场渠道有体积限制，避免二次处理</li><li>apk安装时间减小</li><li>运行时内存占用小</li><li>磁盘空间占用小，odex二进制文件小。</li></ol><h3 id="APK组成及分析"><a href="#APK组成及分析" class="headerlink" title="APK组成及分析"></a>APK组成及分析</h3><h4 id="APK组成"><a href="#APK组成" class="headerlink" title="APK组成"></a>APK组成</h4><ul><li>assets: 开发目录下assets目录</li><li>lib：所需要的so库</li><li>META-INF：签名文件</li><li>okhttp3：okhttp网络相关</li><li>org：org相关信息</li><li>res：布局信息，对应开发目录res下</li><li>AndroidManifest：四大组件配置</li><li>classes.dex：代码压缩文件</li></ul><h4 id="apk分析"><a href="#apk分析" class="headerlink" title="apk分析"></a>apk分析</h4><ol><li>使用常规apktool方法</li><li><p>使用jadx工具</p><p><a href="https://github.com/skylot/jadx">https://github.com/skylot/jadx</a></p><p>直接将apk拖入程序即可查看各种信息</p></li><li>Android Studio中的Analyze apk可以分析apk的组成</li></ol><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>代码全部存储在dex文件中，所以我们需要先搞懂什么是dex？</p><h5 id="dex理解"><a href="#dex理解" class="headerlink" title="dex理解"></a>dex理解</h5><p><strong>dex文件是专为Dalvik设计的一种压缩格式</strong></p><blockquote><p>.java–&gt;.class–&gt;.dex</p></blockquote><p>在.java–&gt;.class过程中，主要是jvm的操作，在.class–&gt;.dex过程中，需要将.class文件转化为Dalvik识别的.dex文件</p><p>dex主要结构如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/16729fad9d5f4ab1" alt="image"></p><blockquote><p>同jar相比，dex文件的大小能够缩减50%左右</p></blockquote><h5 id="ProGuard代码混淆"><a href="#ProGuard代码混淆" class="headerlink" title="ProGuard代码混淆"></a>ProGuard代码混淆</h5><p>在build.gradle中开启混淆，将类名转化为没有意义的a,b,c等，提高阅读难度，其次通过缩短名称可以有效缩减dex大小，而且会移除在代码中没有使用的代码。</p><h5 id="D8与R8的优化"><a href="#D8与R8的优化" class="headerlink" title="D8与R8的优化"></a>D8与R8的优化</h5><ul><li>D8：把java字节码转化为dex代码，简单来说就是dex编译器</li><li>R8：混淆压缩与优化部分的替代品，但是不能完全替代proguard</li></ul><p>D8的提出是用来取代DX的，他的优化如下：</p><ul><li>编译时间缩短</li><li>.dex文件更小</li><li>.dex运行性能更好</li><li>包含java8语言支持</li></ul><p>R8与proguard非常相似，但不能完全替代proguard</p><ul><li>ProGuard 在将枚举类型简化为原始整数方面会更加强大</li><li>ProGuard 中应用的模式匹配算法可以识别和替换短指令序列，从而提高代码效率并为更多优化打开了机会。在优化遍历的顺序中，尤其是数学运算和字符串运算可从中受益</li><li>ProGuard 具有独特的能力来优化使用 GSON 库将对象序列化或反序列化为 JSON 的代码</li></ul><h5 id="Dex分包优化"><a href="#Dex分包优化" class="headerlink" title="Dex分包优化"></a>Dex分包优化</h5><p>当apk方法数超过65536时，必须采用分包策略，这样跨dex调用会出现一些重复信息：</p><ul><li>多余的 method id：跨 Dex 调用会导致当前dex保留被调用dex中的方法id，这种冗余会导致每一个dex中可以存放的class变少，最终又会导致编译出来的dex数量增多，而dex数据的增加又会进一步加重这个问题。</li><li>其它跨dex调用造成的信息冗余：除了需要多记录被调用的method id之外，还需多记录其所属类和当前方法的定义信息，这会造成 string_ids、type_ids、proto_ids 这几部分信息的冗余。</li></ul><p>所以使用ReDex进行分包优化，同时，去除dex文件中的debug信息及行号信息</p><h4 id="svg的使用"><a href="#svg的使用" class="headerlink" title="svg的使用"></a>svg的使用</h4><h4 id="使用指定语言，删除不必要的语言"><a href="#使用指定语言，删除不必要的语言" class="headerlink" title="使用指定语言，删除不必要的语言"></a>使用指定语言，删除不必要的语言</h4><h5 id="使用XZ-Utils进行Dex压缩"><a href="#使用XZ-Utils进行Dex压缩" class="headerlink" title="使用XZ Utils进行Dex压缩"></a>使用XZ Utils进行Dex压缩</h5><p><a href="https://tukaani.org/xz/">https://tukaani.org/xz/</a><br>将dex压缩后放在assets目录中，减少包体积，但是会提高安装时间</p><h5 id="三方库优化"><a href="#三方库优化" class="headerlink" title="三方库优化"></a>三方库优化</h5><p>在使用三方库中，小库可以完成目前业务就是用小库，减小三方库的大小，比如Picasso、Glide、Fresco的大小和功能</p><h5 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h5><p>使用Lint优化代码，移除没有使用的代码</p><h5 id="减少enum的使用"><a href="#减少enum的使用" class="headerlink" title="减少enum的使用"></a>减少enum的使用</h5><p><a href="https://www.liaohuqiu.net/cn/posts/android-enum-memory-usage/">Android 中的 Enum 到底占多少内存？该如何用？</a></p><h4 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h4><ul><li>Lint：使用lint去除冗余资源</li><li>shrinkResources：去除无用资源</li><li>重复资源优化：多模块使用同一个资源文件，去除重复资源文件，保留第一份资源</li><li>图片压缩：AAPT优化图片，选择webp格式的图片</li><li>使用针对性图片格式<ol><li>聊天表情出一套图 =&gt; hdpi。</li><li>纯色小 icon 使用 VD =&gt; raw。</li><li>背景大图出一套 =&gt; xhdpi。</li><li>logo 等权重比较大的图片出两套 =&gt; hdpi，xhdpi。</li><li>若某些图在真机中有异常，则用多套图。</li><li>若遇到奇葩机型，则针对性补图。</li></ol></li><li>资源路径混淆成单个资源的路径：使用AndroidResGuard，缩短资源路径</li><li>将资源文件放置在服务器上，通过网络加载</li></ul><h4 id="so库优化"><a href="#so库优化" class="headerlink" title="so库优化"></a>so库优化</h4><ul><li>通过abiFilters过滤so库</li><li>对于敏感的so库，不同架构全部放置在armeabi中，在程序中判断系统架构，加载不同的so库</li><li>Native Library压缩：XZ Utils，SoLoader</li><li>so库动态下载：<a href="https://mp.weixin.qq.com/s/X58fK02imnNkvUMFt23OAg">https://mp.weixin.qq.com/s/X58fK02imnNkvUMFt23OAg</a></li></ul><h4 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h4><ol><li><p>插件化</p><p>插件可以热插拔，从服务器下载</p></li><li><p>转变开发模式</p><p>使用混合式开发</p></li><li>梳理业务，简化逻辑和业务</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;优化好处&quot;&gt;&lt;a href=&quot;#优化好处&quot; class=&quot;headerlink&quot; title=&quot;优化好处&quot;&gt;&lt;/a&gt;优化好处&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;包体积减小，易于升级&lt;/li&gt;
&lt;li&gt;多市场渠道有体积限制，避免二次处理&lt;/li&gt;

      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>布局优化</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/05/31/移动端/Android原生/布局优化/</id>
    <published>2021-05-31T13:00:35.000Z</published>
    <updated>2021-06-24T09:16:05.588Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="绘画原理"><a href="#绘画原理" class="headerlink" title="绘画原理"></a>绘画原理</h3><p><strong>Android的绘制主要是借助cpu和gpu结合刷新机制共同完成的</strong></p><ul><li>cpu：负责执行measure、layout等方法，计算显示内容</li><li>gpu：负责栅格化（将UI元素绘制在屏幕上）<br><img src="https://user-gold-cdn.xitu.io/2020/1/14/16fa19bed0589207" alt="image"></li></ul><p>绘制过程使用skia库（2D），硬件本质是采用openGL库进行绘制</p><p>16ms内渲染一次，否则会掉帧</p><h3 id="布局加载原理"><a href="#布局加载原理" class="headerlink" title="布局加载原理"></a>布局加载原理</h3><p>Android中的布局加载入口为setContentView()，分析如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">       getDelegate().setContentView(layoutResID);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//AppCompatDelegate.java</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resId)</span></span>;</span><br></pre></td></tr></table></figure><br>查看抽象接口实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">       ensureSubDecor();</span><br><span class="line">       <span class="comment">//获取content跟布局</span></span><br><span class="line">       ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">       <span class="comment">//移除所有布局</span></span><br><span class="line">       contentParent.removeAllViews();</span><br><span class="line">       <span class="comment">//加载新布局</span></span><br><span class="line">       LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">       <span class="comment">//接口状态通知</span></span><br><span class="line">       mOriginalWindowCallback.onContentChanged();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>进入inflate方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(resource, root, root != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;INFLATING from resource: \&quot;&quot;</span> + res.getResourceName(resource) + <span class="string">&quot;\&quot; (&quot;</span></span><br><span class="line">                    + Integer.toHexString(resource) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parser.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>getLayout方法返回一个XmlResourceParser对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> XmlResourceParser <span class="title">getLayout</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> id)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadXmlResourceParser(id, <span class="string">&quot;layout&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function">XmlResourceParser <span class="title">loadXmlResourceParser</span><span class="params">(<span class="meta">@AnyRes</span> <span class="keyword">int</span> id, <span class="meta">@NonNull</span> String type)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TypedValue value = obtainTempTypedValue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ResourcesImpl impl = mResourcesImpl;</span><br><span class="line">        impl.getValue(id, value, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (value.type == TypedValue.TYPE_STRING) &#123;</span><br><span class="line">            <span class="keyword">return</span> impl.loadXmlResourceParser(value.string.toString(), id,</span><br><span class="line">                    value.assetCookie, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="string">&quot;Resource ID #0x&quot;</span> + Integer.toHexString(id)</span><br><span class="line">                + <span class="string">&quot; type #0x&quot;</span> + Integer.toHexString(value.type) + <span class="string">&quot; is not valid&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        releaseTempTypedValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>进入loadXmlResourceParser：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">   <span class="function">XmlResourceParser <span class="title">loadXmlResourceParser</span><span class="params">(<span class="meta">@NonNull</span> String file, <span class="meta">@AnyRes</span> <span class="keyword">int</span> id, <span class="keyword">int</span> assetCookie,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="meta">@NonNull</span> String type)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (mCachedXmlBlocks) &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span>[] cachedXmlBlockCookies = mCachedXmlBlockCookies;</span><br><span class="line">                   <span class="keyword">final</span> String[] cachedXmlBlockFiles = mCachedXmlBlockFiles;</span><br><span class="line">                   <span class="keyword">final</span> XmlBlock[] cachedXmlBlocks = mCachedXmlBlocks;</span><br><span class="line">                   <span class="comment">// First see if this block is in our cache.</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> num = cachedXmlBlockFiles.length;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (cachedXmlBlockCookies[i] == assetCookie &amp;&amp; cachedXmlBlockFiles[i] != <span class="keyword">null</span></span><br><span class="line">                               &amp;&amp; cachedXmlBlockFiles[i].equals(file)) &#123;</span><br><span class="line">                           <span class="keyword">return</span> cachedXmlBlocks[i].newParser();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// Not in the cache, create a new block and put it at</span></span><br><span class="line">                   <span class="comment">// the next slot in the cache.</span></span><br><span class="line">                   <span class="keyword">final</span> XmlBlock block = mAssets.openXmlBlockAsset(assetCookie, file);</span><br><span class="line">                   <span class="keyword">if</span> (block != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">int</span> pos = (mLastCachedXmlBlockIndex + <span class="number">1</span>) % num;</span><br><span class="line">                       mLastCachedXmlBlockIndex = pos;</span><br><span class="line">                       <span class="keyword">final</span> XmlBlock oldBlock = cachedXmlBlocks[pos];</span><br><span class="line">                       <span class="keyword">if</span> (oldBlock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           oldBlock.close();</span><br><span class="line">                       &#125;</span><br><span class="line">                       cachedXmlBlockCookies[pos] = assetCookie;</span><br><span class="line">                       cachedXmlBlockFiles[pos] = file;</span><br><span class="line">                       cachedXmlBlocks[pos] = block;</span><br><span class="line">                       <span class="keyword">return</span> block.newParser();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">final</span> NotFoundException rnf = <span class="keyword">new</span> NotFoundException(<span class="string">&quot;File &quot;</span> + file</span><br><span class="line">                       + <span class="string">&quot; from xml type &quot;</span> + type + <span class="string">&quot; resource ID #0x&quot;</span> + Integer.toHexString(id));</span><br><span class="line">               rnf.initCause(e);</span><br><span class="line">               <span class="keyword">throw</span> rnf;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="string">&quot;File &quot;</span> + file + <span class="string">&quot; from xml type &quot;</span> + type + <span class="string">&quot; resource ID #0x&quot;</span></span><br><span class="line">               + Integer.toHexString(id));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>加载指定布局文件的xml，生成XMLBlock：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="function"><span class="keyword">final</span> XmlBlock <span class="title">openXmlBlockAsset</span><span class="params">(<span class="keyword">int</span> cookie, String fileName)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!mOpen) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Assetmanager has been closed&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">long</span> xmlBlock = openXmlAssetNative(cookie, fileName);</span><br><span class="line">           <span class="keyword">if</span> (xmlBlock != <span class="number">0</span>) &#123;</span><br><span class="line">               XmlBlock res = <span class="keyword">new</span> XmlBlock(<span class="keyword">this</span>, xmlBlock);</span><br><span class="line">               incRefsLocked(res.hashCode());</span><br><span class="line">               <span class="keyword">return</span> res;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;Asset XML file: &quot;</span> + fileName);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">openXmlAssetNative</span><span class="params">(<span class="keyword">int</span> cookie, String fileName)</span></span>;</span><br></pre></td></tr></table></figure><br>最终指向了native方法</p><p>获取到XMLResourceParser后，进行渲染：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;inflate&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Context inflaterContext = mContext;</span><br><span class="line">        <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">        Context lastContext = (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">        View result = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Look for the root node.</span></span><br><span class="line">            <span class="keyword">int</span> type;</span><br><span class="line">            <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="comment">// Empty</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription()</span><br><span class="line">                        + <span class="string">&quot;: No start tag found!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Creating root view: &quot;</span></span><br><span class="line">                        + name);</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是merge标签，查看是否是当前布局的父节点，不是的话抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">&quot;&lt;merge /&gt; can be used only with a valid &quot;</span></span><br><span class="line">                            + <span class="string">&quot;ViewGroup root and attachToRoot=true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Temp is the root view that was found in the xml</span></span><br><span class="line">                <span class="comment">//获取xml中的根节点</span></span><br><span class="line">                <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>使用XmlPull解析布局，如果是merge标签，merge节点不是当前布局的父节点，则抛出异常，进入CreateViewFromTag：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createViewFromTag(parent, name, context, attrs, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="keyword">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          View view;</span><br><span class="line">          <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">              view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">              view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              view = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; mPrivateFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">              view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">              mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                      view = onCreateView(parent, name, attrs);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      view = createView(name, <span class="keyword">null</span>, attrs);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>使用mFactory2、mFactory、mPrivateFactory创建view，如果null的情况下，就会调用createView方法，内部采用反射创建节点，过多的反射会造成性能问题，可以进行优化。</p><h3 id="获取界面布局耗时"><a href="#获取界面布局耗时" class="headerlink" title="获取界面布局耗时"></a>获取界面布局耗时</h3><ol><li>手动埋点，打印时间</li><li>AOP打印setContView的时间</li><li>重写LayoutInflaterCompat.setFactory2方法，打印每一个控件的耗时时间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用LayoutInflaterCompat.Factory2全局监控Activity界面每一个控件的加载耗时，</span></span><br><span class="line">    <span class="comment">// 也可以做全局的自定义控件替换处理，比如：将TextView全局替换为自定义的TextView。</span></span><br><span class="line">    LayoutInflaterCompat.setFactory2(getLayoutInflater(), <span class="keyword">new</span> LayoutInflater.Factory2() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TextUtils.equals(name, <span class="string">&quot;TextView&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 生成自定义TextView</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            View view = getDelegate().createView(parent, name, context, attrs);</span><br><span class="line">            LogHelper.i(name + <span class="string">&quot; cost &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也可以直接调用这个方法</span></span><br><span class="line"><span class="comment">//    LayoutInflater.from(this).setFactory2(new LayoutInflater.Factory2() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                if (TextUtils.equals(name, &quot;TextView&quot;)) &#123;</span></span><br><span class="line"><span class="comment">//                    // 生成自定义TextView</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                long time = System.currentTimeMillis();</span></span><br><span class="line"><span class="comment">//                // 1</span></span><br><span class="line"><span class="comment">//                View view = getDelegate().createView(parent, name, context, attrs);</span></span><br><span class="line"><span class="comment">//                AppLog.E(name + &quot; cost &quot; + (System.currentTimeMillis() - time));</span></span><br><span class="line"><span class="comment">//                return view;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public View onCreateView(String name, Context context, AttributeSet attrs) &#123;</span></span><br><span class="line"><span class="comment">//               return null;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、setFactory2方法需在super.onCreate方法前调用，否则无效  </span></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(getLayoutId());</span><br><span class="line">    unBinder = ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">    mActivity = <span class="keyword">this</span>;</span><br><span class="line">    ActivityCollector.getInstance().addActivity(<span class="keyword">this</span>);</span><br><span class="line">    onViewCreated();</span><br><span class="line">    initToolbar();</span><br><span class="line">    initEventAndData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a>优化工具</h3><h4 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h4><p>Android Studio自带工具，可以进行代码校验，发现代码结构/质量问题</p><h4 id="Layout-Inspector"><a href="#Layout-Inspector" class="headerlink" title="Layout Inspector"></a>Layout Inspector</h4><p>Android Studio推荐布局检测工具，可以查看整个布局的层级，进而优化处理</p><h4 id="GPU过度绘制"><a href="#GPU过度绘制" class="headerlink" title="GPU过度绘制"></a>GPU过度绘制</h4><p>手机中打开开发者选项-开启GPU过度绘制</p><h3 id="布局优化的必要性"><a href="#布局优化的必要性" class="headerlink" title="布局优化的必要性"></a>布局优化的必要性</h3><ol><li>减少页面卡顿，提高流畅度</li><li>减少线上bug产出</li></ol><h3 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a>总体原则</h3><ol><li>避免层间嵌套</li><li>减少绘制时间，三个方法的执行时间</li></ol><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><ol><li>使用include标签重用公共布局</li><li><p>使用merge减少视图层级</p><p>当使用的是merge时，连续两个布局相似会合并，减少层级。</p></li><li>使用viewStub延迟加载，减少资源浪费</li><li>简单布局使用LinearLayout，复杂布局使用RelativeLayout或者ConstraintLayout减少层级嵌套。</li><li>善用控件属性<ul><li>TextView实现图片+文字显示</li><li>使用LinearLayout自带的分割线</li></ul></li><li>使用space控件</li><li>尽量少使用wrap_content，增加计算成本，绘制过久</li></ol><h3 id="主要布局比较"><a href="#主要布局比较" class="headerlink" title="主要布局比较"></a>主要布局比较</h3><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>RelativeLayout</td><td>减少层级嵌套</td><td>onDraw执行两次，耗时</td></tr><tr><td>LinearLayout</td><td>不使用weight，onDraw执行一次</td><td>布局时容易层级嵌套</td></tr><tr><td>FrameLayout</td><td></td><td></td></tr><tr><td>ConstraintLayout</td><td>减少层级 + 比例布局</td><td>耗时</td></tr></tbody></table><p>总结：性能好的布局，FrameLayout和LinearLayout<br>功能复杂，需要层级嵌套使用RelativeLayout或者ConstraintLayout。</p><blockquote><p>优先考虑层级问题，在考虑单个布局性能问题</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;绘画原理&quot;&gt;&lt;a href=&quot;#绘画原理&quot; class=&quot;headerlink&quot; title=&quot;绘画原理&quot;&gt;&lt;/a&gt;绘画原理&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Android的绘制主要是借助cpu和gpu结合刷新机制共同完成的&lt;/strong
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/05/31/移动端/Android原生/设计模式/</id>
    <published>2021-05-31T12:59:26.000Z</published>
    <updated>2021-05-31T13:13:46.660Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>确保某个类中只有一个实例，而且子性实例化并向整个系统提供整个实例</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="饿汉："><a href="#饿汉：" class="headerlink" title="饿汉："></a>饿汉：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在静态初始化器中创建单例实例，这段代码保证了线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//Singleton类只有一个构造方法并且是被private修饰的，所以用户无法通过new方法创建该对象实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉："><a href="#懒汉：" class="headerlink" title="懒汉："></a>懒汉：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//没有加入synchronized关键字的版本是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span>  Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前单例是否已经存在，若存在则返回，不存在则再建立单例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="双重校验锁（DCL）："><a href="#双重校验锁（DCL）：" class="headerlink" title="双重校验锁（DCL）："></a>双重校验锁（DCL）：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>双重判断的原因？<ul><li>第一个判断减少锁的使用，提升性能</li><li>多个线程同时等待锁，当第一个创建后，就不需要其他线程重复重建</li></ul></li><li>volatile的理解<ul><li>禁止重排序导致instance获取失败。<ul><li>给Singleton的实例分配内存</li><li>调用构造函数，初始化成员</li><li>将instance对象指向分配的内存空间<blockquote><p>执行顺序有可能是1-2-3，1-3-2</p></blockquote></li></ul></li></ul></li></ol><p>如果是1-3-2，new Singleton()方法执行时可能导致分配了空间，并指向了内存空间，但是没有赋值，这样另一个线程拿到后会导致出错</p><p>缺点：部分情况下，这种单例模式会失效</p><h5 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首次加载Singleton不会初始化instance，当调用getInstance方法时，初始化SingletonHolder类，这样虚拟机加载该类是线程安全的，保证单例对象的唯一性</p><h5 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span></span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在反序列化时，会重新创建对象，不符合单例</p></blockquote><h5 id="容器单例"><a href="#容器单例" class="headerlink" title="容器单例"></a>容器单例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key,Object instance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!objMap.containsKey(key))&#123;</span><br><span class="line">            objMap.put(key,instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getValue</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objMap.get(Key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对单例内容统一管理，放置在map中，但是HashMap线程不安全，所以最好使用ConcurrentHashMap，管理多个单例类</p><h4 id="源码应用"><a href="#源码应用" class="headerlink" title="源码应用"></a>源码应用</h4><ol><li>LayoutInflater.from(context)</li></ol><ul><li>进入main函数</li><li>新建ActivityThread，调用attach函数</li><li>AMS通信最终调用ahndlelauncherActivity</li><li>创建Activity</li><li>创建Application</li><li>获取Context对象</li><li>将context对象attach到activity中</li><li>调用Activity的onCreate方法</li></ul><p>在虚拟机第一次加载ContextImpl时会注册LayoutInflater Service，将这些服务存储在HashMap中，下次直接从缓存中读取，应用的是容器单例形式。</p><ol start="2"><li>深入LayoutInflater<br>LayoutInflater是抽象类，具体实现类是<strong>PhoneLayoutInflater</strong></li></ol><p>inflate方法：</p><ul><li>解析xml根标签（父布局）</li><li>判断merge，如果是merge直接将子布局添加到根布局</li><li>如果是普通标签，调用createViewFromTag对该元素进行解析</li><li>解析所有子view，将这些子view都添加到根布局temp下</li><li>返回解析到根视图</li></ul><p>q：为什么自定义view要使用全包名，而内置view（TextView）就不用?</p><p>a：因为在布局加载过程中，如果是内置view，直接执行onCreateView方法创建view，并将“android.widget.”加在内置view前（android.widget.TextView），然后执行createView方法。如果是自定义view，从xml中获取全量包名直接执行createView方法即可，默认前缀为null</p><blockquote><p>inflate通过<strong>深度优先</strong>遍历来构造视图树</p></blockquote><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ol><li>减少内存开支，避免创建和销毁的性能损耗</li><li>减少性能开销，永久驻留内存方式初始化复杂对象和依赖</li><li>避免对同一资源的多重占用，例如-个写文件操作，只有一个实例可以写，避免对这一个资源文件的同时写操作（避免线程不安全）</li><li>设置全局访问点，优化和共享资源访问，便于管理</li></ol><p>缺点：</p><ol><li>拓展困难，只能修改代码</li><li>如果持有context对象，会造成内存泄漏</li></ol><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>将一个复杂对象的构建与他的表示分离，是的同样的构建过程可以创建不同的表示</p><blockquote><p>核心思想是添加建造者构建主类，减少主类功能，建造者只负责构建主类</p></blockquote><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//显示器</span></span><br><span class="line">    String display;</span><br><span class="line">    <span class="comment">//cpu型号</span></span><br><span class="line">    String cpu;</span><br><span class="line">    <span class="comment">//主板型号</span></span><br><span class="line">    String mainBoard;</span><br><span class="line">    <span class="comment">//显卡型号</span></span><br><span class="line">    String gpu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.display = builder.display;</span><br><span class="line">        <span class="keyword">this</span>.cpu = builder.cpu;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = builder.mainBoard;</span><br><span class="line">        <span class="keyword">this</span>.gpu = builder.gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;显示器是&quot;</span> + display + <span class="string">&quot;\ncpu是&quot;</span> + cpu + <span class="string">&quot;\n主板是&quot;</span> + mainBoard + <span class="string">&quot;\n显卡是&quot;</span> + gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="comment">//显示器</span></span><br><span class="line">        String display;</span><br><span class="line">        <span class="comment">//cpu型号</span></span><br><span class="line">        String cpu;</span><br><span class="line">        <span class="comment">//主板型号</span></span><br><span class="line">        String mainBoard;</span><br><span class="line">        <span class="comment">//显卡型号</span></span><br><span class="line">        String gpu;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.display = <span class="string">&quot;三星曲屏&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.cpu = <span class="string">&quot;i5 8400&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = <span class="string">&quot;华硕Z360-B&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.gpu = <span class="string">&quot;GTX 1050Ti&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setcpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMainBoard</span><span class="params">(String mainBoard)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = mainBoard;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setGpu</span><span class="params">(String gpu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.gpu = gpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Computer(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer.Builder()</span><br><span class="line">                .setcpu(<span class="string">&quot;i9 4700u&quot;</span>)</span><br><span class="line">                .setGpu(<span class="string">&quot;GTX 2060Ti&quot;</span>)</span><br><span class="line">                .setMainBoard(<span class="string">&quot;华硕Z480&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(computer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码应用-1"><a href="#源码应用-1" class="headerlink" title="源码应用"></a>源码应用</h4><ol><li><p>AlertDialog<br>内部调用Buidler模式构建，最终通过WindowManager显示在手机屏幕上。</p></li><li><p>WindowManager源码分析<br>所有需要显示到屏幕上的内容都是通过WindowManager来操作的，WM的一个非常重要的子系统为WMS（WindowManagerService）<br>在android.app.SystemServiceRegistry中：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">               <span class="keyword">new</span> CachedServiceFetcher&lt;WindowManager&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> WindowManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(ctx);</span><br><span class="line">           &#125;&#125;);</span><br></pre></td></tr></table></figure><p>WMS也是初始化的众多服务的一种，所以在ContentImpl中初始化,并将初始化的服务注册到一个map中，需要时通过键获取调用，属于单例模式的容器单例。</p><p>以PopupWindow为例，我们获取到popupWindow的初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br></pre></td></tr></table></figure><br>通过以上方法获取WM，显示时使用showAtLocation()方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAtLocation</span><span class="params">(IBinder token, <span class="keyword">int</span> gravity, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">    invokePopup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokePopup</span><span class="params">(WindowManager.LayoutParams p)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mWindowManager.addView(decorView, p);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>通过一系列的调用，最终使用WM的addView方法添加布局，回溯之前的分析WM的实例是WindowManagerImpl，进入addView方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而在WMImpl方法中调用WMGlobal.addView方法，进入：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="params"><span class="function">           Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">       </span><br><span class="line">       ViewRootImpl root;</span><br><span class="line">       View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">       <span class="comment">//构建ViewRootImpl</span></span><br><span class="line">       root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">       <span class="comment">//view设置参数</span></span><br><span class="line">       view.setLayoutParams(wparams);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//将view添加到列表</span></span><br><span class="line">       mViews.add(view);</span><br><span class="line">       <span class="comment">//将ViewRootImpl添加到列表</span></span><br><span class="line">       mRoots.add(root);</span><br><span class="line">       <span class="comment">//将参数添加在列表</span></span><br><span class="line">       mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// do this last because it fires off messages to start doingthings</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用viewRootImpl的setView方法添加布局</span></span><br><span class="line">           root.setView(view, wparams, panelParentView);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">           <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ul><li>构建ViewRootImpl</li><li>将布局参数设置给view</li><li>存储ViewRootImpl、View、LayoutParam到列表</li><li>调用ViewRootImpl.setView将view显示在窗口</li></ul><p>进一步查看ViewRootImpl是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">      mContext = context;</span><br><span class="line">      <span class="comment">//获取WindowSession，也就是和WMS建立连接</span></span><br><span class="line">      mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">      ......</span><br><span class="line">      <span class="comment">//创建线程为当前线程，因为主界面在UI线程，所以在子线程更新UI会抛出异常，但并不是只用UI线程才能更新UI</span></span><br><span class="line">      mThread = Thread.currentThread();</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>进入WMGlobal.getWindowSession方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">                <span class="comment">//获取WMS</span></span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                <span class="comment">//建立一个WindowSession</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>进入getWindowManagerService，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowManager <span class="title">getWindowManagerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowManagerService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">                    ServiceManager.getService(<span class="string">&quot;window&quot;</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sWindowManagerService != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ValueAnimator.setDurationScale(</span><br><span class="line">                            sWindowManagerService.getCurrentAnimatorScale());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowManagerService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过ServiceManager.getService()获取WMS，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder service = sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Binder.allowBlocking(getIServiceManager().getService(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;error in getService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过sCache获取到一个IBinder对象，所以FrameWork与WMS之间也是通过Binder机制进行通信的，回溯到之前，会调用IWindowManager.Stub.asInterface()，将IBinder对象转化为WM对象，然后通过openSession与WMS建立通信绘画，之后通过这个session进行交换信息，但是到现在还是没有显示view，所以继续走ViewRootImpl.setView方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//请求布局</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通过Windowsession和WMS通信，请求显示</span></span><br><span class="line">                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">            &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>requestlayout：请求布局</li><li>向WMS请求显示布局</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        <span class="comment">//线程校验</span></span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//开启屏障消息，优先处理</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//通过handler回调执行MTraversalRunnable</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过handler回调执行MTraversalRunnable，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//view的具体操作</span></span><br><span class="line">        performTraversals();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终进入performTraversals进行具体操作</p><ol><li>获取Surface对象，用于图形绘制</li><li>performMeasure函数，测量整个视图树各个view的大小</li><li>performLayout,布局整个view</li><li>performDraw，绘制整个view</li></ol><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>良好的封装性，使客户端不知道产品内部组成细节</li><li>独立，容易拓展</li></ul><p>缺点：</p><ul><li>产生多余Builder对象和Director对象，消耗内存</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象</p><h4 id="简单例子-1"><a href="#简单例子-1" class="headerlink" title="简单例子"></a>简单例子</h4><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>原型模式实际上是浅拷贝，也称为影子拷贝。拷贝实际不是将所有字段重新构造一份，而是拷贝文档的字段引用原始文档的字段而已，所以会导致修改副本的字段，原始字段也会跟着修改，因为最终修改的是同一个内存单元，所以在原型模式中，要尽量使用深拷贝。</p><ul><li>深拷贝：复制引用对象的值</li><li>浅拷贝：复制引用</li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ol><li><p>ArrayList的clone方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//克隆自身</span></span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//克隆数组对象</span></span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>克隆自身后，在克隆数组对象，并没有对size进行克隆是因为size是值类型，并不是引用类型。</p></li><li><p>Intent的clone方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Intent(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Intent</span><span class="params">(Intent o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(o, COPY_MODE_ALL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Intent</span><span class="params">(Intent o, <span class="meta">@CopyMode</span> <span class="keyword">int</span> copyMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mAction = o.mAction;</span><br><span class="line">    <span class="keyword">this</span>.mData = o.mData;</span><br><span class="line">    <span class="keyword">this</span>.mType = o.mType;</span><br><span class="line">    <span class="keyword">this</span>.mPackage = o.mPackage;</span><br><span class="line">    <span class="keyword">this</span>.mComponent = o.mComponent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o.mCategories != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mCategories = <span class="keyword">new</span> ArraySet&lt;&gt;(o.mCategories);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copyMode != COPY_MODE_FILTER) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mFlags = o.mFlags;</span><br><span class="line">        <span class="keyword">this</span>.mContentUserHint = o.mContentUserHint;</span><br><span class="line">        <span class="keyword">this</span>.mLaunchToken = o.mLaunchToken;</span><br><span class="line">        <span class="keyword">if</span> (o.mSourceBounds != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mSourceBounds = <span class="keyword">new</span> Rect(o.mSourceBounds);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o.mSelector != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mSelector = <span class="keyword">new</span> Intent(o.mSelector);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copyMode != COPY_MODE_HISTORY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.mExtras != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mExtras = <span class="keyword">new</span> Bundle(o.mExtras);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o.mClipData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mClipData = <span class="keyword">new</span> ClipData(o.mClipData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.mExtras != <span class="keyword">null</span> &amp;&amp; !o.mExtras.maybeIsEmpty()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mExtras = Bundle.STRIPPED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Also set &quot;stripped&quot; clip data when we ever log mClipData in the (broadcast)</span></span><br><span class="line">            <span class="comment">// history.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在Intent的clone方法中直接使用new方法构建了新intent</p><p>所以延伸出一个问题，new和clone怎么选择？</p><p>如果对象的构造成本太高或者构造比较麻烦，那么使用clone函数效率高，否则使用new</p><ol start="3"><li>intent的查找和匹配</li></ol><p>intent是怎么查找对应的组件然后跳转的呢？</p><p>在ContextImpl初始化的SystemServiceRegistry中初始化各种服务（WMS,AMS等），其中，初始化了PMS（PackageManagerService）</p><p>在ContextImpl中执行getPackageManager方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Doesn&#x27;t matter if we make more than one instance.</span></span><br><span class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>进入ActivityThread.getPackageManager()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</span></span><br><span class="line">        <span class="keyword">return</span> sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取PackageManagerService</span></span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">&quot;package&quot;</span>);</span><br><span class="line">    <span class="comment">//Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</span></span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    <span class="comment">//Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</span></span><br><span class="line">    <span class="keyword">return</span> sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取到PackageManagerService服务，这个服务是在系统初始化时通过SystemServer启动的，现在只是获取，查看PackageManagerService类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PMS为IPackageManager.Stub的具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageManagerService</span> <span class="keyword">extends</span> <span class="title">IPackageManager</span>.<span class="title">Stub</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">PackageSender</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,<span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Collect privileged system packages.</span></span><br><span class="line">        <span class="comment">// 扫描特殊系统包</span></span><br><span class="line">        <span class="keyword">final</span> File privilegedAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">&quot;priv-app&quot;</span>);</span><br><span class="line">        scanDirTracedLI(privilegedAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_PRIVILEGED,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect ordinary system packages.</span></span><br><span class="line">        <span class="comment">// 扫描普通系统包</span></span><br><span class="line">        <span class="keyword">final</span> File systemAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        scanDirTracedLI(systemAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect privileged vendor packages.</span></span><br><span class="line">        <span class="comment">// 扫描特殊vendor下包</span></span><br><span class="line">        File privilegedVendorAppDir = <span class="keyword">new</span> File(Environment.getVendorDirectory(), <span class="string">&quot;priv-app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            privilegedVendorAppDir = privilegedVendorAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(privilegedVendorAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_VENDOR</span><br><span class="line">                | SCAN_AS_PRIVILEGED,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect ordinary vendor packages.</span></span><br><span class="line">        <span class="comment">// 扫描普通vendor下包</span></span><br><span class="line">        File vendorAppDir = <span class="keyword">new</span> File(Environment.getVendorDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            vendorAppDir = vendorAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(vendorAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_VENDOR,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect privileged odm packages. /odm is another vendor partition</span></span><br><span class="line">        <span class="comment">// other than /vendor.</span></span><br><span class="line">        <span class="comment">// 扫描特殊odm下包/odm时vendor的一部分</span></span><br><span class="line">        File privilegedOdmAppDir = <span class="keyword">new</span> File(Environment.getOdmDirectory(),</span><br><span class="line">                    <span class="string">&quot;priv-app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            privilegedOdmAppDir = privilegedOdmAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(privilegedOdmAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_VENDOR</span><br><span class="line">                | SCAN_AS_PRIVILEGED,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect ordinary odm packages. /odm is another vendor partition</span></span><br><span class="line">        <span class="comment">// other than /vendor.</span></span><br><span class="line">        <span class="comment">// 扫描普通odm下包/odm时vendor的一部分</span></span><br><span class="line">        File odmAppDir = <span class="keyword">new</span> File(Environment.getOdmDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            odmAppDir = odmAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(odmAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_VENDOR,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect all OEM packages.</span></span><br><span class="line">        <span class="comment">// 扫描所有OEM包</span></span><br><span class="line">        <span class="keyword">final</span> File oemAppDir = <span class="keyword">new</span> File(Environment.getOemDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        scanDirTracedLI(oemAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_OEM,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collected privileged product packages.</span></span><br><span class="line">        <span class="comment">// 扫描特殊product包</span></span><br><span class="line">        File privilegedProductAppDir = <span class="keyword">new</span> File(Environment.getProductDirectory(), <span class="string">&quot;priv-app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            privilegedProductAppDir = privilegedProductAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(privilegedProductAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_PRODUCT</span><br><span class="line">                | SCAN_AS_PRIVILEGED,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect ordinary product packages.</span></span><br><span class="line">         <span class="comment">// 扫描普通product包</span></span><br><span class="line">        File productAppDir = <span class="keyword">new</span> File(Environment.getProductDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            productAppDir = productAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(productAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_PRODUCT,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>PMS会加载一系列，在不同目录下的包执行scanDirTracedLI方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirTracedLI</span><span class="params">(File dir, <span class="keyword">final</span> <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;scanDir [&quot;</span> + dir.getAbsolutePath() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        scanDirLI(dir, parseFlags, scanFlags, currentTime);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirLI</span><span class="params">(File dir, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取目录下所有文件</span></span><br><span class="line">    <span class="keyword">final</span> File[] files = dir.listFiles();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isPackage = (isApkFile(file) || file.isDirectory())</span><br><span class="line">                &amp;&amp; !PackageInstallerService.isStageName(file.getName());</span><br><span class="line">        <span class="keyword">if</span> (!isPackage) &#123;</span><br><span class="line">            <span class="comment">// Ignore entries which are not packages</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parallelPackageParser.submit(file, parseFlags);</span><br><span class="line">        fileCount++;</span><br><span class="line">    &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> (; fileCount &gt; <span class="number">0</span>; fileCount--) &#123;</span><br><span class="line">            scanPackageLI(parseResult.pkg, parseResult.scanFile, parseFlags, scanFlags,</span><br><span class="line">                            currentTime, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>扫描目录下的子目录，对apk文件进行解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(File scanFile, <span class="keyword">int</span> parseFlags)</span> </span>&#123;</span><br><span class="line">       mService.submit(() -&gt; &#123;</span><br><span class="line">           ParseResult pr = <span class="keyword">new</span> ParseResult();</span><br><span class="line">           Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;parallel parsePackage [&quot;</span> + scanFile + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//创建一个包解析器</span></span><br><span class="line">               PackageParser pp = <span class="keyword">new</span> PackageParser();</span><br><span class="line">               pp.setSeparateProcesses(mSeparateProcesses);</span><br><span class="line">               pp.setOnlyCoreApps(mOnlyCore);</span><br><span class="line">               pp.setDisplayMetrics(mMetrics);</span><br><span class="line">               pp.setCacheDir(mCacheDir);</span><br><span class="line">               pp.setCallback(mPackageParserCallback);</span><br><span class="line">               pr.scanFile = scanFile;</span><br><span class="line">               <span class="comment">//执行apk包解析</span></span><br><span class="line">               pr.pkg = parsePackage(pp, scanFile, parseFlags);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               pr.throwable = e;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               mQueue.put(pr);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               Thread.currentThread().interrupt();</span><br><span class="line">               <span class="comment">// Propagate result to callers of take().</span></span><br><span class="line">               <span class="comment">// This is helpful to prevent main thread from getting stuck waiting on</span></span><br><span class="line">               <span class="comment">// ParallelPackageParser to finish in case of interruption</span></span><br><span class="line">               mInterruptedInThread = Thread.currentThread().getName();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@VisibleForTesting</span></span><br><span class="line">   <span class="keyword">protected</span> PackageParser.<span class="function">Package <span class="title">parsePackage</span><span class="params">(PackageParser packageParser, File scanFile,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> parseFlags)</span> <span class="keyword">throws</span> PackageParser.PackageParserException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> packageParser.parsePackage(scanFile, parseFlags, <span class="keyword">true</span> <span class="comment">/* useCaches */</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>创建一个PackageParser，调用parsePackage函数解析apk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">parsePackage</span><span class="params">(File packageFile, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> useCaches)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">    Package parsed = useCaches ? getCachedResult(packageFile, flags) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (parsed != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> parsed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是文件夹类型</span></span><br><span class="line">    <span class="keyword">if</span> (packageFile.isDirectory()) &#123;</span><br><span class="line">        parsed = parseClusterPackage(packageFile, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//解析单个apk</span></span><br><span class="line">        parsed = parseMonolithicPackage(packageFile, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cacheResult(packageFile, flags, parsed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parsed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是文件夹类型，加载多个apk文件，如果是单个apk，只加载一个apk<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Package <span class="title">parseMonolithicPackage</span><span class="params">(File apkFile, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AssetManager assets = newConfiguredAssetManager();</span><br><span class="line">        <span class="keyword">final</span> PackageLite lite = parseMonolithicPackageLite(apkFile, flags);</span><br><span class="line">        <span class="keyword">if</span> (mOnlyCoreApps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lite.coreApp) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,</span><br><span class="line">                        <span class="string">&quot;Not a coreApp: &quot;</span> + apkFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行具体解析</span></span><br><span class="line">            <span class="keyword">final</span> Package pkg = parseBaseApk(apkFile, assets, flags);</span><br><span class="line">            pkg.setCodePath(apkFile.getAbsolutePath());</span><br><span class="line">            pkg.setUse32bitAbi(lite.use32bitAbi);</span><br><span class="line">            <span class="keyword">return</span> pkg;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(assets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>进入parseBaseApk:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApk</span><span class="params">(File apkFile, AssetManager assets, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">       <span class="comment">//获取apk路径</span></span><br><span class="line">       <span class="keyword">final</span> String apkPath = apkFile.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">       String volumeUuid = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (apkPath.startsWith(MNT_EXPAND)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> end = apkPath.indexOf(<span class="string">&#x27;/&#x27;</span>, MNT_EXPAND.length());</span><br><span class="line">           volumeUuid = apkPath.substring(MNT_EXPAND.length(), end);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mParseError = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">       mArchiveSourcePath = apkFile.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (DEBUG_JAR) Slog.d(TAG, <span class="string">&quot;Scanning base APK: &quot;</span> + apkPath);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> cookie = loadApkIntoAssetManager(assets, apkPath, flags);</span><br><span class="line"></span><br><span class="line">       Resources res = <span class="keyword">null</span>;</span><br><span class="line">       XmlResourceParser parser = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//获取apk资源文件</span></span><br><span class="line">           res = <span class="keyword">new</span> Resources(assets, mMetrics, <span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//解析AndroidManifest</span></span><br><span class="line">           parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> String[] outError = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">final</span> Package pkg = parseBaseApk(apkPath, res, parser, flags, outError);</span><br><span class="line">           <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> PackageParserException(mParseError,</span><br><span class="line">                       apkPath + <span class="string">&quot; (at &quot;</span> + parser.getPositionDescription() + <span class="string">&quot;): &quot;</span> + outError[<span class="number">0</span>]);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           pkg.setVolumeUuid(volumeUuid);</span><br><span class="line">           pkg.setApplicationVolumeUuid(volumeUuid);</span><br><span class="line">           pkg.setBaseCodePath(apkPath);</span><br><span class="line">           pkg.setSignatures(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> pkg;</span><br><span class="line">           ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>获取apk路径，解析apk资源文件及AndroidManifest<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">parseBaseApkChild</span><span class="params">(Package parentPkg, Resources res, XmlResourceParser parser,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> flags, String[] outError)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建package对象，将版本信息存储进来</span></span><br><span class="line">    <span class="comment">// Go ahead and parse the child</span></span><br><span class="line">    Package childPkg = <span class="keyword">new</span> Package(childPackageName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Child package inherits parent version code/name/target SDK</span></span><br><span class="line">    childPkg.mVersionCode = parentPkg.mVersionCode;</span><br><span class="line">    childPkg.baseRevisionCode = parentPkg.baseRevisionCode;</span><br><span class="line">    childPkg.mVersionName = parentPkg.mVersionName;</span><br><span class="line">    childPkg.applicationInfo.targetSdkVersion = parentPkg.applicationInfo.targetSdkVersion;</span><br><span class="line">    childPkg.applicationInfo.minSdkVersion = parentPkg.applicationInfo.minSdkVersion;</span><br><span class="line"></span><br><span class="line">    childPkg = parseBaseApkCommon(childPkg, CHILD_PACKAGE_TAGS, res, parser, flags, outError);</span><br><span class="line">    <span class="keyword">if</span> (childPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If we got null then error was set during child parsing</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the parent-child relation</span></span><br><span class="line">    <span class="keyword">if</span> (parentPkg.childPackages == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentPkg.childPackages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    parentPkg.childPackages.add(childPkg);</span><br><span class="line">    childPkg.parentPackage = parentPkg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建package对象，将版本信息存储进来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApkCommon</span><span class="params">(Package pkg, Set&lt;String&gt; acceptedTags, Resources res,</span></span></span><br><span class="line"><span class="params"><span class="function">        XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span> <span class="keyword">throws</span> XmlPullParserException,</span></span><br><span class="line"><span class="function">        IOException </span>&#123;</span><br><span class="line">        .......</span><br><span class="line">    <span class="comment">//解析AndroidManifest的深度</span></span><br><span class="line">    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(TAG_APPLICATION)) &#123;</span><br><span class="line">           ......</span><br><span class="line">           <span class="comment">//解析Application标签</span></span><br><span class="line">            <span class="keyword">if</span> (!parseBaseApplication(pkg, res, parser, flags, outError)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(TAG_PERMISSION)) &#123;</span><br><span class="line">            <span class="comment">//解析权限标签</span></span><br><span class="line">            <span class="keyword">if</span> (!parsePermission(pkg, res, parser, outError)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> pkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取AndroidManifest的深度，然后深度遍历获取所有的标签并依次处理，这里以Application为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">parseBaseApplication</span><span class="params">(Package owner, Resources res,</span></span></span><br><span class="line"><span class="params"><span class="function">        XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取应用信息</span></span><br><span class="line">    <span class="keyword">final</span> ApplicationInfo ai = owner.applicationInfo;</span><br><span class="line">    <span class="comment">//获取包名</span></span><br><span class="line">    <span class="keyword">final</span> String pkgName = owner.applicationInfo.packageName;</span><br><span class="line">    <span class="comment">//获取Application的TypedArray</span></span><br><span class="line">    TypedArray sa = res.obtainAttributes(parser,</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestApplication);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取应用名</span></span><br><span class="line">    String manageSpaceActivity = sa.getNonConfigurationString(</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,</span><br><span class="line">            Configuration.NATIVE_CONFIG_VERSION);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取Application的allowBackUp</span></span><br><span class="line">    <span class="keyword">boolean</span> allowBackup = sa.getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestApplication_allowBackup, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//获取主题</span></span><br><span class="line">    ai.theme = sa.getResourceId(</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestApplication_theme, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//获取描述</span></span><br><span class="line">    ai.descriptionRes = sa.getResourceId(</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestApplication_description, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取taskAffinity</span></span><br><span class="line">    ai.taskAffinity = buildTaskAffinityName(ai.packageName, ai.packageName,</span><br><span class="line">            str, outError);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> innerDepth = parser.getDepth();</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="comment">//迭代Application元素下的所有子元素</span></span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取标签名</span></span><br><span class="line">        String tagName = parser.getName();</span><br><span class="line">        <span class="comment">//如果是Activity</span></span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;activity&quot;</span>)) &#123;</span><br><span class="line">            Activity a = parseActivity(owner, res, parser, flags, outError, <span class="keyword">false</span>,</span><br><span class="line">                    owner.baseHardwareAccelerated);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            owner.activities.add(a);</span><br><span class="line">            <span class="comment">//如果是receiver</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;receiver&quot;</span>)) &#123;</span><br><span class="line">            Activity a = parseActivity(owner, res, parser, flags, outError, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            owner.receivers.add(a);</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>解析Application的其他属性及其子标签,而后返回方法直到scanDirLI方法，执行scanPackageLI函数</p><p>scanPackageLI—&gt;scanPackageInternalLI—&gt;scanPackageLI—&gt;scanPackageDirtyLI—&gt;commitPackageSettings<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">commitPackageSettings</span><span class="params">(PackageParser.Package pkg, PackageSetting pkgSetting,</span></span></span><br><span class="line"><span class="params"><span class="function">            UserHandle user, <span class="keyword">int</span> scanFlags, <span class="keyword">boolean</span> chatty)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//获取activities的大小</span></span><br><span class="line">            N = pkg.activities.size();</span><br><span class="line">            r = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                PackageParser.Activity a = pkg.activities.get(i);</span><br><span class="line">                a.info.processName = fixProcessName(pkg.applicationInfo.processName,</span><br><span class="line">                        a.info.processName);</span><br><span class="line">                <span class="comment">//将activity添加到mActivies</span></span><br><span class="line">                mActivities.addActivity(a, <span class="string">&quot;activity&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (chatty) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        r = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    r.append(a.info.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//其他标签忽略</span></span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>将解析的标签，例activity记载到PMS的缓存中。至此，apk的所有信息就被存储在系统中，当使用intent跳转时会在该信息表中进行查找，然后跳转。</p><p>我们使用intent时，一般是这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MainActivity.class);</span><br><span class="line"><span class="keyword">this</span>.startActivity(intent);</span><br></pre></td></tr></table></figure><br>跟踪源码，最终跳转到startActivityForResult：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(<span class="meta">@RequiresPermission</span> Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="meta">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">           options = transferSpringboardActivityOptions(options);</span><br><span class="line">           <span class="comment">//启动Activity</span></span><br><span class="line">           Instrumentation.ActivityResult ar =</span><br><span class="line">               mInstrumentation.execStartActivity(</span><br><span class="line">                   <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                   intent, requestCode, options);</span><br><span class="line">           <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//发送启动请求</span></span><br><span class="line">               mMainThread.sendActivityResult(</span><br><span class="line">                   mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                   ar.getResultData());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           cancelInputsAndStartExitTransition(options);</span><br><span class="line">           <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">               <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">               mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>通过instrumentation启动Activity，并向主线程发送启动请求<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     Context who, IBinder contextThread, IBinder token, String target,</span></span></span><br><span class="line"><span class="params"><span class="function">     Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">     IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">     ......</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//将Intent中的数据迁移到粘贴板</span></span><br><span class="line">         intent.migrateExtraStreamToClipData();</span><br><span class="line">         <span class="comment">//准备离开当前进程</span></span><br><span class="line">         intent.prepareToLeaveProcess(who);</span><br><span class="line">         <span class="comment">//通过AMS启动Activity</span></span><br><span class="line">         <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">             .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                     intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                     token, target, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">         <span class="comment">//检测结果，并且回调给调用端</span></span><br><span class="line">         checkStartActivityResult(result, intent);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>进入AMS方法，调用</p><p>startActivityAsUser—&gt;ActivityStarter.startActivityMayWait—&gt;ActivityStackSupervisor.resolveIntent—&gt;AMS.getPackageManagerInternalLocked—&gt;PMS.resolveIntent—&gt;PMS.resolveIntentInternal—&gt;PMS.queryIntentActivitiesInternal<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="meta">@NonNull</span> <span class="function">List&lt;ResolveInfo&gt; <span class="title">queryIntentActivitiesInternal</span><span class="params">(Intent intent,</span></span></span><br><span class="line"><span class="params"><span class="function">        String resolvedType, <span class="keyword">int</span> flags, <span class="keyword">int</span> filterCallingUid, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> resolveForStart)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取包名</span></span><br><span class="line">    <span class="keyword">final</span> String pkgName = intent.getPackage();</span><br><span class="line">    <span class="comment">//获取component对象</span></span><br><span class="line">    ComponentName comp = intent.getComponent();</span><br><span class="line">    <span class="comment">//如果component不为null</span></span><br><span class="line">    <span class="keyword">if</span> (comp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ResolveInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;ResolveInfo&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//直接getActivityInfo获取ActivityInfo对象</span></span><br><span class="line">        <span class="keyword">final</span> ActivityInfo ai = getActivityInfo(comp, flags, userId);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果是隐式intent</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="comment">//如果包名为null</span></span><br><span class="line">        <span class="keyword">if</span> (pkgName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;CrossProfileIntentFilter&gt; matchingFilters =</span><br><span class="line">                    getMatchingCrossProfileIntentFilters(intent, resolvedType, userId);</span><br><span class="line">            <span class="comment">// Check for results that need to skip the current profile.</span></span><br><span class="line">            <span class="comment">//获取resolveInfo对象</span></span><br><span class="line">            ResolveInfo xpResolveInfo  = querySkipCurrentProfileIntents(matchingFilters, intent,</span><br><span class="line">                    resolvedType, flags, userId);</span><br><span class="line">            <span class="keyword">if</span> (xpResolveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                List&lt;ResolveInfo&gt; xpResult = <span class="keyword">new</span> ArrayList&lt;ResolveInfo&gt;(<span class="number">1</span>);</span><br><span class="line">                xpResult.add(xpResolveInfo);</span><br><span class="line">                <span class="keyword">return</span> applyPostResolutionFilter(</span><br><span class="line">                        filterIfNotSystemUser(xpResult, userId), instantAppPkgName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过包名获取Package对象</span></span><br><span class="line">            <span class="keyword">final</span> PackageParser.Package pkg = mPackages.get(pkgName);</span><br><span class="line">            result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (pkg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//通过package获取ActivityInfo</span></span><br><span class="line">                result = filterIfNotSystemUser(</span><br><span class="line">                        mActivities.queryIntentForPackage(</span><br><span class="line">                                intent, resolvedType, flags, pkg.activities, userId),</span><br><span class="line">                        userId);</span><br><span class="line">            &#125;</span><br><span class="line">           ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果intent指明了Component（即MainActivity），直接获取到ActivityInfo并且数量只有一个，直接返回。如果Component为空，会检测发起方所在的包名，如果有包名，通过包名获取ActivityInfo，反之，根据其他信息比如外部拉起，action，Category等判断。</p><p>总结：在系统启动时，PMS启动分析所有apk的信息，创建一个信息表，当用胡使用Intent跳转时，会根据intent中包含的信息到PMS的信息表查找，最后跳转到目标组件</p><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>内存中二进制流的拷贝，其比直接new一个对象性能会好很多<br>缺点：</li><li>直接在内存中拷贝，不会执行构造函数，使用过程中对比new和clone方法的区别</li></ul><blockquote><p>原型模式就是要实现深拷贝</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>用于创建对象的接口，让子类决定实例化那个类，解决对象之间的解耦</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类具体实现方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制造ProductA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制造ProductB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;A&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;B&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">    Product a = factory.create(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    a.method();</span><br><span class="line">    Product b = factory.create(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    b.method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后：</p><p>制造ProductA</p><p>制造ProductB</p><h5 id="工厂方法抽象"><a href="#工厂方法抽象" class="headerlink" title="工厂方法抽象"></a>工厂方法抽象</h5><p>产品类不变，工厂变为抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂具体实现方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    FactoryA factoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">    FactoryB factoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">    factoryA.create().method();</span><br><span class="line">    factoryB.create().method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后：</p><p>制造ProductA</p><p>制造ProductB</p><h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h5><p>需要多个产品最终组成为一个产品<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cpu子类的具体执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CpuA</span> <span class="keyword">extends</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A型号CPU&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CpuB</span> <span class="keyword">extends</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B型号CPU&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示屏的子类执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayA</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A型号显示屏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayB</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B型号显示屏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Cpu</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Cpu <span class="title">createCpu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建显示屏</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Display <span class="title">createDisplay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">createCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CpuA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Display <span class="title">createDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DisplayA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">createCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CpuB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Display <span class="title">createDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DisplayB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        FactoryA factoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        FactoryB factoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        factoryA.createCpu().method();</span><br><span class="line">        factoryA.createDisplay().method();</span><br><span class="line">        factoryB.createCpu().method();</span><br><span class="line">        factoryB.createDisplay().method();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>执行结果如下：</p><p>A型号CPU</p><p>A型号显示屏</p><p>B型号CPU</p><p>B型号显示屏</p><blockquote><p>抽象工厂的核心是复杂的工厂模式。存在多个工厂，多种产品类型，就会使用抽象工厂，在android源码中使用较少，并没有那么多产品种类，大部分使用简单工厂或者工厂方法就可以解决。</p></blockquote><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><ol><li>ArrayList和HashSet都继承自Collection接口，collection接口继承自Iterator接口。</li><li>xxxActivity都继承自Activity，其onCreate方法就是工厂方法，两个Activity构建不同的view，可以将view看成product，Activity为Factory。</li><li>xxService都继承自Service，其onBind方法也可以看作是一个工厂方法<br>4.</li></ol><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>功能逻辑解耦</li></ul><p>缺点：</p><ul><li>拓展新功能需要添加新类，复杂类结构</li></ul><p>抽象工厂的优点:</p><ul><li>分离接口与实现,使用方不知道具体的实现是什么,同时使抽象该工厂方法模式在切换产品类时更加灵活,容易</li></ul><p>抽象工厂的缺点:</p><ul><li>类文件结构复杂</li><li>不容易拓展新类</li></ul><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>定义一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，策略模式让算法独立于使用他们的客户而独立存在，解决if-else滥用的问题</p><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePrice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TransPortType</span> </span>&#123;</span><br><span class="line">        BUS,</span><br><span class="line">        SUBWAY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算公交车车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateBus</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;公交车&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算地铁车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateSubWay</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;地铁&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> km, TransPortType transPortType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (transPortType) &#123;</span><br><span class="line">            <span class="keyword">case</span> BUS:</span><br><span class="line">                calculateBus(km);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUBWAY:</span><br><span class="line">                calculateSubWay(km);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        CalculatePrice calculatePrice = <span class="keyword">new</span> CalculatePrice();</span><br><span class="line">        calculatePrice.calculate(<span class="number">16</span>,TransPortType.BUS);</span><br><span class="line">        calculatePrice.calculate(<span class="number">15</span>,TransPortType.SUBWAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>公交车16公里的车票</p><p>地铁15公里的车票</p><p>当需要拓展时，比如多了一个出租车，需要这样做<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePrice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TransPortType</span> </span>&#123;</span><br><span class="line">        BUS,</span><br><span class="line">        SUBWAY,</span><br><span class="line">        TAXI</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算公交车车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateBus</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;公交车&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算地铁车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateSubWay</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;地铁&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算出租车车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateTaxi</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出租车&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> km, TransPortType transPortType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (transPortType) &#123;</span><br><span class="line">            <span class="keyword">case</span> BUS:</span><br><span class="line">                calculateBus(km);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUBWAY:</span><br><span class="line">                calculateSubWay(km);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TAXI:</span><br><span class="line">                calculateTaxi(km);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        CalculatePrice calculatePrice = <span class="keyword">new</span> CalculatePrice();</span><br><span class="line">        calculatePrice.calculate(<span class="number">16</span>,TransPortType.BUS);</span><br><span class="line">        calculatePrice.calculate(<span class="number">15</span>,TransPortType.SUBWAY);</span><br><span class="line">        calculatePrice.calculate(<span class="number">17</span>,TransPortType.TAXI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果：</p><p>公交车16公里的车票</p><p>地铁15公里的车票</p><p>出租车17公里的车票</p><p>改动还是比较大的，对源代码的基础上做了更改，并且添加了if-else判断taxi类型。<br>如果把他改成策略模式，试试效果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类具体执行车票计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getPrice</span><span class="params">(<span class="keyword">int</span> km)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusCalculateStrategy</span> <span class="keyword">extends</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;公交车&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubWayCalculateStrategy</span> <span class="keyword">extends</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;地铁&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        CalculateStrategy calculateStrategy = <span class="keyword">new</span> BusCalculateStrategy();</span><br><span class="line">        calculateStrategy.getPrice(<span class="number">16</span>);</span><br><span class="line">        CalculateStrategy calculateStrategy1 = <span class="keyword">new</span> SubWayCalculateStrategy();</span><br><span class="line">        calculateStrategy1.getPrice(<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>结果：</p><p>公交车16公里的车票</p><p>地铁15公里的车票</p><p>当需要拓展出租车时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaxiCalculateStrategy</span> <span class="keyword">extends</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出租车&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        CalculateStrategy calculateStrategy2 = <span class="keyword">new</span> TaxiCalculateStrategy();</span><br><span class="line">        calculateStrategy2.getPrice(<span class="number">17</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>只需要添加Taxi类继承自策略类，执行具体车费计算方法，在main中调用即可，这样对代码的侵入性最小，不用修改原有逻辑代码，在咋付逻辑出引用效果优秀</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>当一个对象的内在行为改变时，允许改变其行为，整个对象看起来像是改变了其类</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><ol><li>wifi状态管理<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4>使多个对象都有机会处理请求，这些对象形成一条链，依次执行，直到结束。<h4 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h4></li><li>view的事件传递</li></ol><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>定义对象间一种一对多的一栏关系，使得每当一个对象改变状态，则所有依赖与他的对象都会得到通知并被自动更新</p><h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mode2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IObserver</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> temp)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IObservable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(IObserver iObserver)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(IObserver iObserver)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被观察者（发布者）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> <span class="keyword">implements</span> <span class="title">IObservable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;IObserver&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(IObserver iObserver)</span> </span>&#123;</span><br><span class="line">            list.add(iObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(IObserver iObserver)</span> </span>&#123;</span><br><span class="line">            list.remove(iObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                list.get(i).update(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemp</span><span class="params">(<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.temp = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者1（订阅者）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer1</span> <span class="keyword">implements</span> <span class="title">IObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Observable1更新为 = &quot;</span> + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者2(订阅者)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer2</span> <span class="keyword">implements</span> <span class="title">IObserver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Observable2更新为 = &quot;</span> + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Observable observable = <span class="keyword">new</span> Observable();</span><br><span class="line">        Observer1 observer1 = <span class="keyword">new</span> Observer1();</span><br><span class="line">        Observer2 observer2 = <span class="keyword">new</span> Observer2();</span><br><span class="line">        observable.register(observer1);</span><br><span class="line">        observable.register(observer2);</span><br><span class="line">        observable.setTemp(<span class="number">32131232</span>);</span><br><span class="line">        observable.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h3&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>启动优化</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/05/31/移动端/Android原生/启动优化/</id>
    <published>2021-05-31T12:58:13.000Z</published>
    <updated>2021-06-01T05:55:34.883Z</updated>
    
    <content type="html"><![CDATA[<h4 id="app启动过程"><a href="#app启动过程" class="headerlink" title="app启动过程"></a>app启动过程</h4><ol><li>点击图标启动</li><li>LauncherApp通知AMS进行启动，LauncherActivity onPause</li><li>AMS新建app进程，创建ActivityThread，创建ApplicationThread</li><li>通过ApplicationThread向AMS注册Binder</li><li>执行Application的onCreate方法</li><li>新建进入的Activity</li><li>执行Activity的onCreate方法，进行UI绘制等操作</li></ol><h4 id="启动分类"><a href="#启动分类" class="headerlink" title="启动分类"></a>启动分类</h4><ul><li>冷启动：从点击应用图标到UI界面完全显示且用户可操作的全部过程。</li></ul><p>Click Event    -&gt;     IPC     -&gt;     Process.start     -&gt;      ActivityThread -&gt;    bindApplication      -&gt;      LifeCycle    -&gt;     ViewRootImpl</p><ul><li>热启动：直接从后台切换到前台。</li></ul><h4 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h4><p>可优化Application、Activity的创建以及回调过程</p><ol><li>提前展示一个window（欢迎页），给用户友好的提示</li><li>避免启动做繁重密集的初始化操作</li><li>过度绘制，网络，io等优化</li></ol><h4 id="优化检测"><a href="#优化检测" class="headerlink" title="优化检测"></a>优化检测</h4><ol><li>adb命令检测<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中的AppstartActivity全路径可以省略前面的packageName</span></span><br><span class="line">adb shell am start -W [packageName]/[AppstartActivity全路径]</span><br></pre></td></tr></table></figure></li></ol><ul><li>ThisTime：最后一个Activity的启动耗时</li><li>TotalTime：所有Activity的启动耗时</li><li>WaitTime：表示AMS启动Activity的总耗时。</li></ul><p>一般读取WaitTime，为Application和Activity的初始化过程耗时。（冷启动耗时）</p><p>优缺点：</p><ul><li>线下使用方便，不能带到线上</li><li>非精确时间</li></ul><ol start="2"><li>自定义打点查看耗时</li></ol><ul><li>应用生命周期节点</li><li>启动的初始化方法节点</li><li>其他耗时业务，算法节点</li></ul><p>优缺点：</p><ul><li>精确，可上线</li><li>修改成本高</li></ul><p>3.AOP打点<br>加入aspectjx库，打印出Application，Activity的耗时时间，进行针对优化</p><p>根路径build.gradle中添加<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath <span class="string">&#x27;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.0&#x27;</span></span><br></pre></td></tr></table></figure><br>app中build.gradle中添加<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;android-aspectjx&#x27;</span></span><br><span class="line">...</span><br><span class="line">implementation <span class="string">&#x27;org.aspectj:aspectjrt:1.8.+&#x27;</span></span><br></pre></td></tr></table></figure><br>使用如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LauncherAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;call(* com.jw.myapplication.MainActivity.**(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        String name = signature.toShortString();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(<span class="string">&quot;kangkang = &quot;</span>,<span class="string">&quot;kangaop = &quot;</span> +name+ <span class="string">&quot; cost &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.TraceView</p><p>代码中开启<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing();</span><br><span class="line">method();</span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure></p><p>生成.trace文件，导入Android Studio，使用profile中的cpu查看文件生成的火炬图</p><h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><ol><li>主题切换</li></ol><p>设置自定义主题设置背景图，执行到onCreate方法后替换为Activiy的真实布局</p><ol start="2"><li>初始化分化<br><img src="/imageMd/appStartUp-1.png" alt="img"></li></ol><ul><li>MultiDex以及Tinker的初始化操作</li><li>Application中的第三方组件的初始化<ol><li>异步初始化组件，不阻塞主线程，设置异步线程为THREAD_PRIORITY_BACKGROUND</li><li>延迟初始化操作，再线程空闲时加载，</li><li>EventBus、ota、bugly、migu、Linphone、Butterknife、地图、IOT</li></ol></li><li>设置线程池初始化任务<ol><li>仿照AsyncTask新建线程池，核心线程数为2-4个</li><li>任务使用该线程池加载，如有顺序，使用CountDownLatch进行处理</li></ol></li><li>部分任务可以延迟加载，使用IdleHandler，在主线程空闲时加载</li><li>Multidex预加载优化</li></ul><h4 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h4><p>在使用Aspect进行时间的监测时，发现Application和Activity中的初始化三方进程耗费了大量时间，在初始化时，我们开启了百度OTA服务，Bugly监测服务，咪咕音乐服务，阿里IOT服务，日志监测服务，Linphone语音服务，Ifly语音服务等，这些串行起来是比较耗时的。<br>所以我们采用开启一个线程池的方案，在子线程启动这些服务，对于OTA，IOT，日志检测，Linphone等服务不需要在第一时间初始化，所以放到线程池中根据执行顺序分别初始化。但是对于咪咕、Ifly和bugly来说，需要第一时间初始化，才能进行后边的逻辑，所以我们将这些服务优先初始化，并联合CountDownLatch，当必须的服务初始化完成后，才进入下面的流程。<br>对于必须要在主线程进行初始化的操作，可能会造成主线程繁忙卡顿，所以使用IdleHandler方法，在主线程空闲时执行，</p><p>具体优化了40%，由2.3s压缩到1.4s。</p><p>如果由任务A，B，C，D，要求C在A之后执行，D在B之后执行，那么直接将A,C合并为一个任务，放入线程池中运行，B、D合并为一个任务，放入线池程中执行，如需决定AC和BD的顺序，那么可以按照AC、BD的顺序依次放入子线程中。</p><h4 id="如何对IDLEHandler进行顺序划分？比如先执行B，在执行A"><a href="#如何对IDLEHandler进行顺序划分？比如先执行B，在执行A" class="headerlink" title="如何对IDLEHandler进行顺序划分？比如先执行B，在执行A"></a>如何对IDLEHandler进行顺序划分？比如先执行B，在执行A</h4><p>规划一个空闲队列，在Handler空闲时进行处理，每次出队优先级最高的，其他等到下次空闲在执行</p><h4 id="2-4是怎么计算的？"><a href="#2-4是怎么计算的？" class="headerlink" title="2-4是怎么计算的？"></a>2-4是怎么计算的？</h4><p>核心线程数位2-4，计算方式是cpu核数-1，如果比2小，就选择2，比4大就选择4，中间就选它自己，<br>之所以 减掉这个1，是因为为了避免后台任务将 CPU 资源完全耗尽， 减掉的这个1 是留给我们 主线程 使用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;app启动过程&quot;&gt;&lt;a href=&quot;#app启动过程&quot; class=&quot;headerlink&quot; title=&quot;app启动过程&quot;&gt;&lt;/a&gt;app启动过程&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;点击图标启动&lt;/li&gt;
&lt;li&gt;LauncherApp通知AMS进行启动，Launche
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>注解原理</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/31/移动端/Android原生/注解原理/</id>
    <published>2021-05-31T12:56:54.000Z</published>
    <updated>2021-05-31T13:05:16.422Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="简析"><a href="#简析" class="headerlink" title="简析"></a>简析</h3><p>元注解：修饰注解的注解，</p><ul><li>@Target：注解的作用目标（修饰方法，类还是字段）</li><li>@Retention：注解的生命周期<ul><li>SOURCE：仅存在java源文件中，经过编译器后就丢弃，适用于一些检查行的操作，比如@Override</li><li>CLASS：编译class文件时生效，适用于在编译时女性一些预处理操作，比如Butterknife的@BindView，在编译时，通过注解器生成一些辅助代码，完成完整的功能</li><li>RUNTIME：保留在运行时VM中可以通过反射获取注解。适用于一些需要运行时动态获取注解信息，类似反射获取注解等，比如EventBus的@Subscribe</li></ul></li><li>@Documented：注解是否应当被包含在JavaDoc文档中</li><li>@Inherited：是否允许子类继承该注解</li><li>AnnotationInvocationHandler：专门处理注解的Handler</li></ul><p>代码的生命周期包含：编码(SOURCE)—-&gt;编译(CLASS)—-&gt;运行(RUNTIME)</p><blockquote><p>默认时注解在编译阶段，即CLASS阶段</p></blockquote><p>本质：一个继承了Annotation接口的接口</p><ul><li>运行时处理：使用反射获取当前的所需要的东西</li><li>编译时处理：APT技术，即编译期扫描java文件的注解，并传递到注解处理器，注解处理器可根据注解生成新的java文件</li></ul><h3 id="注解器"><a href="#注解器" class="headerlink" title="注解器"></a>注解器</h3><p>注解器通常是以Java代码（或者编译过的字节码）作为输入，生成.java文件作为输出</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bf16b90b04e6c" alt="image"></p><p>使用google的AutoService（@AutoService）可以自动生成resources/META-INF.services中的注册目录</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bf16ca4f2434d" alt="image"></p><p>包含注解处理器，注解声明库，实际使用APT的Android/Java项目</p><h4 id="为什么把注解处理器独立抽成一个库呢？"><a href="#为什么把注解处理器独立抽成一个库呢？" class="headerlink" title="为什么把注解处理器独立抽成一个库呢？"></a>为什么把注解处理器独立抽成一个库呢？</h4><p>对于Android项目默认是不包含 APT相关类的。所以要使用APT技术，那么就必须创建一个Java Library。对于Java项目，独立抽成一个库，更容易维护与扩展。</p><h4 id="为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？"><a href="#为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？" class="headerlink" title="为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？"></a>为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？</h4><p>这样可以不用将注解处理器的相关代码大报道使用者的项目中去</p><h4 id="注解器声明"><a href="#注解器声明" class="headerlink" title="注解器声明"></a>注解器声明</h4><p>其方法包含四个主要重写方法</p><ul><li>init() ：初始化调用</li><li>process()：实际处理方法</li><li>getSupportedAnnotationTypes()：返回当前注解器处理注解的类型</li><li>getSupportedSourceVersion()：指定你使用的java版本</li></ul><p>在注解处理过程中，会扫描所有的java源文件，查询注解，在java源代码中，每一部分都代表一个特定类型的Element，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jennifer.andy.aptdemo.domain;<span class="comment">//PackageElement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;<span class="comment">//TypeElement </span></span><br><span class="line">    <span class="keyword">private</span> String where;<span class="comment">//VariableElement</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; &#125;<span class="comment">//ExecutableElement</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//ExecutableElement</span></span><br><span class="line">        <span class="keyword">int</span> runTime;<span class="comment">//VariableElement</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注解处理器是运行在它自己的虚拟机JVM中，javac启动一个完整Java虚拟机来运行注解处理器。</p></blockquote><p>最终是通过自定义注解器在编译时期生成加载注解后的类，在process方法中具体做了执行，编译了程序模版信息进行添加。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>如果是单一属性，可以使用value字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> MyAnno1 &#123;</span><br><span class="line">    <span class="comment">//格式：类型名 属性名（）</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnno1(&quot;kang&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> MyAnno2 &#123;</span><br><span class="line">    <span class="comment">//格式：类型名 属性名（）</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnno2(name = &quot;kang&quot;)</span></span><br></pre></td></tr></table></figure><p>如果不是value字段的话，需要（指定属性 = 值）</p><blockquote><p>注解中只允许八中基本数据类型、字符串、类类型，注解类型，枚举类型及其一维数组</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h2&gt;&lt;h3 id=&quot;简析&quot;&gt;&lt;a href=&quot;#简析&quot; class=&quot;headerlink&quot; title=&quot;简析&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>LiveData和ViewModel源码分析</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/LiveData%E5%92%8CViewModel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/05/31/移动端/Android原生/LiveData和ViewModel源码分析/</id>
    <published>2021-05-31T12:55:45.000Z</published>
    <updated>2021-06-01T05:58:30.948Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><h4 id="ViewModel的定义"><a href="#ViewModel的定义" class="headerlink" title="ViewModel的定义"></a>ViewModel的定义</h4><p>ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。</p><p><strong>历史方式的缺点</strong>：</p><ol><li>对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。</li><li>需要处理异步调用，内存泄漏等问题</li><li>使界面控制器类越发膨胀</li></ol><blockquote><p>ViewModel将数据存储和界面控制进行分离，独立出来<br>ViewModel 存在的时间范围是从您首次请求 ViewModel 直到 Activity 完成并销毁。</p></blockquote><h4 id="ViewModel生命周期"><a href="#ViewModel生命周期" class="headerlink" title="ViewModel生命周期"></a>ViewModel生命周期</h4><p><img src="/imageMd/LiveData&amp;ViewModel-1.png" alt="img"></p><p>ViewModel在onCreate中初始化，在finish()后会调用onCleared()方法，</p><blockquote><p>所以ViewModel生命周期长于Activity,ViewModel不持有UI的引用，通过观察者通知界面更新</p></blockquote><h4 id="ViewModel在Fragment之间共享数据"><a href="#ViewModel在Fragment之间共享数据" class="headerlink" title="ViewModel在Fragment之间共享数据"></a>ViewModel在Fragment之间共享数据</h4><p>为什么能在Fragment中共享数据？<br>因为在Fragment中初始化ViewModel时传入的宿主Activity，ViewModelStore中取出当前Activity对应的ViewModel对象，返回给Fragment，这样他们获取的是同一个ViewModel实例，数据当然也会共享</p><h4 id="ViewModel源码分析"><a href="#ViewModel源码分析" class="headerlink" title="ViewModel源码分析"></a>ViewModel源码分析</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>我们通常使用这种方式初始化ViewModel<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProgressViewModel processViewModel = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>).get(ProcessViewModel.class);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(owner.getViewModelStore(), owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">                ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">                : NewInstanceFactory.getInstance());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>从ViewModelStoreOwer中获取ViewModelStore，ViewModelStore是从AppCompatActivity-&gt;FragmentActivity-&gt;ComponentActivity中获取，本质还是new ViewModelStore()。<br>Factory在AppCompatActivity和Fragment中的是HasDefaultViewModelProviderFactory，具体实现是SavedStateViewModelFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStore store, <span class="meta">@NonNull</span> Factory factory)</span> </span>&#123;</span><br><span class="line">    mFactory = factory;</span><br><span class="line">    mViewModelStore = store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将ViewModelStore和Factory进行赋值</p><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><p>进入get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回该类的规范名称，如果它是本地或匿名类或其组件类型没有规范名称的数组，则返回null。</span></span><br><span class="line">    String canonicalName = modelClass.getCanonicalName();</span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//key = DEFAULT_KEY + &quot;:&quot; + canonicalName</span></span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从ViewModelStore中获取ViewModel，首次进入获取为空</span></span><br><span class="line">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等效于instanceOf，判断是否是所需viewModel</span></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel = (mFactory).create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可知<br>Factory放入具体实现是SavedStateViewModelFactory，SavedStateViewModelFactory又继承于KeyedFactory，我们看下create方法，值得一提的是，这里的mFactory是AndroidViewModelFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//是否为AndroidViewModel类，或者其子类</span></span><br><span class="line">        <span class="keyword">boolean</span> isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class="line">        Constructor&lt;T&gt; constructor;</span><br><span class="line">        <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doesn&#x27;t need SavedStateHandle</span></span><br><span class="line">        <span class="comment">//如果constructor为null，create内部什么也不处理</span></span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mFactory.create(modelClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SavedStateHandleController controller = SavedStateHandleController.create(</span><br><span class="line">                mSavedStateRegistry, mLifecycle, key, mDefaultArgs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T viewmodel;</span><br><span class="line">            <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">                viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class="line">            &#125;</span><br><span class="line">            viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class="line">            <span class="keyword">return</span> viewmodel;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failed to access &quot;</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;A &quot;</span> + modelClass + <span class="string">&quot; cannot be instantiated.&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;An exception happened in constructor of &quot;</span></span><br><span class="line">                    + modelClass, e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>判断ViewModel类型，获取不同的构造方法，通过反射实现ViewModel的初始化，然后使用mViewModelStore.put(key, viewModel); 将viewModel以key的形式存入ViewModelStore<br>进入ViewModelStore：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>内部实现就是一个HashMap，Key为String，value为ViewModel，put后新放入的ViewModel覆盖新的ViewModel，这里的key强调一下，统一格式为<code>androidx.lifecycle.ViewModelProvider.DefaultKey:com.zz.chatright.ChatViewModel</code></p><h5 id="SavedState"><a href="#SavedState" class="headerlink" title="SavedState"></a>SavedState</h5><p>在源码分析中我们看到构造函数中都包含了一个SavedStateHandleController类，这里保存了数据类，使其不受生命周期影响，例如发生屏幕旋转等。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8zLzE5LzE3MGYzNWYyZjgyMmIwMWM?x-oss-process=image/format,png" alt="img"></p><ul><li>SaveStateHandle：<br>内部存储数据格式为<em>Map&lt;String, Object&gt;</em>，亦存在<em>Map&lt;String, SavingStateLiveData&lt;?&gt;&gt;</em>完成值的通知</li><li>SaveStateHandleController：<br>将SaveStateHandle同Lifecycle生命周期进行绑定</li><li>SavedStateRegistry：<br>管理 SavedStateProvider 列表的组件，此注册表绑定了其所有者的生命周期（即 activity 或 fragment）</li><li>SavedStateProvider：<br>保存状态的组件，此状态将在以后恢复并使用</li></ul><blockquote><p>activity 的状态保存分为 view 状态和成员状态</p></blockquote><h6 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8zLzE5LzE3MGYzNWYyY2Y0NGU1ZDQ?x-oss-process=image/format,png" alt="img"></p><h4 id="如何保证viewModel的唯一性？"><a href="#如何保证viewModel的唯一性？" class="headerlink" title="如何保证viewModel的唯一性？"></a>如何保证viewModel的唯一性？</h4><p>通过反射进行初始化操作，带入的是Application的Context对象，这样就保证不会持有Activity或者Fragment的引用。然后会将创建出来的实例对象存储在ViewModelStore（内部HashMap）中，每次使用都会去ViewModelStore中查看是否存在，如果存在，则直接使用，不需要实例化<br>key就是DEFAULT_KEY + “:” + canonicalName（viewmModel类名路径，eg：com.zz.test.MyViewModel）</p><h4 id="为什么viewModel能管理生命周期，并且不受重建情况的影响"><a href="#为什么viewModel能管理生命周期，并且不受重建情况的影响" class="headerlink" title="为什么viewModel能管理生命周期，并且不受重建情况的影响"></a>为什么viewModel能管理生命周期，并且不受重建情况的影响</h4><p>2.0以前：创建了一个无view的HolderFragment同步Activity的生命周期，并关联ViewModelStore，而且设置setRetainInstance(true)时，会保证屏幕切换时生命周期不会改变，让fragment在Activity重建时存活下来</p><p>2.0以后：运用了androidx新库，用到了AppCompatActivity的父类ComponentActivity，重写onRetainNonConfigurationInstance()方法保存了ViewModelStore，Activity通过onRetainNonConfigurationInstance()方法获取ViewModelStore实例，保证了ViewModel不会随着Activity的重建而重建。<br>不论是Activity还是Fragment都实现了LifecycleOwner，所以生命周期通过Lifecycles组件感知每个页面的生命周期</p><blockquote><p>onRetainNonConfigurationInstance()和onSaveInstanceState的调用时机是一样的，但是onRetainNonConfigurationInstance()的Bundle数据不限制大小，所以更倾向这个</p></blockquote><p>当Activity因为配置需要重建时，系统会调用onRetainNonConfigurationInstance()方法，将ViewModelStore存储在NonConfigurationInstances中，最终交给ActivityClientRecord类，因为ActivityClientRecord不受Activity重建的影响，所以NoConfigurationInstances也不受Activity重建的影响</p><h4 id="ViewModel同onSaveInstanceState-的区别"><a href="#ViewModel同onSaveInstanceState-的区别" class="headerlink" title="ViewModel同onSaveInstanceState()的区别"></a>ViewModel同onSaveInstanceState()的区别</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>在Activity变得“容易”销毁时，就会触发onSaveInstanceState()</p><ol><li>当按下HOME键后，系统就会触发调用</li><li>当长按HOME键，选择运行其他程序时</li><li>按电源键息屏的时候</li><li>从Activity A中启动一个新的Activity</li><li>横竖屏切换时</li></ol><blockquote><p>而使用ViewModel恢复数据 则 只有在 因配置更改界面销毁重建 的情况。</p></blockquote><h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><p>ViewModel存储在内存中，onSaveInstanceState()是序列化到磁盘中存储的</p><h5 id="存储大小"><a href="#存储大小" class="headerlink" title="存储大小"></a>存储大小</h5><p>ViewModel存储大小限制时app的可用内存<br>onSaveInstanceState()因为使用了序列化和反序列化，那么通过Bundle存储大小限制为1M</p><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><h4 id="LiveData的定义"><a href="#LiveData的定义" class="headerlink" title="LiveData的定义"></a>LiveData的定义</h4><p><img src="https://developer.android.google.cn/images/topic/libraries/architecture/lifecycle-states.svg?hl=zh-cn" alt="img"></p><blockquote><p>当在onStart后，onResume,onPause都是STARTED/RESUMED的，即为活跃的（onActive），当在onStop后，则为非活跃状态（onInActive）<br>LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。</p></blockquote><p>如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。LiveData 只会将更新通知给活跃的观察者。为观察 LiveData 对象而注册的非活跃观察者不会收到更改通知。</p><p>您可以注册与实现 LifecycleOwner 接口的对象配对的观察者。有了这种关系，当相应的 Lifecycle 对象的状态变为 DESTROYED 时，便可移除此观察者。这对于 Activity 和 Fragment 特别有用，因为它们可以放心地观察 LiveData 对象，而不必担心泄露（当 Activity 和 Fragment 的生命周期被销毁时，系统会立即退订它们）。</p><h4 id="LiveData的优势"><a href="#LiveData的优势" class="headerlink" title="LiveData的优势"></a>LiveData的优势</h4><ol><li>及时更新界面数据</li><li>不会发生内存泄漏，当其关联的生命周期被摧毁，则回收自己</li><li>不会因为Activity停止而崩溃，准确判断生命周期，决定是否通知</li><li>不需要自己手动处理生命周期</li><li>在再次活跃时会接收到最新的数据，保持数据最新状态</li><li>如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。</li><li>共享资源。<br>您可以使用单例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。</li></ol><h4 id="LiveData源码分析"><a href="#LiveData源码分析" class="headerlink" title="LiveData源码分析"></a>LiveData源码分析</h4><p>建立号viewModel后，我们在Activity中这样使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">processViewModel.isBigScreen.observe(appCompatActivity, it -&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>进入observe方法进行查看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="comment">//如果该生命周期为onDestory之后，则return，不做处理</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    <span class="comment">//将观察者注册到mObservers中，如果存在，则返回wrapper，否则，返回null</span></span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加到LifeCycle中</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通常我们使用setValue和postValue的方法进行数据更新<br>进入setValue下查看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进入dispatchingValue()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//便利订阅者集合</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="keyword">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">            </span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>便利订阅者集合，进行分发：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果改订阅者不活跃，直接过滤</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">    <span class="comment">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class="line">    <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">    <span class="comment">//如果不是onResume状态</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过version判断是否是最新数据</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="comment">//执行分发逻辑</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在active的生命周期下，如果是onResume状态且是最新数据，则进行数据分发，否则，进入activeStateChanged方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">        <span class="comment">// owner</span></span><br><span class="line">        mActive = newActive;</span><br><span class="line">        <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">        LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">            <span class="comment">//调用具体分发逻辑</span></span><br><span class="line">            dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>当不是active状态下，则不会进行分发处理，当页面从后台回到前台时，也会触发该方法，那么会取最新的mData并分发给该页面。</p><p>如果是post请求，会通过handler传递到主线程，调用setvalue方法，所有的回掉，observer方法都是在主线程中的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;ViewModel&quot;&gt;&lt;a href=&quot;#ViewModel&quot; class=&quot;headerlink&quot; title=&quot;ViewModel&quot;&gt;&lt;/a&gt;ViewModel&lt;/h2&gt;&lt;h4 id=&quot;ViewModel的定义&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android大厂面试题</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Android%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2021/05/31/移动端/Android原生/Android大厂面试题/</id>
    <published>2021-05-31T12:53:14.000Z</published>
    <updated>2021-05-31T12:54:06.971Z</updated>
    
    <content type="html"><![CDATA[<p>京1:</p><ol><li>butterknife原理，R2文件？</li><li>Handler异步消息，同步屏障？同步消息？looper.perpare()何时创建？message.obtain()?</li><li>Vsync，垂直同步信号？</li><li>UI滑动渲染优化？</li><li>内存泄漏？leakcarray原理？</li><li>oom的条件？<ol><li>开辟多个线程导致oom？</li></ol></li><li>bitmap的存储形式在系统中的存储？存储在哪？</li><li>布局优化？LinearLayout   draw几次？</li><li>IPC机制，binder机制的理解？为什么使用线程池？（一个服务端对多个客户端）</li><li>flutter渲染机制？flutter的树？</li></ol><p>京2:</p><ol><li>移动端自动化开发</li><li>EventBus原理？优点？缺点？切换线程的方式</li><li>ViewModel+LiveData</li><li>音箱和手机的差异化？android版本，厂商room，客户群体不同</li><li>apk瘦身？</li><li><strong>启动优化的时间检测？启动器优化方式</strong></li><li>组件化？如何设计一个组件</li></ol><p>小米1：</p><ol><li><p>Activity的生命周期？activityA在下拉框的时候的生命周期？（不变化）onDestory有立即执行吗？</p></li><li><p>activity启动后在最后一帧绘制在哪？</p></li><li><p>android启动打点？AOP？启动优化？开启一个线程？AMS，反射？如何对函数进行插桩？</p><p>ASM对.class文件修改，生成.dex文件前搞定，在.class和.dex文件转化中间作修改</p></li><li><p>leakcanary原理？自己如何做内存泄漏器？各个函数之间的耗时情况？</p></li><li><p>亮点？有向无环图？contentprovider的初始化？</p></li><li><p>Handler内存泄漏的原因？怎么处理？handler持有Activity强引用，messageQueue持有handler的强引用</p></li><li><p>view的绘制？dispatchDraw()和onDraw()的执行顺序？</p></li><li><p>如果绘制一个圆，保证这个圆的中间不被绘制？cavas进行裁剪，画布上就缺一块，则子view绘制不上</p></li><li><p>view的事件分发？如果dispatch返回true，会拦截到onInterrcept和onTouch</p></li><li><p>bitmap的优化？bitmap的大小的计算？2x的大小图片放大1x的图片中，bitmap会变大</p></li><li><p>线程池？阻塞的处理？exectue和submit的区别，如何捕获线程池错误（ThreadFactory）</p></li><li><p>生产者消费者通知？</p></li><li><p>线程同步？加锁，Sychronized，ReentrantLock</p></li><li><p>Hashmap，hash值计算？为什么这么计算？arraymap和hashmap？</p></li><li><p>数组和链表的区别？</p></li><li><p>https加密形式</p></li></ol><p>小米2面：</p><ol><li>启动优化？bitmap预加载？如何更快加载图片？还有别的什么优化？</li><li>Glide的into方法是怎么执行的，如何显示到imageView中的？</li><li>Glide的加载流程？fragment如何绑定？imageView正在加载，再次加载另一个图片，具体会执行什么？</li><li>Android启动流程？Activity启动流程？</li><li>ViewModel？LiveData的理解 ？mvvm的理解？</li><li>网络请求异步框架？线程池？</li><li>链表反转（逆置）</li></ol><p>Yy1:</p><ol><li><p>okhttp io的方式？okio，java中io的方式？责任链模式？连接池复用？</p></li><li><p>Glide的缓存结构？为什么要用activieResource？</p></li><li><p>EventBus的简述？字节码=.class文件，注解方式？</p></li><li><p>RecyclerView缓存形式？</p></li><li><p>MotionLayout的内部原理</p></li><li><p>Mvvm需要注意什么？内存泄漏？持有view的引用</p></li><li><p>leakCanary原理，gc间隔=5s，在idleHandler中使用延迟5s的操作，大概是主线程闲置后在等待5s中进行验证后执行gc？Fragment怎么监听内存泄漏的？fragmentManager.registerFragmentLifecycleCallbacks中检测</p></li><li><p>apk瘦身？so库合并</p><p>先把所有要打包的库编译生成静态库，然后使用如下命令把它们合并成一个*.so:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o c.so -Wl,--whole-archive a.a b.a -Wl,--no-whole-archive</span><br></pre></td></tr></table></figure></li><li><p>启动优化？其他的优化框架，</p></li><li><p>线程，进程，协程？时间分片？协程是怎么做的？那个io？</p></li><li><p>handler机制？子线程中如何使用handler？handler中的Looper.prepareMain和Looper.prepare的区别？主线程永不退出，死循环？同步屏障？</p></li></ol><p>Yy2:</p><ol><li>音频协议？</li><li>协程，进程，线程的区别？</li><li>mvvm？组件化？</li><li>websocket协议和http协议的区别？</li><li>butterknife原理？注解的三种形式？</li><li>动态代理的方式？2中？动态代理的关联？</li><li>类型擦出？范性？</li><li>类加载过程？类什么时候初始化？静态类的初始化过程？</li><li>编译器优化？</li><li>GCroot？栈溢出？（递归）</li><li>java异常有几种？可以捕获oom异常吗？可以，在bitmap中如果触发oom可以进行try catch</li><li>动画？差值器，估值器？</li><li>二叉树之字形打印</li></ol><p>581:</p><ol><li><p>组件化ARouter框架原理？</p><p>编译时注解生成类文件，存储全局路由管理，通过反射创建对象。</p><p>如果是Activity，通过Intent进行跳转传参，Fragment，BroadCastReceiver，Service等都是通过反射创建对象的</p></li><li><p>LiveData，viewModel机制，如何绑定生命周期，viewModel中持久化是怎么做的，LiveData中的粘性事件</p><p>粘性事件是通过版本号控制的，当进入active状态后，会比对version版本，进行订阅者的通知</p></li><li><p>Activity的启动过程</p></li><li><p>RecyclerView机制</p></li><li><p>Handler机制</p></li><li><p>java中锁的机制，volatile的可见性怎么理解？Synchronized怎么理解？自旋锁怎么理解？ReentrantLock怎么理解？</p></li><li><p>kotlin中的协程？</p><p>kotlin中协程通过挂起函数来实现协程的处理，使用CPS变换，suspend</p><p>每个挂起函数都会被编译为Continuation ，将函数体编译为状态机</p></li><li><p>ASM</p></li><li><p>flutter理解？fish-redux的分层？数据流向？</p><p>view—–&gt;action—-&gt;effect—–&gt;reducer—–&gt;store—–&gt;view</p></li></ol><p>58 2:</p><ol><li>项目相关。。。</li></ol><p>36012:</p><ol><li><p>Fragment切换，add和replace，复用的问题？</p></li><li><p>Fragment可见性准确保证？</p></li><li><p>Fragment构造传参的劣势？</p><p>在Activity异常退出重建Fragment的时候，会执行Fragment的无参构造方法，如果通过setArguments进行传递参数，Activity在构造Fragment时会通过反射午餐构造实力</p></li><li><p>内联优化？</p></li><li><p>aapt1和aapt2的区别</p><p>aapt1进行全量编译</p><p>aapt2进行差量编译</p></li><li><p>垃圾加载的GC root</p></li><li><p>LRU算法怎么实现的</p></li><li><p>java中的容器有哪些？线程安全的有哪些？</p><p>Vector   与ArrayList几乎相同，但是线程安全</p><p>Stack     继承自Vector</p><p>CopyOnWriteArrayList 写实拷贝</p><p>ConcurrentLinkedQueue　基础链表同步队列</p><p>LinkedBlockingQueue</p><p>HashTable</p><p>ConcurrentHashMap</p></li></ol><p>58 3:</p><ol><li>对排序？</li><li>http请求过程，https的过程</li><li>数组和链表的区别</li><li>栈中调用方法的过程</li><li>LRU算法的实现</li></ol><p>美团 1:</p><p>携程 1:</p><p>快手 1:</p><p>知乎 1:</p><ol><li>Activity的生命后期</li><li>onConfigurationChanged？其他回掉时机？onSaveInstanceState回调？分屏？</li><li>ARouter？</li><li>Fragment的生命周期？onCreateView可以返回null吗？</li><li>fragment怎么初始化？fragment为什么不推荐携带参数？androidx中提供fragment传参？Fragment重建？</li><li>viewModel持久化？viewmodel重建？可以存储Bundle？</li><li>java内存模型？volatile原理？可见性，非原子性，禁止指令重排</li><li>组件化开发？</li><li>二叉树镜像？</li></ol><p>知乎 2:</p><ol><li>mvvm的理解</li><li>离开公司的原因</li><li>未来的方向，2c方向，架构方向</li><li>架构师主要负责，技术选型</li><li>为什么选择知乎？</li><li>知乎界面的分析+选型+排期</li><li>你的优势，为什么给你发offer？</li><li>android启动器？线程池选型？</li><li>大文件查找方案？</li><li>整数的逆置，头和尾是0的情况排除</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;京1:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;butterknife原理，R2文件？&lt;/li&gt;
&lt;li&gt;Handler异步消息，同步屏障？同步消息？looper.perpare()何时创建？message.obtain()?&lt;/li&gt;
&lt;li&gt;Vsync，垂直同步信号？&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>面试指南</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2021/05/31/移动端/Android原生/面试指南/</id>
    <published>2021-05-31T12:47:57.000Z</published>
    <updated>2021-06-01T06:22:55.816Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><h4 id="简述EventBus的理解"><a href="#简述EventBus的理解" class="headerlink" title="简述EventBus的理解"></a>简述EventBus的理解</h4><p>EventBus作为通信事件传递的总线，你无需控制值的传递，也无需通过广播等低效实现，通过EventBus在你需要发送的地方post信息，在你需要接收的地方接收信息处理即可，（前提是register过）</p><h4 id="EventBus的五种线程模式"><a href="#EventBus的五种线程模式" class="headerlink" title="EventBus的五种线程模式"></a>EventBus的五种线程模式</h4><ul><li><strong>POSTING</strong>：默认，发布和订阅在同一个线程，同发布者一个线程（主—&gt;主 , 子—&gt;子），最小的开销，因为不用切换线程，避免了线程的完全切换，使用此模式的事件处理程序必须快速返回，以避免阻塞可能是主线程的发布线程。</li><li><strong>MAIN</strong>：事件处理函数的线程在主线程（UI）线程。不能进行<code>耗时</code>操作，订阅者需快速返回以免阻塞主线程</li><li><strong>MAIN_ORDERED</strong>:事件处理函数的线程在主线程（UI）线程。不会阻塞线程</li><li><strong>BACKGROUND</strong>：处理函数在后台线程，不能进行UI操作。发布在主线程，订阅会开启一个新的后台线程。发布在后台线程，事件处理函数也在该后台线程</li><li><strong>ASYNC</strong>：无论事件发布的线程是哪一个，都会重新开辟一个新的子线程运行，不能进行UI操作</li></ul><h4 id="EventBus的事件类型"><a href="#EventBus的事件类型" class="headerlink" title="EventBus的事件类型"></a>EventBus的事件类型</h4><p>接收事件必须是public修饰符修饰，不能用static关键字修饰，不能是抽象的（abstract）</p><ol><li>普通事件：先订阅在发布，发布到订阅者后进行处理</li><li>粘性事件：支持先发布在订阅，当订阅者订阅后会自动发送到订阅者进行处理，发送粘性事件EventBus.postSticky()，接收粘性事件sticky = true</li></ol><h4 id="为什么必须是public？"><a href="#为什么必须是public？" class="headerlink" title="为什么必须是public？"></a>为什么必须是public？</h4><p>因为源码定义</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>优先级高的订阅者优先接收到任务</p><h4 id="简述源码分析事件"><a href="#简述源码分析事件" class="headerlink" title="简述源码分析事件"></a>简述源码分析事件</h4><ul><li>register：通过注解初始化订阅方法后，在register后，在缓存中获取所有该订阅者的方法，循环遍历订阅，新建newSubscription方法，根据priority优先级将newSubscription方法放入subscriptions中，判断如果<code>是粘性事件</code>，则执行其对应的订阅方法。</li><li>unregister：从typesBySubscriber获取订阅事件类型，根据订阅事件类型从subscriptionsByEventType获取订阅者信息，将subscription的active置为false，并移除该subscription</li></ul><h4 id="索引如何理解？"><a href="#索引如何理解？" class="headerlink" title="索引如何理解？"></a>索引如何理解？</h4><p>EventBus 3.0以后，采用Subscribe注解配置事件订阅方法，采用反射的方式来查找订阅事件的方法，我们都知道反射对性能是有影响的，所以提出了索引的概念。</p><p>在项目编译时，通过配置，生成一个辅助类用来存储订阅信息，原理是HashMap，存储注册类的class类型和事件订阅方法的信息，提高速度3-4倍</p><h4 id="MAIN和MAIN-ORDERED的区别？"><a href="#MAIN和MAIN-ORDERED的区别？" class="headerlink" title="MAIN和MAIN_ORDERED的区别？"></a>MAIN和MAIN_ORDERED的区别？</h4><ol><li><p>在<code>MAIN</code>模式下，如果事件发布者post事件也是在主线程的话，会阻塞post事件所在的线程，意思是连续post多个事件，如果接收事件方法执行完，才能post下一个事件</p><pre><code>**post(1) ——&gt; onReceiveMsg(1) ——&gt;post(2)——&gt;onReceiveMsg(2)——&gt;post(3)——&gt;onReceiveMsg(3)**</code></pre></li><li><p>如果事件发布者post事件不在主线程，连续post多个事件，同时在主线程是接收事件是耗时操作的话，执行的流程是非阻塞的</p><pre><code>**post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(3)**或**post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(2)——&gt;onReceiveMsg(3)**</code></pre></li><li><p>MAIN_ORDERED模式下，无论什么场景都是非阻塞的</p></li></ol><h4 id="EventBus可否跨进程问题？"><a href="#EventBus可否跨进程问题？" class="headerlink" title="EventBus可否跨进程问题？"></a>EventBus可否跨进程问题？</h4><p>不能，单进程间通信</p><p>HermesEventBus——&gt;饿了吗开发框架，可应用于单进程和多进程。</p><p>使用IPC机制，首先选择一个主进程，其他则为子进程，每一个event会经过4步：</p><ol><li>使用Hermes库将event传递给主进程。</li><li>主进程使用EventBus在主进程内部发送event。</li><li>主进程使用Hermes库将event传递给所有的子进程。</li><li>每个子进程使用EventBus在子进程内部发送event。</li></ol><h4 id="BackgroundThread和Async区别"><a href="#BackgroundThread和Async区别" class="headerlink" title="BackgroundThread和Async区别"></a>BackgroundThread和Async区别</h4><p>BackgroundThread：发布在主线程，新开辟子线程中执行。发布在子线程，则在子线程中执行，这个子线程是阻塞式的,按顺序交付所有事件，所以也不适合做耗时任务，因为多个事件共用这一个后台线程</p><p>Async：无论发布在哪一个线程，都会在重新开辟一个子线程执行</p><h4 id="EventBus的优缺点："><a href="#EventBus的优缺点：" class="headerlink" title="EventBus的优缺点："></a>EventBus的优缺点：</h4><p><code>优点</code>:<br>EventBus是greenrobot公司出的另一款开源框架，这个框架是针对Android优化的发布/订阅事件总线，使用EventBus可以极大的减少我们程序的耦合度。<br>调度灵活。不依赖于 Context，使用时无需像广播一样关注 Context 的注入与传递。<br>使用简单。<br>快速且轻量。<br>完全解耦了请求链之间的关系，避免了请求者被长持有，<br>比广播更轻量<br>可以定义在调用线程、主线程、后台线程、异步。</p><p>粘性事件</p><p>优先级概念</p><p>为了避免频繁的向主线程 <code>sendMessage()</code>(Handler机制)，EventBus 的做法是在一个消息里尽可能多的处理更多的消息事件，所以使用了 while 循环，持续从消息队列 queue 中获取消息。</p><p>同时为了避免长期占有主线程，间隔 10ms （maxMillisInsideHandleMessage = 10ms）会重新发送 <code>sendMessage()</code>，用于让出主线程的执行权，避免造成 UI 卡顿和 ANR。</p><p><code>缺点</code>:<br>各种Event的定义工作量大。每次传的内容不一样,就需要重新定义一个JavaBean</p><p>单向传播</p><p>需要显性注册</p><h4 id="EventBus如何做到线程切换"><a href="#EventBus如何做到线程切换" class="headerlink" title="EventBus如何做到线程切换"></a>EventBus如何做到线程切换</h4><p><a href="https://blog.csdn.net/u010457514/article/details/101771245">EventBus发送的消息，如何做到线程切换？</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> POSTING:</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">                <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要分为主线程执行和子线程执行，当为主线程时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HandlerPoster</span><span class="params">(EventBus eventBus, Looper looper, <span class="keyword">int</span> maxMillisInsideHandleMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="keyword">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">                handlerActive = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//循环处理消息事件，避免重复sendMessage()</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                PendingPost pendingPost = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">                <span class="comment">//避免长期占用主线程，间隔10ms重新sendMassage()</span></span><br><span class="line">                <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rescheduled = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            handlerActive = rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用HandlerPoster将任务通过sendMessage方法发送到主线程执行，通过消息队列存储该handler的任务，通过10ms发送一次任务，防止主线程卡顿，MAIN情况下，如果在主线程，直接执行。MAIN_ORDER的情况下，全部交给handler异步执行，所以区别于MAIN不是同步的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</span><br><span class="line"></span><br><span class="line">    BackgroundPoster(EventBus eventBus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!executorRunning) &#123;</span><br><span class="line">                executorRunning = <span class="keyword">true</span>;</span><br><span class="line">                eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    PendingPost pendingPost = queue.poll(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                            <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                            pendingPost = queue.poll();</span><br><span class="line">                            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                executorRunning = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + <span class="string">&quot; was interruppted&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorRunning = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    AsyncPoster(EventBus eventBus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No pending post available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子线程执行是通过线程池进行管理，内部也存在一个消息队列，按顺序执行任务，对于BACKGROUND情况下，同时只会使用线程池中的一个线程，而Async直接放入线程池，让线程池去规划线程。当线程池中等待任务过多时，会触发oom（线程池是newCachedThreadPool()，则线程为非核心线程MAX）</p><h4 id="粘性事件的原理"><a href="#粘性事件的原理" class="headerlink" title="粘性事件的原理"></a>粘性事件的原理</h4><p>普通事件是先注册后发布，而粘性事件可以先发布后注册，实现方式上是这样的：</p><p>发送时会将粘性事件的事件类型和对应事件保存起来，在执行post方法，在注册后，如果是粘性事件，会多走一步类似于post的方法，触发进行分发</p><h4 id="如何判断当前线程是否为主线程？"><a href="#如何判断当前线程是否为主线程？" class="headerlink" title="如何判断当前线程是否为主线程？"></a>如何判断当前线程是否为主线程？</h4><p>在发布事件的地方判断发送线程和主线程的Looper对象是否相等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Looper.getMainLooper() == Looper.myLooper();</span><br></pre></td></tr></table></figure></p><h4 id="如何优化EventBus"><a href="#如何优化EventBus" class="headerlink" title="如何优化EventBus"></a>如何优化EventBus</h4><ol><li>尽量使用索引功能，避免不必要的反射，提升性能</li><li>增加EventBus的进程间通信</li></ol><h4 id="为什么使用ConcurrentHashMap保存数据"><a href="#为什么使用ConcurrentHashMap保存数据" class="headerlink" title="为什么使用ConcurrentHashMap保存数据"></a>为什么使用ConcurrentHashMap保存数据</h4><p><a href="#ConcurrentHashMap和HashMap的区别">ConcurrentHashMap和HashMap的区别</a></p><p>因为EventBus是单进程、多线程间通信，可能涉及到线程安全问题，使用ConcurrentHashMap可以有效解决线程安全和效率。</p><h2 id="Okhttp3"><a href="#Okhttp3" class="headerlink" title="Okhttp3"></a>Okhttp3</h2><p><img src="/imageMd/okhttp-1.png" alt="okhttp3"></p><h4 id="简述OkHttp"><a href="#简述OkHttp" class="headerlink" title="简述OkHttp"></a>简述OkHttp</h4><p>是基于Socket的封装，主要有三个类：Response、Request、Call</p><p>同步使用client.excute();  异步使用client.enqueue();</p><p>OkHttp的高效在于内部有一个Dispatcher，是okhttp维护的一个线程池，对最大连接数（并发），host最大访问量做了定义，维护了3个队列（同步正在执行，准备执行，异步正在执行）和一个线程池（0~max）</p><p>内部还维护了连接池，实现了复用机制，减少重复握手</p><p>提供缓存机制。</p><h4 id="有几个拦截器，分别是干什么的？"><a href="#有几个拦截器，分别是干什么的？" class="headerlink" title="有几个拦截器，分别是干什么的？"></a>有几个拦截器，分别是干什么的？</h4><p><code>client.intercepters()：应用拦截器</code></p><p>RetryAndFollowUpIntercepter：重试和重定向机制，最大重试次数为20，构造StreamAllocation，创建缓存池，复用</p><p>BridgeIntercepter：将用户构造的请求转化为服务器识别的请求，将服务器返回的响应转化为用户识别的响应，添加keep-alive，供连接池复用</p><p>CacheIntercepter：缓存读取和更新</p><p>ConnectIntercepter：dns解析与服务器建立连接(握手结束)，它利用 Okio 对 Socket 的读写操作进行封装，它对 java.io 和 java.nio 进行了封装，让我们更便捷高效的进行 IO 操作</p><p><code>client.networkIntercepter：网络拦截器</code></p><p>CallServerIntercepter：最后一个拦截器，负责向服务器发送请求和接收服务器的响应</p><p>采用责任链模式，将请求和发送分别处理，并且可以动态添加中间的处理方实现对请求的处理、短路等操作。</p><p>addNetworkInterceptor() （网络拦截器）和addInterceptor() （应用拦截器）</p><p>区别就是一个靠前一个靠后，其中经过的拦截器会导致不一样的结果</p><p><a href="https://www.cnblogs.com/liyutian/p/9489016.html">自定义拦截器区别</a></p><h4 id="RetryAndFollowUpIntercepter中怎么进行重定向？"><a href="#RetryAndFollowUpIntercepter中怎么进行重定向？" class="headerlink" title="RetryAndFollowUpIntercepter中怎么进行重定向？"></a>RetryAndFollowUpIntercepter中怎么进行重定向？</h4><p>最大重试次数为20次<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> HTTP_PERM_REDIRECT:<span class="comment">//307</span></span><br><span class="line"><span class="keyword">case</span> HTTP_TEMP_REDIRECT:<span class="comment">//308</span></span><br><span class="line">  <span class="comment">// &quot;If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">  <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request&quot;</span></span><br><span class="line">  <span class="keyword">if</span> (!method.equals(<span class="string">&quot;GET&quot;</span>) &amp;&amp; !method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// fall-through</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MULT_CHOICE:<span class="comment">//300</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_PERM:<span class="comment">//301</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_TEMP:<span class="comment">//302</span></span><br><span class="line"><span class="keyword">case</span> HTTP_SEE_OTHER:<span class="comment">//303</span></span><br><span class="line">  <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">  <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  String location = userResponse.header(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t follow redirects to unsupported protocols.</span></span><br><span class="line">  <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If configured, don&#x27;t follow redirects between SSL and non-SSL.</span></span><br><span class="line">  <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">  <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Most redirects don&#x27;t include a request body.</span></span><br><span class="line">  Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">      requestBuilder.method(<span class="string">&quot;GET&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="keyword">null</span>;</span><br><span class="line">      requestBuilder.method(method, requestBody);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">  <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">  <span class="comment">// way to retain them.</span></span><br><span class="line">  <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">    requestBuilder.removeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> requestBuilder.url(url).build();</span><br></pre></td></tr></table></figure><br>如果返回响应code是307和308，则只对get和head类型的请求进行重定向。<br>如果返回请求为PROPFIND，则重新发送的请求都为保持原状，如果不是propFind，则重新请求的都会被设置为<code>get</code>请求，且请求信息为空</p><blockquote><p>RetryAndFollowUpInterceptor的intercept中先是创建了StreamAllocation对象，然后开启while(true)无限循环。接着在这个循环中先调用下层拦截器去网络请求，若请求期间发生异常，判断能否重试，能就continue进行下一轮循环，否则抛异常退出循环结束方法。如果下层拦截器请求完成返回response，通过response的状态码判断是否需要重定向，若需要重定向，修改request后进行下一轮循环，否则返回response结束方法。</p></blockquote><h4 id="什么是连接池？"><a href="#什么是连接池？" class="headerlink" title="什么是连接池？"></a>什么是连接池？</h4><p>OkHttp的底层是通过Java的Socket发送HTTP请求与接受响应的(这也好理解，HTTP就是基于TCP协议的)，但是OkHttp实现了连接池的概念，</p><p>即对于同一主机的多个请求，其实可以公用一个Socket连接，而不是每次发送完HTTP请求就关闭底层的Socket，这样就实现了连接池的概念。</p><h4 id="简述连接池的复用？"><a href="#简述连接池的复用？" class="headerlink" title="简述连接池的复用？"></a>简述连接池的复用？</h4><p>okhttp中所有的请求都被抽象为RealConnection，而ConnectionPool就是管理这些connection的，共享一个Address的链接可以复用</p><p>ConnectionPool，默认大小是5，每个链接存储5分钟，使用keep-alive，达到久连接，所以默认keep-alive是5分钟，也可以自定义</p><p>excutor：线程池，监测时间并释放连接的后台线程</p><p>connections：缓存池。是一个双端列表，这里用作栈</p><p>routeDatabase：记录连接失败router（路由）</p><p>使用put方法将连接放入缓存池，并清除闲置的线程，对缓存池进行排序（对比最大闲置时间），使用StreamAllocation复用请求</p><p>StreamAllocation的初始化在RetryAndFllowUpIntercepter。</p><p>在StreamAllocation调用newStream进行初始化，其中使用get方法在缓存池中查找相同的请求，如果找到就复用这条请求，没找到就新建连接并put到缓存池</p><blockquote><p>连接池的工作就这么多，并不负责，主要就是管理双端队列Deque<RealConnection>，可以用的连接就直接用，然后定期清理连接，同时通过对StreamAllocation的引用计数实现自动回收。</p></blockquote><h4 id="简述StreamAllocation"><a href="#简述StreamAllocation" class="headerlink" title="简述StreamAllocation"></a>简述StreamAllocation</h4><p>StreamAllocation是用来协调connections，stream和Call(请求)的。</p><p>HTTP通信执行网络请求<code>Call</code>需要在连接<code>Connection</code>上建立一个新的流<code>Stream</code>，我们将<code>StreamAllocation</code>称之流 的桥梁，它负责为一次<code>请求</code>寻找<code>连接</code>并建立<code>流</code>，从而完成远程通信。</p><p>其初始化在RetryAndFllowUpIntercepter，再次使用在CallServerInterceptor，复用机制使用该方法调用，减少一个三次握手的时间（不需要握手）</p><h4 id="OKIO的优势"><a href="#OKIO的优势" class="headerlink" title="OKIO的优势"></a>OKIO的优势</h4><ol><li>更加轻便，速度更快，使用更快</li><li>实现缓存结构，对cpu和内存进行优化，避免频繁gc（Segment链表实现）</li><li>功能强大，支持阻塞和非阻塞IO</li><li>支持多种类型，想比较于java.io和java.nio，不需要庞大的装饰类</li></ol><h4 id="Dispatcher的理解"><a href="#Dispatcher的理解" class="headerlink" title="Dispatcher的理解"></a>Dispatcher的理解</h4><p><img src="/imageMd/okhttp-2.png" alt="img"><br>内部维护了三个队列，分别为：</p><ul><li>runningAsyncCalls：正在请求的异步队列</li><li>readyAsyncCalls：准备请求的异步队列\等待请求的异步队列</li><li>runningSyncCalls：正在请求的同步队列</li></ul><blockquote><p>maxRequest：默认64。这是okhttp允许的最大请求数量。<br>maxRequestsPerHost ：默认5。这是okhttp对同一主机允许的最大请求数量。</p></blockquote><p><strong>同步执行源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="comment">//此处除去一些其他代码</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//通知Dispatcher这个Call正在被执行,同时将此Call交给Dispatcher</span></span><br><span class="line">    <span class="comment">//Dispatcher可以对此Call进行管理</span></span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//请求的过程，注意这行代码是阻塞的，直到返回result！</span></span><br><span class="line">    Response result = getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//此时这个请求已经执行完毕了，通知Dispatcher，不要再维护这个Call了</span></span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>try 中的return执行完成后，执行finally语句，所以不论请求成功或者失败，都会关闭这个请求</p><p><strong>异步执行源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="comment">//判断是否已经执行过了</span></span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//捕获调用栈的信息，用来分析连接泄露</span></span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  <span class="comment">//封装一个AsyncCall交给Dispatcher调度</span></span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断正在执行的异步请求数没有达到阈值，并且每一个Host的请求数也没有达到阈值</span></span><br><span class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">    <span class="comment">//加入到正在执行队列，并立即执行</span></span><br><span class="line">    runningAsyncCalls.add(call);</span><br><span class="line">    executorService().execute(call);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//加入到等待队列</span></span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简述OKhttp的缓存机制"><a href="#简述OKhttp的缓存机制" class="headerlink" title="简述OKhttp的缓存机制"></a>简述OKhttp的缓存机制</h4><p>okhttp有具备网络缓存机制，短时间内重复请求会复用缓存的数据，这样节省流量，应用也会很流畅。但是okhttp本身默认是不打开缓存机制的，需要配置后才能启动。</p><p>okhttp的缓存机制是以DiskLruCache（最近最少使用算法（Least recently used））为基础的，仅支持文件存储。</p><p>MD5(url)作为key，value是存储的服务端响应数据</p><p>默认不开启缓存机制</p><p>文件存储</p><p>DiskLruCache写入是依赖于okio的，内部实现类似于LinkedHashMap，键值对获取。</p><p>使用DiskLruCache，仅支持get请求的缓存</p><ol><li>如果服务器支持缓存，即response携带Cache-control属性，则当你打开okhttp缓存即开始缓存，通过属性控制类型</li><li>如果服务器不支持缓存或者okhttp不想按照服务器缓存策略来存储，通过自定义拦截器重写response的头部即可</li><li>客户端不支持缓存，则可以不缓存，不理会服务器的cache-control属性</li></ol><p>可以直接使用CacheControl类，包含</p><ul><li><strong>CacheControl.FORCE_NETWORK</strong>，即强制使用网络请求</li><li><strong>CacheControl.FORCE_CACHE</strong>，即强制使用本地缓存，如果无可用缓存则返回一个code为504的响应</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</span><br><span class="line">no-cache：不做缓存。</span><br><span class="line">max-age：这个参数告诉浏览器将页面缓存多长时间，超过这个时间后才再次向服务器发起请求检查页面是否有更新。对于静态的页面，比如图片、CSS、Javascript，一般都不大变更，因此通常我们将存储这些内容的时间设置为较长的时间，这样浏览器是不会向服务器反复发起请求，也不会去检查是否更新了。</span><br></pre></td></tr></table></figure><p>添加自定义网络拦截器，在其中改变Response的响应头，添加Cache-control，后续回到CacheIntercepter中时，就会执行缓存策略。</p><p>CacheControl.Builder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- noCache();<span class="comment">//不使用缓存，用网络请求</span></span><br><span class="line">- noStore();<span class="comment">//不使用缓存，也不存储缓存</span></span><br><span class="line"></span><br><span class="line">- onlyIfCached();<span class="comment">//只使用缓存</span></span><br><span class="line">- noTransform();<span class="comment">//禁止转码</span></span><br><span class="line">- maxAge(<span class="number">10</span>, TimeUnit.MILLISECONDS);<span class="comment">//设置超时时间为10ms。</span></span><br><span class="line">- maxStale(<span class="number">10</span>, TimeUnit.SECONDS);<span class="comment">//超时之外的超时时间为10s</span></span><br><span class="line">- minFresh(<span class="number">10</span>, TimeUnit.SECONDS);<span class="comment">//超时时间为当前时间加上10秒钟。</span></span><br></pre></td></tr></table></figure><p>CacheStrategy：缓存策略类，通过响应头信息与服务器端信息进行对比，最后返回是否使用新的网络请求还是直接使用缓存。其中存储的是Request请求体和Response响应体的具体内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 如果不使用网络，则 networkRequest为 null */</span></span><br><span class="line"><span class="comment">//客户端请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Request networkRequest;</span><br><span class="line"><span class="comment">/** 如果不使用缓存，则 cacheResponse为 null */</span></span><br><span class="line"><span class="comment">//服务端返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Response cacheResponse;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据输出的networkRequest和cacheResponse的值是否为null给出不同的策略，如下：</p><table><thead><tr><th>networkRequest</th><th>cacheResponse</th><th>result 结果</th></tr></thead><tbody><tr><td>null(不使用网络)</td><td>null（不使用缓存）</td><td>only-if-cached (表明不进行网络请求，且缓存不存在或者过期，一定会返回<strong>503</strong>错误)</td></tr><tr><td>null</td><td>non-null</td><td>不进行网络请求，直接返回缓存，不请求网络</td></tr><tr><td>non-null</td><td>null</td><td>需要进行网络请求，而且缓存不存在或者过去，直接访问网络</td></tr><tr><td>non-null</td><td>non-null</td><td>Header中包含ETag/Last-Modified标签，需要在满足条件下请求，还是需要访问网络（根据情况使用）</td></tr></tbody></table><p>如果网络不为null，则使用网络请求，如果网络为null，当缓存不为null，则使用缓存，当缓存为null时，返回503错误</p><h4 id="为什么只做get的缓存？"><a href="#为什么只做get的缓存？" class="headerlink" title="为什么只做get的缓存？"></a>为什么只做get的缓存？</h4><p>其他响应成本大，效率低</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>okhttp其中有一个dispatcher对最大连接数（并发），host最大访问量做了定义，维护了3个队列（同步正在执行，准备执行，异步正在执行）和一个线程池（0~max）</p><p>该线程池类似于CachedThreadPool，没有核心线程，全是非核心线程，超时时间是60s，即60s后回收该线程，其队列为空，没有容量，是一种特殊的队列，适用于执行短时的大量任务。</p><h4 id="okhttp的优势？"><a href="#okhttp的优势？" class="headerlink" title="okhttp的优势？"></a>okhttp的优势？</h4><p>最大特点是，intercepter拦截器，连接池复用，okio io处理，线程池处理（全是非核心线程），支持http1.0，1.1，2.0</p><p>okio内部封装链表数据存储，比较之前的数组存储，更加节省空间，还可以复用</p><h4 id="长连接（websocket）和久连接（keep-alive）的区别"><a href="#长连接（websocket）和久连接（keep-alive）的区别" class="headerlink" title="长连接（websocket）和久连接（keep-alive）的区别"></a>长连接（websocket）和久连接（keep-alive）的区别</h4><p>调用的是equeue异步方法，将长连接放入线程池中不会被释放掉</p><ol><li>1.1推出keep-alive机制，服务器不会主动发送请求，一个request返回一个response。</li><li>减少了握手的次数而已</li><li>久连接是同步串行处理的，当某一个请求因为网络，服务器等原因阻塞时，那么后面的请求都得不到处理</li><li>http头部太大，传输耗时</li><li>实时性得不到保证</li></ol><blockquote><p>http是单向的，websocket属于应用层协议，使用http1.1的101码进行握手状态判断</p></blockquote><p>websocket建立连接是使用https连接，三次握手，在通信过程中</p><ul><li>以ws开头</li><li>握手成功后，复用连接发送请求和接收</li><li>不需要发送header信息</li><li>服务端客户端平等，可以相互建立连接，http久连接是基于http的，符合http协议。</li></ul><p>最开始使用<strong>get</strong>请求进行握手，携带Upgrade: websocket ，告知服务器上升为websocket协议，成功后，使用web socket数据流（帧）进行通信，设置超时时间为永不超时，客户端设置循环，一直从服务端取消息。</p><p>使用http的get请求进行3次握手协议，使用http1.1版本的101状态码返回成功后，就不需要http交互了，后续采用web socket流进行通信，减少包体</p><blockquote><p>使用标准的HTTP协议无法实现WebSocket，只有支持那些协议的专门浏览器才能正常工作。</p></blockquote><h4 id="websocket的握手和http的握手有什么区别？"><a href="#websocket的握手和http的握手有什么区别？" class="headerlink" title="websocket的握手和http的握手有什么区别？"></a>websocket的握手和http的握手有什么区别？</h4><p>使用http的get请求进行握手，基本一致，额外传输了header的信息标记为websocket。</p><h4 id="MQTT理解"><a href="#MQTT理解" class="headerlink" title="MQTT理解"></a>MQTT理解</h4><p>发布订阅者模式，低带宽，低开销的即时通信协议，基于tcp/ip协议，成为IOT通讯标准</p><p>消息体如下：<strong>固定头部+可变头部+消息体</strong>，整个消息体比较轻便，便于交互及时</p><table><thead><tr><th>固定报头（fixed header）</th><th>可变报头（variable header）</th><th>荷载（payload）</th></tr></thead><tbody><tr><td>所有报文都包含，数据包类型及数据包的分组类标识</td><td>部分报文包含，数据包类型决定了可变头是否存在及其具体内容</td><td>部分报文包含，表示客户端收到的具体内容</td></tr></tbody></table><p>基于二进制实现，MQTT运行于http上，所以明文传输，如果位于https中，则可以使用TLS加密传输</p><p>发布者，订阅者模式：客户端是发布者和订阅者，服务端是代理服务器</p><h4 id="MQTT和websocket的区别？"><a href="#MQTT和websocket的区别？" class="headerlink" title="MQTT和websocket的区别？"></a>MQTT和websocket的区别？</h4><p>MQTT面向原生设备，基于二进制实现，提供一对多的通信方式，采用发布/订阅模式传输</p><p>websocket面向web设备，是全双工通信</p><h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>基于Okhttp的RESTFUL Api请求工具，Retrofit可以让你简单到调用一个Java方法的方式去请求一个api，这样App中的代码就会很简洁方便阅读</p><p><img src="/imageMd/retrofit-1.png" alt="img"></p><p>Retrofit通过java接口及注解来描述网络请求，并用动态代理的方式生成网络请求的Request，通过调用相应的网络框架（默认Okhttp）去发起网络请求，并将返回的Response通过converterFactory转化成相应的model，最后通过CallAdapter转换成其他的数据方式（Rxjava Observable）</p><p>Retrofit.create()方法是Retrofit的核心，其中，使用Proxy.newProxyInstance()方法创建ServiceMethod，具体实现是在InvocationHandler类中的invoke方法，实现了动态代理的形式，而这个InvocationHandler对象就是代理对象，这个对象是在运行时动态生成的。</p><h4 id="Retrofit中的动态代理"><a href="#Retrofit中的动态代理" class="headerlink" title="Retrofit中的动态代理"></a>Retrofit中的动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            ...</span><br><span class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过动态代理生成InvocationHandler类，在内部，创建一个ServiceMethod，存储接口的请求信息，构建一个OKhttpCall对象，初始化网络请求</p><h4 id="Retrofit的优势"><a href="#Retrofit的优势" class="headerlink" title="Retrofit的优势"></a>Retrofit的优势</h4><p>Retrofit是对okhttp的二次封装，解决okhttp中接口请求、数据结果返回和接口调用的短板。</p><ol><li>规划了interface接口类，整合所有接口调用的详细内容，便于调用，降低耦合性。</li><li>配合RxJava，okhttp，职责明确。RxJava负责异步处理，Retrofit负责请求的数据和结果的展示，okhttp负责接口请求和返回的具体过程</li></ol><ul><li>Retrofit主要负责应用层面的封装，就是说主要面向开发者，方便使用，比如请求参数，响应数据的处理，错误处理等等。</li><li>OkHttp主要负责socket部分的优化，比如多路复用，buffer缓存，数据压缩等等。</li></ul><ol start="3"><li>相对于okhttp来说，使用动态代理生成Request对象，不用每次调用自己实现</li><li>网络结果线程切换库（RxJava，普通），网络结果格式化库（Gson，xml）等可以做到随意替换和支持</li></ol><h4 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h4><p>静态代理：<br>由程序员创建或工具生成的代理类，在运行前就存在代理类的字节码文件，代理类和委托类的关系已经确定</p><p>动态代理：<br>在程序运行过程中，通过反射实现对代理类的动态创建，可以代理多个方法。（InvocationHandler、CGLib）</p><h2 id="Butterknife———view的注入"><a href="#Butterknife———view的注入" class="headerlink" title="Butterknife———view的注入"></a>Butterknife———view的注入</h2><h4 id="简述Butterknife"><a href="#简述Butterknife" class="headerlink" title="简述Butterknife"></a>简述Butterknife</h4><p>初始化控件会写大量的findViewById()，setOnClickListener()方法，很繁琐，该框架使用注解的方式实现辅助代码的生成，简化这些代码。</p><p>该框架是基于java注解机制实现的，也就是在<code>编译期间</code>就初始化好了一个viewBinding类（view和点击事件的处理），生成findViewById来绑定布局，不用开发者每次去初始化</p><h4 id="Butterknife为什么初始化控件不能用private和static"><a href="#Butterknife为什么初始化控件不能用private和static" class="headerlink" title="Butterknife为什么初始化控件不能用private和static"></a>Butterknife为什么初始化控件不能用private和static</h4><p>因为在编译期间构建view的绑定事件会报错，无法访问private变量，否则，要加入反射，导致性能问题</p><p>static可能会导致内存泄漏，而且外部可以访问。</p><h4 id="ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么"><a href="#ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么" class="headerlink" title="ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么"></a>ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么</h4><p>解析注解处理器， 对比Butterknife，Dagger2，DBFlow。</p><p>没有反射机制，使用自定义注解框架</p><h4 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h4><p>butterknife继承后，子类可以使用父类控件，但是<strong>必须在setContView之后</strong>进行绑定。如果在子view进行绑定控件，但是父类找不到子类的控件，因为生成的是子view_ViewBinding类，父类获取不到</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>每个Activity会生成一个类，增大包体积</li><li>butterknife可以称之为view的注入，对findviewById包装更加简单，功能单一</li></ul><h2 id="ViewBinding最终最好的解决方案"><a href="#ViewBinding最终最好的解决方案" class="headerlink" title="ViewBinding最终最好的解决方案"></a>ViewBinding最终最好的解决方案</h2><h4 id="简析ViewBinding"><a href="#简析ViewBinding" class="headerlink" title="简析ViewBinding"></a>简析ViewBinding</h4><p>在build.gradle中开启ViewBinding<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    viewBinding.enabled = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>android studio会将xml文件中所有文件在编译过程中生成<strong>xxxBinding</strong>类，这个类有三种初始化方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binding = LayoutSecondBinding.inflate(getLayoutInflater());</span><br></pre></td></tr></table></figure><br>在Activity或Fragment中调用inflate方法进行初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inflate(LayoutInflater inflater)</span><br><span class="line">inflate(LayoutInflater inflater,ViewGroup parent,<span class="keyword">boolean</span> attachToParent)</span><br><span class="line">bind(View rootView)</span><br></pre></td></tr></table></figure><br>最终三个方法都会走到bind方法中，在这个方法中，对View进行findViewById操作</p><h4 id="ViewBinding和Butterknife的区别"><a href="#ViewBinding和Butterknife的区别" class="headerlink" title="ViewBinding和Butterknife的区别"></a>ViewBinding和Butterknife的区别</h4><p>ViewBinding会处理空安全，类型安全，还可以兼容java和kotlin。最新版本Gradle中设置对R文件的修改，R文件中的id不再是final的，(Fragment中R文件不是final的时候，Butterknife使用生成R2文件的做法围魏救赵)这样就会影响注解的使用，butterknife就被迫下台<br>Viewbinding根正苗红，官方支持就是最大优势</p><h4 id="Viewbinding如何处理include布局？"><a href="#Viewbinding如何处理include布局？" class="headerlink" title="Viewbinding如何处理include布局？"></a>Viewbinding如何处理include布局？</h4><p>xml布局中存在include布局的，需要给include布局添加id，生成一个includexxxBinding文件，在xxxBinding类中做映射体现。</p><blockquote><p>内部view由final修饰，保证view不能被重新创建的view替换（引用不可修改），但是其内部的值可以修改</p></blockquote><h2 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h2><h4 id="简析"><a href="#简析" class="headerlink" title="简析"></a>简析</h4><p>元注解：修饰注解的注解，</p><ul><li>@Target：注解的作用目标（修饰方法，类还是字段）</li><li>@Retention：注解的生命周期<ul><li>SOURCE：仅存在java源文件中，经过编译器后就丢弃，适用于一些检查行的操作，比如@Override</li><li>CLASS：编译class文件时生效，适用于在编译时做一些预处理操作，比如Butterknife的@BindView，在编译时，通过注解器生成一些辅助代码，完成完整的功能</li><li>RUNTIME：保留在运行时VM中可以通过反射获取注解。适用于一些需要运行时动态获取注解信息，类似反射获取注解等，比如EventBus的@Subscribe</li></ul></li><li>@Documented：注解是否应当被包含在JavaDoc文档中</li><li>@Inherited：是否允许子类继承该注解</li><li>AnnotationInvocationHandler：专门处理注解的Handler</li></ul><p>代码的生命周期包含：编码(SOURCE)—-&gt;编译(CLASS)—-&gt;运行(RUNTIME)</p><blockquote><p>默认时注解在编译阶段，即CLASS阶段</p></blockquote><p>本质：一个继承了Annotation接口的接口</p><ul><li>运行时处理：使用反射获取当前的所需要的东西</li><li>编译时处理：APT技术，即编译期扫描java文件的注解，并传递到注解处理器，注解处理器可根据注解生成新的java文件</li></ul><blockquote><p>APT(Annotation Processing Tool)编译期解析注解</p></blockquote><h4 id="注解的种类"><a href="#注解的种类" class="headerlink" title="注解的种类"></a>注解的种类</h4><ul><li>JDK提供的注解（源码注解）</li><li>自定义注解</li><li>元注解</li></ul><h4 id="注解的用处"><a href="#注解的用处" class="headerlink" title="注解的用处"></a>注解的用处</h4><ol><li>降低项目的耦合</li><li>自动完成一些规律性代码</li><li>自动生成java代码，减少开发工作量</li></ol><h4 id="注解器"><a href="#注解器" class="headerlink" title="注解器"></a>注解器</h4><p>注解器通常是以Java代码（或者编译过的字节码）作为输入，生成.java文件作为输出</p><p>AbstractProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源于javax.annotation.processing;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合中指定支持的注解类型的名称（这里必须时完整的包名+类名)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            SupportedAnnotationTypes sat = <span class="keyword">this</span>.getClass().getAnnotation(SupportedAnnotationTypes.class);</span><br><span class="line">            <span class="keyword">if</span>  (sat == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isInitialized())</span><br><span class="line">                    processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,</span><br><span class="line">                                                             <span class="string">&quot;No SupportedAnnotationTypes annotation &quot;</span> +</span><br><span class="line">                                                             <span class="string">&quot;found on &quot;</span> + <span class="keyword">this</span>.getClass().getName() +</span><br><span class="line">                                                             <span class="string">&quot;, returning an empty set.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> arrayToSet(sat.value());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 指定当前正在使用的Java版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SupportedSourceVersion ssv = <span class="keyword">this</span>.getClass().getAnnotation(SupportedSourceVersion.class);</span><br><span class="line">        SourceVersion sv = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ssv == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sv = SourceVersion.RELEASE_6;</span><br><span class="line">            <span class="keyword">if</span> (isInitialized())</span><br><span class="line">                processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,</span><br><span class="line">                                                         <span class="string">&quot;No SupportedSourceVersion annotation &quot;</span> +</span><br><span class="line">                                                         <span class="string">&quot;found on &quot;</span> + <span class="keyword">this</span>.getClass().getName() +</span><br><span class="line">                                                         <span class="string">&quot;, returning &quot;</span> + sv + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            sv = ssv.value();</span><br><span class="line">        <span class="keyword">return</span> sv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot call init more than once.&quot;</span>);</span><br><span class="line">        Objects.requireNonNull(processingEnv, <span class="string">&quot;Tool provided null ProcessingEnvironment&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.processingEnv = processingEnv;</span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这些注解是否由此 Processor 处理，该方法返回ture表示该注解已经被处理, 后续不会再有其他处理器处理; 返回false表示仍可被其他处理器处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    RoundEnvironment roundEnv)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>如果是单一属性，可以使用value字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> MyAnno1 &#123;</span><br><span class="line">    <span class="comment">//格式：类型名 属性名（）</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnno1(&quot;kang&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> MyAnno2 &#123;</span><br><span class="line">    <span class="comment">//格式：类型名 属性名（）</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnno2(name = &quot;kang&quot;)</span></span><br></pre></td></tr></table></figure><p>如果不是value字段的话，需要（指定属性 = 值）</p><blockquote><p>注解中只允许八种基本数据类型、字符串、类类型，注解类型，枚举类型及其一维数组</p></blockquote><h2 id="Glide和Picasso"><a href="#Glide和Picasso" class="headerlink" title="Glide和Picasso"></a>Glide和Picasso</h2><h4 id="简述LruCache和DiskLruCache"><a href="#简述LruCache和DiskLruCache" class="headerlink" title="简述LruCache和DiskLruCache"></a>简述LruCache和DiskLruCache</h4><p>内部都实现了LRU算法，即：优先淘汰那些最近最少使用的缓存对象</p><p>LruCache：</p><p>内部采用LinkedHashMap，是线程安全的（get、put、remove方法都是用synchronized），双向链表（保持LinkedList规定顺序+HashMap便于查找）<br>将最近使用的节点放置在链表尾部，当超过大小时，删除第一个头节点。</p><p>存储了前一个元素和后一个元素的引用，get方法后，就查出值删除，然后放置在头部，如果超过Lru算法的大小，直接遍历删除尾节点，直到大小在范围内</p><h4 id="简述Glide的缓存过程"><a href="#简述Glide的缓存过程" class="headerlink" title="简述Glide的缓存过程"></a>简述Glide的缓存过程</h4><p>默认打开缓存，内存缓存使用LruCache+弱引用实现，磁盘缓存使用DiskLruCache实现</p><p>使用内存缓存+磁盘缓存的策略，生成key时，图片只要发生变化，就算长宽发生变化也会导致缓存不同的key。Glide将内存缓存划分为两个区域：</p><ul><li>LruResourceCache：使用LruCache算法，LinkedHashMap（不在使用的）</li><li>activeResources：添加弱引用机制，HashMap（正在使用的图片）</li></ul><p>磁盘缓存之存在DiskLruCache，因为Glide可以压缩图片（尺寸压缩），所以磁盘缓存中可以设置缓存原始图片还是压缩后的图片，压缩图片可以有效避免大图和超大图带来的OOM，Glide没有使用google提供的DiskLruCache，而是使用自己开发的，不过原理都一样</p><p>在首次访问时，将正在使用的图片信息会存储在activeResources的弱引用中，当引用次数为0时（调用release方法），会将其放入LruResourceCache中，执行Lru算法，移除后会存入DiskLruCache中。</p><p>所以，先去activeResources中寻找，找到后，将引用对象索引+1（active.aquire();）（计算引用次数）。然后去LruResourceCache中寻找了，若找到了，在LruResourceCache中移除，并将其放入activeResources中。然后去DiskLruCache中寻找，若找到了，在DiskLruCache中删除，并将其放入activeResources中。</p><blockquote><p>Glide 缓存的是imageView的所需图片的大小，若大小不同，重新缓存</p><p>Picasse 缓存图片原图大小</p></blockquote><h4 id="Glide是如何绑定生命周期的？"><a href="#Glide是如何绑定生命周期的？" class="headerlink" title="Glide是如何绑定生命周期的？"></a>Glide是如何绑定生命周期的？</h4><ul><li>Application参数:如果传入的是Application对象,那么这里就会调用带有Context参数的get()方法重载，调用getApplicationManager()方法来获取一个RequestManager对象。其实这是最简单的一种情况，因为Application对象的生命周期即应用程序的生命周期，因此Glide并不需要做什么特殊的处理，它自动就是和应用程序的生命周期是同步的，如果应用程序关闭的话，Glide的加载也会同时终止。</li><li>非Application参数:不管传入的是Activity、FragmentActivity、v4包下的Fragment、还是app包下的Fragment，最终的流程都是一样的，那就是会向当前的Activity当中添加一个隐藏的Fragment。因为Glide需要知道加载的生命周期。很简单的一个道理，如果你在某个Activity上正在加载着一张图片，结果图片还没加载出来，Activity就被用户关掉了，那么图片还应该继续加载吗？当然不应该。可是Glide并没有办法知道Activity的生命周期，于是Glide就使用了添加隐藏Fragment的这种小技巧，因为Fragment的生命周期和Activity是同步的，如果Activity被销毁了，Fragment是可以监听到的，这样Glide就可以捕获这个事件并停止图片加载了。</li><li>如果我们是在<strong>非主线程</strong>当中使用的Glide，那么不管你是传入的Activity还是Fragment，都会被强制当成Application来处理。</li></ul><ol><li>RequestManagerFragment：实现一个无UI的fragment。</li><li>ActivityFragmentLifecycle：无UI的fragment通过它，去调用RequestManager</li><li>RequestManager：实现关键的几个方法，去调用glide 的操作</li><li>RequestManagerRetriever：作为一个桥梁，将RequestManagerFragment<br>和RequestManager给联系起来</li></ol><blockquote><p>空RequestManagerFragment 的生命周期调用 ActivityFragmentLifecycle，然后ActivityFragmentLifecycle 调用 RequestManager ，RequestManager 再去调用RequestTracker 的glide操作，最终实现gilde的操作，能够根据页面的生命周期做相应的处理。</p></blockquote><h4 id="Glide中Fragment中是怎么绑定生命周期的？"><a href="#Glide中Fragment中是怎么绑定生命周期的？" class="headerlink" title="Glide中Fragment中是怎么绑定生命周期的？"></a>Glide中Fragment中是怎么绑定生命周期的？</h4><h4 id="Glide中into指定view，再次刷新view会发生什么？"><a href="#Glide中into指定view，再次刷新view会发生什么？" class="headerlink" title="Glide中into指定view，再次刷新view会发生什么？"></a>Glide中into指定view，再次刷新view会发生什么？</h4><blockquote><p>Glide内部通过HttpUrlConnection进行通信，也可切换为okhttp/volley</p></blockquote><ol><li>根据ScaleType进行相应的设置</li><li>根据传入的类型对Glide加载进行配置，asBitmap，asGif，asDrawable</li><li>根据target（View）创建Request请求，根据生命周期管控Request的暂停和下载</li></ol><p><code>target</code>就是<code>view</code>，先判断<code>target</code>是之前已经绑定了请求，如果旧请求和新请求一样且处于请求完成或者正在请求状态就直接复用旧请求。如果不复用,就<code>RequestManager</code>先移除和旧请求绑定的<code>target</code>对象，<code>Target</code>再重新和<code>Request</code>对象进行一个绑定，调用<code>requestManager.track(target, request)</code>再加入请求队列，开启请求，最后返回经过处理的<code>traget</code>对象。</p><h4 id="Glide和Picasso对比"><a href="#Glide和Picasso对比" class="headerlink" title="Glide和Picasso对比"></a>Glide和Picasso对比</h4><ol><li>Glide较Picasso庞大的多</li><li>Glide绑定生命周期，onPause时暂停加载，onResume时再启动，Picasso只存在context</li><li>Glide会缓存imageView图片大小，尺寸不同，key不同，会缓存两份，Picasso是缓存完整大小，使用时会重新设置大小</li><li>Glide首次加载快于Picasso，而后每次加载慢于Picasso，因为Glide需要改变图片的大小再缓存到内存，时间会慢。picasso拿到缓存后需要对图片重新设置大小，耗时较长。</li><li>Glide支持gif</li><li>Glide加载的图片质量略差，因为bitmap的格式内存开销小，但是很难察觉</li><li>Glide可以配置图片显示的动画，而picasso只有默认的一种动画</li><li>Glide缓存方式更优，减少OOM的发生</li></ol><blockquote><p>Glide：RGB565<br>Picasso：ARGB8888</p></blockquote><h4 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h4><p>缓存机制：LruCache，DiskLruCache</p><p>内存缓存占用一个app的15%内存</p><p>网络请求使用的okhttp，内部缓存也使用okhttp，一般大小不超过50M</p><p>网络机制：network</p><h4 id="Fresco比较"><a href="#Fresco比较" class="headerlink" title="Fresco比较"></a>Fresco比较</h4><p>缓存机制：</p><ol><li><p><strong>BitmapMemoryCache</strong>缓存，已解码的内存缓存</p></li><li><p><strong>EncodedMemoryCache</strong>缓存，</p></li><li><h3 id="CountingLruMap，Lru算法清除缓存"><a href="#CountingLruMap，Lru算法清除缓存" class="headerlink" title="CountingLruMap，Lru算法清除缓存"></a>CountingLruMap，Lru算法清除缓存</h3></li></ol><p>分层处理，producer层层处理，每层处理结果通过Consumer向上传递，Producer-consumer链</p><ol><li>从已编码缓存中获取bitmap缓存</li><li>从未编码缓存中获取EncodedImage类型</li><li>从磁盘中获取</li><li>从网络中获取</li></ol><p>DraweeView：</p><p>动图播放，多级图层，渐进显示，画面剪裁</p><p><img src="/imageMd/fresco-1.png" width="70%"/></p><ol><li>解码器优化，避免频繁解码导致内存抖动，使用pool内存池复用</li></ol><p>适合各个android版本的解码器</p><p>优点：</p><ol><li>内存管理，LRU算法，缓存和磁盘管理</li><li>加载大图和高清图时可以先加载低清晰度图和缩略图</li><li>加载gif</li><li>图片渐进式处理：，渐进式图片格式先呈现大致的图片轮廓，然后随着图片下载的继续，呈现逐渐清晰的图片</li></ol><h4 id="包体积"><a href="#包体积" class="headerlink" title="包体积"></a>包体积</h4><p>Fresco&gt;Glide&gt;Picasso</p><h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p>检测内存泄漏</p><h4 id="ActivityLifecycleCallbacks-与-FragmentLifeCycleCallbacks"><a href="#ActivityLifecycleCallbacks-与-FragmentLifeCycleCallbacks" class="headerlink" title="ActivityLifecycleCallbacks 与 FragmentLifeCycleCallbacks"></a>ActivityLifecycleCallbacks 与 FragmentLifeCycleCallbacks</h4><p>通过application.registerActivityLifecyleCallbacks获取Activity的生命周期</p><p>通过fragmentManager.registerFragmentLifecyleCallbacks获取Fragment的生命周期</p><p>注册接口，拿到Activity和Fragment的各种生命周期回调信息</p><h4 id="如何做到内存泄漏检测"><a href="#如何做到内存泄漏检测" class="headerlink" title="如何做到内存泄漏检测"></a>如何做到内存泄漏检测</h4><p>Activity在onDestory后会将Activity生成一个唯一的key后存储在弱引用队列中，在主线程空闲时（IdleHandler）触发gc机制，垃圾回收，整理弱引用队列，查看弱引用队列中没有被回收的对象，即是内存泄漏的对象，打印出栈堆信息以供分析dump</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>只能监听Activity和Fragment的内存泄漏检测，无法检测Service</p><h4 id="其他内存泄漏检测工具"><a href="#其他内存泄漏检测工具" class="headerlink" title="其他内存泄漏检测工具"></a>其他内存泄漏检测工具</h4><p>Profiler：android studio自带，可以查看内存的整体过程，分析是否发生内存泄漏</p><h2 id="ASM函数插桩"><a href="#ASM函数插桩" class="headerlink" title="ASM函数插桩"></a>ASM函数插桩</h2><h4 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h4><p>简析为字节码插桩，可以直接修改已经存在的class文件或者生成class文件，相比较于AspectJ，ASM更加偏向于底层，他是直接操作字节码的，在设计中更小，更快</p><blockquote><p>class文件本质是16进制数据</p></blockquote><p>ClassVisitor</p><p>MethodVistor</p><h1 id="Android基础篇"><a href="#Android基础篇" class="headerlink" title="Android基础篇"></a>Android基础篇</h1><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><h4 id="简述Application"><a href="#简述Application" class="headerlink" title="简述Application"></a>简述Application</h4><p>作用：做初始化工作，提供上下文。继承自ContextWarpper，获取的是ContextWrapper中的context对象</p><ul><li>一个应用中有且只有一个</li><li>其生命周期和应用程序一样长</li><li>Application的onCreate方法才是整个应用程序的入口</li><li>只会实例化一次，所以天生就是一个单例</li></ul><p>生命周期：</p><ul><li>onCreate：创建时执行</li><li>onTerminate：终止时执行</li><li>onLowMemory：低内存时执行</li></ul><h4 id="Application的初始化流程"><a href="#Application的初始化流程" class="headerlink" title="Application的初始化流程"></a>Application的初始化流程</h4><p>通过AMS协调，ActivityThread优先建立后，会新建一个ApplicationThread，用作和AMS通过Binder通信，之后AMS通知ActivityThread去bindApplication，将消息返送到messageQueue，进行初始化Application的任务，然后调用<code>attachBaseContext</code>将Context绑定到Application，最后调用Application.onCreate()方法进行后续Activity的初始化</p><blockquote><p>AMS 来通知 zygote 进程来 fork 一个新进程，来开启我们的目标 App 的</p></blockquote><h4 id="ActivityLifecycleCallbacks理解"><a href="#ActivityLifecycleCallbacks理解" class="headerlink" title="ActivityLifecycleCallbacks理解"></a>ActivityLifecycleCallbacks理解</h4><p>ActivityLifecycleCallback是Application中的一个接口，可以监听应用中所有Activity的生命周期，可以通过该方法完成一些特殊的需求，比如监测当前App显示的Activity是那个？App是否存在前台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> ActivityLifecycleCallbacks activityLifecycleCallbacks = <span class="keyword">new</span> ActivityLifecycleCallbacks() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Bundle outState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册Callback</span></span><br><span class="line">        registerActivityLifecycleCallbacks(callbacks);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h4 id="简述生命周期"><a href="#简述生命周期" class="headerlink" title="简述生命周期"></a>简述生命周期</h4><p><img src="https://developer.android.google.cn/guide/components/images/activity_lifecycle.png?hl=zh-cn" alt="img"></p><h5 id="Activity："><a href="#Activity：" class="headerlink" title="Activity："></a>Activity：</h5><ul><li>onCreate()   正在被创建</li><li>onRestart()    不可见到可见</li><li>onStart()    Activity正在启动，已经可见了</li><li>onResume()   Acitivty已经可见，并在前台显示</li><li>onPause()    Acitivty正在停止，之后会不可见</li><li>onStop()    Activity即将停止</li><li>onDestory()    Activity被销毁</li></ul><blockquote><p>onStart和onResume都为可见，onStart不在前台显示，onResume在前台显示</p><p>onPause后已经不可见，会进入onResume或者另一个onResume，所以不能做耗时操作，会影响界面显示</p><p>onPause和onStop中不能太耗时</p><p>如果新的Activity采用了透明主题，那么当前Activity不会回调onStop</p><p>onStart和onStop对应Activity是否可见</p><p>onResume和onPause对应Activity是否在前台显示</p></blockquote><p>异常情况下会执行onSaveInstance方法进行数据保存</p><h4 id="简述启动模式"><a href="#简述启动模式" class="headerlink" title="简述启动模式"></a>简述启动模式</h4><ul><li>standard：标准模式，来一个添加一个</li><li>singleTop：栈顶复用，如果在栈顶，就复用这个Activity，<code>onNewIntent</code>会被执行，替代onCreate()</li><li>singleTask：栈内复用，如果在栈内，就复用这个Activity，该Activity之上的全部出栈，onNewIntent会被执行</li><li>singleInstance：单实例模式。加强版singleTask，会为自己新建一个栈，在该栈中栈内复用</li></ul><h4 id="LauncherMode和startActivityForResult"><a href="#LauncherMode和startActivityForResult" class="headerlink" title="LauncherMode和startActivityForResult"></a>LauncherMode和startActivityForResult</h4><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180103/a3b5ebe0294548348fe4d18bf3fcb0e0.jpeg" width="70%"/></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180103/f5357e8487474ae2b5e17f08725778c2.jpeg" width="70%"/></p><p>在5.0之前，当启动一个Activity时，系统将首先检查Activity的launchMode，如果为A页面设置为SingleInstance或者B页面设置为singleTask或者singleInstance,则会在LaunchFlags中加入FLAG_ACTIVITY_NEW_TASK标志，而如果含有FLAG_ACTIVITY_NEW_TASK标志的话，onActivityResult将会立即接收到一个cancle的信息，而5.0之后这个方法做了修改，修改之后即便启动的页面设置launchMode为singleTask或singleInstance，onActivityResult依旧可以正常工作，也就是说无论设置哪种启动方式，StartActivityForResult和onActivityResult()这一组合都是有效的</p><h4 id="什么时候会启动一个新的Activity栈？"><a href="#什么时候会启动一个新的Activity栈？" class="headerlink" title="什么时候会启动一个新的Activity栈？"></a>什么时候会启动一个新的Activity栈？</h4><ul><li>allowTaskReparenting：</li></ul><ol><li>singleInstance单独使用，会新建一个栈</li><li>singleTask配合taskAffinity使用</li><li>taskAffinity配合Intent.FLAG_ACTIVITY_NEW_TASK修饰Activity（AMS先处理LauncherMode，在处理FLAG_ACTIVITY_NEW_TASK）</li><li>taskAffinity配合allowTaskReparenting属性，使Activity从启动栈移动到正在使用的栈中并显示出来</li></ol><h4 id="如何控制Activity的动画切换"><a href="#如何控制Activity的动画切换" class="headerlink" title="如何控制Activity的动画切换"></a>如何控制Activity的动画切换</h4><ol><li>通过overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_left)方法控制<br>再startActivity方法后或者finish方法之后调用即可生效</li><li>使用style定义切换动画</li></ol><h4 id="如何控制Fragment的动画切换"><a href="#如何控制Fragment的动画切换" class="headerlink" title="如何控制Fragment的动画切换"></a>如何控制Fragment的动画切换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FragmentTransaction fragmentTransaction = mFragmentManager</span><br><span class="line">                .beginTransaction();</span><br><span class="line"></span><br><span class="line">fragmentTransaction.setCustomAnimations(</span><br><span class="line">                R.anim.in_from_right,</span><br><span class="line">                R.anim.out_to_left);</span><br></pre></td></tr></table></figure><p>使用FragmentTransaction开启Fragment动画，设置自定义动画切换，进入动画和推出动画</p><h4 id="ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？"><a href="#ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？" class="headerlink" title="ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？"></a>ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？</h4><p>ActivityA跳转到ActivityB：onPauseA()—–&gt;onCreateB()—–&gt;onStartB()—–&gt;onResumeB()—–&gt;onStopA()</p><p>ActivityB按back键返回ActivityA：</p><p>onPauseB()—–&gt;onRestartA()—–&gt;onStartA()—–&gt;onResumeA()—–&gt;onStopB()—–&gt;onDestoryB()</p><h4 id="如果ActivityB是窗口Activity呢？"><a href="#如果ActivityB是窗口Activity呢？" class="headerlink" title="如果ActivityB是窗口Activity呢？"></a>如果ActivityB是窗口Activity呢？</h4><p>ActivityA跳转到ActivityB：onPauseA()—–&gt;onCreateB()—–&gt;onStartB()—–&gt;onResumeB()</p><p>ActivityB按back键返回ActivityA：onPauseB()—–&gt;onResumeA()—–&gt;onStopB()—–&gt;onDestoryB()</p><h4 id="Activity的生命周期会受Dialog影响吗？"><a href="#Activity的生命周期会受Dialog影响吗？" class="headerlink" title="Activity的生命周期会受Dialog影响吗？"></a>Activity的生命周期会受Dialog影响吗？</h4><p>不会，Activity生命周期不会随Dialog的显示而变化</p><p>Activity的生命周期受AMS调用，而dialog不是Activity，所以不受AMS控制，所以不会触发Activity的生命周期</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h4 id="Service有几种创建方式？有什么区别？"><a href="#Service有几种创建方式？有什么区别？" class="headerlink" title="Service有几种创建方式？有什么区别？"></a>Service有几种创建方式？有什么区别？</h4><ol><li>startService()，在不需要的时候stopService()</li><li>bindService()，与生命周期相绑定，在销毁的时候进行回收unbind()</li></ol><p><img src="/imageMd/service-1.png" alt="生命周期"></p><h4 id="如何理解IntentService？生命周期是什么？HandlerThread-是什么？"><a href="#如何理解IntentService？生命周期是什么？HandlerThread-是什么？" class="headerlink" title="如何理解IntentService？生命周期是什么？HandlerThread 是什么？"></a>如何理解IntentService？生命周期是什么？HandlerThread 是什么？</h4><p>intentService继承自Service，持有Service的功能，同时，他是一个处理异步操作的类，当异步执行结束后会自动关闭intentService，多次执行startService()，只是执行onStartCommand方法，将消息加入到消息队列中。</p><p>其本质就是启动了一个类似于主线程Handler的机制去维护异步操作。</p><p>生命周期：onStartCommand()中执行onStart()方法，在onstart()方法中添加handler.sendMessage()方法</p><p>HandlerThread：就是将Handler+looper进行封装，允许直接在子线程中使用handler的一套逻辑。</p><blockquote><p>IntentService更像是一个后台线程，但是他又是一个服务，不容易被回收，这是他的优点</p></blockquote><h4 id="JobIntentService"><a href="#JobIntentService" class="headerlink" title="JobIntentService"></a>JobIntentService</h4><p>是IntentService的子类，在android 8.0（26）以上，IntentService的所有后台执行任务都会受到限制约束，所以要使用JobIntentService。</p><blockquote><p>service不能使用后台服务，需要使用ContextCompat.startForegroundService启动前台服务，这样就会启动一个notification，对用户来说体验不是很好，所以就要使用<br>JobIntentService启动一个后台服务</p></blockquote><p>在使用JobIntentService的时候不需要startService，stopService，在需要的时候调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DownLoadJobIntentService.enqueueWork(MainActivity.<span class="keyword">this</span>,DownLoadJobIntentService.class,jobId(<span class="number">8</span>),intent);</span><br></pre></td></tr></table></figure><br>而后会执行onHandleWork方法中的逻辑，执行完毕后自动销毁</p><h4 id="onStartCommand中三个回调分别是什么？"><a href="#onStartCommand中三个回调分别是什么？" class="headerlink" title="onStartCommand中三个回调分别是什么？"></a>onStartCommand中三个回调分别是什么？</h4><ul><li>START_NOT_STICKY：Service被回收后不做处理</li><li>START_STICKY：Service在被回收后，重新创建Service，但是<code>不保存</code>intent</li><li>START_REDELIVER_INTENT：Service在被回收后，重新创建Service，<code>保存</code>intent</li><li>START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但不保证服务被kill后一定能重启。</li></ul><h4 id="Service保活"><a href="#Service保活" class="headerlink" title="Service保活"></a>Service保活</h4><ol><li>设置成前台服务，绑定Notification， startForeground(1, getNotification());</li><li>单独设置为服务进程</li><li>onStartCommand返回START_STICKY，START_REDELIVER_INTENT，保证服务被干掉后重启</li><li>在onDestory发送一个广播，广播接收器接收广播后拉起服务</li><li>添加系统广播拉起</li><li>提升服务的优先级</li></ol><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="http://img-blog.csdnimg.cn/20190717110219153.png" width="400" height="700"/></p><h4 id="FragmentPagerAdapter和FragmentStatePagerAdapter的区别？"><a href="#FragmentPagerAdapter和FragmentStatePagerAdapter的区别？" class="headerlink" title="FragmentPagerAdapter和FragmentStatePagerAdapter的区别？"></a>FragmentPagerAdapter和FragmentStatePagerAdapter的区别？</h4><p>FragmentPagerAdapter：切换页面只是将Fragment分离，适合Fragment较少的情况不影响内存</p><p>FragmentStatePagerAdapter：切换页面将Fragment回收，适合Fragment较多的情况，这样不会消耗太多内存资源</p><h4 id="Fragment的3种切换方式"><a href="#Fragment的3种切换方式" class="headerlink" title="Fragment的3种切换方式"></a>Fragment的3种切换方式</h4><ol><li>add方法：只是重新回到fragment</li><li>replace方法：每次都会重新构建fragment</li></ol><h4 id="为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？"><a href="#为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？" class="headerlink" title="为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？"></a>为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？</h4><p>Fragment在异常崩溃后重建时，默认会调用Fragment无参构造，这样会导致Fragment中的有参构造的值不会被执行，这样数据就会异常</p><p>Fragment中调用setArguments来传递参数，在Activity构造Fragment时会通过反射午餐构造实例化一个新的Fragment，并且给mArguments初始化为原先的值</p><h4 id="Fragment的重建在那个生命周期中？"><a href="#Fragment的重建在那个生命周期中？" class="headerlink" title="Fragment的重建在那个生命周期中？"></a>Fragment的重建在那个生命周期中？</h4><p>在FragmentActivity的onSaveInstanceState中做存储，将Framgent通过序列化Parcelable进行存储，在Activity的onCreate中进行恢复</p><p>当配置发生变化时，Activity进入销毁过程，FragmentManager先销毁队列中Fragment的视图，然后检查每个Fragment的retainInstance属性。如果retainInstance为false，FragmentManager会销毁该Fragment实例；如果retainInstance为true，则不会销毁该Fragment实例，Activity重建后，新的FragmentManager会找到保留的Fragment并为其创建视图。</p><h2 id="BroadCastReceiver"><a href="#BroadCastReceiver" class="headerlink" title="BroadCastReceiver"></a>BroadCastReceiver</h2><h4 id="简述广播的启动方式和区别"><a href="#简述广播的启动方式和区别" class="headerlink" title="简述广播的启动方式和区别"></a>简述广播的启动方式和区别</h4><ul><li>静态注册：在AndroidManifest中注册，常驻型广播</li><li>动态注册：使用intentFilter过滤广播，registerReceiver注册广播，跟随生命周期</li></ul><blockquote><p>Android8.0以上部分广播不允许静态注册</p></blockquote><h4 id="无序广播和有序广播的区别"><a href="#无序广播和有序广播的区别" class="headerlink" title="无序广播和有序广播的区别"></a>无序广播和有序广播的区别</h4><ul><li>无序广播：所有广播接收器都可以获得，不可以拦截，不可以修改</li><li>有序广播：按照优先级向下传递，可拦截广播，修改广播</li></ul><h4 id="本地广播和全局广播"><a href="#本地广播和全局广播" class="headerlink" title="本地广播和全局广播"></a>本地广播和全局广播</h4><p>本地广播接收器只接收本地广播，减少应用外广播干扰，高效<br>androidx中1.1.0-alpha01中弃用本地广播，官方推荐该用LiveData或响应式流</p><h2 id="IPC机制"><a href="#IPC机制" class="headerlink" title="IPC机制"></a>IPC机制</h2><h4 id="简述android中的IPC机制"><a href="#简述android中的IPC机制" class="headerlink" title="简述android中的IPC机制"></a>简述android中的IPC机制</h4><p>进程间通信</p><p>架构：Client/Server架构，Binder机制，之间通过代理接口通信</p><p>client，server，serverManager</p><p>AndroidManifest中指定Android:process属性</p><ul><li>包名:remote为应用私有进程，其他应用不可访问</li><li>包名.remote为全局进程，其他应好通过ShareUID可以和他跑在同一个进程</li></ul><p>多进程带来的问题：四大组件共享数据失败，每个进程会单独开辟内存空间存储信息</p><ol><li>静态成员和单例模式完全失效</li><li>线程同步机制完全失效</li><li>SharedPreferences可靠性下降，不支持多进程</li><li>Application会多次创建</li></ol><h4 id="Serializable和parcelable区别"><a href="#Serializable和parcelable区别" class="headerlink" title="Serializable和parcelable区别"></a>Serializable和parcelable区别</h4><p>serializable:java自带，反射后产生大量临时变量，容易引起gc，主要用于持久化存储和网络传输的序列化</p><p>parcelable:android专用，性能强，将完整对象分解为部分对象，每一部分进行intent传输，可用于ipc，内部实现Bundle，主要用于内存的序列化</p><h4 id="Android为什么引入Parcelable？"><a href="#Android为什么引入Parcelable？" class="headerlink" title="Android为什么引入Parcelable？"></a>Android为什么引入Parcelable？</h4><ol><li>serializable通过反射，性能不好，</li><li>serializable反射产生大量临时变量，容易gc，导致内存抖动</li><li>serializable使用了大量的IO操作，也影响了耗时</li></ol><p>parcelable使用复杂，但高效，适用于内存序列化</p><h4 id="Parcelable一定比Serializable快吗？"><a href="#Parcelable一定比Serializable快吗？" class="headerlink" title="Parcelable一定比Serializable快吗？"></a>Parcelable一定比Serializable快吗？</h4><p>单论内存中的传输速度，Parcelable一定快于Serializable，但是Parcelable没有缓存的概念<br>Serializable存在缓存，会将解析过的内容放置在HandleTable，下次解析到同一类型的对象时就可以直接复用</p><h4 id="为什么java使用Serializable序列化对象，而不是json或者xml？"><a href="#为什么java使用Serializable序列化对象，而不是json或者xml？" class="headerlink" title="为什么java使用Serializable序列化对象，而不是json或者xml？"></a>为什么java使用Serializable序列化对象，而不是json或者xml？</h4><p>因为历史遗留问题，在json和xml出来之前，java已经设计了Serializable，对于Java的庞大体系，并不容易修改这个问题。java官方文档也推荐使用json库，因为他简单、易读、高效</p><h4 id="简析Binder机制"><a href="#简析Binder机制" class="headerlink" title="简析Binder机制"></a>简析Binder机制</h4><blockquote><p>在Android通信中并不是所有的进程通信都使用Binder，当fork()进程时，使用的是Socket()通信，因为fork不允许多线程，Binder是多线程模式，所以不被允许</p></blockquote><h4 id="进程空间划分"><a href="#进程空间划分" class="headerlink" title="进程空间划分"></a>进程空间划分</h4><p>一个进程空间分为<strong>用户空间</strong>和<strong>内核空间</strong></p><p>用户空间：数据独享，其他进程无法访问</p><p>内核空间：数据共享，其他进程可以访问</p><blockquote><p>所有的进程共用1个内核空间</p></blockquote><h4 id="如何看待ServiceManager？"><a href="#如何看待ServiceManager？" class="headerlink" title="如何看待ServiceManager？"></a>如何看待ServiceManager？</h4><p>ServiceManager管理系统中所有的服务，服务需要使用时都要在ServiceManager中进行注册，他的存在类似于DNS，提供client访问某一个服务的查询。</p><h4 id="Binder原理"><a href="#Binder原理" class="headerlink" title="Binder原理"></a>Binder原理</h4><p>binder驱动属于进程中的内核空间，即共享空间，在client发起请求时，需要将数据从用户空间拷贝到内核空间，binder通过传输内核空间中数据存储的引用映射给服务端，供服务端调用，服务端处理后，将返回值放在内核空间，通过binder传递引用映射给客户端进行处理</p><p><img src="/imageMd/binder-1.webp" alt="img"></p><h5 id="简述通信流程"><a href="#简述通信流程" class="headerlink" title="简述通信流程"></a>简述通信流程</h5><p>总体通信流程就是：</p><ul><li>客户端通过代理对象向服务器发送请求。</li><li>代理对象通过Binder驱动发送到服务器进程</li><li>服务器进程处理请求，并通过Binder驱动返回处理结果给代理对象</li><li>代理对象将结果返回给客户端。</li></ul><h5 id="详细的通信过程"><a href="#详细的通信过程" class="headerlink" title="详细的通信过程"></a>详细的通信过程</h5><ul><li>服务端跨进程的类都要继承Binder类，所以也就是服务端对应的Binder实体。这个类并不是实际真实的远程Binder对象，而是一个Binder引用(即服务端的类引用)，会在Binder驱动里还要做一次映射。</li><li>客户端要调用远程对象函数时，只需把数据写入到Parcel，在调用所持有的Binder引用的transact()函数</li><li>transact函数执行过程中会把参数、标识符（标记远程对象及其函数）等数据放入到Client的共享内存，Binder驱动从Client的共享内存中读取数据，根据这些数据找到对应的远程进程的共享内存。</li><li>然后把数据拷贝到远程进程的共享内存中，并通知远程进程执行onTransact()函数，这个函数也是属于Binder类。</li><li>远程进程Binder对象执行完成后，将得到的写入自己的共享内存中，Binder驱动再将远程进程的共享内存数据拷贝到客户端的共享内存，并唤醒客户端线程。</li></ul><p>通过Binder将客户端，服务端的共享内存中的数据进行读写，放入对方的共享内存中，并通知。</p><h5 id="Binder在Android中的应用？"><a href="#Binder在Android中的应用？" class="headerlink" title="Binder在Android中的应用？"></a>Binder在Android中的应用？</h5><ul><li><strong>系统服务及四大组件的启动调用工作</strong>：系统服务是通过getSystemService获取的服务，内部也就是通过ServiceManager。例如四大组件的启动调度等工作，就是通过Binder机制传递给ActivityManagerService，再反馈给Zygote。而我们自己平时应用中获取服务也是通过getSystemService(getApplication().WINDOW_SERVICE)代码获取。</li><li>AIDL（Android Interface definition language）。例如我们定义一个IServer.aidl文件，aidl工具会自动生成一个IServer.java的java接口类（包含Stub，Proxy等内部类）。</li><li>前台进程通过bindService绑定后台服务进程时，onServiceConnected(ComponentName name, IBinder service)传回IBinder对象，并且可以通过IServer.Stub.asInterface(service)获取IServer的内部类Proxy的对象，其实现了IServer接口。</li></ul><h4 id="为什么选择Binder机制？他的优势是什么？"><a href="#为什么选择Binder机制？他的优势是什么？" class="headerlink" title="为什么选择Binder机制？他的优势是什么？"></a>为什么选择Binder机制？他的优势是什么？</h4><ol><li>性能高，效率高：<br>传统的IPC（socket，管道，消息队列）需要拷贝两次内存，Binder只需要拷贝一次内存、共享内存不需要拷贝数据，只需要传递引用</li><li>安全性好：<br>C/S通信添加UID/PID，方便验证，安全机制完善。</li><li>利用C/S架构，通过多线程控制一个服务端多个客户端的情况</li></ol><h4 id="Android中IPC的几种方式详细分析与优缺点分析"><a href="#Android中IPC的几种方式详细分析与优缺点分析" class="headerlink" title="Android中IPC的几种方式详细分析与优缺点分析"></a>Android中IPC的几种方式详细分析与优缺点分析</h4><ol><li>Bundle</li><li>文件共享</li><li>Messenger：内部实现AIDL机制，c/s架构，通过handler接收message对象</li><li>AIDL</li><li>ContentProvider</li><li>Binder连接池</li></ol><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><a href="https://www.jianshu.com/p/43bb31d8a742">Android Handler机制之总目录</a></p><p><a href="https://blog.csdn.net/songzi1228/article/details/82835982">Android面试题：Handler</a></p><blockquote><p>其实并不是每一次添加消息时，都会唤醒线程。当该消息插入到队列头时，会唤醒该线程；如果有延迟消息，插入到头部，也会唤醒线程后在休眠</p></blockquote><h4 id="一句话概括Handler，并简述其原理"><a href="#一句话概括Handler，并简述其原理" class="headerlink" title="一句话概括Handler，并简述其原理"></a>一句话概括Handler，并简述其原理</h4><p>android中用于主线程和子线程之间通信的工具</p><p>主要包含Handler,Looper,MessageQueue,ThreadLocal.</p><p><strong>Handler</strong>：封装了消息的发送和接收looper分发过来的Message</p><p><strong>Looper</strong>：协调Handler和MessageQueue之间的桥梁，Looper的作用是循环从MessageQueue中取出message，并分发</p><p>给相应的Handler，Handler则存储在Message中的target中</p><p><strong>message</strong>：单节点，存储handler传输的数据</p><p><strong>MessageQueue</strong>：内部结构为单链表，由Looper创建，具体代码为Looper.prepare()；先进先出原则(队列)，根据                                Message.when进行插入队列（队列中是按时间执行顺序排序）</p><p><strong>ThreadLocal</strong>：负责存储和获取本线程的Looper</p><p>handler.sendMessage(message)将message发送到MessageQueue，MessageQueue执行enqueueMessage()方法入队，Looper执行looper.loop()方法从MessageQueue中取出message，执行message.target.dispatchMessage(message)方法将消息发送到Handler中，在handleMessage()方法中拿到回调</p><h4 id="Looper-loop-是在主线程的死循环，为什么没有造成线程阻塞？"><a href="#Looper-loop-是在主线程的死循环，为什么没有造成线程阻塞？" class="headerlink" title="Looper.loop()是在主线程的死循环，为什么没有造成线程阻塞？"></a>Looper.loop()是在主线程的死循环，为什么没有造成线程阻塞？</h4><p>真正的ANR是在生命周期的回调中等待的时间过长导致的，深层次的讲，就是Looper.loop()没有及时取出消息进行分发导致的。一旦没有消息，Linux的epoll机制则会通过管道写<strong>文件描述符</strong>的方式来对主线程进行唤醒与沉睡，Android里调用了linux层的代码实现在适当时会睡眠主线程。</p><p>MessageQueue包含jni调用，无消息时，通知epoll休眠，来消息时，线程启动</p><h4 id="looper-loop-中循环，判空退出怎么理解？"><a href="#looper-loop-中循环，判空退出怎么理解？" class="headerlink" title="looper.loop()中循环，判空退出怎么理解？"></a>looper.loop()中循环，判空退出怎么理解？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ....</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Message msg = queue.next(); <span class="comment">// might block（可能会阻塞）</span></span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>在queue.next中，会通过jni调用，通过Linux的epoll机制则会通过管道写文件描述符的方式来对主线程进行唤醒与沉睡，只有当应用程序退出时，才会执行if语句退出循环。</p><h4 id="为什么不能在子线程更新UI？"><a href="#为什么不能在子线程更新UI？" class="headerlink" title="为什么不能在子线程更新UI？"></a>为什么不能在子线程更新UI？</h4><p>因为如果要在子线程中更新UI，势必要考虑线程安全，加锁机制，这样很耗时，不加锁又很容易发生错误，这些错误是致命的，所以在设计时只允许UI线程更新UI，避免这些错误。</p><h4 id="真的不能在子线程更新UI吗？"><a href="#真的不能在子线程更新UI吗？" class="headerlink" title="真的不能在子线程更新UI吗？"></a>真的不能在子线程更新UI吗？</h4><p>ViewRootImpl中会进行通过checkThread()进行线程检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                    <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由此得出：viewRootImpl在那个线程被初始化，就会在那个线程更新UI，大部分情况下，ViewRootImpl都是在UI线程中初始化的，所以只能在UI线程更新UI，部分情况下可以在子线程更新UI（比如Dialog是在addView中初始化ViewRootImpl）</p><p>SurfaceView可以在子线程中更新</p><h4 id="ViewRootImpl是什么时候被创建的？"><a href="#ViewRootImpl是什么时候被创建的？" class="headerlink" title="ViewRootImpl是什么时候被创建的？"></a>ViewRootImpl是什么时候被创建的？</h4><p>在Acitivty中，ViewRootImpl是在<strong>onResume</strong>中创建的，所以在onCreate中进行子线程更新是可以绕过checkThread()检测的。</p><h4 id="一个Thread中可以有几个Looper-几个Handler"><a href="#一个Thread中可以有几个Looper-几个Handler" class="headerlink" title="一个Thread中可以有几个Looper?几个Handler"></a>一个Thread中可以有几个Looper?几个Handler</h4><p>一个Thread中只有一个Looper，可以存在无数个Handler，但是使用MessageQueue都是同一个，也就是一个Looper</p><h4 id="可以在子线程直接new一个Handler吗？那该怎么做？"><a href="#可以在子线程直接new一个Handler吗？那该怎么做？" class="headerlink" title="可以在子线程直接new一个Handler吗？那该怎么做？"></a>可以在子线程直接new一个Handler吗？那该怎么做？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thread= new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                //创建Looper，Looper再创建MessageQueue</span><br><span class="line">                Looper.prepare();</span><br><span class="line">                //新建Handler</span><br><span class="line">                handler=new Handler();</span><br><span class="line">                //循环取出消息并执行</span><br><span class="line">                Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br></pre></td></tr></table></figure><p>需要创建Looper，Looper会创建MessageQueue，循环从MessageQueue中取消息。</p><h4 id="Message可以如何创建？哪种效果更好，为什么？"><a href="#Message可以如何创建？哪种效果更好，为什么？" class="headerlink" title="Message可以如何创建？哪种效果更好，为什么？"></a>Message可以如何创建？哪种效果更好，为什么？</h4><p><strong>享元模式</strong></p><p>数据重复利用</p><ol><li>Message msg = new Message();</li><li>Message msg2 = Message.obtain();</li><li>Message msg1 = handler1.obtainMessage();</li></ol><p>2，3从整个Messge池中返回一个新的Message实例，通过obtainMessage能避免重复Message创建对象。</p><p>所以2，3都可以避免重复创建Message对象，所以建议用第二种或者第三种任何一个创建Message对象。</p><p>messge就是一个节点，存在就是一条链表，链表中存储的都是可以复用的message，在handleMessage和callback</p><p>方法执行完成后执行message.recycle()方法，进行信息重置后加入闲置链表头部中，每次调用obtain方法会从闲置链表中取出头节点，如果闲置链表为空，则新建message。</p><blockquote><p>Message缓存池大小为50</p></blockquote><h4 id="使用Hanlder的postDelay-后消息队列会发生什么变化？"><a href="#使用Hanlder的postDelay-后消息队列会发生什么变化？" class="headerlink" title="使用Hanlder的postDelay()后消息队列会发生什么变化？"></a>使用Hanlder的postDelay()后消息队列会发生什么变化？</h4><p>postDelay()内部调用sendMessageDelayed()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间：<strong>SystemClock.uptimeMillis() + delayMillis</strong></p><p>SystemClock.uptimeMills()是<strong>从开机到现在</strong>的时间，不使用currentMills，因为其是可变的，uptimeMills()期间不包括休眠的时间，是一个相对时间</p><ol><li>Handler.postDelayed(Runnable r, long delayMillis)</li><li>Handler.sendMessageDelayed(getPostMessage(r), delayMillis)</li><li>Handler.sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)</li><li>Handler.enqueueMessage(queue, msg, uptimeMillis)</li><li>MessageQueue.enqueueMessage(msg, uptimeMillis)</li></ol><blockquote><p>消息入队的时候会根据when判断时间，最终按照时间大小排序，时间短的在链表头，时间长的在链表尾部。</p></blockquote><p>案例如下：</p><ol><li><code>postDelay()</code>一个10秒钟的Runnable A、消息进队，MessageQueue调用<code>nativePollOnce()</code>阻塞，Looper阻塞；</li><li>紧接着<code>post()</code>一个Runnable B、消息进队，判断现在A时间还没到、正在阻塞，把B插入消息队列的头部（A的前面），然后调用<code>nativeWake()</code>方法唤醒线程；</li><li><code>MessageQueue.next()</code>方法被唤醒后，重新开始读取消息链表，第一个消息B无延时，直接返回给Looper；</li><li>Looper处理完这个消息再次调用<code>next()</code>方法，MessageQueue继续读取消息链表，第二个消息A还没到时间，计算一下剩余时间（假如还剩9秒）继续调用<code>nativePollOnce()</code>阻塞；</li><li>直到阻塞时间到或者下一次有Message进队；</li></ol><h4 id="同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？"><a href="#同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？" class="headerlink" title="同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？"></a>同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？</h4><p>同步消息：handler默认无参构造的形式是同步消息</p><p>异步消息：async传入true，则为异步消息</p><p>屏障消息：<code>msg.target == null</code>，使用postSyncBarrier()方法打开同步屏障，导致同步消息不执行，优先执行异步消息，规则同同步消息一样，当执行完毕后关闭同步屏障。</p><p>应用场景：在view的更新过程中，draw，requestLayout、invalidate中都用到这个方法，系统会优先处理这些异步消息，等处理结束后再处理同步消息。这样可以优先处理我们指定的系统消息。</p><blockquote><p>postSyncBarrier()该方法为私有方法，所以api不允许我们在开发中调用，我们只要知道原理就好了</p><p>调用该方法，会直接发送一个屏障消息进入messageQueue，则队列头部为屏障消息</p></blockquote><h4 id="ThreadLocal，谈谈你的理解"><a href="#ThreadLocal，谈谈你的理解" class="headerlink" title="ThreadLocal，谈谈你的理解"></a>ThreadLocal，谈谈你的理解</h4><p>跟HashMap功能类似，为什么不直接用HashMap呢？<br>原因：</p><ol><li>HashMap太大了，太臃肿了。ThreadLocal的key值只有Thread，value为looper，而HashMap的key值则可以<br>是string、int等数据类型，我们可以不用考虑这些数据类型;</li><li>线程隔离：我们的线程是系统中唯一的，用ThreadLocal来管理这些唯一的线程和其对应的value值会非常方便，</li><li>ThreadLocal参照了HashMap,简化了HashMap,便于我们使用。</li><li>HashMap线程不安全</li></ol><p><a href="#ThreadLocal的理解">ThreadLocal的理解</a></p><h4 id="为什么子线程中不能使用Handler，而UI线程可以？"><a href="#为什么子线程中不能使用Handler，而UI线程可以？" class="headerlink" title="为什么子线程中不能使用Handler，而UI线程可以？"></a>为什么子线程中不能使用Handler，而UI线程可以？</h4><p>UI线程就是ActivityThread，他在初始化的时候创建了Looper,MessageQueue，所以可以直接使用Handler，而新创建的子线程没有创建Looper，所以创建了就可以使用了</p><p>Handler的构造方法中使用Looper.myLooper()获取了looper，但是在子线程中并没有looper</p><h4 id="Handler如何引起内存泄露？怎么解决？"><a href="#Handler如何引起内存泄露？怎么解决？" class="headerlink" title="Handler如何引起内存泄露？怎么解决？"></a>Handler如何引起内存泄露？怎么解决？</h4><p>非静态内部类或匿名内部类默认持有外部类的引用，当外部类被回收时，因为内部类持有外部类的引用，导致外部类不能被回收，造成内存泄露。</p><ol><li>Activity销毁时及时清理消息队列；</li><li>自定义静态Handler类+弱引用。</li></ol><h4 id="MessageQueue-next-会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？"><a href="#MessageQueue-next-会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？" class="headerlink" title="MessageQueue.next()会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？"></a>MessageQueue.next()会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？</h4><p>首先非延时消息会入队，并且插入链表头，这时唤醒线程，进行循环取出message，非延时消息出队，到延迟消息后，如果事件未到，触发next的阻塞机制，如果时间到了，取出message，执行消息</p><h4 id="Handler延时机制保时吗？"><a href="#Handler延时机制保时吗？" class="headerlink" title="Handler延时机制保时吗？"></a>Handler延时机制保时吗？</h4><p><code>不保时</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">chatIflyHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       chatIflyHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               Log.e(<span class="string">&quot;handler&quot;</span>,<span class="string">&quot;执行延时1s操作&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>首先一个非延时消息入队，紧接着一个延时消息入队，执行第一个非延时消息，用时3s后执行延时消息，对比when，然后直接执行，测试总共耗时3420ms</p><h4 id="Handler的入队机制是线程安全的（synchronized）"><a href="#Handler的入队机制是线程安全的（synchronized）" class="headerlink" title="Handler的入队机制是线程安全的（synchronized）"></a>Handler的入队机制是线程安全的（synchronized）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">messageQueue.equeue()&#123;</span><br><span class="line">    synchronized(this)&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何精确计时？"><a href="#如何精确计时？" class="headerlink" title="如何精确计时？"></a>如何精确计时？</h4><ul><li><p>使用timer（子线程处理TimerThread）</p></li><li><p>误差补偿算法(TextClock控件方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mTicker = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            onTimeChanged();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">long</span> next = now + (<span class="number">1000</span> - now % <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            getHandler().postAtTime(mTicker, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>整秒数执行，当上次执行累积到1200，在下次执行时，通过next的计算后保证下次执行的时间不被累加到2200，而是同样在2000</p></li></ul><h4 id="IdleHandler是什么？用处是什么？"><a href="#IdleHandler是什么？用处是什么？" class="headerlink" title="IdleHandler是什么？用处是什么？"></a>IdleHandler是什么？用处是什么？</h4><p>messageQueue中有一个addIdleHandler()方法，添加IdleHandler接口</p><ul><li>添加时messageQueue不为空，则在线程休眠（没有消息，延时消息）时回掉方法</li><li>添加时messageQueue为空，则当时不会触发回掉，当线程被唤醒时才会执行</li></ul><blockquote><p>就是在启用IdleHandler的时候，如果线程处于休眠状态，要等到下次休眠状态才会生效。如果不是休眠状态，则下一次休眠立即生效。</p></blockquote><blockquote><p>启用IdleHandler后，主线程下次休眠时会通知<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">//do something</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></blockquote><p>如果return <strong>true</strong>，则表示这个IdleHandler可多次使用<br>如果return <strong>false</strong>，则表示这个IdleHandler只能使用一次</p><h4 id="主线程的Looper何时退出？能否手动退出？"><a href="#主线程的Looper何时退出？能否手动退出？" class="headerlink" title="主线程的Looper何时退出？能否手动退出？"></a>主线程的Looper何时退出？能否手动退出？</h4><p>在app退出或者异常终止时，会退出Looper。在正常退出时，ActivityThread主线程中的mH（Handler）会接收到回调信息，调用quit()方法，强制退出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">    <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInitialApplication.onTerminate();</span><br><span class="line">    &#125;</span><br><span class="line">    Looper.myLooper().quit();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><ul><li><p>Looper.quit():调用后直接终止Looper，不在处理任何Message，所有尝试把Message放进消息队列的操作都会失败，比如Handler.sendMessage()会返回 false，但是存在不安全性，因为有可能有Message还在消息队列中没来的及处理就终止Looper了。</p></li><li><p>Looper.quitSafely():调用后会在所有消息都处理后再终止Looper，所有尝试把Message放进消息队列的操作也都会失败。</p></li></ul><p>当尝试在主线程手动退出looper时，会报错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Main thread not allowed to quit.</span><br><span class="line">    at android.os.MessageQueue.quit(MessageQueue.java:<span class="number">428</span>)</span><br><span class="line">    at android.os.Looper.quit(Looper.java:<span class="number">354</span>)</span><br><span class="line">    at com.jackie.testdialog.Test2Activity.onCreate(Test2Activity.java:<span class="number">29</span>)</span><br><span class="line">    at android.app.Activity.performCreate(Activity.java:<span class="number">7802</span>)</span><br><span class="line">    at android.app.Activity.performCreate(Activity.java:<span class="number">7791</span>)</span><br><span class="line">    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:<span class="number">1299</span>)</span><br><span class="line">    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:<span class="number">3245</span>)</span><br><span class="line">    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:<span class="number">3409</span>) </span><br><span class="line">    at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:<span class="number">83</span>) </span><br><span class="line">    at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:<span class="number">135</span>) </span><br><span class="line">    at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:<span class="number">95</span>) </span><br><span class="line">    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:<span class="number">2016</span>) </span><br><span class="line">    at android.os.Handler.dispatchMessage(Handler.java:<span class="number">107</span>) </span><br><span class="line">    at android.os.Looper.loop(Looper.java:<span class="number">214</span>) </span><br><span class="line">    at android.app.ActivityThread.main(ActivityThread.java:<span class="number">7356</span>) </span><br><span class="line">    at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">    at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">492</span>) </span><br><span class="line">    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">930</span>) </span><br></pre></td></tr></table></figure></p><p>因为主线程退出意味着app的关闭，这种操作不和规范，需要使用正式的退出操作</p><h4 id="如何退出app"><a href="#如何退出app" class="headerlink" title="如何退出app"></a>如何退出app</h4><ol><li>记录Activity任务栈，全部finish</li><li>System.exit(0);//正常退出<br>System.exit(1);//非正常退出</li><li>android.os.Process.killProcess(android.os.Process.myPid()); 关闭进程，如果系统发现进程未正常关闭，会重新启动进程</li><li>在Intent中直接加入标识Intent.FLAG_ACTIVITY_CLEAR_TOP，这样开启B时，会清除该进程空间的所有Activity。</li><li><p>2.2版本之前使用ActivityManager关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager am = (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE);</span><br><span class="line">am.restartPackage(getPackageName());</span><br></pre></td></tr></table></figure><p>2.2版本以后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager am = (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE);</span><br><span class="line">am.killBackgroundProcesses(getPackageName());</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>该方法只是结束后台进程的方法，不能结束当前应用移除所有的 Activity。如果需要退出应用，需要添加System.exit(0)方法一起使用，并且只限栈内只有一个Activity，如果有多个Activity时，正如上面 方法 2 所说，就不起作用了。</p></li><li><p>将MainActivity设置为singleTask，返回MainActivity后会清空所有的Activity，这样直接在MainActivity执行finish()方法即可</p></li></ol><h4 id="如何看待sendMessageAtFrontOfQueue"><a href="#如何看待sendMessageAtFrontOfQueue" class="headerlink" title="如何看待sendMessageAtFrontOfQueue()"></a>如何看待sendMessageAtFrontOfQueue()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的延迟时间为0，头插入消息队列，即消息队列下一次立即执行的消息，</p><h5 id="如何看待Handler构造中的CallBack方法？"><a href="#如何看待Handler构造中的CallBack方法？" class="headerlink" title="如何看待Handler构造中的CallBack方法？"></a>如何看待Handler构造中的CallBack方法？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里的 callback 是 Runnable</span></span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage</span></span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可以看出构造函数中传入Callback参数，调用dispatch方法时，会优先调用callback方法，在调用handleMessage方法，即</p><blockquote><p>Callback接口可以在handleMessage前收到消息，如果返回true，则不会调用handleMessage方法</p></blockquote><p><strong>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</strong></p><h4 id="Looper-prepareMain-和Looper-perpare的区别？"><a href="#Looper-prepareMain-和Looper-perpare的区别？" class="headerlink" title="Looper.prepareMain()和Looper.perpare的区别？"></a>Looper.prepareMain()和Looper.perpare的区别？</h4><p>区别是一个boolean值，主线程的looper永不退出，除非调用</p><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><h4 id="如何理解AsyncTask？"><a href="#如何理解AsyncTask？" class="headerlink" title="如何理解AsyncTask？"></a>如何理解AsyncTask？</h4><ul><li>必须创建在主线程</li></ul><p>AscncTask内部封装了Handler+线程池</p><p>包含两个线程池，一个是用来排队的 ，一个才是真正的执行，通过Handler将状态回掉到主线程</p><ul><li>核心线程数，最少两个，最多四个</li><li>最大线程数= cpu核心数*2+1</li><li>核心线程无超时限制，非核心线程在闲置时的超时时间为1s</li><li>任务队列容量为128</li></ul><p>execute方法执行，加入排队线程池排队，等待任务执行后通过handler通知主线程，调用状态回调方法，内部实现因为排队线程池阻塞，导致任务是串行的，即同时只有一个任务会进入线程池执行</p><p>executeOnExecutor执行调用异步操作</p><h4 id="谷歌为何弃用AsyncTask"><a href="#谷歌为何弃用AsyncTask" class="headerlink" title="谷歌为何弃用AsyncTask"></a>谷歌为何弃用AsyncTask</h4><ol><li>使用多线程更加复杂，使bug难以定位</li><li>太过复杂</li><li>滥用继承，effic java推荐“使用组合而不是继承”，使类多，且低效</li><li>默认的THREAD_POOL_EXECUTOR线程池配置不太合适</li></ol><h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><p><a href="#线程">线程</a></p><h4 id="简述线程池"><a href="#简述线程池" class="headerlink" title="简述线程池"></a>简述线程池</h4><p>android中线程池主要实现是ThreadPoolExecutor</p><p>参数：</p><ul><li><strong>核心线程数</strong>：如果指定ThreadPoolExecutor的allowCoreThreadTimeOut这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间，就会被销毁掉</li><li><strong>最大线程数</strong>： = 核心线程数 + 非核心线程数</li><li><strong>超时时间</strong>：非核心线程的闲置超时时间</li><li><strong>超时时间单位</strong>：非核心线程的闲置超时时间<strong>单位</strong></li><li><strong>线程等待队列</strong>：当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务</li><li><strong>线程创建工厂</strong>：线程池的拒绝策略，可以出错，也可以顾虑</li></ul><blockquote><p>allowCoreThreadTimeOut设置为true，非核心线程超时时间同样用于核心线程，如果为false，核心线程永远不会终止</p></blockquote><ol><li><p><strong>SynchronousQueue</strong>（空集合）：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大</p></li><li><p><strong>LinkedBlockingQueue</strong>（大小无限）：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize</p></li><li><p><strong>ArrayBlockingQueue</strong>（大小可以设置）：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误</p></li><li><p><strong>DelayQueue</strong>（延迟出队，大小可以设置）：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</p></li></ol><p>规则：</p><ol><li>未达到核心线程数，新建核心线程</li><li>达到或者大于核心线程数，任务被插入任务队列等待执行</li><li>步骤2中无法插入队列（队列满了），线程数量小于线程池最大值，启动一个非核心线程执行任务</li><li>步骤3 中线程数量达到最大值，则拒绝执行此任务</li></ol><h4 id="android主要分为几种线程池？"><a href="#android主要分为几种线程池？" class="headerlink" title="android主要分为几种线程池？"></a>android主要分为几种线程池？</h4><p>四种</p><p>FixedThreadPool：全是核心线程，没有超时机制，任务队列没有大小限制</p><p>CachedThreadPool：全是非核心线程，最大为Integer.MAX_VALUE，空闲线程60s超时（60s内可以复用，60s后回收），适用于执行短时的大量任务，空闲时也不占用cpu资源</p><p>ScheduledThreadPool：核心线程固定，非核心线程为Interger.MAX_VALUE，非核心线程无超时机制（执行完就被回收），适用执行定时任务和固定周期任务</p><p>SingleThreadExecutor：只有一个核心线程，无超时机制，保证只在一个线程中执行任务</p><h4 id="线程池中一个线程崩溃会导致线程池崩溃吗？"><a href="#线程池中一个线程崩溃会导致线程池崩溃吗？" class="headerlink" title="线程池中一个线程崩溃会导致线程池崩溃吗？"></a>线程池中一个线程崩溃会导致线程池崩溃吗？</h4><p>不会，线程池存在两种方式去执行线程任务，submit和execute方式。  当发生线程崩溃时，execute下会将线程关闭，开辟新的线程，submit会返回异常，但不会关闭线程。</p><p>submit：</p><ul><li>继承自ExecutorService</li><li>不会抛出栈堆异常，通过Future.get方法获取异常信息</li><li>submit通过构造一个RunnableFuture后，执行execute方法，RunnableFuture内部使用状态管理，通过死循环判断任务执行状态，在执行完或者cancle后返回，</li></ul><blockquote><p><code>get()</code>方法是一个阻塞方法，在调用时需要注意</p></blockquote><p>execute：</p><ul><li>继承自Executor</li><li>会抛出堆栈异常信息，关闭该线程并创建新的线程</li></ul><h4 id="如何检测线程池中的崩溃问题呢？"><a href="#如何检测线程池中的崩溃问题呢？" class="headerlink" title="如何检测线程池中的崩溃问题呢？"></a>如何检测线程池中的崩溃问题呢？</h4><p>submit的get()方法可以获取崩溃，但是该方法是阻塞的，可用性不高，于是我们使用另一种方法</p><ol><li>execute+ThreadFactory.UncaughtExceptionHandler<br>在submit下UncaughtExceptionHandler失效，因为FutureTask会捕获异常并保存不会放入UncaughtExceptionHandler中</li><li>在run方法中自行捕获</li><li>重写ThreadLocalExecutor.afterExecute方法</li><li>submit+get方法</li></ol><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h4 id="触摸事件传递"><a href="#触摸事件传递" class="headerlink" title="触摸事件传递"></a>触摸事件传递</h4><p><img src="https://pic1.zhimg.com/80/v2-5fdce519c134bdb81a38e9feb31ffb2c_1440w.jpg" width="300" height="400"/></p><p>DecorView为最顶层的view，DecorView、TitleView和ContentView都为FrameLayout</p><blockquote><p>如果一个view处理了down事件，那么后续的move，up都会交给他处理</p></blockquote><h5 id="点击事件的传递流程"><a href="#点击事件的传递流程" class="headerlink" title="点击事件的传递流程"></a>点击事件的传递流程</h5><p>onTouchListener(onTouch)&gt;onTouchEvent()&gt;onClickListener(onClick)</p><p>onTouchListener的onTouch返回为false，则onTouchEvent被调用</p><h5 id="简述view的事件传递"><a href="#简述view的事件传递" class="headerlink" title="简述view的事件传递"></a>简述view的事件传递</h5><p>事件传递从父类向子类传递，其中包含3个方法，在一个类中顺序执行，</p><ul><li>dispatchEvent：事件的分发，true—-&gt;分发给自己</li><li>onIntercepterEvent：事件拦截，true—-&gt;拦截后交给自己的onTouchEvent处理，false —-&gt;传递给子View</li><li>onTouchEvent：事件的执行。</li></ul><p><img src="https://img-blog.csdnimg.cn/2018110610205215.jpg" width="50%"/></p><p>如果View没有对ACTION_DOWN进行消费，之后的事件也不会传递过来。</p><p>事件的传递是从Activity开始的，Activity –&gt;PhoneWindow–&gt;DectorView–&gt;ViewGroup–&gt;View；主要操作在ViewGroup和View中；</p><p>ViewGroup类主要调用：dispatchTouchEvent()–&gt;onInterceptTouchEnent()–&gt;dispatchTransformedTouchEvent()；<strong>ViewGroup不直接调用onTouchEvent()方法；</strong></p><table><thead><tr><th>类</th><th>相关子类</th><th>方法</th></tr></thead><tbody><tr><td>Activity类</td><td>Activity……</td><td>dispatchTouchEvent(); onTouchEvent();</td></tr><tr><td>View容器（ViewGroup的子类）</td><td>FrameLayout、LinearLayout、ListView、ScrollVIew……</td><td>dispatchTouchEvent(); onInterceptTouchEvent(); onTouchEvent();</td></tr><tr><td>View控件（非ViewGroup子类）</td><td>Button、TextView、EditText……</td><td>dispatchTouchEvent(); onTouchEvent();</td></tr></tbody></table><blockquote><p>onIntercepterTouchEvent()方法之只存在ViewGroup中，Activity为最顶层，不需要拦截，直接分发，view为最底层，不需要拦截，直接分发</p></blockquote><ul><li>以ACTION_DOWN为开始，UP或者CANCEL为结束</li><li>如果dispatch不处理ACTION_DOWN事件，那么就不会继续接收到后续的ACTION_xxxx事件</li></ul><h5 id="如何让只执行onTouch事件，不执行onClick事件？"><a href="#如何让只执行onTouch事件，不执行onClick事件？" class="headerlink" title="如何让只执行onTouch事件，不执行onClick事件？"></a>如何让只执行onTouch事件，不执行onClick事件？</h5><p>将onTouch方法的返回值改为true，就会只执行onTouch事件，不执行onClick事件。</p><h5 id="如果截取了事件，还会往下传吗？那会走到哪里？"><a href="#如果截取了事件，还会往下传吗？那会走到哪里？" class="headerlink" title="如果截取了事件，还会往下传吗？那会走到哪里？"></a>如果截取了事件，还会往下传吗？那会走到哪里？</h5><p>如果截取了事件就不会往下传递了，只会执行本Viewgroup的onTouchEvent。</p><h5 id="如果截取了事件并处理了事件还会返回父级吗？"><a href="#如果截取了事件并处理了事件还会返回父级吗？" class="headerlink" title="如果截取了事件并处理了事件还会返回父级吗？"></a>如果截取了事件并处理了事件还会返回父级吗？</h5><p>会返回父类，因为父类需要确认子级是否已经处理了事件</p><h5 id="requestDisallowInterceptTouchEvent"><a href="#requestDisallowInterceptTouchEvent" class="headerlink" title="requestDisallowInterceptTouchEvent"></a>requestDisallowInterceptTouchEvent</h5><p>子view让其父view不做事件拦截，<br>在子view的onTouchEvent方法中调用parent.requestDisallowInterceptTouchEvent(true)方法，</p><p>如果父view拦截事件，是怎么通知到子view的onInterceptTouchEvent中调用disallowIntercepter？</p><p>在ScrollView中进行源码分析：<br>在onIntercepterTouchEvent中返回true，则进行拦截，在按下滑动一小部分距离后设置为false（ACTION_MOVE），可以进行事件传递，当然就可以调用disallowIntercepter方法进行处理，后续的值触发父view的机制，直接过滤掉了onIntercepterTouchEvent</p><p>所以在ScrollView中默认的onClickListener是不生效的</p><p>onIntercepterTouchEvent不执行，直接返回false，然后向下dispatch到子类</p><blockquote><p>该方法生效的前提是父view不拦截ACTION_DOWN事件，第一次的ACTION_DOWN事件可以传递到子view中，则后续的ACTION事件父view无法拦截</p></blockquote><h5 id="如何解决滑动冲突"><a href="#如何解决滑动冲突" class="headerlink" title="如何解决滑动冲突"></a>如何解决滑动冲突</h5><ol><li><p>外部拦截法：</p><p>重写父view的onIntercepterTouchEvent，在其中对触摸的坐标进行控制，在父view要拦截的时候拦截，在子view想要调用的时候不进行拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (满足父容器的拦截要求) &#123;</span><br><span class="line">                    intercepted = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastXIntercept = x;</span><br><span class="line">        mLastYIntercept = y;</span><br><span class="line">        <span class="keyword">return</span> intercepted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>内部拦截法：</p><p>在子view的dispatchTouchEvent中在ACTION_DOWN事件下调用parent.requestDisallowInterceptTouchEvent(true);，设置不允许父view的拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">                <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">                <span class="keyword">if</span> (父容器需要此类点击事件) &#123;</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLastX = x;</span><br><span class="line">        mLastY = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该条件需要在父view的ACTION_DOWN事件可以传递到子view中才可以实现，所以需要在父view的onInterceptTouchEvent中不拦截父View的ACTION_DOWN事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="ACTION-CANCEL怎么理解？"><a href="#ACTION-CANCEL怎么理解？" class="headerlink" title="ACTION_CANCEL怎么理解？"></a>ACTION_CANCEL怎么理解？</h5><ul><li>在划出子view的布局后，onIntercepterTouchEvent进行拦截ACTION_MOVE事件，并将其转化为ACTION_CANCEL交给子view的处理，表示手指划出view所在区域</li><li>在父view进行拦截的时候，子view有可能接收到ACTION_CANCEL事件</li></ul><p>触摸事件的结束有两种状态，一种时ACTION_UP事件，另一种就是ACTION_CANCEL事件，正常在view的事件传递中，抬起手指的ACTION_UP事件会被监听，当父view认为不需要将后续的ACTION_MOVE事件传递给子View的时候，就会将ACTION_MOVE事件转化为ACTION_CANCEL事件，子View就会认为事件结束</p><blockquote><p>主要是父view在拦截中做了处理影响子view的触摸，不需要触摸就直接传ACTION_CANCEL。</p></blockquote><p><strong>使用TouchTarget（具体实现时mFirstTouchTarget）单链表存储触摸事件的，当置为CANCLE时，将触摸view在mFirstTouchEvent删除</strong></p><h5 id="事件到底是先到DecorView还是先到Window的？"><a href="#事件到底是先到DecorView还是先到Window的？" class="headerlink" title="事件到底是先到DecorView还是先到Window的？"></a>事件到底是先到DecorView还是先到Window的？</h5><p>ViewRootImpl——&gt;DecorView——&gt;Activity——&gt;PhoneWindow——&gt;DecorView——&gt;ViewGroup</p><p>为什么绕来绕去的呢，光DecorView就走了两遍。</p><ul><li>ViewRootImpl并不知道有Activity这种东西存在，它只是持有了DecorView。所以先传给了DecorView，而DecorView知道有Activity，所以传给了Activity。</li><li>Activity也不知道有DecorView，它只是持有PhoneWindow，所以这么一段调用链就形成了。</li></ul><h4 id="多点触控-非重点"><a href="#多点触控-非重点" class="headerlink" title="多点触控(非重点)"></a>多点触控(非重点)</h4><p>使用TouchTarge（mFirstTouchTarget）管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchTarget</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The touched child view.</span></span><br><span class="line">        <span class="keyword">public</span> View child;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> pointerIdBits;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The next target in the target list.</span></span><br><span class="line">        <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>view：触摸目标view</li><li>pointerIdBits：位运算（与、或）</li><li>next：链表指针</li></ul><p>第一个触摸目标，在ACTION_DOWN、ACTION_POINTER_DOWN时会触发寻找触摸目标过程（事件分发），所以DOWN事件会重置mFirstTouchTarget。</p><ul><li>单点触控，mFirstTouchEvent为单个对象</li><li>多点触控，在一个view上，也是单个对象</li><li>多点触控，在多个view上，会成为一个链表</li></ul><p>传入的view消耗了事件，则构建一个TouchTarget，并发至在mFirstTouchTarget的头部。多个view目标会头插在链表中。</p><blockquote><p>即便是多指触控，也都是使用ACTION_MOVE，不做区分，可以使用index获取</p></blockquote><h4 id="如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？"><a href="#如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？" class="headerlink" title="如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？"></a>如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？</h4><p>当使用纵向滑动，默认事件传递是viewPager到RecyclerView，即后续的所有事件都由RecyclerView进行处理，那么RecycleView没有横向事件，所以不会做处理，所以不会出现横向的滑动。</p><h4 id="View的加载流程"><a href="#View的加载流程" class="headerlink" title="View的加载流程"></a>View的加载流程</h4><h5 id="简述View的加载流程"><a href="#简述View的加载流程" class="headerlink" title="简述View的加载流程"></a>简述View的加载流程</h5><ol><li>通过Activity的setContentView方法间接调用Phonewindow的setContentView（），在PhoneWindow中通过getLayoutInflate（）得到LayoutInflate对象</li><li>通过LayoutInflate对象去加载View，主要步骤是</li></ol><p>（1）通过xml的Pull方式去解析xml布局文件，获取xml信息，并保存缓存信息，因为这些数据是静态不变的</p><p>（2）根据xml的tag标签通过反射创建View逐层构建View</p><p>（3）递归构建其中的子View，并将子View添加到父ViewGroup中</p><p>加载结束后就开始绘制view了</p><h4 id="View的绘制机制"><a href="#View的绘制机制" class="headerlink" title="View的绘制机制"></a>View的绘制机制</h4><p><img src="https://pic1.zhimg.com/80/v2-5fdce519c134bdb81a38e9feb31ffb2c_1440w.jpg" width="300"/></p><p>DecorView为最顶层的view，DecorView、TitleView和ContentView都为FrameLayout，</p><blockquote><p>当Activity对象被创建完毕后，会将DecorView添加到PhoneWindow中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，view的绘制过程是由ViewRootImpl完成的。</p></blockquote><p><strong>所有的view都是依附在window上的，比如PopupWindow、菜单。</strong></p><blockquote><p>Window是个概念性的东西，你看不到他，如果你能感知它的存在，那么就是通过View，所以View是Window的存在形式，有了View，你才感知到View外层有一个皇帝的新衣——window</p></blockquote><p><strong>有视图的地方就有window</strong></p><h5 id="简述View的绘制流程"><a href="#简述View的绘制流程" class="headerlink" title="简述View的绘制流程"></a>简述View的绘制流程</h5><p><strong>深度便利</strong><br>主要分为3个方法，顺序执行：</p><ul><li>measure()：测量视图的大小，根据MeasureSpec进行计算大小</li><li>layout()：确定view的位置</li><li>draw()：绘制view。创建Canvas对象。六个步骤：①、绘制视图的背景；②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用；⑤、还原图层（Layer）；⑥、绘制滚动条。</li></ul><h4 id="draw-中的具体流程是什么？"><a href="#draw-中的具体流程是什么？" class="headerlink" title="draw()中的具体流程是什么？"></a>draw()中的具体流程是什么？</h4><ol><li>绘制背景：drawBackground(canvas)</li><li>绘制自己的内容：onDraw(canvas)</li><li>绘制Children：dispatchDraw(canvas)</li><li>绘制装饰：onDrawForeground(canvas)</li></ol><h5 id="MeasureSpec分析"><a href="#MeasureSpec分析" class="headerlink" title="MeasureSpec分析"></a>MeasureSpec分析</h5><p>MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求，子view依据该值进行大小的绘制</p><p>MeasureSpec是个大小和模式的组合值。是一个32位的整型，将size（大小）和mode（模式）打包成一个int，其中高两位是mode，其余30位存储size（大小）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取测量模式</span></span><br><span class="line"><span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取测量大小</span></span><br><span class="line"><span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Mode 和 Size 生成新的SpecMode</span></span><br><span class="line"><span class="keyword">int</span> measureSpec=MeasureSpec.makeMeasureSpec(size, mode);</span><br></pre></td></tr></table></figure><br>测量模式有三种：</p><ul><li>EXACTLY: 相等于MATCH_CONTENT</li><li>AT_MOST: 相等于WRAP_CONTENT</li><li>UNSPECIFIED: 相等于具体的值</li></ul><h4 id="RelativeLayout、LinearLayout和ConstraintLayout"><a href="#RelativeLayout、LinearLayout和ConstraintLayout" class="headerlink" title="RelativeLayout、LinearLayout和ConstraintLayout"></a>RelativeLayout、LinearLayout和ConstraintLayout</h4><p>LinearLayout：</p><ul><li>weight设置导致二次测量，首先测量一遍大小onMeasure（非weight），然后根据weight在次测量，调整大小</li></ul><p>RelativeLayout：</p><ul><li>onMeasure执行两遍，对横向和纵向分别测量，所以是2遍</li></ul><p>ConstraintLayout：</p><ul><li>可以不使用嵌套，提供相对布局，并且支持权重布局，尽可能减少层级，提高性能，类似于flex布局</li></ul><p>对比</p><ol><li>同层级的布局，LinearLayout&lt;RelatvieLayout=ConstraintLayout，因为LinearLayout执行onMeasure一遍，RelativeLayout执行两遍</li><li>LinearLayout会增加层级深度，RelativeLayout减少层级，所以通常下使用RelativeLayout，如果层级简单则使用LinearLayout</li></ol><blockquote><p>RelativeLayout的子View如果高度和RelativeLayout不同，会引发效率问题</p></blockquote><h4 id="setContentView的执行过程"><a href="#setContentView的执行过程" class="headerlink" title="setContentView的执行过程"></a>setContentView的执行过程</h4><ol><li>初始化windows</li><li>绑定ui布局</li></ol><h4 id="什么时候可以获得view的宽高"><a href="#什么时候可以获得view的宽高" class="headerlink" title="什么时候可以获得view的宽高"></a>什么时候可以获得view的宽高</h4><p>因为onMeasure和生命周期不同步，所以不能在onCreate，onStart，onResume中进行获取操作，</p><ol><li>在view.post方法中进行获取，内部实现是handler机制，回调的时候已经执行完了</li><li>在onWindowFocusChanged获取焦点后，view的绘制完成，可以在这里拿到view的宽高</li><li>使用ViewTreeObserver的回调也可以解决这个问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ViewTreeObserver observer = tv1.getViewTreeObserver();</span><br><span class="line">        observer.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</span><br><span class="line">                    tv1.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> width = tv1.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">int</span> height = tv1.getMeasuredHeight();</span><br><span class="line">                Log.d(<span class="string">&quot;tv1Width&quot;</span>, String.valueOf(width));</span><br><span class="line">                Log.d(<span class="string">&quot;tv1Height&quot;</span>, String.valueOf(height));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li><li>手动调用measure方法后，获取宽高</li></ol><h4 id="什么时候开始绘制Activity的view的？"><a href="#什么时候开始绘制Activity的view的？" class="headerlink" title="什么时候开始绘制Activity的view的？"></a>什么时候开始绘制Activity的view的？</h4><p>在DecorView添加(addView)到phoneWindows中时，触发measure，layout，draw方法</p><h4 id="PhoneWindow是在什么时候创建的？"><a href="#PhoneWindow是在什么时候创建的？" class="headerlink" title="PhoneWindow是在什么时候创建的？"></a>PhoneWindow是在什么时候创建的？</h4><p>在Activity的attch方法时，创建了PhoneWindow</p><h4 id="View的刷新机制"><a href="#View的刷新机制" class="headerlink" title="View的刷新机制"></a>View的刷新机制</h4><h5 id="requestLayout和invalidate区别是什么"><a href="#requestLayout和invalidate区别是什么" class="headerlink" title="requestLayout和invalidate区别是什么"></a>requestLayout和invalidate区别是什么</h5><p><strong>requestLayout</strong>：触发onMeasure,onLayout方法，大小和位置变化，不一定触发onDraw</p><p><strong>invalidate</strong>：触发performTraversals机制，导致view重绘，调用onDraw方法，主要是内容发生变化</p><p><strong>postInvalidate</strong>：异步调用invalidate方法</p><blockquote><p>invalidate如果是个view，那就只有自己本身会draw，如果是ViewGroup就是对子view进行重绘</p></blockquote><h4 id="简析Activity、Window、DecorView以及ViewRoot之间的错综关系"><a href="#简析Activity、Window、DecorView以及ViewRoot之间的错综关系" class="headerlink" title="简析Activity、Window、DecorView以及ViewRoot之间的错综关系"></a>简析Activity、Window、DecorView以及ViewRoot之间的错综关系</h4><ul><li><p>Activity是控制器</p></li><li><p>windows装载DecorView，并将DecorView交给ViewRoot进行绘制和交互，其唯一实现子类就是PhoneWindow，在attach中创建，是Activity和View交互的中间层，帮助Activity管理View。</p></li><li>DecorView是FrameLayout的子类，是视图的顶级view</li><li>viewRoot负责view的绘制和交互，实际的viewRoot就是ViewRootImpl类，是连接WMS和DecorView的纽带</li></ul><h4 id="setContentView执行的具体过程"><a href="#setContentView执行的具体过程" class="headerlink" title="setContentView执行的具体过程"></a>setContentView执行的具体过程</h4><ol><li>Activity实例化，执行<strong>attach</strong>方法，在attach中创建<strong>PhoneWindow</strong></li><li>执行onCreate方法，执行<strong>setContentView</strong>，先调用phoneWindow.setContentView(),然后开始根据不同的主题创建<strong>DecorView</strong>的结构，传入我们的<strong>xml</strong>文件，生成一个多结构的View</li><li>Activity调用<strong>onResume</strong>方法，调用<strong>WindowManager.addView</strong>()方法，随后在addView()方法中创建<strong>ViewRootImpl</strong></li><li>接着调用ViewRootImpl的setView方法，最终触发meaure，layout，draw方法进行渲染绘制，其中和WMS通过Binder交互，最终显示在界面上</li></ol><h4 id="四者的创建时机？"><a href="#四者的创建时机？" class="headerlink" title="四者的创建时机？"></a>四者的创建时机？</h4><ul><li>Activity：startActivity后，performLaunchActivity方法中创建</li><li>PhoneWindow：Activity的attach方法</li><li>DecorView：setConentView中创建</li><li>ViewRootImpl：onResume中调用WM.addView方法创建</li></ul><h4 id="dialog为什么不能用application创建？"><a href="#dialog为什么不能用application创建？" class="headerlink" title="dialog为什么不能用application创建？"></a>dialog为什么不能用application创建？</h4><p><a href="https://juejin.cn/post/6873669458742525960">Android-Window机制原理之Token验证(为什么Application的Context不能show dialog)</a></p><blockquote><p>token是WMS唯一用来标识系统中的一个窗口</p></blockquote><p>Dialog有一个PhoneWindow实例，属于应用窗口。Dialog最终也是通过系统的WindowManager把自己的Window添加到WMS上。Dialog是一个子Window，需要依附一个父window。</p><p>Dialog创建PhoneWindow时，token是null。只有传入Activity中的Context对象，Activity才会将自己的token给Dialog，这样，才会被WMS所识别，如果使用的不是Activit的token，就会报错BadTokenException</p><p>在application的情况下，将Dialog的window升级为系统window即可显示</p><h2 id="RecyclerView和ListView"><a href="#RecyclerView和ListView" class="headerlink" title="RecyclerView和ListView"></a>RecyclerView和ListView</h2><p><a href="https://blog.csdn.net/ListerCi/article/details/105480322">Android—RecyclerView进阶(4)—复用机制及性能优化</a></p><p><a href="https://blog.csdn.net/m0_37700275/article/details/89839599">RecyclerView问题汇总</a></p><p><a href="https://my.oschina.net/u/2458461/blog/4870218">老大爷都能看懂的RecyclerView动画原理</a></p><p><a href="https://blog.csdn.net/smileiam/article/details/88396546">RecyclerView性能优化及高级使用</a></p><h4 id="简述RecyclerView的刷新和缓存机制"><a href="#简述RecyclerView的刷新和缓存机制" class="headerlink" title="简述RecyclerView的刷新和缓存机制"></a>简述RecyclerView的刷新和缓存机制</h4><p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c09a12ec1bd3ba?imageslim" alt="img"></p><p>recyclerView中有三个重要方：</p><ul><li>Adapter：负责与数据集交互</li><li>LayoutManager：负责ItemView的布局，接管Measure，Layout，Draw过程</li><li>Recycler：负责管理ViewHolder</li><li>ViewHolder：视图的创建和显示在Recycler中有多个缓存池，</li></ul><p>mAttachedScrap被称为一级缓存，在重新layout时使用，主要是数据集发生变化的场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//屏幕内缓存scrap</span><br><span class="line">// mAttachedScrap在重新layout时使用，表示未与RecyclerView分离的ViewHolder</span><br><span class="line">final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;();</span><br><span class="line">// mChangedScrap用于数据变化等</span><br><span class="line">ArrayList&lt;ViewHolder&gt; mChangedScrap = null;</span><br><span class="line">//屏幕外缓存cache</span><br><span class="line">// mCachedViews和RecycledViewPool用于滑动时的缓存</span><br><span class="line">final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();</span><br><span class="line">// 用户自定义缓存，一般不用</span><br><span class="line">private ViewCacheExtension mViewCacheExtension;</span><br><span class="line">//屏幕外缓存pool，数据会被重置，虚之行onBindViewHolder</span><br><span class="line">RecycledViewPool mRecyclerPool;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>mAttachedScrap：mAttachedScrap用于屏幕中可见表项的回收和复用，没有大小限制<br>mAttachedScrap生命周期起始于RecyclerView布局开始，终止于RecyclerView布局结束，无论mAttachedScrap中是否存在数据，都会清空，存储到mCacheView或者mRecyclerPool</li></ul><blockquote><p>插入或是删除itemView时，先把屏幕内的ViewHolder保存至AttachedScrap中</p></blockquote><blockquote><p>mAttachView和mCacheView都是通过比对position或者id（setStableIds（true）+getItemId复写）来确定是否复用的</p></blockquote><h4 id="缓存存储结构区别"><a href="#缓存存储结构区别" class="headerlink" title="缓存存储结构区别"></a>缓存存储结构区别</h4><ul><li>mAttachedScrap：ArrayList<ViewHolder></li><li>mCachedView：ArrayList<ViewHolder></li><li>mRecyclerPool：SparseArray<ScrapData>，ScrapData中包含ArrayList<ViewHolder>和其他标记位。<h5 id="数据集发生变化"><a href="#数据集发生变化" class="headerlink" title="数据集发生变化"></a>数据集发生变化</h5>当数据集发生变化后，我们会调用notifyDataSetChanged()方法进行刷新布局操作，这时LayouManager通过调用detachAndScrapAttachedViews方法，将布局中正在显示的ItemView缓存到mAttachScrap中，重新构建ItemView时，LayoutManager会首先到mAttachScrap中进行查找<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDMzMTg0LTljYmYwNTQ3YTNjN2JkZDYucG5n?x-oss-process=image/format,png" alt="img"><br>如图所示，如果只是删除Data1数据，执行NotifyDataSetChanged()方法时，layoutManager将Data0到Data4缓存到mAttachScrap中，重新渲染布局时，会直接复用mAttachScrap中的四个布局，而得不到复用的布局会被放置在mRecyclerPool中。</li></ul><blockquote><p>通过比较Position确定mAttachScrap中ItemView的复用，因为2的位置从2变为1，位置发生变化，但是还是通过比对position进行复用，那是因为在recyclerView重新渲染时，执行dispatchLayoutStep1()对position进行了校正。</p></blockquote><h5 id="滑动类型"><a href="#滑动类型" class="headerlink" title="滑动类型"></a>滑动类型</h5><p>在滑出可视区域后，会将ViewHolder存储在mCachedView中，当超出大小（默认大小为2+预加载item）后会将最先放进来的放在RecyclerViewPool中，根据viewType进行缓存，每个viewType缓存最多5个，从RecyclerViewPool中取出的数据，最终会调用onBindViewHolder()方法重新绑定</p><p>当发现有新的构建时，会去缓存找，找不到就去mRecyclerPool中寻找，如果有viewType相同的就取出来绑定并复用。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDMzMTg0LWRmYTljNDZmZmI1NDJkZTAucG5n?x-oss-process=image/format,png" alt="img"></p><p>RecyclerView滑动时，刚开始的时候回收了Position0和Position1，它们被添加到了mCachedViews中。随后回收Position2时，达到数量上限，最先进入mCachedViews的Position0被放进了mRecyclerPool中。<br>再看下方进入可视区域的3个Item，最初的Position6和Position7找不到对应的缓存，只能新建ViewHolder并绑定。当Position8滑入可视区域时，发现mRecyclerPool中有一个ViewType相等的缓存，则将其取出并绑定数据进行复用。</p><p>当有数据进行变动时，数据的position会发生变化。</p><p>stableId</p><blockquote><p>mChangedScrap—–&gt;mAttachedScrap—–&gt;mCachedViews—–&gt;ViewCacheExtension—–&gt;RecycledViewPool——–&gt;onCreatViewHolder</p><p>如果是单个viewType的RecyclerView，在滑动过程中，RecyclerPool最多可能存在一个数据</p></blockquote><p>假设一屏幕显示7个，向上滑动10个，总共bindView10个，又下滑10个（滑回去），总共8个（cacheView复用两个），一共18个</p><blockquote><p>在RecyclerView的v25版本中，引入<strong>预取机制</strong>，在初始化时，初始化8个，提前缓存一个数据</p></blockquote><h4 id="RecyclerView的优化"><a href="#RecyclerView的优化" class="headerlink" title="RecyclerView的优化"></a>RecyclerView的优化</h4><h5 id="放大缓存大小和缓存池大小"><a href="#放大缓存大小和缓存池大小" class="headerlink" title="放大缓存大小和缓存池大小"></a>放大缓存大小和缓存池大小</h5><ol><li>再滑动过程中，不论上滑还是下滑都会从<strong>mCachedViews</strong>中查找缓存，如果滑动频繁，可以通过<code>RecyclerView.setItemViewCacheSize(...)</code>方法增大<strong>mCachedViews</strong>的大小，减少onBindViewHolder()和onCreateViewHolder()调用</li><li>放大RecyclerViewPool的默认大小，现在是每个viewType中默认大小为5，如果显示数据过多，可放大默认大小<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置viewType类型的默认存储大小为10</span></span><br><span class="line">recyclerview.getRecycledViewPool().setMaxRecycledViews(viewType,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>如果多个RecyclerView中存在相同ViewType的ItemView，那么这些RecyclerView可以公用一个mRecyclerPool。</li></ol><h5 id="优化onBindViewHolder-耗时"><a href="#优化onBindViewHolder-耗时" class="headerlink" title="优化onBindViewHolder()耗时"></a>优化onBindViewHolder()耗时</h5><p>尽量少的在onBindViewHolder中执行操作，减少新建对象对内消耗</p><h5 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h5><p>多使用include,merage，viewStub,LinearLayout,FrameLayout</p><h5 id="measure-优化和减少requestLayout-调用"><a href="#measure-优化和减少requestLayout-调用" class="headerlink" title="measure()优化和减少requestLayout()调用"></a>measure()优化和减少requestLayout()调用</h5><p>当RecyclerView宽高的测量模式都是EXACTLY（精确数据）时，onMeasure()方法不需要执行dispatchLayoutStep1()等方法来进行测量。而当RecyclerView的宽高不确定并且至少一个child的宽高不确定时，要measure两遍。<br>因此将RecyclerView的宽高模式都设置为EXACTLY有助于优化性能。</p><p>如果RecyclerView的宽高都不会变，大小不变,方法<code>RecyclerView.setHasFixedSize(true)</code>可以避免数据改变时重新计算RecyclerView的大小，优化性能</p><h4 id="notifyDataSetChanged-与-notifyItemRangeChanged-的区别？"><a href="#notifyDataSetChanged-与-notifyItemRangeChanged-的区别？" class="headerlink" title="notifyDataSetChanged 与 notifyItemRangeChanged 的区别？"></a>notifyDataSetChanged 与 notifyItemRangeChanged 的区别？</h4><p>当notifyItemRangeChanged的区间在mRecyclerpool的大小的间隔内，则会通过mRecyclerpool复用viewholder，响应快速。</p><p>notifyItemInsert()和notifyItemRemove()方法，会通过RecyclerView的预加载流程，会将ViewHolder缓存到mAttachView中，避免重新create和bind。</p><p>notifyItemChanged(int)方法更新固定item</p><p>notifyDataSetChanged 会将所有viewholder放置在pool中，但是只能放置5个，其他就回收了，再构建时，需要重新绘制测量，界面会导致闪烁等</p><p>如果使用SetHasStableIds（true）,会将数据缓存到scrap中，复用时直接使用</p><h4 id="调用-notifyDataSetChanged-时闪烁的原因？"><a href="#调用-notifyDataSetChanged-时闪烁的原因？" class="headerlink" title="调用 notifyDataSetChanged 时闪烁的原因？"></a>调用 notifyDataSetChanged 时闪烁的原因？</h4><p>itemView重新测量和布局导致的(bindViewHolder)，并非createViewHolder。数据存储在RecyclerViewPool中，拿出需要重新BindView，itemView重新进行测量和布局，导致出现UI线程耗时，出现闪烁</p><p>如果使用SetHasStableIds（true）,会将数据缓存到scrap中，复用时直接使用</p><blockquote><p><strong>如果你的列表能够容纳很多行，而且使用 notifyDataSetChanged 方法比较频繁，那么你应该考虑设置一下容量大小。</strong></p></blockquote><h4 id="RecyclerView相对于ListView的优势是什么？"><a href="#RecyclerView相对于ListView的优势是什么？" class="headerlink" title="RecyclerView相对于ListView的优势是什么？"></a>RecyclerView相对于ListView的优势是什么？</h4><ol><li>屏幕外缓存可以直接在mCacheView()中复用，不需要重新BindView</li><li>recyclerPool可以提供给多个RecyclerView使用，在特定场景下，如viewpaper+多个列表页下有优势.</li><li>ListView缓存<strong>View</strong>，RecyclerView缓存<strong>ViewHolder</strong></li></ol><h4 id="adapter，viewHolder的作用-adapter中常用方法的作用是什么？"><a href="#adapter，viewHolder的作用-adapter中常用方法的作用是什么？" class="headerlink" title="adapter，viewHolder的作用?adapter中常用方法的作用是什么？"></a>adapter，viewHolder的作用?adapter中常用方法的作用是什么？</h4><ul><li>Adapter：负责与数据集交互</li><li>ViewHolder：视图的创建和显示，持有所有的用于绑定数据或者需要操作的View</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Item视图，并返回相应的ViewHolder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> VH <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span></span></span><br><span class="line"><span class="function"><span class="comment">//绑定数据到正确的Item视图上。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(VH holder, <span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回该Adapter所持有的Item数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//用来获取当前项Item(position参数)是哪种类型的布局</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h4 id="RecyclerPool为何使用SparseArray？"><a href="#RecyclerPool为何使用SparseArray？" class="headerlink" title="RecyclerPool为何使用SparseArray？"></a>RecyclerPool为何使用SparseArray？</h4><p>在RecyclerView中，第四级缓存，mRecyclerPool中存储是通过SparseArray存储ViewHolder，根据不同的ViewType的int值为键，ScrapData为值，ScrapData也是ArrayList<ViewHolder>及其标志位组成的，在进行put和get方法时，都是通过ViewType值获取。<br>不使用HashMap的原因是：</p><ul><li>我们定义了viewType为int值，则不用HashMap中较为繁重的类型，减少装箱问题耗时</li><li>量级较小，不需要HashMap的大量级处理</li><li>节省内存</li></ul><p>使用SparseArray存储空间id和空间对象关系。</p><p>HashMap更加复杂，SparseArray减少开销</p><h4 id="LayoutManager样式有哪些？setLayoutManager源码里做了什么？"><a href="#LayoutManager样式有哪些？setLayoutManager源码里做了什么？" class="headerlink" title="LayoutManager样式有哪些？setLayoutManager源码里做了什么？"></a>LayoutManager样式有哪些？setLayoutManager源码里做了什么？</h4><ul><li>LinearLayoutManager 水平或者垂直的Item视图。</li><li>GridLayoutManager 网格Item视图。</li><li>StaggeredGridLayoutManager 交错的网格Item视图。</li></ul><p>当之前设置过 LayoutManager 时，移除之前的视图，并缓存视图在 Recycler 中，将新的 mLayout 对象与 RecyclerView 绑定，更新缓存 View 的数量。最后去调用 requestLayout ，重新请求 measure、layout、draw。</p><h4 id="ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration-源码？"><a href="#ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration-源码？" class="headerlink" title="ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration()源码？"></a>ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration()源码？</h4><p>用途：来改变Item之间的偏移量或者对Item进行装饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装饰的绘制在Item条目绘制之前调用，所以这有可能被Item的内容所遮挡</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c, RecyclerView parent)</span></span></span><br><span class="line"><span class="function"><span class="comment">//装饰的绘制在Item条目绘制之后调用，因此装饰将浮于Item之上</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawOver</span><span class="params">(Canvas c, RecyclerView parent)</span></span></span><br><span class="line"><span class="function"><span class="comment">//与padding或margin类似，LayoutManager在测量阶段会调用该方法，计算出每一个Item的正确尺寸并设置偏移量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffsets</span><span class="params">(Rect outRect, <span class="keyword">int</span> itemPosition, RecyclerView parent)</span></span></span><br></pre></td></tr></table></figure><p>当通过这个方法添加分割线后，会指定添加分割线在集合中的索引，然后再重新请求 View 的测量、布局、(绘制)</p><h4 id="mChangedScrap和mAttachedScrap的区别是什么？"><a href="#mChangedScrap和mAttachedScrap的区别是什么？" class="headerlink" title="mChangedScrap和mAttachedScrap的区别是什么？"></a>mChangedScrap和mAttachedScrap的区别是什么？</h4><p>因为mChangedScrap表示item变化了，有可能是数据变化，有可能是类型变化，所以它的viewHolder无法重用，只能去RecycledViewPool中重新取对应的，然后再重新绑定。</p><p>mChangedScrap与mAttachedScrap，作用差不多。</p><p>mChangedScrap更多的用于pre-layout的动画处理。</p><p>然后一点需要注意：mChangedScrap只能在pre-layout中使用，mAttachedScrap可以在pre-layout与post-layout中使用。</p><p>mChangedScrap：ViewHolder.isUpdated() == true</p><p>mAttachedScrap：1.被同时标记为<code>remove</code>和<code>invalid</code>；2.完全没有改变的<code>ViewHolder</code></p><p>在notifyItemRangeChanged，将数据变化的放置在mChangedScrap，没有变化的存储在mAttachScrap中，然后再取出来，mChangedScrap的数据会被移动到RecyclerPool中，进行重新绑定后再放回mChangedScrap中</p><p>mAttachScrap中得不到复用的会放置在recyclerpool中</p><h4 id="onMeasure过程"><a href="#onMeasure过程" class="headerlink" title="onMeasure过程"></a>onMeasure过程</h4><p>过程中包含mAttachedScrap的使用</p><p>dispatchLayoutStep1：预布局</p><p>dispatchLayoutStep2：实际布局</p><p>dispatchLayoutStep3：执行动画信息</p><h4 id="如何解决Glide错乱问题"><a href="#如何解决Glide错乱问题" class="headerlink" title="如何解决Glide错乱问题"></a>如何解决Glide错乱问题</h4><p>因为存在复用机制，8可能会复用1，在网络不好或者图片过大的情况下，8的图片加载缓慢，会先显示1的图片，加载后才会刷新掉。</p><p>方案：imageView设置tag，判断是否复用，如果是复用，就清除该控件上Glide的缓存</p><h4 id="RecyclerView卡顿优化"><a href="#RecyclerView卡顿优化" class="headerlink" title="RecyclerView卡顿优化"></a>RecyclerView卡顿优化</h4><p>通过BlockCanary进行主线程卡顿检测，打印出任务耗时，在卡顿时，打印出栈堆信息</p><p>原理是在looper.loop()死循环中，执行任务都是dispatchMessage方法，如果该方法超过一个任务的常规耗时，就会导致主线程卡顿</p><p>解决方法：</p><ol><li><p>放大mCacheView和RecyclerPool的大小，提高复用率，减少渲染</p></li><li><p>图片在滑动结束后再进行加载，避免在滑动的时候向主线程做更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.addOnScrollListener(<span class="keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE) &#123;</span><br><span class="line">            Glide.with(mContext).resumeRequests();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Glide.with(mContext).pauseRequests();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在滑动过程中停止加载，在滑动结束后恢复加载</p></li><li><p>使用DiffUtil进行局部刷新优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DiffUtil会自动计算新老数据的差异，自动调用notifyxxx方法，将无脑的notifyDataSetChanged()进行优化</span></span><br><span class="line"><span class="comment">//并且伴随动画</span></span><br><span class="line">adapter.notifyItemRangeInserted(position, count);</span><br><span class="line">adapter.notifyItemRangeRemoved(position, count);</span><br><span class="line">adapter.notifyItemMoved(fromPosition, toPosition);</span><br><span class="line">adapter.notifyItemRangeChanged(position, count, payload);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文艺青年新宠</span></span><br><span class="line"><span class="comment">//利用DiffUtil.calculateDiff()方法，传入一个规则DiffUtil.Callback对象，和是否检测移动item的 boolean变量，得到DiffUtil.DiffResult 的对象</span></span><br><span class="line">DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(<span class="keyword">new</span> DiffCallBack(mDatas, newDatas), <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//利用DiffUtil.DiffResult对象的dispatchUpdatesTo（）方法，传入RecyclerView的Adapter，轻松成为文艺青年</span></span><br><span class="line">diffResult.dispatchUpdatesTo(mAdapter);</span><br><span class="line"><span class="comment">//别忘了将新数据给Adapter</span></span><br><span class="line">mDatas = newDatas;</span><br><span class="line">mAdapter.setDatas(mDatas);</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>减少布局的嵌套和层级，减少过度绘制，尽量自定义view</p></li><li><p>如果Item高度固定，调用<code>RecyclerView.setHasFixedSize(true);</code>来避免<code>requestLayout</code>浪费资源</p></li><li><p>可以关闭动画，减少RecyclerView的渲染次数</p></li></ol><h4 id="RecyclerView的自适应高度"><a href="#RecyclerView的自适应高度" class="headerlink" title="RecyclerView的自适应高度"></a>RecyclerView的自适应高度</h4><ol><li>使用瀑布流布局StaggeredGridLayoutManager</li><li>重写LinearLayoutManager，onMeasure中重新测量子布局的大小</li></ol><h4 id="RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView"><a href="#RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView" class="headerlink" title="RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView"></a>RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView</h4><ol><li>同方向的情况下会造成滑动冲突，默认外层的RecyclerView可滑动<br>一般有两种处理方案：<strong>内部拦截法</strong>和<strong>外部拦截法</strong><br>这里推荐内部拦截法，通过设置requestDisallowInterceptTouchEvent(true)时，不让父RecyclerView拦截子类的事件</li><li>ScrollView嵌套RecyclerView同样可以使用这个方法解决。也可以使用NestedScrollView，该类就是为了解决滑动冲突问题，可以保证两View类都可以滑动，但是需要设置RecyclerView.setNestedScrollingEnabled(false)，取消RecyclerView本身的滑动效果。解决滑动的卡顿感</li></ol><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h4 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h4><p>帧动画：一连串的图片进行连贯的播放，形成动画。</p><p>补间动画：通过xml文件实现，实现 <strong>alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）</strong>，通过不断的绘制view，看起来移动了效果，实际上view没有变化，还在原地</p><p>属性动画：对于对象属性的动画，也可以使用xml配置，但是推荐代码配置，比xml更加方便。通过不断改变自己view的属性值，真正的改变view</p><blockquote><p>所有的补间动画都可以用属性动画实现</p></blockquote><h4 id="属性动画和补间动画的区别"><a href="#属性动画和补间动画的区别" class="headerlink" title="属性动画和补间动画的区别"></a>属性动画和补间动画的区别</h4><ol><li>补间动画虽然移动了，但是点击的还是原来的位置，点击事件允许触发。而属性动画不是，所以我们可以确认，属性动画才是真正实现了View的移动，补间动画的view其实只是在其他地方绘制了一个影子</li><li>Activity退出时，没有关闭动画，属性动画会导致Activity无法释放的内存泄漏，而补间动画不会发生这样的情况</li><li>xml的补间动画复用率极高，在页面切换过程中都有很好的效果</li></ol><blockquote><p>帧动画避免大图，否则会带来oom</p></blockquote><h4 id="属性动画中的差值器和估值器是什么？"><a href="#属性动画中的差值器和估值器是什么？" class="headerlink" title="属性动画中的差值器和估值器是什么？"></a>属性动画中的差值器和估值器是什么？</h4><p>差值器：定义动画随时间流逝的变化规律。通俗点就是动画的执行速度的变化，可以是由缓即快，由快即缓，也可以是匀速，也可以是弹性动画效果 ，LinearInterpolator（匀速差值器）</p><p>估值器：定义从初始值过渡到结束值的规则定义，TypeEvaluator，可以通俗的理解为位置的移动</p><h2 id="android系统启动流程"><a href="#android系统启动流程" class="headerlink" title="android系统启动流程"></a>android系统启动流程</h2><h4 id="android系统架构"><a href="#android系统架构" class="headerlink" title="android系统架构"></a>android系统架构</h4><h4 id="简述系统启动流程"><a href="#简述系统启动流程" class="headerlink" title="简述系统启动流程"></a>简述系统启动流程</h4><p>从系统层看：</p><ol><li>linux 系统层</li><li>Android系统服务层</li><li>Zygote</li></ol><p>从开机启动到Home Launcher：</p><ol><li>启动bootloader （小程序；初始化硬件）</li><li>加载系统内核 （先进入实模式代码在进入保护模式代码）</li><li>启动init进程（用户级进程 ，进程号为1）</li><li>启动Zygote进程（初始化Dalvik VM等）</li><li>启动Runtime进程</li><li>启动本地服务（system service）</li><li>启动 HomeLauncher</li></ol><h4 id="第一个启动的进程是什么？"><a href="#第一个启动的进程是什么？" class="headerlink" title="第一个启动的进程是什么？"></a>第一个启动的进程是什么？</h4><p>init进程，其他进程都是fork这个进程的</p><h4 id="init进程孵化出了什么进程？"><a href="#init进程孵化出了什么进程？" class="headerlink" title="init进程孵化出了什么进程？"></a>init进程孵化出了什么进程？</h4><ul><li>守护进程</li><li>Zygote进程，负责孵化应用进程</li><li>MediaServer进程</li></ul><h4 id="Zygote进程做了什么？"><a href="#Zygote进程做了什么？" class="headerlink" title="Zygote进程做了什么？"></a>Zygote进程做了什么？</h4><ul><li>创建Socket服务端</li><li>加载虚拟机</li><li>SystemServer进程</li><li>fork第一个应用进程—Launcher</li></ul><h4 id="为什么要创建Socket服务端？"><a href="#为什么要创建Socket服务端？" class="headerlink" title="为什么要创建Socket服务端？"></a>为什么要创建Socket服务端？</h4><ul><li>ServiceManager不能保证在孵化Zygote进程时就初始化好了，所以无法使用Binder</li><li>Binder属于多线程操作，fork不允许多线程操作，容易发生死锁，所以使用Socket<h2 id="app启动流程"><a href="#app启动流程" class="headerlink" title="app启动流程"></a>app启动流程</h2></li></ul><ol><li>用户点击 icon</li><li>系统开始加载和启动应用</li><li>应用启动：开启空白(黑色)窗口</li><li>创建应用进程</li><li>初始化Application</li><li>启动 UI 线程</li><li>创建第一个 Activity</li><li>解析(Inflater)和加载内容视图</li><li>布局(Layout)</li><li>绘制(Draw)</li></ol><p>源码分析</p><ol><li>LauncherActivity.startActivitySafely(intent)：使用intent启动</li><li>Activity.startActivity(intent)：</li><li>Activity.startActivityForResult(intent)：获取ApplicationThread成员变量，是一个Binder对象</li><li>Instrumentation.execStartActivity：ActivityManagerService的远程接口</li><li>ActivityManagerProxy.startActivity：通过Binder进入AMS</li><li>ActivityManagerService.startActivity</li><li>ActivityStack.startActivityMayWait：解析MainActivity的信息</li><li>ActivityStack.startActivityLocked：创建即将要启动的Activity的相关信息</li><li>ActivityStack.startActivityUncheckedLocked：获取intent标志位，新建Task栈，添加到AMS中</li><li>Activity.resumeTopActivityLocked：查看LauncherActivity状态，新建Activity的状态</li><li>ActivityStack.startPausingLocked：停止LauncherActivity，onPause</li><li>ApplicationThreadProxy.schedulePauseActivity</li><li>ApplicationThread.schedulePauseActivity</li><li>ActivityThread.queueOrSendMessage：在主线程通过Handler发送消息</li><li>H.handleMessage：Handler的回调</li><li>ActivityThread.handlePauseActivity：pause LauncherActivity</li><li>ActivityManagerProxy.activityPaused：进入AMS中的onPause事件</li><li>ActivityManagerService.activityPaused</li><li>ActivityStack.activityPaused</li><li>ActivityStack.completePauseLocked</li><li>ActivityStack.resumeTopActivityLokced：LauncherActivity已经onPause了</li><li>ActivityStack.startSpecificActivityLocked</li><li>ActivityManagerService.startProcessLocked：创建新进程</li><li>ActivityThread.main：app入口，添加looper循环</li><li>ActivityManagerProxy.attachApplication：通过Binder进入AMS中</li><li>ActivityManagerService.attachApplication</li><li>ActivityManagerService.attachApplicationLocked</li><li>ActivityStack.realStartActivityLocked</li><li>ApplicationThreadProxy.scheduleLaunchActivity：进入ApplicationThread</li><li>ApplicationThread.scheduleLaunchActivity</li><li>ActivityThread.queueOrSendMessage</li><li>H.handleMessage</li><li>ActivityThread.handleLaunchActivity</li><li>ActivityThread.performLaunchActivity：进入onCreat方法</li><li>MainActivity.onCreate</li></ol><p>总结：</p><p>1～11：Launcher通过Binder进程通知ActivityManagerService，他要启动一个Activity</p><p>12～16：ActivityManagerService通过Binder进程通知Launcher进入Pause阶段</p><p>17～24：Launcher告知我已进入pause阶段，ActivityManagerService创建新进程，用来启动ActivityThread。</p><p>25～27：ActivityThread通过Binder进程将ApplicationThread的Binder传递给ActivityManagerService，以便AMS可以直接用这个Binder通信</p><p>28～35：AMS通过Binder通知ActivityThread，你可以启动</p><p>这里以启动微信为例子说明</p><ol><li>Launcher通知AMS 要启动微信了，并且告诉AMS要启动的是哪个页面也就是首页是哪个页面</li><li>AMS收到消息告诉Launcher知道了，并且把要启动的页面记下来</li><li>Launcher进入Paused状态，告诉AMS，你去找微信吧</li></ol><p>上述就是Launcher和AMS的交互过程</p><ol><li>AMS检查微信是否已经启动了也就是是否在后台运行，如果是在后台运行就直接启动，如果不是，AMS会在新的进程中创建一个ActivityThread对象，并启动其中的main函数。</li><li>微信启动后告诉AMS，启动好了</li><li>AMS通过之前的记录找出微信的首页，告诉微信应该启动哪个页面</li><li>微信按照AMS通知的页面去启动就启动成功了。</li></ol><h2 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h2><p>参照app的启动流程</p><ul><li>ApplicationThread：ActivityThread的内部类，负责和AMS进行Binder通信</li><li>ActivityManagerService：服务端对象，负责管理系统中所有的Activity</li></ul><p>Activity 启动过程是由 ActivityMangerService（AMS) 来启动的，底层 原理是 Binder实现的 最终交给 ActivityThread 的 performActivity 方法来启动她</p><p>ActivityThread大概可以分为以下五个步骤</p><ol><li>通过ActivityClientRecord对象获取Activity的组件信息</li><li>通过Instrument的newActivity使用类加载器创建Activity对象</li><li>检验Application是否存在，不存在的话，创建一个，保证 只有一个Application</li><li>通过ContextImpl和Activity的attach方法来完成一些初始化操作</li><li>调用oncreat方法</li></ol><p>Android开启新进程的方式是通过复制第一个zygote（受精卵）进程实现，所以像受精卵一样快速分裂</p><h4 id="SystemServer是什么？有什么作用？他和zygote的关系是什么？"><a href="#SystemServer是什么？有什么作用？他和zygote的关系是什么？" class="headerlink" title="SystemServer是什么？有什么作用？他和zygote的关系是什么？"></a>SystemServer是什么？有什么作用？他和zygote的关系是什么？</h4><p>SystemServer也是一个进程，并且复制于zygote，系统中重要的服务都是在这个进程中开启的，如：AMS，PMS，WMS等</p><h4 id="ActivityManagerService是什么？什么时候初始化的？有什么作用？"><a href="#ActivityManagerService是什么？什么时候初始化的？有什么作用？" class="headerlink" title="ActivityManagerService是什么？什么时候初始化的？有什么作用？"></a>ActivityManagerService是什么？什么时候初始化的？有什么作用？</h4><p>简称AMS，负责系统中所有Activity的生命周期，控制其开启、关闭、暂停等<br>是在SystemServer进程开启时进行初始化的</p><h4 id="App-和-AMS-SystemServer-进程-还有-zygote-进程是如何通信的？"><a href="#App-和-AMS-SystemServer-进程-还有-zygote-进程是如何通信的？" class="headerlink" title="App 和 AMS(SystemServer 进程)还有 zygote 进程是如何通信的？"></a>App 和 AMS(SystemServer 进程)还有 zygote 进程是如何通信的？</h4><p>App 与 AMS 通过 <strong>Binder</strong> 进行 IPC 通信，AMS(SystemServer 进程)与 zygote 通过 <strong>Socket</strong> 进行 IPC 通信。</p><h4 id="AMS-PMS-WMS运行在一个线程中还是进程中？"><a href="#AMS-PMS-WMS运行在一个线程中还是进程中？" class="headerlink" title="AMS/PMS/WMS运行在一个线程中还是进程中？"></a>AMS/PMS/WMS运行在一个线程中还是进程中？</h4><p>运行在System_server进程中的线程中</p><h2 id="apk打包流程"><a href="#apk打包流程" class="headerlink" title="apk打包流程"></a>apk打包流程</h2><p><img src="/imageMd/package-1.png" width="50%" /></p><ol><li>aapt阶段，打包res目录，生成R.java</li><li>AIDL阶段，生成java文件</li><li>java编译器。将java文件通过javac编译生成<code>.class</code>文件</li><li>dex阶段，生成<code>.dex</code>文件</li><li>apk打包阶段，将文件打包成为apk文件</li><li>签名阶段，对apk进行签名</li><li>整理apk文件</li></ol><h4 id="aapt和aapt2的区别？"><a href="#aapt和aapt2的区别？" class="headerlink" title="aapt和aapt2的区别？"></a>aapt和aapt2的区别？</h4><p>aapt是全量编译，打包res目录，生成R文件</p><p>aapt2是差量编译，将变化的res目录进行重新打包，修改R文件</p><blockquote><p>aapt2中存在两部分，编译和链接</p><p>编译：将资源文件编译为二进制文件</p><p>链接：将编译后二进制文件进行合并，生成独立的文件</p></blockquote><p>在需要差量的时候，只需要重新编译二进制文件，再将这些二进制文件生成新的文件即可</p><h2 id="apk的组成"><a href="#apk的组成" class="headerlink" title="apk的组成"></a>apk的组成</h2><ol><li>AndroidManifest.xml</li><li>assets（项目中assets目录）</li><li>classes.dex</li><li>lib库</li><li>META-INF（校验文件）</li><li>res（资源文件）</li><li>resources.arsc（资源文件映射，索引文件）</li></ol><h2 id="apk安装流程"><a href="#apk安装流程" class="headerlink" title="apk安装流程"></a>apk安装流程</h2><h4 id="存在多少种安装方式，分别是什么？"><a href="#存在多少种安装方式，分别是什么？" class="headerlink" title="存在多少种安装方式，分别是什么？"></a>存在多少种安装方式，分别是什么？</h4><p>四种</p><ul><li>系统应用安装——————开机时完成安装，没有安装界面</li><li>网络下载安装——————通过市场应用完成，没有安装界面</li><li>adb命令安装——————没有安装界面</li><li>第三方应用安装——————sdk卡导入apk，点击安装，存在安装界面</li></ul><h4 id="安装过程中的重要路径"><a href="#安装过程中的重要路径" class="headerlink" title="安装过程中的重要路径"></a>安装过程中的重要路径</h4><p>应用安装涉及到如下几个目录：</p><p>system/app —————系统自带的应用程序，获得adb root权限才能删除</p><p>data/app  —————用户程序安装的目录。安装时把      apk文件复制到此目录</p><p>data/data —————存放应用程序的数据</p><p>data/dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)</p><h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><ol><li>将apk文件复制到/data/app目录</li><li>解析apk信息</li><li>dexopt操作（将dex文件优化为odex文件）</li><li>更新权限信息</li><li>发送安装完成广播</li></ol><h4 id="Android虚拟机发展史"><a href="#Android虚拟机发展史" class="headerlink" title="Android虚拟机发展史"></a>Android虚拟机发展史</h4><ol><li>android初期，Dalvik负责加载dex/odex文件</li><li>2.2版本，JIT（即时编译）初次加入，每次启动的时候编译，耗时，耗电</li><li>4.4版本引入ART（Android RunTime）和AOT（Ahead-of-time）（运行前编译成机器码），与Dalvik共存</li><li>5.0版本全部采用ART编译器，不耗时，不耗电，在安装期间比较慢而已，而且会占用额外的控件存储机器码</li><li>7.0版本JIT回归，再用JIT/AOT并用，即初次启动使用JIT，在手机空闲时，使用AOT生成机器码（只编译热点函数信息，用户操作次数越多，性能越高），这样保证了安装迅速，启动迅速，耗电少</li></ol><h4 id="Dalvik和ART是什么，有啥区别？"><a href="#Dalvik和ART是什么，有啥区别？" class="headerlink" title="Dalvik和ART是什么，有啥区别？"></a>Dalvik和ART是什么，有啥区别？</h4><h5 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h5><p>Dalvik是Google公司自己设计用于Android平台的虚拟机。支持已转换为<code>.dex格式</code>的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。<br>Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。<br>很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。<br>2014年6月25日，Android L 正式亮相于召开的谷歌I/O大会，Android L 改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART。</p><h5 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h5><p>即Android Runtime<br>ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>Dalvik是基于寄存器的，而JVM是基于栈的。<br>Dalvik运行dex文件，而JVM运行java字节码<br>自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）。<br>优化后的Dalvik较其他标准虚拟机存在一些不同特性:<br>1.占用更少空间<br>2.为简化翻译，常量池只使用32位索引<br>3.标准Java字节码实行8位堆栈指令,Dalvik使用16位指令集直接作用于局部变量。局部变量通常来自4位的“虚拟寄存器”区。这样减少了Dalvik的指令计数，提高了翻译速度。<br>当Android启动时，Dalvik VM 监视所有的程序（APK），并且创建依存关系树，为每个程序优化代码并存储在Dalvik缓存中。Dalvik第一次加载后会生成Cache文件，以提供下次快速加载，所以第一次会很慢。<br>Dalvik解释器采用预先算好的Goto地址，每个指令对内存的访问都在64字节边界上对齐。这样可以节省一个指令后进行查表的时间。为了强化功能, Dalvik还提供了快速翻译器（Fast Interpreter）。</p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>ART有什么优缺点呢？</p><p>优点：<br>1、系统性能的显著提升。<br>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。<br>3、更长的电池续航能力。<br>4、支持更低的硬件。<br>缺点：<br>1.机器码占用的存储空间更大，字节码变为机器码之后，可能会增加10%-20%<br>2.应用的安装时间会变长</p><h4 id="dex-class-odex的区别"><a href="#dex-class-odex的区别" class="headerlink" title=".dex .class .odex的区别"></a>.dex .class .odex的区别</h4><p>.dex是谷歌对.class文件进行了优化后得到的文件格式</p><ol><li>.dex去除了.class中冗余的信息，更加轻量</li><li>.class内存占用大，不适合移动端，堆栈的加栈模式，加载速度慢，文件IO操作多，类查找慢</li></ol><p>.dex文件在虚拟机进行加载时，会预加载成.odex文件，.odex文件对.dex文件进行了优化，避免了重复验证和优化处理，启动时，可直接接在odex文件，提升app启动的速度</p><h4 id="简述安装流程"><a href="#简述安装流程" class="headerlink" title="简述安装流程"></a>简述安装流程</h4><ol><li>使用installPackageAsUser判断安装来源</li><li>校验后（权限，存储空间，安全）将apk文件copy至data/app目录</li><li>解析apk信息，覆盖安装或者安装新应用</li><li><p>Dalvik中将dex优化为odex文件</p><pre><code>ART将dex翻译为oat文件（机器码）预编译过程</code></pre></li><li><p>创建/data/data/包名    存放应用数据，发送广播结束安装</p></li></ol><h2 id="接口加密"><a href="#接口加密" class="headerlink" title="接口加密"></a>接口加密</h2><h4 id="项目中的接口加密技巧"><a href="#项目中的接口加密技巧" class="headerlink" title="项目中的接口加密技巧"></a>项目中的接口加密技巧</h4><p>在版本中写死一个密钥，首个接口请求后返回该app的密钥。</p><p>对上传的get，post请求的参数以ASCII码进行排序+密钥后生成md5值，添加到header中，传递给服务器</p><p>服务器端根据获取到的参数依据同样的规则生成md5后进行比较，如果相同，比较时间戳是否在5秒内，通过则成功</p><p>不使用token机制的原因是本产品不存在账号密码等机制，应用可能一直保持在线状态，不会下线，需要协调token的时效性，所以不使用该方案。</p><p>缺点：token机制一台机子只允许一个token进行访问，而上述方案没有该限制</p><h4 id="常规token校验机制"><a href="#常规token校验机制" class="headerlink" title="常规token校验机制"></a>常规token校验机制</h4><p><img src="/imageMd/token-1.png" width="60%"/></p><p>适用于存在账户名密码的应用</p><h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><h4 id="ANR条件？"><a href="#ANR条件？" class="headerlink" title="ANR条件？"></a>ANR条件？</h4><p>Service执行的操作最多是20s，BroadcastReceiver是10s，Activity是5s，超过时间发生ANR</p><h4 id="ANR原理解析"><a href="#ANR原理解析" class="headerlink" title="ANR原理解析"></a>ANR原理解析</h4><p>Application Not Responding</p><ol><li>主线程频繁进行IO操作，比如读写文件或者数据库；</li><li>硬件操作如进行调用照相机或者录音等操作；</li><li>多线程操作的死锁，导致主线程等待超时；</li><li>主线程操作调用join()方法、sleep()方法或者wait()方法；</li><li>耗时动画/耗资源行为导致CPU负载过重</li><li>system server中发生WatchDog ANR；</li><li>service binder的数量达到上限</li></ol><p>在应用程序运行过程中，通过send一个延迟的handler，延迟时间为设置的anr时间，如果到时间，没有执行完任务/没有移除handler任务，就会调用appNotResponding方法，触发anr</p><blockquote><p>主要在AMS和WMS中进行控制，通过获取/data/anr/trace.txt进行分析</p></blockquote><h4 id="什么情况下会导致oom？"><a href="#什么情况下会导致oom？" class="headerlink" title="什么情况下会导致oom？"></a>什么情况下会导致oom？</h4><ol><li>大图片存储导致oom，内存溢出<ul><li>使用软弱引用，当内存不足时，删除Bitmap缓存</li><li>调用Bitmap.recycle()快速回收，但是慎用，容易报错</li></ul></li><li>除了程序计数器之外的内存模型都会发生oom<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError:死循环/递归调用产生的</span><br></pre></td></tr></table></figure></li><li>关闭流文件、数据库cursor等对象关闭</li><li>创建很多线程会导致oom，因为开辟线程需要对虚拟机栈，本地方法栈，程序计数器，开辟内存，线程数量过多，会导致OOM</li></ol><h4 id="如何将应用设置为Launcher？"><a href="#如何将应用设置为Launcher？" class="headerlink" title="如何将应用设置为Launcher？"></a>如何将应用设置为Launcher？</h4><p>设置HOME，DEFAULT。</p><h4 id="MVC-MVP-MVVM"><a href="#MVC-MVP-MVVM" class="headerlink" title="MVC,MVP,MVVM"></a>MVC,MVP,MVVM</h4><p><a href="https://blog.csdn.net/lmj623565791/article/details/46596109">浅谈MVP in Android</a></p><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><ul><li>View：对应于布局文件</li><li>Model：业务逻辑和实体模型</li><li>Controller：对应于Activity</li></ul><p><strong>缺点</strong>：</p><ol><li>Controller（Activity）中处理的逻辑过于繁重，原因是在Activity有太多操作View的代码，View和Controller绑定太过紧密</li></ol><blockquote><p>android中算不上mvc模式，Activity可以叫View层，也可以叫Controller层，所有代码基本都在Activity中</p></blockquote><h5 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h5><ul><li>View 对应于Activity，负责View的绘制以及与用户交互</li><li>Model 依然是业务逻辑和实体模型</li><li>Presenter 负责完成View于Model间的交互</li></ul><p><img src="http://img-blog.csdn.net/20150622212916054" alt="img"></p><p>因为Activity任务过于繁重，所以在Activity中提炼出一个Presenter层，该层主要通过接口和View层交互，同时获得View层的反馈</p><p><strong>优点</strong></p><ol><li>大大减轻了Activity的逻辑，将View和Presenter做分离，让项目更加简单明确</li></ol><p><strong>缺点</strong></p><ol><li>每个功能需要添加一个Presenter类，添加各种借口，增加开发量</li><li>Presenter层持有Activity层的引用，需要注意内存泄漏或空指针的问题</li></ol><h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><ol><li>View：View层</li><li>ViewModel层：JetPack中的ViewModel组件，配合LiveData+DataBinding，保证View和ViewModel之间的交互，双向绑定，数据的更新可以实时绑定到界面中。</li><li>Model层：数据层</li></ol><p>ViewModel层中代替了Presenter的作用，里边做具体的逻辑，ViewModel与Activity的绑定通过反射构建，通过LiveData达到响应式，在Activity中调用ViewModel的逻辑，并实时更新到界面。</p><p><strong>优点</strong></p><ol><li>ViewModel+LiveData同Activity的生命周期绑定，当Avtivity不存在后，会销毁ViewModel，减少内存泄漏</li><li>提供Activity中多个Fragment的数据共享和逻辑调用</li><li>提供响应式编程，提供解决问题新方向</li><li>优秀的架构思想+官方支持=强大</li><li>代码量少，双向绑定减少UI的更新代码</li></ol><p><strong>缺点</strong></p><ol><li>降低了View的复用性，因为添加了很多DataBinding的代码，绑定到Activity中</li><li>难以定位bug，流程许多地方都是自动化更新，执行，无法确定当中哪一个环节出现问题（数据逻辑问题还是界面显示问题）</li></ol><h4 id="SharedPreferences-commit-apply使⽤区别"><a href="#SharedPreferences-commit-apply使⽤区别" class="headerlink" title="SharedPreferences commit apply使⽤区别"></a>SharedPreferences commit apply使⽤区别</h4><ol><li><p>commit具有回调</p></li><li><p>apply将信息推送到主存，异步提交到文件，commit同步提交到文件</p></li></ol><h4 id="Bitmap解析"><a href="#Bitmap解析" class="headerlink" title="Bitmap解析"></a>Bitmap解析</h4><h5 id="Bitmap是怎么存储图片的？"><a href="#Bitmap是怎么存储图片的？" class="headerlink" title="Bitmap是怎么存储图片的？"></a>Bitmap是怎么存储图片的？</h5><p>Bitmap是图片在内存中的表达形式，存储的是有限个像素点，每个像素点存储着ARGB值，代表每个像素所代表的颜色（RGB）和透明度（A）</p><h5 id="Bitmap图片的内存是怎么计算的？"><a href="#Bitmap图片的内存是怎么计算的？" class="headerlink" title="Bitmap图片的内存是怎么计算的？"></a>Bitmap图片的内存是怎么计算的？</h5><p>图片内存 = 宽 <em> 高 </em> 每个像素所占字节<br>每个像素所占字节和Bitmap.Config有关：</p><ul><li>ARGB_8888：常用类型，总共32位，<strong>4</strong>个字节，分别表示透明度和RGB通道。</li><li>ARGB_4444：<strong>2</strong>个字节</li><li>RGB_565：16位，<strong>2</strong>个字节，只能描述RGB通道。</li><li>ALPHA_8：<strong>1</strong>个字节</li></ul><h5 id="Bitmap加载优化？不改变图片质量的情况下怎么优化？"><a href="#Bitmap加载优化？不改变图片质量的情况下怎么优化？" class="headerlink" title="Bitmap加载优化？不改变图片质量的情况下怎么优化？"></a>Bitmap加载优化？不改变图片质量的情况下怎么优化？</h5><ol><li>修改Bitmap.Config，降低bitmap每个像素所占用的字节大小，替换格式为RGB_565，这样，内存直接缩小1倍</li><li>修改inSampleSize采样率，降低图片的大小，不影响图片的质量，控制每隔inSampleSize个像素进行一次采集</li></ol><blockquote><p>inSampleSize为1时，为原图大小。大于1时，比如2时，宽高就会缩小为原来的1/2</p><p>inSampleSize进行2的幂取整操作，1，2，4，8等</p></blockquote><h5 id="Bitmap内存复用怎么实现？"><a href="#Bitmap内存复用怎么实现？" class="headerlink" title="Bitmap内存复用怎么实现？"></a>Bitmap内存复用怎么实现？</h5><p>如果在一个imageView中加载多种不同的Bitmap图片，如果频繁的去创建bitmap，获取内存，释放内存，从而导致大量GC，内存抖动。<br>在使用Bitmap时，使用inBitmap配合inMutable参数，复用Bitmap内存。在4.4之前，只能复用内存大小相同的Bitmap，4.4之后，新Bitmap内存大小小于或等于复用Bitmap空间的，可以复用</p><h5 id="高清大图如何加载？"><a href="#高清大图如何加载？" class="headerlink" title="高清大图如何加载？"></a>高清大图如何加载？</h5><p>使用BitmapRegionDecoder属性进行部分加载，根据界面滑动，不断更新部分图片的位置</p><h5 id="intent可以传递bitmap吗？"><a href="#intent可以传递bitmap吗？" class="headerlink" title="intent可以传递bitmap吗？"></a>intent可以传递bitmap吗？</h5><p>可以，bitmap是parcelable序列化过的，也可以转化成byte[]进行传递</p><p>大小受限1M，因为binder的大小是1M，binder的线程数不大于16</p><h5 id="Bitmap内存在各个android版本的存储？"><a href="#Bitmap内存在各个android版本的存储？" class="headerlink" title="Bitmap内存在各个android版本的存储？"></a>Bitmap内存在各个android版本的存储？</h5><p><a href="https://www.jianshu.com/p/d5714e8987f3">Android Bitmap变迁与原理解析（4.x-8.x）</a></p><ol><li>2.3版本之前：存储在本地内存中，不及时回收（recycler()方法），会触发OOM</li><li>2.3版本到7.0版本：像素数据和对象数据都存储在堆中</li><li>8.0以后：将对象存储在本地内存中（非java内存），通过NativeAllocationRegistry对bitmap进行回收<blockquote><p>Fresco 对这个有详细的描述</p></blockquote></li></ol><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>深拷贝：拷贝堆区中值<br>浅拷贝：拷贝堆区中的引用地址</p><h4 id="创建一个对象的方式？"><a href="#创建一个对象的方式？" class="headerlink" title="创建一个对象的方式？"></a>创建一个对象的方式？</h4><ol><li>使用new关键字创建</li><li>Class.newInstance反射创建</li><li>Constructor.newInstance反射创建</li><li>利用clone方法实现（浅拷贝）</li><li>通过反序列化实现（深拷贝）</li></ol><h4 id="界面卡顿的原因"><a href="#界面卡顿的原因" class="headerlink" title="界面卡顿的原因"></a>界面卡顿的原因</h4><ol><li>UI线程存在耗时操作</li><li>视图渲染时间过长，导致卡顿</li><li>频繁gc，内存抖动</li></ol><h4 id="冷启动、温启动、热启动"><a href="#冷启动、温启动、热启动" class="headerlink" title="冷启动、温启动、热启动"></a>冷启动、温启动、热启动</h4><p>冷启动：app首次启动，或者上次正常关闭后的启动，需要创建app的进程</p><ol><li>启动系统进程。加载启动app进程，创建app进程</li><li>启动app进程任务。渲染屏幕，加载布局等</li></ol><p>温启动：系统进程存在，app非正常关闭，只需要执行第二步，需要创建Activity或者重新布局等</p><p>热启动：热启动就是App进程存在，并且Activity对象仍然存在内存中没有被回收。所以热启动的开销最少，这个过程只会把Activity从后台展示到前台，无需初始化，布局绘制等工作</p><blockquote><p>冷启动可以认为是android标准启动流程</p></blockquote><h4 id="Android类加载器"><a href="#Android类加载器" class="headerlink" title="Android类加载器"></a>Android类加载器</h4><p>Android从ClassLoader中派生出两个类加载器：PathClassLoader和DexClassLoader</p><p>DexClassLoader：是一个可以从包含classes.dex实体的.jar或.apk文件中加载classes的类加载器。可以用于实现dex的动态加载、代码热更新等等。</p><p>PathClassLoader：可以操作在本地文件系统的文件列表或目录中的classes</p><blockquote><p>DexClassLoader：能够加载未安装的jar/apk/dex<br>PathClassLoader：只能加载系统中已经安装过的apk</p></blockquote><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>当一个类需要被初始化加载时，总会先把加载请求传递给父加载器，最终会传递到最高层加载器进行加载。父类加载器会检查是否加载过该类，如果没有加载过，则加载，若无法加载，会传递给子类加载器加载。</p><h5 id="为何要使用双亲委派"><a href="#为何要使用双亲委派" class="headerlink" title="为何要使用双亲委派"></a>为何要使用双亲委派</h5><ol><li>首先明确，jvm认为不同加载器加载的类为两个不同的对象，所以为了系统安全性，需要保证相同的类要被同一个类加载器加载</li><li>避免了重复加载，如果父类加载过，直接使用父类加载过的类。</li></ol><h5 id="能不能自己写个类叫java-lang-System？"><a href="#能不能自己写个类叫java-lang-System？" class="headerlink" title="能不能自己写个类叫java.lang.System？"></a>能不能自己写个类叫java.lang.System？</h5><p>不可以，通过双亲委派该类名被加载为系统类，不会加载自己写的类。<br>如果非要实现这个效果，需要绕过双亲委派机制，实现自己的类加载器进行加载</p><h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><p><img src="https://upload-images.jianshu.io/upload_images/1115031-70a55fecac4da43b.png" width="60%"/></p><p><strong>PathClassLoader</strong>:只能加载已经安装到Android系统中的apk文件（/data/app目录），是Android默认使用的类加载器。</p><p><strong>DexClassLoader</strong>:可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现热修复的重点。</p><p>阿里系：DeXposed、andfix：从底层二进制入手（c语言）。阿里andFix hook 方法在native的具体字段。<br>art虚拟机上是一个叫ArtMethod的结构体。通过修改该结构体上有bug的字段来达到修复bug方法的目的，<br>但这个artMethod是根据安卓原生的结构写死的，国内很多第三方厂家会改写ArtMethod结构，导致替换失效。<br>腾讯系：tinker：从java加载机制入手。qq的dex插装就类似上面分析的那种。通过将修复的dex文件插入到app的dexFileList的前面，达到更新bug的效果，但是不能及时生效，需要重启。<br>但虚拟机在安装期间会为类打上CLASS_ISPREVERIFIED标志，是为了提高性能的，我们强制防止类被打上标志是否会有些影响性能<br>美团robust：是在编译器为每个方法插入了一段逻辑代码，并为每个类创建了一个ChangeQuickRedirect静态成员变量，当它不为空会转入新的代码逻辑达到修复bug的目的。<br>优点是兼容性高,但是会增加应用体积</p><ol><li>startActivity 的时候最终会走到 AMS 的 startActivity 方法</li><li>系统会检查一堆的信息验证这个 Activity 是否合法。</li><li>然后会回调 ActivityThread 的 Handler 里的 handleLaunchActivity</li><li>在这里走到了 performLaunchActivity 方法去创建 Activity 并回调一系列生命周期的方法</li><li>创建 Activity 的时候会创建一个 LoaderApk对象，然后使用这个对象的 getClassLoader 来创建 Activity</li><li>我们查看 getClassLoader() 方法发现返回的是 PathClassLoader，然后他继承自 BaseDexClassLoader</li><li>然后我们查看 BaseDexClassLoader 发现他创建时创建了一个 DexPathList 类型的 pathList对象，然后在 findClass 时调用了 pathList.findClass 的方法</li><li>然后我们查看 DexPathList类 中的 findClass 发现他内部维护了一个 Element[] dexElements的dex 数组，findClass 时是从数组中遍历查找的</li></ol><h4 id="sqlite怎么保证数据可见性和线程安全性？"><a href="#sqlite怎么保证数据可见性和线程安全性？" class="headerlink" title="sqlite怎么保证数据可见性和线程安全性？"></a>sqlite怎么保证数据可见性和线程安全性？</h4><p>sqlite不支持多个数据库连接进行写操作，但是使用同一个SQLiteHelper连接，可以进行多线程读和写，同一个连接下，sqlite内部有锁机制，不会出现异常，由于有锁的机制，所以是阻塞的，并不是真正的并发</p><p>延伸：SharedPreference是线程安全的，内部使用sychronized的</p><h4 id="bundle的数据结构，为什么intent要使用bundle？"><a href="#bundle的数据结构，为什么intent要使用bundle？" class="headerlink" title="bundle的数据结构，为什么intent要使用bundle？"></a>bundle的数据结构，为什么intent要使用bundle？</h4><p>内部存储ArrayMap，key是int数组，value是object数组，使用Bundle传递对象和对象数组的时候会默认使用序列化，不用我们做处理。</p><p>key是hash值，value[]是存储的数据key值，和value值，采用二分法排序，使用二分法查找</p><p>优势：省内存，小数据上占优势。</p><h4 id="大图传输"><a href="#大图传输" class="headerlink" title="大图传输"></a>大图传输</h4><blockquote><p>文件描述符是一个简单的整数，用以标明每一个被进程所打开的文件和socket。第一个打开的文件是0，第二个是1，依此类推。<br>socket：如果是网络中，会使用ip号+port号方式为<strong>套接字地址</strong>，但是如果同一台主机上两个进程间通信用套接字,还需要指定ip地址,有点过于繁琐. 这个时候就需要用到UNIX Domain Socket, 简称UDS,UDS不需要IP和Port, 而是通过一个文件名来表示<br>（int,  (AF_UNIX,文件路径)）</p><ol><li>直接传输Bitmap，Bitmap实现Parcelable序列化，所以可以直接在内存中传输，所以可以直接通过Bundle传输过去，但是限制大小为1M。</li><li>可以存储在文件中，传输一个文件路径过去</li><li>使用Bundle的putBinder方法，通过Binder发送，其实putBinder传输过去的只是一个文件描述符fd，获取到fd后，从共享内存中获取到Bitmap</li></ol></blockquote><blockquote><p>而用Intent/bundle直接传输的时候，会禁用文件描述符fd，只能在parcel的缓存区中分配空间来保存数据，所以无法突破1M的大小限制</p></blockquote><h4 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h4><h5 id="android调用js代码"><a href="#android调用js代码" class="headerlink" title="android调用js代码"></a>android调用js代码</h5><ol><li>通过loadUrl的方法直接调用js方法，会刷新页面，没有返回值</li><li>evaluateJavascript()方法，android4.4以后使用，不会刷新页面，有返回值</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/944365-30f095d4c9e638fd.png" width="100%" /></p><h5 id="js调用android代码"><a href="#js调用android代码" class="headerlink" title="js调用android代码"></a>js调用android代码</h5><ol><li><p>addJavascriptInterface()方法进行对象映射，<code>存在漏洞</code> 4.2以下</p><p>创建一个类，使用@JavascriptInterface注解标识方法，使用addJavascriptInterface()为js创建对象</p><p>漏洞：</p><ul><li>通过反射获取到这个类的所有方法和系统类，进行获取信息泄漏</li><li>4.2后添加注解避免漏洞攻击</li></ul></li><li><p>webViewClient.shouldOverrideUrlLoading()拦截url    <code>不存在漏洞</code></p><p>在js中传入url，携带参数，拼接到url中，在shouldOverrideUrlLoading获取</p></li><li><p>触发js弹窗向android发消息。之后再回调中通过2方式的url传输消息</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/944365-8c91481325a5253e.png" width="100%"/></p><p>内存泄漏：加弱引用即可</p><h4 id="要实现可以拖动的View该怎么做？"><a href="#要实现可以拖动的View该怎么做？" class="headerlink" title="要实现可以拖动的View该怎么做？"></a>要实现可以拖动的View该怎么做？</h4><p>使用windowManager的updateViewLayout方法吗，实时传入手指的坐标就可以移动window<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">btn.setOnTouchListener &#123; v, event -&gt;</span><br><span class="line">    <span class="keyword">val</span> index = event.findPointerIndex(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">        ACTION_MOVE -&gt; &#123;</span><br><span class="line">            windowParams.x = event.getRawX(index).toInt()</span><br><span class="line">            windowParams.y = event.getRawY(index).toInt()</span><br><span class="line">            windowManager.updateViewLayout(btn, windowParams)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Android新知识"><a href="#Android新知识" class="headerlink" title="Android新知识"></a>Android新知识</h2><h4 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h4><p>响应式编程：根据响应去触发动作</p><p>使用观察者模式调用，使用于逻辑复杂的操作可以使用Rxjava做异步处理</p><ol><li>按钮短300ms内不允许重复点击</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RxView.clicks(button).debounce(<span class="number">300</span>, TimeUnit.MILLISECONDS).subscribe(<span class="keyword">new</span> Action1&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Void aVoid)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;clicked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>轮询，定时执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每隔两秒执行一次</span></span><br><span class="line">   Observable.interval(<span class="number">2</span>, <span class="number">2</span>, TimeUnit.SECONDS).subscribe(<span class="keyword">new</span> Action1&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//TODO WHAT YOU WANT</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>消息传递，可取代EventBus</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//发布消息</span><br><span class="line">RxBus.getInstance().post(&quot;SomeChange&quot;);</span><br><span class="line"></span><br><span class="line">//接收消息并处理</span><br><span class="line">Subscription mSubscription = RxBus.getInstance().toObserverable(String.class).subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(String s) &#123;</span><br><span class="line">                handleRxMsg(s);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//取消订阅</span><br><span class="line">mSubscription.unsubscribe();</span><br></pre></td></tr></table></figure><h4 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h4><p>一系列辅助android开发者的使用工具，统称Jetpack</p><p>提供新组件，比如导航组件，分页组件，切片组件等，例如mvvm中的LiveData，viewmodel都属于Jetpack组件</p><p>paging,room,livedata,viewmodel,lifecycler,compose,databinding,viewbinding</p><p>Jetpack在androidx中进行发布，androidx也属于Jetpack</p><h4 id="AndroidX"><a href="#AndroidX" class="headerlink" title="AndroidX"></a>AndroidX</h4><p>androidx空间中包含Jetpack库，</p><p>之前使用android-support-v4(最低支持1.6) 和 android-support-v7（最低支持2.1）库做支持，androidx提出后，对support-v4 和 support-v7库不再做维护</p><h4 id="MVVM-1"><a href="#MVVM-1" class="headerlink" title="MVVM"></a>MVVM</h4><p><img src="https://upload-images.jianshu.io/upload_images/1813550-356c0729e43b8148.jpg" width="70%"/></p><p>LiveData使用观察者模式观察生命周期，在onStart和onResume时回调onChanged，确保liveData对象内存泄漏。</p><p>DataBind   双向绑定，将view和model进行绑定，一方变化会导致另一方变化。</p><p>缺点：</p><ol><li>难以排查bug，不知道是view的bug还是model的bug，bug会转移</li><li>不能复用view，因为绑定不同的model</li></ol><h4 id="LiveData-ViewModel替换EventBus"><a href="#LiveData-ViewModel替换EventBus" class="headerlink" title="LiveData+ViewModel替换EventBus"></a>LiveData+ViewModel替换EventBus</h4><h4 id="ViewBinding替换Butterknife"><a href="#ViewBinding替换Butterknife" class="headerlink" title="ViewBinding替换Butterknife"></a>ViewBinding替换Butterknife</h4><h4 id="组件化，插件化，热修复"><a href="#组件化，插件化，热修复" class="headerlink" title="组件化，插件化，热修复"></a>组件化，插件化，热修复</h4><h4 id="Kotlin理解"><a href="#Kotlin理解" class="headerlink" title="Kotlin理解"></a>Kotlin理解</h4><h4 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h4><h1 id="Java基础篇"><a href="#Java基础篇" class="headerlink" title="Java基础篇"></a>Java基础篇</h1><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h4><p>不管指令怎么重排序，在单线程下执行结果不能改变</p><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>一个操作的执行结果需要对另一个操作可见，则两个操作之间必须存在happens-before关系，主要强调在多线程情况中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlDep</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">      a = <span class="number">1</span>; <span class="comment">//1</span></span><br><span class="line">      flag = <span class="keyword">true</span>; <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(flag)&#123; <span class="comment">//3</span></span><br><span class="line">          <span class="keyword">int</span> i = a * a; <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在两个线程A，B，当A执行init发生了重排序，即先执行2，在执行1，当执行2时，B执行了use方法，但是B拿到的a还是0，所以i = 0，而正确的答案应该是i = 1</p><p>解决上面问题有两种方案：</p><ol><li>内存屏障（volatile），禁止关于a的指令重排</li><li>synchronized锁，锁住该对象或者该类</li></ol><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p><img src="https://img-blog.csdnimg.cn/20210302003053823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1NjAwMA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>本地方法栈，程序计数器，虚拟机栈都是线程私有的，不存在线程安全<br>方法区和堆区，所有线程共享的，需要加锁保证线程安全</p><ul><li>程序计数器：占用内存小，线程私有，生命周期与线程相同，大致为字节码行号指示器</li><li>虚拟机栈：java方法执行的内存模型，包含局部变量表，操作栈，动态链接，方法出口等信息，用于管理java方法的调用，使用连续的内存空间</li><li>本地方法栈：本地方法栈用于管理<strong>本地方法</strong>的调用</li></ul><hr><ul><li>堆区：与jvm生命周期相同，存储所有的对象实例（包括数组）</li><li>方法区：存储已被加载的类信息，常量池，静态变量，即使编译器编译后的代码</li></ul><blockquote><p>静态变量创建在方法区，程序结束后回收，与堆无关</p></blockquote><blockquote><p>stack的大小默认为1M，如果是递归调用，大概只支持800多次</p></blockquote><h4 id="JVM内存模型的三大特性"><a href="#JVM内存模型的三大特性" class="headerlink" title="JVM内存模型的三大特性"></a>JVM内存模型的三大特性</h4><p><strong>原子性</strong>：多线程情况下，一旦一个线程开始执行，就不能被其他线程干扰</p><p>可见行：当一个线程修改了变量后及时更新到主存</p><p>有序性：处理器在执行运算的时候，会对程序代码进行乱序执行优化，也叫做重排序优化</p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p><img src="https://pic4.zhimg.com/80/v2-40cbacd540b1555badbbf89132aace5f_1440w.jpg" alt="img"></p><h4 id="如何判断对象是个垃圾？"><a href="#如何判断对象是个垃圾？" class="headerlink" title="如何判断对象是个垃圾？"></a>如何判断对象是个垃圾？</h4><ol><li>引用计数法<br>要操作对象必须使用引用，所以通过引用计数来判断对象是否需要被回收。因为无法解决循环引用的问题，所以JAVA中并没有采用这种方式（python中采用）</li><li>可达性分析法<br>为了解决循环引用的问题，使用可达性分析。通过一系列的”GC ROOT”对象作为起点进行搜索，如果在”GC ROOT”和对象之间没有可达路径，那么该对象为不可达对象，并标记一次，标记两次后就会被回收。<br>“GC ROOT”：<ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）；</li><li>方法区中的常量引用的对象；</li><li>方法区中的类静态属性引用的对象；</li><li>本地方法栈中JNI（Native方法）的引用对象。</li><li>活跃线程对象<blockquote><p>垃圾回收机制是针对堆区的回收</p></blockquote></li></ul></li></ol><h4 id="比较常见的将对象判定为可回收变量"><a href="#比较常见的将对象判定为可回收变量" class="headerlink" title="比较常见的将对象判定为可回收变量"></a>比较常见的将对象判定为可回收变量</h4><ol><li>某个引用对象为null<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li>已经指向某个对象的引用指向新的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">obj1 = obj2;</span><br></pre></td></tr></table></figure></li><li>局部引用所指向的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">.....</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>循环每执行完一次，生成的Object对象都会成为可回收的对象。</li><li>只有弱引用修饰的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wr = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ol><li>标记清除算法<br>将可回收对象标记后指定删除对象<br>缺点：产生大量内存碎片</li><li>复制算法<br>为了解决内存碎片的问题，提出复制算法。把内存按容量分成两份，当一份用完了，将还存活的对象复制在另一块对象中，把已使用的内存空间一次性清理掉<br>缺点：空间上的两倍消耗，可使用内存空间减半</li><li>标记整理算法<br>为了充分利用内存空间，在标记回收对象后，将存活对象向一端移动，然后清理掉端边界以外的内存</li><li>分代回收算法<br>将内存分为新生代，老年代和永久代。<br>新生代：<br>使用复制算法，回收大量对象，但不是按照1:1分配内存空间，将内存空间分为3份，较大的Eden和两块较小的Survivor空间，每次使用Eden和一块Survivor，当进行回收时，会将Eden和一块Survivor中存活的对象复制到另一个Survivor中。（比例为8:1:1）<br>老年代：<br>使用标记整理算法（和标记清除算法—-垃圾收集器种说），回收少量对象<br>永久代：<br>存在于方法区，不属于堆区，用来存储class类，常量，方法描述等，对永久代的回收主要包含两种：废弃常量和无用的类</li></ol><p>注意: 在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</p><blockquote><p>新生代 = 1/3的堆空间大小，老年代 = 2/3的对空间大小</p></blockquote><blockquote><p>新创建的对象都是在Eden区，<strong>大对象</strong>因为在新生代复制会影响性能，则直接创建在老年代</p></blockquote><blockquote><p>在Survivor中复制一次，就年龄计数+1，当年龄大大于15岁时，会移动到老年区</p></blockquote><h4 id="jdk7和jdk8上的JVM内存结构的变化？"><a href="#jdk7和jdk8上的JVM内存结构的变化？" class="headerlink" title="jdk7和jdk8上的JVM内存结构的变化？"></a>jdk7和jdk8上的JVM内存结构的变化？</h4><p>jdk7:</p><ol><li><img src="https://pic4.zhimg.com/80/v2-d3426c78d9d7f20874b25377bd37c193_720w.jpg" alt="堆和方法区的物理存储"><br>在物理存储上，堆区和方法区是连续的，但是在逻辑上是分离的，因为物理存储上是存在一起的，所以在Full GC时，会触发堆永久代的回收</li></ol><p>jdk8:</p><ol><li>取消永久代，将类的结构等信息放入Native内存区，常量池和静态变量/全局变量存储在堆区</li><li>方法区存在元空间中，Native内存区就是元空间区</li></ol><blockquote><p>Native Memory（本地内存），空间不足，不会触发gc</p></blockquote><h4 id="为什么使用元空间替代永久代？"><a href="#为什么使用元空间替代永久代？" class="headerlink" title="为什么使用元空间替代永久代？"></a>为什么使用元空间替代永久代？</h4><p>避免永久代的OOM发生，因为需要加载的类的总数，方法总数难以确定，分配的空间也难以确定，为了避免OOM，使用元空间，理论上可以获得本地内存中所有可用的空间</p><h4 id="字符常量池存在那？"><a href="#字符常量池存在那？" class="headerlink" title="字符常量池存在那？"></a>字符常量池存在那？</h4><p>1.6：存储在方法区<br>1.7：对象存储在堆区中，引用存在字符串常量池，都在堆中<br>1.8：存储在堆区中</p><h4 id="运行时常量池在哪？"><a href="#运行时常量池在哪？" class="headerlink" title="运行时常量池在哪？"></a>运行时常量池在哪？</h4><p>1.8的时候移动到元空间中，之前都在方法区中</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p><img src="https://pic3.zhimg.com/80/v2-f5426caf176fac7d2d7edcf43e127eaa_1440w.jpg" alt="img"><br>java种使用的是HotSpot虚拟机，HotSpot一共7种垃圾收集器，大致分为3类：<br>新生代收集器：Serial，ParNew，Parllel Scavenge<br>老年代收集器：Serial Old，CMS，Parllel Old<br>回收整个堆的G1收集器</p><ul><li>Serial（复制）：新生代单线程收集器，在标记和清理都是单线程，优点是效率高，缺点是停留时间长。</li><li>ParNew（复制）：新生代并行收集器，Serial的多线程版本，在多核cpu环境下比Serial表现更好（只有他能和CMS配合）</li><li>Parllel Scavenge（复制）：新生代并行收集器，追求高吞吐量，高效利用CPU。尽快完成程序的运算任务，适合后台应用等对交互场景要求不高的场景。<br>吞吐量 = 用户线程时间/（用户线程时间+GC线程时间），缩短工作线程的等待时间</li><li>Serial Old（标记-整理）：老年代的单线程收集器，老年版的单线程</li><li>Parllel Old（标记-整理）：老年代的并行收集器，老年版的Parllel Scavenge</li><li>CMS（Concurrent Mark Sweep）（标记-清除）：老年代并行收集器，以获取最短回收停顿时间为目标，具有高并发，低停顿的特点。追求最短GC回收停顿时间，就是GC的时间更短<br>缺点：<ol><li>对CPU资源异常敏感，应用程序变慢，吞吐率下降</li><li>无法处理浮动垃圾。因为在标记和清除的时候，工作线程是运行的，所以期间会产生新的垃圾，但是本次无法回收。</li><li>产生大量内存碎片，会提前触发Full GC</li></ol></li><li>G1（Garbage First）(标记-整理)：java并行收集器，G1的回收范围包含新生代和老年代。他用来作为下一代的收集器，保存新生代和老年代的概念，但是内部将Java堆划分为多个大小相等Region独立区域<br>优点：<ol><li>并行和并发。使用多个CPU缩短回收停顿时间，与用户线程并发执行</li><li>分带收集。独立去管理整个堆区间，能够采用不同的方式去处理<strong>新创建对</strong>象和<strong>已经存活了一段时间、熬过多次GC的旧对象</strong>，以获取更好的收集效果</li><li>使用标记-整理算法。无内存碎片产生。</li><li>可预测的停顿。可以使开发者制定一个时间长度，在该时间长度内，需要完成垃圾回收。</li></ol></li></ul><blockquote><p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合</p></blockquote><h4 id="gc的种类和方式"><a href="#gc的种类和方式" class="headerlink" title="gc的种类和方式"></a>gc的种类和方式</h4><ol><li>Minor GC：新生代GC<ul><li>当Eden（[‘id(ə)n]）区放满的时候，触发Minor GC</li></ul></li><li>Major GC：老年代GC</li><li>Full GC：全局GC（青年+老年）<ul><li>System.gc()方法有可能触发Full GC</li><li>老年代存储满了</li><li>永久代存储满了，触发Full GC，针对常量池的回收和类型的卸载</li><li>Minor GC后放入老年代大小&gt;老年代可用内存，即老年代放不下</li><li>Minor GC后，放入一个1区中时，放不下，溢出来部分放入老年区，老年区放不下就会触发Full GC<blockquote><p>GC会触发“stop-the-world”，即工作线程全部关闭，进行gc回收，当gc回收结束后，才会执行任务</p></blockquote></li></ul></li></ol><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><a href="https://blog.csdn.net/qq_36520235/article/details/82417949">（1）美团面试题：Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析</a></p><h4 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h4><p>影响性能的两个参数：</p><ul><li>初始容量：2的幂，默认是16</li><li>加载因子：什么时候扩容的标志，默认0.75，即16*0.75=12的时候开始hashmap扩容（容量为原来的2倍）</li></ul><ul><li>最大容量：2的30次方，如果大于，则使用2的30次方的大小</li><li>可以存储key == null，value == null，key == null则存储在table[0]位置</li><li>删除元素的本质是“删除单向链表的节点”</li><li>Entry是单向链表</li></ul><p>计算key的hash值，并将hash值添加到对应的链表中，若key存在，则更新vlaue值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">//计算出来的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;     <span class="comment">//key</span></span><br><span class="line">    V value;         <span class="comment">//value</span></span><br><span class="line">    Node&lt;K,V&gt; next;  <span class="comment">//链表next引用</span></span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和修改</p><ul><li>因为是非synchronized的，非线程安全，所以比较快</li><li>HashMap可以接受null键和null值</li></ul><h4 id="数组下标index的计算过程"><a href="#数组下标index的计算过程" class="headerlink" title="数组下标index的计算过程"></a>数组下标index的计算过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组长度-1 &amp; hash值</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>同等于hash值对数组长度的求余</p><h4 id="描述一下具体的put过程"><a href="#描述一下具体的put过程" class="headerlink" title="描述一下具体的put过程"></a>描述一下具体的put过程</h4><ol><li>对key求hash值，然后计算数组下标</li><li>如果数组下标没有碰撞，将Node放置在数组中</li><li>如果碰撞，将Node以链表的形式连接在后面</li><li>如果链表长度超过阈值（8），将链表转化为红黑树，链表长度低于6，则将红黑树转回链表</li><li>如果节点存在，则替换旧值</li><li>如果数组快满了（最大容量16*加载因子0.75），就需要resize（扩容两倍）</li></ol><h4 id="为什么选择6和8-？"><a href="#为什么选择6和8-？" class="headerlink" title="为什么选择6和8 ？"></a>为什么选择6和8 ？</h4><p>因为中间7的位置放置频繁的数据结构切换后，影响性能</p><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><ol><li>计算key的hash，在计算index值</li><li>在数组中查找index值，在比对key值，取出value，复杂度最好是O(1)，最坏为O(n)</li></ol><h4 id="为什么不直接使用红黑树？"><a href="#为什么不直接使用红黑树？" class="headerlink" title="为什么不直接使用红黑树？"></a>为什么不直接使用红黑树？</h4><p>空间和时间的选择，链短的时候空间上占用小，时间还好，转化为红黑树后，便于查找，但是耗费空间。</p><h4 id="处理hash冲突的方法有以下几种："><a href="#处理hash冲突的方法有以下几种：" class="headerlink" title="处理hash冲突的方法有以下几种："></a>处理hash冲突的方法有以下几种：</h4><ol><li>开放地址法（线性探测再散列（碰撞后，位置后挪，数组长度+x）x可为正数，二次探测再散列（数组长度+x的平方）x可为正负数，平方后均为正数）</li><li>再哈希法（多种计算哈希的方法，相同则替换方法，直到算出不重复的哈希值）</li><li>链地址法（链表）</li><li>建立公共溢出区（建立一个溢出表，存放冲突的数据）</li></ol><h4 id="HashMap的性能慢原因？"><a href="#HashMap的性能慢原因？" class="headerlink" title="HashMap的性能慢原因？"></a>HashMap的性能慢原因？</h4><ul><li>数据类型自动装箱问题</li><li>resize扩容重新计算index值和hashcode，重新赋值（1.7）<br>1.8后，扩容位置 = hash值 &amp; 数组长度，如果为0，则不动，反之则反</li></ul><h4 id="线程不安全会导致什么"><a href="#线程不安全会导致什么" class="headerlink" title="线程不安全会导致什么"></a>线程不安全会导致什么</h4><p>环状链表，resize（扩容）时头插法导致环形链表（1.7版本）</p><p>都存在数据丢失的问题数据丢失，1.8版本修复环形链表（尾插）</p><h4 id="HashMap中默认容量为什么是2的幂？"><a href="#HashMap中默认容量为什么是2的幂？" class="headerlink" title="HashMap中默认容量为什么是2的幂？"></a>HashMap中默认容量为什么是2的幂？</h4><p>因为如果不是2的幂，可能会造成更多的hash碰撞（index 下标碰撞）<br>假设n为17，n-1的二进制为10000，01001和01101算出的index值均为0<br>假设n为16，n-1的二进制为01111，01001和01101算出的index值不同</p><h4 id="hashcode计算原理"><a href="#hashcode计算原理" class="headerlink" title="hashcode计算原理"></a>hashcode计算原理</h4><p>对于int类型，hashcode为它本身，eg：int i = 1;   hashcode = 1;<br>对于对象来说，hashcode是内部地址和对象值的一个映射</p><h4 id="hash-算法原理"><a href="#hash-算法原理" class="headerlink" title="hash()算法原理"></a>hash()算法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到key的hashCode()，在将该值与该值的高16位（h无符号右移16位）进行亦或运算（相同为0，不同为1）</p><h4 id="HashTable的理解"><a href="#HashTable的理解" class="headerlink" title="HashTable的理解"></a>HashTable的理解</h4><p>put和get方法是用了synchronized修饰，锁住了整个map，同一时刻只有一个线程可以操作</p><p>不可以存储null值和null健</p><h4 id="SparseArray理解"><a href="#SparseArray理解" class="headerlink" title="SparseArray理解"></a>SparseArray理解</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>装箱，int数据类型—-&gt;Integer对象，拆箱，Integer对象—-&gt;int数据类型</p><p>默认容量是10</p><ul><li>key是int值（避免装箱问题），使用二分查找寻找key，同样也是用二分插入，从小到大排列好的</li><li>两个数组，一组存放key（int []），一组存放value(object [])</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mKeys[i] = key;</span><br><span class="line">mValues[i] = value;</span><br></pre></td></tr></table></figure><ul><li>如果冲突，直接替换value的值</li></ul><p>二分插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标处的值</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值小，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的中后部部分，所以当前下标取值为mid + 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               lo = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值大，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的前中部部分，所以当前下标取值为mid - 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               hi = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//数组中间处的值与要找的值相等，直接返回数组中部的下标mid</span></span><br><span class="line">               <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>第一个值放到最中间位置</p><p>第二个值如果大于中间的值放置在左边的中间位置</p><p>………….</p><p>put方法中，容量充足，计算key值所需存放的index，如果key相同，就直接替换value，如果不同，就insert数组，后续index元素后移，新key放置在index上</p><h5 id="较HashMap的优点"><a href="#较HashMap的优点" class="headerlink" title="较HashMap的优点"></a>较HashMap的优点</h5><ul><li>节省内存</li><li>性能更好，避免装箱问题</li><li>数据量不达到千级，key为int值，可以用SparseArray替换HashMap</li></ul><h4 id="SparseArray与HashMap的比较，应用场景是？"><a href="#SparseArray与HashMap的比较，应用场景是？" class="headerlink" title="SparseArray与HashMap的比较，应用场景是？"></a>SparseArray与HashMap的比较，应用场景是？</h4><ol><li>SparseArray采用的不是哈希算法，HashMap采用的是哈希算法</li><li>SparseArray采用的是两个一维数组分别用于存储键和值，HashMap采用的是一维数组+单向链表/红黑树</li><li>SparseArray key只能是int类型，而HashMap可以任何类型</li><li>SparseArray  key是有序存储（升序），而HashMap不是</li><li>SparseArray 默认容量是10，而HashMap默认容量是16</li><li>SparseArray 内存使用要优于HashMap，因为：<ul><li>SparseArray key是int类型，而HashMap是Object</li><li>SparseArray value的存储被不像HashMap一样需要额外的需要一个实体类（Node）进行包装</li></ul></li><li>SparseArray查找元素总体而言比HashMap要逊色，因为SparseArray查找是需要经过二分法的过程，而HashMap不存在冲突的情况其技术处的hash对应的下标直接就可以取到值</li></ol><p>针对上面与HashMap的比较，采用SparseArray还是HashMap，建议根据如下需求选取：</p><ol><li>如果对内存要求比较高，而对查询效率没什么大的要求，可以是使用SparseArray</li><li>数量在百级别的SparseArray比HashMap有更好的优势</li><li>要求key是int类型的，因为HashMap会对int自定装箱变成Integer类型</li><li>要求key是有序的且是升序</li></ol><h4 id="ArrayMap的理解"><a href="#ArrayMap的理解" class="headerlink" title="ArrayMap的理解"></a>ArrayMap的理解</h4><p>内部也使用二分算法进行存储和查找，设计上更多考虑了内存中的优化</p><ul><li>int []存储hash值，array[index]存储key，array[index+1]存储value</li></ul><blockquote><p>数据量最好在千级以内</p></blockquote><h4 id="ArrayMap和SparseArray怎么进行选取？"><a href="#ArrayMap和SparseArray怎么进行选取？" class="headerlink" title="ArrayMap和SparseArray怎么进行选取？"></a>ArrayMap和SparseArray怎么进行选取？</h4><ol><li>如果key为int，那么选取SparseArray进行存储， 不存在封/拆箱问题</li><li>如果key不为int，则使用ArrayMap</li></ol><h4 id="TreeMap的理解"><a href="#TreeMap的理解" class="headerlink" title="TreeMap的理解"></a>TreeMap的理解</h4><p>TreeMap是一个二叉树的结构，红黑树</p><p>不允许重复的key</p><p>TreeMap没有调优选项，因为其红黑树总保持在平衡状态</p><h4 id="TreeMap和HashMap的区别？"><a href="#TreeMap和HashMap的区别？" class="headerlink" title="TreeMap和HashMap的区别？"></a>TreeMap和HashMap的区别？</h4><ol><li>TreeMap由红黑树构成，HashMap由数组+链表/红黑树构成</li><li>HashMap元素没有顺序，TreeMap元素会根据可以进行升序排序</li><li>HashMap进行插入，查找，删除最好，TreeMap进行自然顺序便利或者自定义顺序便利比较好</li></ol><h4 id="ThreadLocal的理解"><a href="#ThreadLocal的理解" class="headerlink" title="ThreadLocal的理解"></a>ThreadLocal的理解</h4><p><a href="https://www.cnblogs.com/wang-meng/p/12856648.html#:~:text=ThreadLocalMap%20%E6%9C%89%E7%82%B9%E7%B1%BB%E4%BC%BC%20HashMap%20%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8F%AA%E6%98%AF%20HashMap%20%E6%98%AF%E7%94%B1%20%E6%95%B0%E7%BB%84%2B%E9%93%BE%E8%A1%A8%20%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E8%80%8C,key%20%E6%98%AF%20ThreadLocal%3C%3F%3E%20k%20%EF%BC%8C%E7%BB%A7%E6%89%BF%E8%87%AA%20WeakReference%20%EF%BC%8C%20%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E5%B8%B8%E8%AF%B4%E7%9A%84%E5%BC%B1%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E3%80%82">面试官：小伙子，听说你看过ThreadLocal源码？（万字图文深度解析ThreadLocal）</a></p><p>线程隔离，数据不交叉</p><ul><li>ThreadLocalMap，每个thread都存在一个变量ThreadLocalMap threadLocals</li><li>threadLocalMap中存在Entry，同ThreadLocal之间为弱引用关系</li><li>ThreadLocalMap中key为ThreadLocal的弱引用，value为Entry，内部为一个object对象</li><li>table默认大小为16，存在初始容量（16）和阈值（16*2/3）</li><li>在ThreadLocal中使用get()和set()方法初始化threadLocals</li><li>get、set、remove方法将key==null的数据清除</li><li>table是环形数组</li></ul><p>线性探测法避免哈希冲突，增量查找没有被占用的地方</p><p>通过hashcode计算索引位置，如果key值相同，则替换，不同就nextIndex，继续判断，直到插入数据</p><p>ThreadLocal就是管理每个线程中的ThreadLocalMap，所以线程隔离了。</p><h4 id="ThreadLocalMap的理解"><a href="#ThreadLocalMap的理解" class="headerlink" title="ThreadLocalMap的理解"></a>ThreadLocalMap的理解</h4><p>新建ThreadLcoal的时候，创建一个ThreadLocalMap对象，计算hash的时候使用0x61c88647这个值，他是黄金分割数，导致计算出来的hash值比较均匀，这样回大大减少hash冲突，内部在采用线性探测法解决冲突<br>set：</p><ol><li>根据key计算出数组索引值</li><li>遍历该索引值的链表，如果为空，直接将value赋值，如果key相等，直接更新value，如果key不相等，使用线性探测法再次检测。</li></ol><h4 id="ThreadLocal使用弱引用的原因"><a href="#ThreadLocal使用弱引用的原因" class="headerlink" title="ThreadLocal使用弱引用的原因"></a>ThreadLocal使用弱引用的原因</h4><p>key使用了弱引用，如果key使用强引用，那么当ThreadLocal的对象被回收了，但ThreadLocalMap还持有ThreadLocal的强引用，回导致ThreadLocal不会被回收，导致内存泄漏</p><h4 id="ThreadLocal的内存泄漏"><a href="#ThreadLocal的内存泄漏" class="headerlink" title="ThreadLocal的内存泄漏"></a>ThreadLocal的内存泄漏</h4><ul><li>避免使用static修饰ThreadLocal：延长生命周期，可能造成内存泄漏</li><li>ThreadLocal弱引用被gc回收后，则key为null，object对象没有被回收，只有当再次调用set，get，remove方法的时候才会清楚key为null的对象</li></ul><h4 id="ThreadLocalMap清理过期key的方式"><a href="#ThreadLocalMap清理过期key的方式" class="headerlink" title="ThreadLocalMap清理过期key的方式"></a>ThreadLocalMap清理过期key的方式</h4><ol><li>探测式清理<br>本该放在4的位置上的值，放到了7的位置上，当5过时后，将7的数据挪到5的位置上</li><li>启发式清理<br>遍历数组，清理数据</li></ol><h4 id="ConcurrentHashMap和HashMap的区别"><a href="#ConcurrentHashMap和HashMap的区别" class="headerlink" title="ConcurrentHashMap和HashMap的区别"></a>ConcurrentHashMap和HashMap的区别</h4><p>jdk  1.7 ReentrantLock+segments + hashEntry(不可变)</p><p><img src="https://upload-images.jianshu.io/upload_images/2843224-25151c12024f0bfb.png" width="50%"/></p><ul><li>线程安全，分段线程锁，hashtable是整段锁，所以性能有所提高</li><li>默认分配16个锁，比Hashtable效率高16倍</li><li>hashEnty是final的，不能被修改，只要被修改，该节点之前的链就要重新创建，采用头插插入，所以顺序反转</li><li>获取size，因为是多线程访问，所以size会获取三遍，如果前后两个相等就返回，假设不相等，就将Segment加锁后计算。</li></ul><p>jdk 1.8 ： synchronized +node+volatile+红黑树</p><p>put：</p><ol><li>根据key的hash值算出Node数组的相应位置</li><li>如果该Node不为空，且当前该节点不处于移动状态，则对节点加synchronized锁，进行遍历节点插入操作</li><li>如果是红黑树节点，向红黑树插入操作</li><li>如果大于8个，拓展为红黑树</li></ol><p>get：</p><ol><li>计算hash值，定位到该table索引位置，如果是首节点符合就返回</li><li>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，通知在新表中查找该节点，匹配就返回</li><li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</li></ol><p>1.7和1.8的区别：</p><ol><li><p>1.7：ReentrantLock+segments + hashEntry(不可变)</p><pre><code>1.8：synchronized +node+volatile+红黑树</code></pre></li><li><p>1.8的锁的粒度更低，锁的是一个链表（table[i]），而1.7锁的是一个小的hashmap（segement）</p></li><li>ReentrantLock性能比synchronized差</li></ol><p>扩容：</p><p>1.7下进行小HashMap（segement）扩容操作</p><p>1.8下使用synchrozied节点加锁，所以可以通过多个线程扩容处理。一个线程创建新的ConcurrentHashMap，并设置大小，多个线程将旧的内容添加到新的map中，如果添加过的内容就会设置标记，其他线程就不会处理</p><h4 id="为什么只有hashmap可以存储null值和null键"><a href="#为什么只有hashmap可以存储null值和null键" class="headerlink" title="为什么只有hashmap可以存储null值和null键"></a>为什么只有hashmap可以存储null值和null键</h4><p>因为hashmap是线程不安全的，而在其他中都是线程安全的，在多线程访问时，无法判断key为null是没有找到，还是key为null</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="常见锁"><a href="#常见锁" class="headerlink" title="常见锁"></a>常见锁</h3><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ol><li><p>公平锁/非公平锁</p><ul><li>公平锁：多个线程按照申请锁的顺序获取锁。</li><li>非公平锁：多个线程申请锁并不是按照顺序获取锁，有可能先申请后获取锁。（Synchronized）</li></ul><blockquote><p>ReentrantLock默认是非公平锁，通过构造传参可设置为公平锁。非公平锁的优点在于吞吐量比公平锁大</p></blockquote></li><li>可重入锁：又名递归锁，指在外层方法获取锁以后，在进入内层方法也会自动获取锁。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title">Exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title">Exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果不是可重入锁，那么setB方法不会被当前线程执行，容易造成死锁<blockquote><p>synchronized是可重入锁</p></blockquote></li><li>独享锁/共享锁<ul><li>独享锁：一个锁一次只能被一个线程所持有（ReentrantLock，synchronized）</li><li>共享锁：一个锁被多个线程所持有。（ReadWriteLock）</li></ul></li><li>互斥锁/读写锁<br>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。<br>互斥锁在Java中的具体实现就是ReentrantLock<br>读写锁在Java中的具体实现就是ReadWriteLock</li><li>乐观锁/悲观锁<ul><li>悲观锁：对同一数据的并发操作，一定会发生修改的。（利用各种锁实现）</li><li>乐观锁：对同一数据的并发操作，一定不会发生修改的。（无锁编程，CAS算法，自旋实现原子操作的更新）</li></ul></li><li>分段锁<br>是一种锁的设计，并不是具体的锁，在1.7版本的ConcurrentHashMap中，使用分段锁设计，该分段锁又称为Segment，map中每一个链表由ReentrantLock修饰</li><li><p>偏向锁/轻量级锁/重量级锁<br>这三种锁是描述synchronized的三种状态。</p><ul><li>偏向锁：一段同步代码一直被一个线程访问，那么会自动获取锁，降低获取锁的代价</li><li>轻量级锁：当锁是偏向锁的时候，被另一个线程访问，偏向锁会升级为轻量级锁，其他线程通过自旋的方式获取锁，不会阻塞，提高性能</li><li>重量级锁：在轻量级锁的基础上，自旋达到上限就会阻塞，升级为重量级锁，会让其他线程进入阻塞，影响性能。</li></ul><blockquote><p>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后无法降为偏向锁，这种升级无法降级的策略目的就是为了提高获得锁和释放锁的效率。</p></blockquote></li><li>自旋锁<br>获取锁的过程中，不会立即阻塞，会采用循环的方式获取锁，<strong>减少线程切换上下文的消耗</strong>，缺点是循环会<strong>消耗cpu</strong></li></ol><h4 id="java中常用锁的类型"><a href="#java中常用锁的类型" class="headerlink" title="java中常用锁的类型"></a>java中常用锁的类型</h4><ol><li>synchronized：非公平，悲观，独享，互斥，可重入，重量级锁</li><li>ReentrantLock：默认非公平（可公平），悲观，独享，互斥，可重入，重量级锁</li></ol><blockquote><p>CAS，全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM 只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p></blockquote><h3 id="synchronized和volatile"><a href="#synchronized和volatile" class="headerlink" title="synchronized和volatile"></a>synchronized和volatile</h3><h4 id="简述synchronized的原理"><a href="#简述synchronized的原理" class="headerlink" title="简述synchronized的原理"></a>简述synchronized的原理</h4><p>可见性：表示A修改的值对于B执行时可以看见A修改后的值</p><ul><li>内部使用<strong>monitorenter</strong>指令，同时只有一个线程可以获取monitor</li><li>未获取monitor的线程会被阻塞，等待获取monitor</li><li>线程A获取主内存值后加锁，在本地内存更新值（临时区）后，推送到主内存，通过synchronized隐式通知线程B访问主存获取值，在B的把本地内存更新值后推送到主存，重复以上操作。</li></ul><p>通过Monitor对象来实现方法和代码块的同步，存在monitorEnter和monitorExit指令，插入程序中，在一个线程访问时，通过Monitor进行线程阻塞</p><h4 id="synchronized修饰静态方法、⾮静态方法区别"><a href="#synchronized修饰静态方法、⾮静态方法区别" class="headerlink" title="synchronized修饰静态方法、⾮静态方法区别"></a>synchronized修饰静态方法、⾮静态方法区别</h4><p>静态方法：该类的对象，new出来的多个实例对象是被一个锁锁住的，多线程访问需要等待</p><p>非静态方法：实例对象</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>修饰成员变量，保证可见性，下一个操作再上一个操作之上。++操作不保证和原子性，</p><p>将本地缓存同步到主存中，使其他本地缓存失效，本地缓存通过嗅探检查自己的缓存是否过期。（下一次访问，主存不会主动通知）</p><p>volatile无法保证原子性，可以使用乐观锁的重试机制进行优化</p><h4 id="synchronized和volatile区别"><a href="#synchronized和volatile区别" class="headerlink" title="synchronized和volatile区别"></a>synchronized和volatile区别</h4><ul><li><p>Synchronized 引起线程阻塞，而volatile不会</p></li><li><p>区别在于，synchronized是隐式通知B去主存获取值，volatile是B主动通过嗅探的方法发现自己的内存过期后去主存做同步</p></li><li><p>synchronized：先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</p></li><li><p>都存在可见性，但是volatile不具备原子性，所以不会造成线程阻塞</p><p>假设某一时刻i=10，线程A读取10到自己的工作内存，A对该值进行加一操作，但正准备将11赋给i时，由于此时i的值并未改变，B读取了主存的值仍为10到自己的工作内存，并执行了加一操作，正准备将11赋给i时，A将11赋给了i，由于volatile的影响，立即同步到主存，主存中的值为11，并使得B工作内存中的i失效，B执行第三步，虽然此时B工作内存中的i失效了，但是第三步是将11赋给i，对B来说，我只是赋值操作，并没有使用i这个动作，所以这一步并不会去刷新主存，B将11赋值给i，并立即同步到主存，主存中的值仍为11。虽然A/B都执行了加一操作，但主存却为11，这就是最终结果不是10000的原因。</p></li><li><p>synchronized修饰方法，类，变量，代码块，volatile只能修饰变量</p></li></ul><h4 id="synchronized修饰不同对象的区别"><a href="#synchronized修饰不同对象的区别" class="headerlink" title="synchronized修饰不同对象的区别"></a>synchronized修饰不同对象的区别</h4><ol><li>修饰类：作用的对象是这个类的所有对象</li><li>方法：作用对象是这个方法的对象</li><li>静态方法：作用对象是这个类的对象</li><li>代码块：作用对象是这个代码块的对象</li></ol><h4 id="悲观锁和乐观锁（CAS）"><a href="#悲观锁和乐观锁（CAS）" class="headerlink" title="悲观锁和乐观锁（CAS）"></a>悲观锁和乐观锁（CAS）</h4><p>悲观锁：当前线程获得锁会阻塞其他线程（sychronized）</p><p>乐观锁：不会添加锁，会存在三个值内存实际值，内存的旧值，更新的新值，如果内存实际值和旧值相等，则没有线程修改该值，将更新的新值直接赋值给内存，如果不相等，就重新尝试赋值操作（volatile）</p><p>CAS的缺点：</p><ol><li>ABA问题，A-&gt;B-&gt;A，乐观锁认为没有变化，都是A，所以直接赋值</li><li>重新赋值的话，会导致时间过长。</li></ol><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>CAS+AQS实现，乐观锁</p><p>AQS（单链表队列）维护一个等待队列，将获取不到锁的线程放入到队列中进行等待，当当前线程执行结束后，进行出队操作，使用一个volatile的int成员变量（state）来表示同步状态</p><p>通过ReentrantLock的Lock方法进行加锁</p><p>通过ReentrantLock的unLock方法进行解锁</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="新建线程有几种方式？"><a href="#新建线程有几种方式？" class="headerlink" title="新建线程有几种方式？"></a>新建线程有几种方式？</h4><ol><li>new Thread</li><li>新建Runnable对象</li><li>新建Callable或者Future对象</li><li>线程池使用</li></ol><h4 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h4><p>执行一个异步任务你还只是如下new Thread吗？<br>new Thread的弊端如下：</p><ol><li>每次new Thread新建对象性能差。</li><li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。</li><li>缺乏更多功能，如定时执行、定期执行、线程中断。</li></ol><p>相比new Thread，Java提供的四种线程池的好处在于：</p><ol><li>重用存在的线程，减少对象创建、消亡的开销，性能佳。</li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ol><h4 id="线程池-2"><a href="#线程池-2" class="headerlink" title="线程池"></a>线程池</h4><p><a href="#简述线程池">简述线程池</a></p><h4 id="线程的5种状态"><a href="#线程的5种状态" class="headerlink" title="线程的5种状态"></a>线程的5种状态</h4><ul><li>NEW：创建一个新线程</li><li>RUNNABLE：可运行</li><li>BLOCKED：阻塞</li><li>WAITING：进入等待状态</li><li>TIMED_WAITING：等待结束，重新获取锁</li><li>TERMINATED：结束</li><li>RUNNING：运行中</li><li>READY：就绪</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4840092-f85e70e2262b7878.png" alt="img"></p><p>一般来说分为五大状态：</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/09/716271-20170320112245721-1831918220.jpg" alt="img"></p><ol><li>新建（New）：<br>创建线程对象，进入新建状态。eg：Thread thread = new Thread();</li><li>就绪（Runnable）：<br>调用thread.start()方法，随时可被cpu执行</li><li>运行（Runnable）：<br>CPU执行线程</li><li>阻塞（Blocked）：<br>出于某些原因，cpu放弃线程执行，线程进入暂停状态<ul><li>等待阻塞：调用wait方法，进行阻塞，线程等待某工作完成</li><li>同步阻塞：在获取Synchronized同步锁时，进行等待</li><li>其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li></ul></li><li>死亡（Dead）：<br>堪称执行完毕或者因异常退出，线程死亡，回收</li></ol><h4 id="start和run的区别？sleep和wait的区别？join-yield，interrupt"><a href="#start和run的区别？sleep和wait的区别？join-yield，interrupt" class="headerlink" title="start和run的区别？sleep和wait的区别？join,yield，interrupt"></a>start和run的区别？sleep和wait的区别？join,yield，interrupt</h4><ul><li>start是启动一个线程</li><li>run只是Thread的实现方法，主要实现是Runnable的接口回调run方法</li><li>sleep不会释放对象锁，只是暂停了线程的运行，当指定时间到了，就恢复运行状态</li><li>wait方法放弃对象锁，只有调用了notify()方法，才会重新获取锁，进入运行状态</li><li>join方法是规定线程的执行顺序，如果在B线程中调用了A的join方法，那么，直到A执行完毕，才会执行B，按照顺序串行执行。实际内部方法是调用了wait方法，让B处于等待状态，A执行完成后，启动B</li></ul><blockquote><p>注意：wait方法是调用u哦在线程放弃对象锁，所以在B线程调用A的join方法，只是让B等待了。</p></blockquote><ul><li>yield方法，通知cpu该线程任务不紧急，可以被暂停让其他线程运行</li><li>interrupt方法，中断通知线程，具体操作由线程执行，根据不同状态，执行不同逻辑</li></ul><h4 id="线程t1、t2、t3，如何保证他们顺序执行？"><a href="#线程t1、t2、t3，如何保证他们顺序执行？" class="headerlink" title="线程t1、t2、t3，如何保证他们顺序执行？"></a>线程t1、t2、t3，如何保证他们顺序执行？</h4><p>t3开始中调用t2.join()，t2开始中调用t1.join()。</p><p>t1执行完毕后，t2中t1.join()方法不阻塞，即t1执行完，执行t2中的方法，后续类似<br>使用CountDownLacth，进行计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//引用t1线程，等待t1线程执行完</span></span><br><span class="line">                   t1.join();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//引用t2线程，等待t2线程执行完</span></span><br><span class="line">                   t2.join();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       t3.start();</span><br><span class="line">       t2.start();</span><br><span class="line">       t1.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>资源竞争互相等待</p><p>假设线程A，线程B，资源A，资源B</p><p>线程A访问资源A，持有资源A锁，线程B访问资源B，持有资源B锁，而后线程A要访问资源B，但是线程B持有资源B锁，线程A等待，线程B要访问资源A，但是线程A持有资源A锁。所以B等待。</p><p>结果就是A、B相互等待对方释放资源，造成死锁。</p><h4 id="一个线程崩溃会影响其他线程吗？"><a href="#一个线程崩溃会影响其他线程吗？" class="headerlink" title="一个线程崩溃会影响其他线程吗？"></a>一个线程崩溃会影响其他线程吗？</h4><p>不一定。<br>如果崩溃发生在堆区（线程共享区域），会导致其他线程崩溃。<br>如果崩溃发生在栈区（线程私有区域），不会导致其他线程的崩溃</p><h2 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h2><ol><li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</li><li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</li><li>反射也是考虑了线程安全的，放心使用；</li><li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li><li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</li><li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li><li>调度反射方法，最终是由jvm执行invoke0()执行；</li></ol><p>使用反射从jvm中的二进制码文件中读取数据</p><h4 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h4><p>.java–&gt;.class–&gt;java.lang.Class对象</p><p>编译过程：</p><ul><li>将.java文件编译成机器可以识别<strong>的二进制文件</strong>.class</li><li>.class文件中存储着类文件的各种信息。<br>比如版本号、类的名字、字段的描述和描述符、方法名称和描述、是不是public、类索引、字段表集合，方法集合等等数据</li><li>JVM从二进制文件.class中取出并拿到内存解析</li><li>类加载器获取类的二进制信息，并在内存中生成java.lang.Class对象</li><li>最后开始类的生命周期并初始化（先静态后非静态和构造，先父类在子类）</li></ul><p>而反射操作的就是内存中的java.lang.Class对象。</p><blockquote><p>总结来说.class是一种有顺序的结构文件,而Class对象就是对这种文件的一种表示，所以我们能从Class对象中获取关于类的所有信息，这就是反射的原理。</p></blockquote><h4 id="为什么反射耗时？"><a href="#为什么反射耗时？" class="headerlink" title="为什么反射耗时？"></a>为什么反射耗时？</h4><ol><li>校验时间长</li><li>基本类型的封箱和拆箱</li><li>方法内联</li></ol><h4 id="什么是内联函数？"><a href="#什么是内联函数？" class="headerlink" title="什么是内联函数？"></a>什么是内联函数？</h4><p>方法调用过多会进行内敛优化，减少方法的嵌套层级，加快执行，缓解栈的空间存储</p><h4 id="反射可以修改final类型的成员变量吗？"><a href="#反射可以修改final类型的成员变量吗？" class="headerlink" title="反射可以修改final类型的成员变量吗？"></a>反射可以修改final类型的成员变量吗？</h4><p>已知final修饰后不会被修改，所以获取这个变量的时候就直接帮你在编译阶段就给赋值了</p><blockquote><p>编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。</p></blockquote><p>所以上述的getName方法经过JVM编译内联优化后会变成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出来也是Bob</span></span><br><span class="line">System.out.println(user.name)</span><br><span class="line"><span class="comment">//经过内联优化</span></span><br><span class="line">System.out.println(<span class="string">&quot;Bob&quot;</span>)</span><br></pre></td></tr></table></figure></p><p>反射是可以修改final变量的，但是如果是<strong>基本数据类型</strong>或者<strong>String类型</strong>的时候，无法通过对象获取修改后的值，因为JVM对其进行了内联优化。</p><h4 id="反射可以修改static值吗？"><a href="#反射可以修改static值吗？" class="headerlink" title="反射可以修改static值吗？"></a>反射可以修改static值吗？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field.get(<span class="keyword">null</span>) 可以获取静态变量。</span><br><span class="line">Field.set(<span class="keyword">null</span>,object) 可以修改静态变量。</span><br></pre></td></tr></table></figure><h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><h4 id="简析-1"><a href="#简析-1" class="headerlink" title="简析"></a>简析</h4><p>java中的异常分为2大类，Error和Exception。Error中有StackOverFlowError和OutOfMemoryError。Exception分为IOException和RuntimeException。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTEvMjcvMTM1NDAyMDQxN181MTc2LmpwZw?x-oss-process=image/format,png" alt="异常"></p><h4 id="Java中检查型异常和非检查型异常有什么区别？"><a href="#Java中检查型异常和非检查型异常有什么区别？" class="headerlink" title="Java中检查型异常和非检查型异常有什么区别？"></a>Java中检查型异常和非检查型异常有什么区别？</h4><p>检查型异常 extends Exception（编译时异常）：需要使用try catch进行捕获，否则会出错，继承自Exception</p><p>非检查型异常 extends RuntimeException（运行时异常）：不需要捕获，在必要时才会报错，</p><h4 id="try-catch-finally-return执行顺序？"><a href="#try-catch-finally-return执行顺序？" class="headerlink" title="try-catch-finally-return执行顺序？"></a>try-catch-finally-return执行顺序？</h4><ol><li>不管是否有异常产生，finally块中代码都会执行</li><li>当try和catch中有return语句时，finally块仍然会执行</li><li>finally是在return后面的表达式运算执行的，所以函数返回值在finally执行前确定的，无论finally中的代码怎么样，返回的值都不会改变，仍然是之前return语句中保存的值</li><li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</li></ol><h4 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h4><p>throw用在方法内部，抛出异常</p><p>throws用在方法外部，在方法中抛出异常</p><h4 id="栈溢出StackOverFlowError发生的几种情况？"><a href="#栈溢出StackOverFlowError发生的几种情况？" class="headerlink" title="栈溢出StackOverFlowError发生的几种情况？"></a>栈溢出StackOverFlowError发生的几种情况？</h4><p>递归，栈内存存满，函数调用栈太深</p><h4 id="Java常见异常有哪些"><a href="#Java常见异常有哪些" class="headerlink" title="Java常见异常有哪些"></a>Java常见异常有哪些</h4><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p><p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p><p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p><p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p><p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p><p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p><p>java.lang.ArithmeticException：算术条</p><p>件异常。譬如：整数除零等。</p><p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p><p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</p><p>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p><p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p><p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p><p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p><p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p><p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</p><h2 id="linux进程通信有几种"><a href="#linux进程通信有几种" class="headerlink" title="linux进程通信有几种"></a>linux进程通信有几种</h2><p>Linux中的进程间通信有哪些？解释Binder通信为什么高效？Binder通信有什么限制？</p><p>Linux中的进程间通信有如下几种：</p><ul><li>信号（signal）</li><li>消息队列</li><li>共享内存（Shared Memory）<br>共享内存允许两个或多个进程进程共享同一块内存(这块内存会映射到各个进程自己独立的地址空间)从而使得这些进程可以相互通信。</li><li>管道/命名管道(Pipe)<br>Pipe这个词很形象地描述了通信双方的行为，即进程A与进程B。一根管道同时具有读取端和写入端。比如进程A从write end写入，那么进程B就可以从read end读取数据。</li><li>Socket<br>本地和服务端各自维护一个“文件”，在建立连接打开后，向自己的文件中写入数据，供对方读取</li></ul><p>Binder通信是Android系统特有的IPC机制，Binder的优点有以下几个：</p><ol><li>性能：Binder的效率高，只需要一次内存拷贝；而Linux中的管道、消息队列、套接字都需要2次；共享内存的方式不需要拷贝数据，但是有多进程同步的问题。</li><li>稳定性：Binder的架构是基于C/S结构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</li><li>安全性：传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限。从安全角度，Binder的安全性更高。</li></ol><p>Binder通信的另外一个限制是最多16个线程。最多只能传输1M的数据，否则会有TransactionTooLarge的Exception。</p><h2 id="CountDownLatch原理"><a href="#CountDownLatch原理" class="headerlink" title="CountDownLatch原理"></a>CountDownLatch原理</h2><p>存在4个线程，想在4个线程都执行完毕后执行另一个线程，</p><p>countDownLatch是采用计数器的原理，存在两个方法:</p><p>countDown：计数-1</p><p>await：线程挂起，当计数为0时，执行其后的逻辑</p><h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h4 id="泛型简述"><a href="#泛型简述" class="headerlink" title="泛型简述"></a>泛型简述</h4><p>java中泛型即是“参数化类型”，即该泛型类型是一个参数传入</p><blockquote><p>只在程序的源代码中存在，在编译后的字节码中已经替换为原生类型，这种方法称为伪泛型。</p></blockquote><p>java中的泛型只在编译时期有效，正确检验泛型的结果后，会将泛型相关的信息擦出，并在对象进入和离开的方法边界上添加<code>类型检查</code>和<code>类型转化</code>的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">    Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(classStringArrayList==classIntegerArrayList)&#123;   <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;类型相同&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>泛型有<code>泛型类</code>、<code>泛型方法</code>和<code>泛型接口</code></p><p>泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Pear&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span></span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型对方法重载的影响？"><a href="#泛型对方法重载的影响？" class="headerlink" title="泛型对方法重载的影响？"></a>泛型对方法重载的影响？</h4><p>方法不能进行重载，会报错，<code>两种方法都有相同的擦除</code>，在编译期间进行泛型擦除的，会导致擦出后都一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listMethod</span><span class="params">(List&lt;String&gt; list1)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listMethod</span><span class="params">(List&lt;Integer&gt; list2)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h4 id="java类的初始化流程"><a href="#java类的初始化流程" class="headerlink" title="java类的初始化流程"></a>java类的初始化流程</h4><p>父类到子类，静态到（非静态，构造），变量—–&gt;代码块</p><p>父类静态变量—-父类静态代码块—-子类静态变量—-子类静态代码块—-父类非静态—-父类构造—-子类非静态—-子类构造</p><h4 id="jvm类加载机制的7个流程"><a href="#jvm类加载机制的7个流程" class="headerlink" title="jvm类加载机制的7个流程"></a>jvm类加载机制的7个流程</h4><p>加载—–验证——准备——解析——初始化——-使用——卸载<br>JVM将.java文件加载成二进制文件.class<br>加载：</p><ol><li>获取二进制流class文件</li><li>将静态存储结构转换为方法区中运行时的数据结构，存储到方法区中</li><li>在堆中生成一个java对象，作为方法区的引用<blockquote><p>获取.class文件并在堆中生成一个class对象，将加载的类结构信息存储在方法区</p></blockquote></li></ol><hr><p>验证：JVM规范校验，代码逻辑校验</p><p>准备：为类变量分配内存并设置类变量的初始化，如果变量被final修饰，会直接放入对应的常量池中，并赋值</p><p>解析：常量池符号引用替换为内存的直接引用</p><p>（上述三种统称为连接）</p><hr><p>初始化：执行代码逻辑，对静态变量，静态代码块和类对象进行初始化</p><p>使用：使用初始化好的class对象</p><p>卸载：销毁创建class对象，负责运行的jvm退出内存</p><h5 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h5><ol><li>全局变量应用于整个类文件。局部变量只在方法执行期间存在，之后被回收。静态局部变量对本函数体始终可见</li><li>全局变量，全局静态变量，局部静态变量都在静态存储空间。局部变量在栈（虚拟机栈）中分配空间</li><li>全局变量初始化需要赋值，局部变量不需要赋值</li><li>一个<strong>类</strong>中不能声明同名全局变量，一个<strong>方法</strong>中不能声明同名局部变量。若全局变量和局部变量同名，则在方法中全局变量不生效。</li></ol><h5 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h5><p>当JVM碰到new字节码的时候，会先判断类是否已经初始化，如果没有初始化（有可能类还没有加载，如果是隐式装载，此时应该还没有类加载，就会先进行装载、验证、准备、解析四个阶段），然后进行类初始化。<br>如果已经初始化过了，就直接开始类对象的实例化工作，这时候会调用类对象的<init>方法。</p><h5 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h5><ol><li>初始化main方法的主类</li><li>new 关键字触发，如果类还没有被初始化</li><li>访问静态方法和静态字段时，目标对象类没有被初始化，则进行初始化操作</li><li>子类初始化过程中，如果发现父类没有初始化，则先初始化父类</li><li>通过反射API调用时，如果类没有初始化，则进行初始化操作</li><li>第一次调用java.lang.invoke.MethodHandle 实例时，需要初始化 MethodHandle 指向方法所在的类。</li></ol><h5 id="类的实例化触发时机"><a href="#类的实例化触发时机" class="headerlink" title="类的实例化触发时机"></a>类的实例化触发时机</h5><ol><li>new 触发实例化，创建对象</li><li>反射，class.newnIstance()和constructor.newnIstance()方法触发创建对象</li><li>Clone方法创建对象</li><li>使用序列化和反序列化的机制创建对象</li></ol><h5 id="类的初始化和类的实例化的区别"><a href="#类的初始化和类的实例化的区别" class="headerlink" title="类的初始化和类的实例化的区别"></a>类的初始化和类的实例化的区别</h5><p>类的初始化：为静态成员赋值，执行静态代码块<br>类的实例化：执行非静态方法和构造方法</p><ol><li>类的初始化只会执行一次，静态代码块只会执行一次</li><li>类的实例化会执行多次，每次实例化执行一次</li></ol><h5 id="在类都没有初始化完毕之前，能直接进行实例化相应的对象吗"><a href="#在类都没有初始化完毕之前，能直接进行实例化相应的对象吗" class="headerlink" title="在类都没有初始化完毕之前，能直接进行实例化相应的对象吗?"></a>在类都没有初始化完毕之前，能直接进行实例化相应的对象吗?</h5><p>正常情况下是先类初始化，再类实例化<br>在非正常情况下，比如在静态变量中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person2 p = <span class="keyword">new</span> Person2();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value4 = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        value1 = <span class="number">101</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        value1 = <span class="number">102</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value1 = <span class="number">103</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行public static Person2 p = new Person2();这样就会直接实例化，然后在执行类的初始化，所以会打印<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23123</span></span><br></pre></td></tr></table></figure></p><h5 id="多线程进行类的初始化会出问题吗？"><a href="#多线程进行类的初始化会出问题吗？" class="headerlink" title="多线程进行类的初始化会出问题吗？"></a>多线程进行类的初始化会出问题吗？</h5><p>不会，类初始化<Clinit>方法是阻塞的，多线程访问，只会有一个线程执行，其他阻塞。</p><h5 id="一个实例变量在对象初始化的过程中最多可以被赋值几次？"><a href="#一个实例变量在对象初始化的过程中最多可以被赋值几次？" class="headerlink" title="一个实例变量在对象初始化的过程中最多可以被赋值几次？"></a>一个实例变量在对象初始化的过程中最多可以被赋值几次？</h5><p>4次</p><ol><li>对象被创建时候，分配内存会把实例变量赋予默认值，这是肯定会发生的。</li><li>实例变量本身初始化的时候，就给他赋值一次，也就是int value1=100。</li><li>初始化代码块的时候，也赋值一次。</li><li>构造函数中，在进行赋值一次。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value1 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        value1 = <span class="number">102</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value1 = <span class="number">103</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h4><h5 id="高刷手机，60hz，120hz指的是什么？"><a href="#高刷手机，60hz，120hz指的是什么？" class="headerlink" title="高刷手机，60hz，120hz指的是什么？"></a>高刷手机，60hz，120hz指的是什么？</h5><p>屏幕刷新率，1s内屏幕刷新的次数。这个参数由手机硬件决定<br>一般大于60hz的就是高刷收集，特点在于刷新频率更高，就算存在丢帧、卡顿，也能保持稳定性。</p><h5 id="屏幕的刷新过程"><a href="#屏幕的刷新过程" class="headerlink" title="屏幕的刷新过程"></a>屏幕的刷新过程</h5><p>从左到右，从上到下，顺序显示像素点。当整个屏幕刷新完毕，即一个垂直刷新周期后，（1000/60）16ms后再次刷新<br>一般一个图形界面的绘制，需要CPU准备数据，然后GPU进行绘制，绘制完写入缓存区，然后屏幕按照刷新频率来从这个缓存区中取图形显示。</p><p>所以整个刷新过程是CPU，GPU，屏幕（Display）三方合作的工作关系。</p><h5 id="帧率，VSYNC是什么"><a href="#帧率，VSYNC是什么" class="headerlink" title="帧率，VSYNC是什么"></a>帧率，VSYNC是什么</h5><p>帧率：GPU一秒内渲染绘制的操作的帧数，单位是fps，所以一般帧数和屏幕刷新度保持一致是效果最好的情况，不会导致一方浪费</p><p>VSYNC：垂直同步，作用是让帧率和屏幕刷新率保持一致，防止卡顿和跳帧。由于CPU和GPU绘制图像的时间不稳定，所以可能会发生卡顿情况，也就是下一帧的数据还没准备好无法正常显示在屏幕上，设置垂直同步后，要求CPU和GPU在16ms之内将下一帧的数据处理好，那么屏幕刷新的时候就可以直接从缓存中获取下一帧的数据并显示出来</p><h5 id="屏幕中单缓存，双缓存，三缓存"><a href="#屏幕中单缓存，双缓存，三缓存" class="headerlink" title="屏幕中单缓存，双缓存，三缓存"></a>屏幕中单缓存，双缓存，三缓存</h5><ol><li>单缓存：CPU计算好数据传递给GPU，GPU图像绘制后放到缓存区，display从缓存中获取数据并刷新屏幕<br>缺点：当第二帧的数据还没生成完成时，会导致屏幕中有一部分第一帧的数据，导致一个屏幕同时显示了两帧的数据</li><li>双缓存：CPU计算好数据传递到GPU，GPU图像会之后放入缓存区BackBuffer，当到达VSYNC垂直同步时间，将数据同步到缓存区FrameBuffer中，display从缓存区FrameBuffer中获取数据并显示<br>缺点：如果在一个垂直同步的时间内CPU+GPU没有渲染完成（开始绘制的时间在下次垂直同步时间附近，导致只有一小份垂直同步时间在绘制），就会浪费一个VSYNC垂直同步时间，当VSYNC垂直同步时间来临时，GPU正在处理数据，那么不会开启下一帧的处理，当GPU处理结束后，无法触发下一帧的数据处理，就会导致卡顿的情况</li><li>三缓存数据：当在一个垂直同步时间内没有完成处理，就会出现第三个缓存区，在第二个垂直同步时间，缓存下一帧的数据，这样两个缓存交替处理，保证FrameBuffer会拿到最新的数据，保证了显示的流畅度</li></ol><h5 id="代码中修改了UI，屏幕是怎么进行刷新的？"><a href="#代码中修改了UI，屏幕是怎么进行刷新的？" class="headerlink" title="代码中修改了UI，屏幕是怎么进行刷新的？"></a>代码中修改了UI，屏幕是怎么进行刷新的？</h5><p>当调用invalidate/requestLayout中进行重绘工作时，会向VSYNC垂直同步服务请求，等待下一次VSYNC垂直同步时间，执行界面绘制刷新操作，CPU-&gt;GPU-&gt;Display</p><h5 id="如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？"><a href="#如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？" class="headerlink" title="如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？"></a>如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？</h5><p>屏幕不会刷新，不会重新绘制，如果屏幕不变，程序就收不到垂直同步时间，自动过滤，不处理屏幕刷新操作，只有当界面改变时，才会请求VSYNC垂直同步服务，触发下一次VSYNC垂直同步刷新屏幕</p><h4 id="jvm垃圾回收机制"><a href="#jvm垃圾回收机制" class="headerlink" title="jvm垃圾回收机制"></a>jvm垃圾回收机制</h4><p>首先介绍4个引用</p><p>强引用：在使用时不会被回收</p><p>软引用：系统内存不足时会被回收</p><p>弱引用：下一次gc会被回收</p><p>虚引用：任何时候都可能被回收</p><h2 id="小知识点-1"><a href="#小知识点-1" class="headerlink" title="小知识点"></a>小知识点</h2><h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><ol><li>抽象类中可包含普通方法+实现，接口类中只存在抽象方法，没有具体实现</li><li>抽象类中的值可以是任何类型的，接口中的值必须是public static final修饰的</li><li>一个类只能继承一个抽象类，一个类可以实现多个接口类</li><li>抽象类存在构造函数，接口类没有</li><li>抽象类中包含初始化块，接口中没有</li></ol><h4 id="static和final的区别"><a href="#static和final的区别" class="headerlink" title="static和final的区别"></a>static和final的区别</h4><p>static</p><p>是可以直接调用的（类名.方法/变量），</p><p>可修饰属性，方法，代码段，内部类</p><p>所有对象只有一个值</p><p>final</p><p>可修饰属性，方法，类，局部变量</p><p>final修饰变量不可被更改值，方法不能被重写，类不能被继承</p><p>修饰集和的话，其引用不变，集和可以自由变化</p><h4 id="java是值传递还是引用传递"><a href="#java是值传递还是引用传递" class="headerlink" title="java是值传递还是引用传递"></a>java是值传递还是引用传递</h4><p>如果是基本类型就是值传递</p><p>引用类型就是引用传递</p><p>String表现为值传递，但是其实是作为形参后重新创建了对象，引用已经变化，所以是值传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    changeValue(str); </span><br><span class="line">    System.out.println(<span class="string">&quot;str值为: &quot;</span> + str);  <span class="comment">// str未被改变，str = &quot;123&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">changeValue</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="string">&quot;Bobo&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    changeValue1(student);   <span class="comment">// student值未改变，不为null! 输出结果 student值为 name:Bobo、age:15</span></span><br><span class="line">    <span class="comment">// changeValue2(student);  // student值被改变，输出结果 student值为 name:Lily、age:20</span></span><br><span class="line">    System.out.println(<span class="string">&quot;student值为 name: &quot;</span> + student.name + <span class="string">&quot;、age:&quot;</span> + student.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">changeValue1</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">    student = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(Student student)</span>  </span>&#123;    </span><br><span class="line">     student.name = <span class="string">&quot;Lily&quot;</span>;    </span><br><span class="line">     student.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h4><p>String是不可变的，每次赋值都是重新创建对象，对内存和性能都有损耗</p><p>StringBuilder是非线程安全的，存储通过一个可变长度的字符数组（char[]）。</p><p>append值时，如果所需长度大于分配长度，新建数组长度为（2倍+2），如果所需长度大于(2倍+2)，则使用所需长度大小，否则，使用(2倍+2)长度，默认长度为16，有参构造=16+参数长度</p><p>StringBuffer是线程安全的</p><p>效率上由快到慢：StringBuilder &gt; StringBuffer &gt; String</p><h4 id="String为什么是final（不可变）的？"><a href="#String为什么是final（不可变）的？" class="headerlink" title="String为什么是final（不可变）的？"></a>String为什么是final（不可变）的？</h4><p>final+private保证了其不可修改性</p><ol><li>不可变性保证了线程安全</li><li>不可变后避免了深拷贝，将String值放在字符串常量池（堆内）中，供其他方引用，提高效率，节约内存</li></ol><h4 id="hashcode、equals和-的区别？"><a href="#hashcode、equals和-的区别？" class="headerlink" title="hashcode、equals和== 的区别？"></a>hashcode、equals和== 的区别？</h4><p>hashcode：</p><ol><li>基本类型就是改值</li><li>引用类型是对象在内存地址的映射</li></ol><p>equals：</p><ol><li>在object中equals方法等效于==</li><li>在其他方法中，重写了equals方法，会判断值是否相等</li></ol><p>==：</p><ol><li>基本类型比对的是值</li><li>引用对象比对的是内存地址的映射</li></ol><p>对于String，Integer对象，他们重写了equals方法，所以其equals方法可以判断值是否相等，而==只能判断引用是否相等</p><h4 id="进程，线程，协程的区别？阻塞和非阻塞的区别？"><a href="#进程，线程，协程的区别？阻塞和非阻塞的区别？" class="headerlink" title="进程，线程，协程的区别？阻塞和非阻塞的区别？"></a>进程，线程，协程的区别？阻塞和非阻塞的区别？</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程包含线程<br>进程是CPU分配资源的最小单位</p><h5 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h5><p>线程包含协程<br>线程是独立运行和独立调度的基本单位（CPU上真正执行的是线程）<br>线程间共享进程内资源<br>线程的调度切换比进程快</p><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>协程是存在线程之上，通过异步IO处理执行多个协程的操作<br>协程的调度切换比线程快</p><h5 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h5><p>阻塞就是线程被cpu挂起，不执行线程逻辑<br>非阻塞就是线程不被cpu挂起，执行线程逻辑</p><h5 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h5><p>并发是你执行一下，我执行一下，轮着执行<br>并行是一起执行</p><h5 id="协程和线程的比较"><a href="#协程和线程的比较" class="headerlink" title="协程和线程的比较"></a>协程和线程的比较</h5><ol><li>协程运行在线程之上</li><li>线程执行由内核控制（内核态执行），控制线程切换消耗资源（抢先式），协程由程序执行（也就是在用户态执行）</li><li>协程比线程更加轻量</li><li>多核处理器的情况下，多个线程是可以并行的，但是运行的协程的函数却只有一个，其他协程都会被suspend（阻塞）。即协程是并发的，但不是并行的。</li><li>执行密集型IO操作，性能提高</li><li>在协程之间的切换不需要涉及任何系统调用或任何阻塞调用</li></ol><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p><img src="https://static.oschina.net/uploads/img/201604/21095604_vhHX.png" alt="img"></p><ol><li><p>多路复用IO</p><p>执行A事件，同时执行B事件，通过状态下发，获取A，B执行状态</p></li><li><p>信号驱动IO</p></li><li><p>异步IO</p><p>执行A事件，通过异步处理，当A事件处理完成不哦，通知主进程/线程</p></li><li><p>阻塞IO：</p><p>执行完A事件，在执行B事件</p></li><li><p>非阻塞IO</p><p>执行A事件，同时执行B事件，一直监听A，B的执行过程</p></li></ol><h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h4 id="kotlin协程？"><a href="#kotlin协程？" class="headerlink" title="kotlin协程？"></a>kotlin协程？</h4><p>kotlin协程使用<code>Coroutine</code>，通过使用<code>函数挂起</code>(非阻塞挂起)的方式来保证协程的使用，内部使用状态机来管理协程的挂起点</p><p>每当遇到<code>suspend</code>修饰的方法，都有可能会挂起当前的协程，通过<code>GlobalScope.launch</code>或者其他方式执行suspend修饰的方法时，进行挂起操作</p><h4 id="suspend，runBlocking，launch，withContext，async，doAsync之间的区别"><a href="#suspend，runBlocking，launch，withContext，async，doAsync之间的区别" class="headerlink" title="suspend，runBlocking，launch，withContext，async，doAsync之间的区别"></a>suspend，runBlocking，launch，withContext，async，doAsync之间的区别</h4><p>suspend：挂起函数的标志</p><p>runBlocking：阻塞式全局协程</p><p>launch：非阻塞全局协程</p><p>withContext：任务是串行的</p><p>async：任务是并行的</p><p>doAsync：封装java的Future类，便于线程切换的，并非协程</p><h1 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h1><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h4 id="简述一次完整的Http请求过程"><a href="#简述一次完整的Http请求过程" class="headerlink" title="简述一次完整的Http请求过程"></a>简述一次完整的Http请求过程</h4><p>通过域名请求后————&gt;DNS域名解析为ip地址————&gt;中间路由跳转————&gt;直接访问ip地址进行三次握手————&gt;tcp三次握手成功后进行通信响应———&gt;tcp四次挥手结束通信</p><p>客户端：</p><ol><li>在浏览器输入网址。</li><li>浏览器解析网址，并生成http请求消息。</li><li>浏览器调用系统解析器，发送消息到DNS服务器查询域名对应的ip。</li><li>拿到ip后，和请求消息一起交给操作系统协议栈的TCP模块。</li><li>将数据分成一个个数据包，并加上TCP报头形成TCP数据包。</li><li>TCP报头包括发送方端口号、接收方端口号、数据包的序号、ACK号。</li><li>然后将TCP消息交给IP模块。</li><li>IP模块会添加IP头部和MAC头部。</li><li>IP头部包括IP地址，为IP模块使用，MAC头部包括MAC地址，为数据链路层使用。</li><li>IP模块会把整个消息包交给网络硬件，也就是数据链路层，比如以太网，WIFI等。</li><li>然后网卡会将这些包转换成电信号或者在光信号，通过网线或者光纤发送出去，再由路由器等转发设备送达接收方。</li></ol><p>服务器端：</p><ol><li>数据包到达服务器的数据链路层，比如以太网，然后会将其转换为数据包（数字信号）交给IP模块。</li><li>IP模块会将MAC头部和IP头部后面的内容，也就是TCP数据包发送给TCP模块。</li><li>TCP模块会解析TCP头信息，然后和客户端沟通表示收到这个数据包了。</li><li>TCP模块在收到消息的所有数据包之后，就会封装好消息，生成相应报文发给应用层，也就是HTTP层。</li><li>HTTP层收到消息，比如是HTML数据，就会解析这个HTML数据，最终绘制到浏览器页面上。</li></ol><h4 id="简述三次握手和四次挥手"><a href="#简述三次握手和四次挥手" class="headerlink" title="简述三次握手和四次挥手"></a>简述三次握手和四次挥手</h4><p><img src="http://img-blog.csdn.net/20180208112533496" alt="img"><br>三次握手：<br>客户端发送一个随机seq=100<br>服务端返回一个随机seq=200，ack=100+1<br>客户端返回一个ack=200+1</p><p>四次挥手：<br>客户端发送一个FIN=1，seq=100<br>服务端发送一个ack=100+1<br>服务端发送一个FIN=1，seq=200<br>客户端发送一个ack=200+1</p><p>服务端发送两次的原因是需要等待服务器处理当前任务完毕。</p><h4 id="为什么需要三次握手而不是2次或者4次？"><a href="#为什么需要三次握手而不是2次或者4次？" class="headerlink" title="为什么需要三次握手而不是2次或者4次？"></a>为什么需要三次握手而不是2次或者4次？</h4><blockquote><p>防止已失效的连接请求又传送到服务器端，因而产生错误</p></blockquote><p>两次的话，服务端是不知道自己的请求是否成功发送到客户端的。但是服务端又会认为连接建立成功了。假设第二次丢失了，客户端认为服务端没有响应，就会重发一次，这样已经失效的连接请求就会传送到服务端。</p><p>tcp是可靠的双方通信协议，所以双方都会生成一个初始的序列号供双方确认，如果改成两次，只会确定客户端对于服务端具有可靠性，而服务端对客户端没有可靠性</p><p>四次的话，太过繁琐</p><h4 id="为什么握手需要三次？挥手却需要四次？"><a href="#为什么握手需要三次？挥手却需要四次？" class="headerlink" title="为什么握手需要三次？挥手却需要四次？"></a>为什么握手需要三次？挥手却需要四次？</h4><p>因为挥手的时候需要等待服务器将本次连接中的所有保文都处理完，在发送关闭状态，说白了，服务器需要等待自身进入可关闭状态</p><h4 id="握手可以携带数据信息吗？"><a href="#握手可以携带数据信息吗？" class="headerlink" title="握手可以携带数据信息吗？"></a>握手可以携带数据信息吗？</h4><p>第三次请求可以携带数据信息，客户端认为连接已经建立的，就可以携带参数，但是前两次不能，容易造成对服务器的攻击</p><h4 id="为什么TIME-WAIT状态需要等待2MSL才能转换到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要等待2MSL才能转换到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要等待2MSL才能转换到CLOSE状态？"></a>为什么TIME_WAIT状态需要等待2MSL才能转换到CLOSE状态？</h4><ol><li>保证最后一次能成功到达服务器。最后一次客户端发送给服务端的确认信息可能丢失，如果丢失，服务端会有重试机制，等待一来一回的时间，也就是2MSL的时间，如果没有接收到服务端的重试请求，就认为服务端接收了，等到了就刷新2MSL时间</li><li>等待2MSL的时间也是为了<strong>防止失效连接的请求报文会出现在新连接</strong>中，防止第三次重试请求能被客户端接受，不会干扰其他请求</li></ol><h4 id="SSL层在传输层还是应用层？"><a href="#SSL层在传输层还是应用层？" class="headerlink" title="SSL层在传输层还是应用层？"></a>SSL层在传输层还是应用层？</h4><p>SSL层在传输层和应用层之间，是一个SSL层</p><h4 id="滑动窗口？"><a href="#滑动窗口？" class="headerlink" title="滑动窗口？"></a>滑动窗口？</h4><h4 id="拥塞控制？"><a href="#拥塞控制？" class="headerlink" title="拥塞控制？"></a>拥塞控制？</h4><h4 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h4><p>1、基于连接与无连接；</p><p>2、对系统资源的要求（TCP较多，UDP少）；</p><p>3、UDP程序结构较简单；</p><p>4、流模式与数据报模式 ；</p><p>5、TCP保证数据正确性，UDP可能丢包；</p><p>6、TCP保证数据顺序，UDP不保证。</p><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><ul><li><p>1XX - 临时消息。服务器收到请求，需要请求者继续操作。</p></li><li><p>2XX - 请求成功。请求成功收到，理解并处理。</p></li><li><p>3XX - 重定向。需要进一步的操作以完成请求。</p></li><li><p>4XX - 客户端错误。请求包含语法错误或无法完成请求。</p></li><li><p>5XX - 服务器错误。服务器在处理请求的过程中发生了错误。</p></li></ul><p>200：客户端请求成功<br>301：资源（网页等）被永久转移到其他URL<br>302：重定向，临时跳转<br>400：客户端请求存在语法错误，不能给被服务器理解（Bad Request）<br>404：请求资源不存在，错误的URL<br>500：服务器内部发生了不可预料的错误<br>502：网关错误（Bad Getway）<br>503：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。（Server Unavailable）</p><h4 id="简述TCP和UDP的区别"><a href="#简述TCP和UDP的区别" class="headerlink" title="简述TCP和UDP的区别"></a>简述TCP和UDP的区别</h4><p>TCP：需要数据准确、顺序不能错、要求稳定可靠的场景就需要用到TCP。<br>UDP：数据即时性</p><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>tcp内部是由socket协议填充的</p><h4 id="简述https的加密过程"><a href="#简述https的加密过程" class="headerlink" title="简述https的加密过程"></a>简述https的加密过程</h4><p>RSA是非对称加密，AES是对称加密</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/882dee9d98c9455bbb51cc73f22d0487~tplv-k3u1fbpfcp-zoom-1.image" alt="加密过程"></p><ol><li>客户端请求服务端进行访问</li><li>服务端创建RSA，获得私钥和公钥</li><li>服务端发送公钥给客户端</li><li>客户端经过复杂的证书验证</li><li>客户端生成AES密钥</li><li>将AES密钥经过RSA公钥加密后发送给服务端</li><li>服务端通过RSA私钥解密获取AES密钥</li><li>客户端和服务端后续通过AES密钥进行通信</li></ol><h4 id="为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？"><a href="#为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？" class="headerlink" title="为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？"></a>为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？</h4><p>因为RSA加密有性能上的损耗，加解密过程会比较耗时，不适用于频繁通信过程，而AES加密比较快捷</p><h4 id="简述中间人攻击，如何解决？（dns劫持）"><a href="#简述中间人攻击，如何解决？（dns劫持）" class="headerlink" title="简述中间人攻击，如何解决？（dns劫持）"></a>简述中间人攻击，如何解决？（dns劫持）</h4><ol><li>客户端访问域名A，向服务端进行请求</li><li>中间人劫持dns，使之指向私人ip  B。即客户端同B建立https连接</li><li>B在和A建立https连接</li><li>服务端创建RSA，获得公钥（S）和私钥（S）</li><li>服务端发送公钥（S）给客户端</li><li>中间人拦截信息，获得公钥（S）</li><li>生成RSA公钥（中）和私钥（中），并将公钥（中）发送给客户端</li><li>客户端生成AES密钥</li><li>使用公钥（中）加密AES密钥，并发送给服务端</li><li>中间人拦截信息，获得加密信息，使用私钥（中）进行解密，获得AES密钥</li><li>中间人使用公钥（S）加密AES密钥，并发送给服务端</li><li>服务端通过私钥（S）进行解密，获得AES密钥。</li></ol><p>到此为止，中间人持有客户端和服务端交换的AES密钥，可以进行消息拦截，并解密信息</p><p>解决方案：将RSA公钥交给CA机构，CA机构添加上域名，有效期等将其制作成证书，在用CA机构的私钥进行加密后放置在服务器上，当客户端请求时，返回加密后信息，客户端从CA机构获取公钥（一般情况下内置在机器中）进行解密，成功解密后，获取的信息，域名等可以匹配上，则CA验证通过，获得服务器公钥，走下面流程。</p><blockquote><p>https 无法防止中间人攻击，只有做证书固定ssl-pinning 或者 apk中预置证书做自签名验证可以防中间人攻击</p></blockquote><blockquote><p>证书固定（Certificate Pinning）是指Client端内置Server端真正的公钥证书。在HTTPS请求时，Server端发给客户端的公钥证书必须与Client端内置的公钥证书一致，请求才会成功。</p></blockquote><h4 id="http分层"><a href="#http分层" class="headerlink" title="http分层"></a>http分层</h4><p><img src="http://bkimg.cdn.bcebos.com/pic/0dd7912397dda144d48ab350bbb7d0a20df48655" alt="img"></p><p><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" alt="img"></p><p><img src="http://img-blog.csdn.net/20170822222325781" alt="img"></p><h4 id="dns污染"><a href="#dns污染" class="headerlink" title="dns污染"></a>dns污染</h4><p>国家或地区防止摸一个网站被访问，是dns发送出错误的ip地址，使之无法访问</p><p>使用代理服务器和vpn</p><h4 id="http1-0、http1-1和http2-0的区别"><a href="#http1-0、http1-1和http2-0的区别" class="headerlink" title="http1.0、http1.1和http2.0的区别"></a>http1.0、http1.1和http2.0的区别</h4><p>1.0：短暂连接，重复访问，连接无法复用</p><p>1.1：支持持久连接，长连接，优化1.0带来的性能问题，可以多路复用（数量限制），串行处理，一条失败，后续全部失败，<strong>同步</strong></p><p>2.0：优化多路复用机制，header压缩，并行处理，<strong>异步</strong></p><p>3.0：UDP</p><h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><table><thead><tr><th>排序方法</th><th>时间复杂度（平均）</th><th>时间复杂度（最坏)</th><th>时间复杂度（最好)</th><th>空间复杂度</th><th>稳定性</th><th>复杂性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n2)O(n2)</td><td>O(n2)O(n2)</td><td>O(n)O(n)</td><td>O(1)O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>希尔排序</td><td>O(nlog2n)O(nlog2n)</td><td>O(n2)O(n2)</td><td>O(n)O(n)</td><td>O(1)O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>直接选择排序</td><td>O(n2)O(n2)</td><td>O(n2)O(n2)</td><td>O(n2)O(n2)</td><td>O(1)O(1)</td><td>不稳定</td><td>简单</td></tr><tr><td>堆排序</td><td>O(nlog2n)O(nlog2n)</td><td>O(nlog2n)O(nlog2n)</td><td>O(nlog2n)O(nlog2n)</td><td>O(1)O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>冒泡排序</td><td>O(n2)O(n2)</td><td>O(n2)O(n2)</td><td>O(n)O(n)</td><td>O(1)O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>快速排序</td><td>O(nlog2n)O(nlog2n)</td><td>O(n2)O(n2)</td><td>O(nlog2n)O(nlog2n)</td><td>O(nlog2n)O(nlog2n)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>归并排序</td><td>O(nlog2n)O(nlog2n)</td><td>O(nlog2n)O(nlog2n)</td><td>O(nlog2n)O(nlog2n)</td><td>O(n)O(n)</td><td>稳定</td><td>较复杂</td></tr><tr><td>基数排序</td><td>O(d(n+r))O(d(n+r))</td><td>O(d(n+r))O(d(n+r))</td><td>O(d(n+r))O(d(n+r))</td><td>O(n+r)O(n+r)</td><td>稳定</td><td>较复杂</td></tr></tbody></table><h4 id="冒泡排序-BubbleSort"><a href="#冒泡排序-BubbleSort" class="headerlink" title="冒泡排序(BubbleSort)"></a>冒泡排序(BubbleSort)</h4><p>依次比较两个相邻的元素，如果顺序错误就交换，直到跑完所有元素，那么最后一个元素就是最大（最小）的值，在接着按照上述操作进行排序。</p><p>时间复杂度：O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                   temp = a[j];</span><br><span class="line">                   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                   a[j+<span class="number">1</span>] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>第一趟找出最小的放在第一个，第二趟找出第二小的放在第二个，。。。。。</p><p>时间复杂度：O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                    a[i] = a[j];</span><br><span class="line">                    a[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h4><p>分治法：将一大块分解成若干小块，一块一块算</p><ul><li>设置一边的值为哨兵</li><li>将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li><li>在对剩下的区间进行排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt;right)&#123;</span><br><span class="line">        <span class="comment">//每一趟排序</span></span><br><span class="line">        <span class="keyword">int</span> base = division(a,left,right);</span><br><span class="line">        <span class="comment">//哨兵两边开始排序</span></span><br><span class="line">        <span class="comment">//左边</span></span><br><span class="line">        quickSort(a,left,base-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右边</span></span><br><span class="line">        quickSort(a,base+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用分治法排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//哨兵</span></span><br><span class="line">    <span class="keyword">int</span> base = a[left];</span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="comment">//哨兵在左边，所以right左移</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; a[right]&gt;=base)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != right) &#123;</span><br><span class="line">            a[left] = a[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//哨兵在右边，所以left右移</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; a[left]&lt;=base)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != right) &#123;</span><br><span class="line">            a[right] = a[left];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = base;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二分插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标处的值</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值小，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的中后部部分，所以当前下标取值为mid + 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               lo = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值大，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的前中部部分，所以当前下标取值为mid - 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               hi = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//数组中间处的值与要找的值相等，直接返回数组中部的下标mid</span></span><br><span class="line">               <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>插入排序</p><p>从尾部开始遍历，每次–，比他大的值后移一位，直到找到相等或者比它小的，直接赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="扑克牌算法"><a href="#扑克牌算法" class="headerlink" title="扑克牌算法"></a>扑克牌算法</h4><h4 id="根节点到目标节点的路径"><a href="#根节点到目标节点的路径" class="headerlink" title="根节点到目标节点的路径"></a>根节点到目标节点的路径</h4><h4 id="找出最小的k个数"><a href="#找出最小的k个数" class="headerlink" title="找出最小的k个数"></a>找出最小的k个数</h4><ol><li>使用快速排序：O(nlogn)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getLeastNumbers1(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    pivotFindMinK(input, output, k, <span class="number">0</span>, input.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pivotFindMinK</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span>[] output, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = start;</span><br><span class="line">    <span class="keyword">int</span> right = end;</span><br><span class="line">    <span class="keyword">int</span> temp = numbers[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (numbers[right] &gt; temp &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[left] = numbers[right];</span><br><span class="line">        <span class="keyword">while</span> (numbers[left] &lt;= temp &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[right] = numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">    numbers[left] = temp;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; k-<span class="number">1</span>) &#123;</span><br><span class="line">        pivotFindMinK(numbers, output, k, start, left - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; k-<span class="number">1</span>) &#123;</span><br><span class="line">        pivotFindMinK(numbers, output, k, right + <span class="number">1</span>, end);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.arraycopy(numbers, <span class="number">0</span>, output, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>新建一个数组，放入数组前k个数，并由小到大排列好，遍历原数组，如果存在比新数组中的值更小，插入排序，而后得到新数组。</li><li>小根堆实现，按顺序放入小根堆—大顶堆（父节点&lt;=子节点），小根堆大小为k，超过大小，删除堆顶元素，相反的话，加入大根堆—小顶堆（父节点&gt;=子节点）</li></ol><h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归的二分查找</span></span><br><span class="line"><span class="comment"> *title:recursionBinarySearch</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> arr 有序数组</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> key 待查找关键字</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@return</span> 找到的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursionBinarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;<span class="comment">//初始中间位置</span></span><br><span class="line"><span class="keyword">if</span>(arr[middle] &gt; key)&#123;</span><br><span class="line"><span class="comment">//比关键字大则关键字在左区域</span></span><br><span class="line"><span class="keyword">return</span> recursionBinarySearch(arr, key, low, middle - <span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; key)&#123;</span><br><span class="line"><span class="comment">//比关键字小则关键字在右区域</span></span><br><span class="line"><span class="keyword">return</span> recursionBinarySearch(arr, key, middle + <span class="number">1</span>, high);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个整形数组里求两个数的和能不能等于一个给定数"><a href="#一个整形数组里求两个数的和能不能等于一个给定数" class="headerlink" title="一个整形数组里求两个数的和能不能等于一个给定数"></a>一个整形数组里求两个数的和能不能等于一个给定数</h4><ol><li>如果数组是有序的，两个下标，如果相加大于给定数，左边–，如果小于给定数，右边++，直到数据相等或者右边等于左边</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">56</span>,<span class="number">456</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = a.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] + a[j] &gt;sum)&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i] + a[j] &lt;sum)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(a[i] + <span class="string">&quot;+&quot;</span> + a[j] + <span class="string">&quot;=&quot;</span> + sum);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果数组是无序的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                System.out.println(nums[map.get(nums[i])] + <span class="string">&quot;+&quot;</span> + nums[i] + <span class="string">&quot;=&quot;</span> + target);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = target-nums[i];</span><br><span class="line">            map.put(value,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + sum &lt; nums[i])&#123;</span><br><span class="line">            sum = nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum +=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">            max = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">       BinaryTreeNode temp;</span><br><span class="line">       Queue&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;BinaryTreeNode&gt;();</span><br><span class="line">       queue.offer(root);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           temp = queue.poll();</span><br><span class="line">           System.out.print(temp.getData() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != temp.getLeft())</span><br><span class="line">               queue.offer(temp.getLeft());</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != temp.getRight()) &#123;</span><br><span class="line">               queue.offer(temp.getRight());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历递归的方式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">           System.out.print(root.getData() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">           preOrder(root.getLeft());</span><br><span class="line">           preOrder(root.getRight());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">//前序遍历非递归的方式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">       Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">       stack.push(root);</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           BinaryTreeNode node = stack.pop();</span><br><span class="line">           System.out.print(node.getData() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">               stack.push(node.getRight());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">               stack.push(node.getLeft());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中序便利非递归</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       stack.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           TreeNode node = stack.pop();</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.add(node);</span><br><span class="line">               stack.add(node.left);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               list.add(node.val);</span><br><span class="line">               <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   stack.add(node.right);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                       TreeNode node1 = stack.pop();</span><br><span class="line">                       list.add(node1.val);</span><br><span class="line">                       <span class="keyword">if</span>(node1.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                           stack.add(node1.right);</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//后序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       stack.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           TreeNode node = stack.pop();</span><br><span class="line">           list.add(node.val);</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.add(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           result.add(list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//之字形打印</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; listList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> listList;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;count;j++)&#123;</span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                   list.addFirst(node.val);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   list.add(node.val);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           i++;</span><br><span class="line">           <span class="keyword">if</span>(list.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               listList.add(list);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> listList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="两个view第一个公共父view"><a href="#两个view第一个公共父view" class="headerlink" title="两个view第一个公共父view"></a>两个view第一个公共父view</h4><ol><li>引入set集和，一个用来存贮a数据，将b放入a数组，当数组重复会返回false，放入另一个set中做返回。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title">getIds</span><span class="params">(Integer[] a, Integer[] b)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  Set&lt;Integer&gt; same = <span class="keyword">new</span> HashSet&lt;Integer&gt;();  <span class="comment">//用来存放两个数组中相同的元素</span></span><br><span class="line">  Set&lt;Integer&gt; temp = <span class="keyword">new</span> HashSet&lt;Integer&gt;();  <span class="comment">//用来存放数组a中的元素</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  temp.add(a[i]);   <span class="comment">//把数组a中的元素放到Set中，可以去除重复的元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">    <span class="comment">//把数组b中的元素添加到temp中</span></span><br><span class="line">    <span class="comment">//如果temp中已存在相同的元素，则temp.add（b[j]）返回false</span></span><br><span class="line"><span class="keyword">if</span>(!temp.add(b[j]))</span><br><span class="line">same.add(b[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想知道两个数组的索引，使用map存储，key是值，value是数组索引，在进行map.containsKey()对比，找到则使用</p><ol start="2"><li>将a数组放入set中，将b轮询放入set中，返回false，则重复值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getIds</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer integer:a)&#123;</span><br><span class="line">            set1.add(integer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer j:b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set1.add(j))&#123;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>两个链表中第一个根节点</li></ol><p>两个指针分别跑两条链，短的跑完后，将长的头赋值过去，再开始跑，长的跑完亦然，最终两指针相交地方为两链表的第一个根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNode</span><span class="params">(Node nodeA, Node nodeB)</span> </span>&#123;</span><br><span class="line">       Node pA = nodeA;</span><br><span class="line">       Node pB = nodeB;</span><br><span class="line">       <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">           <span class="keyword">if</span> (pA.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">               pA = nodeB;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               pA = pA.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (pB.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">               pB = nodeA;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               pB = pB.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.print(pA.value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>二叉树的最近公共祖先<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        dps(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dps</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == p.val)&#123;</span><br><span class="line">            node = p;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == q.val)&#123;</span><br><span class="line">            node = q;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> a = dps(root.left,p,q);</span><br><span class="line">        <span class="keyword">boolean</span> b = dps(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(a &amp;&amp; b)&#123;</span><br><span class="line">            node = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a || b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="判断链表是不是环链，并返回入口"><a href="#判断链表是不是环链，并返回入口" class="headerlink" title="判断链表是不是环链，并返回入口"></a>判断链表是不是环链，并返回入口</h4><p>两个指针，一个一次跑一个，一个一次跑两个，相交的话就是存在环链</p><p>将跑的慢的从头开始一个一个跑，跑的快的从相交的点开始跑，一个一个跑，最终相遇的就是入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">isCircle</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node p = node;</span><br><span class="line">        Node q = node;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">            <span class="keyword">if</span>(p == q)&#123;</span><br><span class="line">                <span class="keyword">while</span>(node != p)&#123;</span><br><span class="line">                  node = node.next;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变"><a href="#有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变" class="headerlink" title="有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变"></a>有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变</h4><p>转化成链表，遍历链表将复苏和单独成链后连接到剩下的正数链上</p><p>数组两个索引，一个索引记录负数的尾部，一个所以负责遍历，每找到一个负数，将其插入该值，后续值后移一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a[j]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">int</span> temp = a[j];</span><br><span class="line">               <span class="keyword">int</span> k = j;</span><br><span class="line">               <span class="keyword">while</span>(i&lt;=k-<span class="number">1</span>)&#123;</span><br><span class="line">                   a[k] = a[k-<span class="number">1</span>];</span><br><span class="line">                   k--;</span><br><span class="line">               &#125;</span><br><span class="line">               a[i] = temp;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i:a)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="打印蛇形矩阵"><a href="#打印蛇形矩阵" class="headerlink" title="打印蛇形矩阵"></a>打印蛇形矩阵</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="comment">// left to right.</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="comment">// top to bottom.</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="comment">// right to left.</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="comment">// bottom to top.</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求二叉树的叶子节点数"><a href="#求二叉树的叶子节点数" class="headerlink" title="求二叉树的叶子节点数"></a>求二叉树的叶子节点数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">testTree</span><span class="params">(Tree tree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree.left==<span class="keyword">null</span>&amp;&amp;tree.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;叶子节点：&quot;</span>+tree.val);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> testTree(tree.left)+testTree(tree.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> left = treeDepth(root.left);</span><br><span class="line">        <span class="comment">// 计算右子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> right = treeDepth(root.right);</span><br><span class="line">        <span class="comment">// 树root的深度=路径最长的子树深度 + 1</span></span><br><span class="line">        <span class="keyword">return</span> left &gt;= right ? (left + <span class="number">1</span>) : (right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="数组最大和"><a href="#数组最大和" class="headerlink" title="数组最大和"></a>数组最大和</h4><p>累加值：一个一个累加的值</p><p>最大值：记录累加值的最大值</p><p>假设数组为最大，每次添加一个值，如果i-1的值&lt;0，那么把i放入累加值，如果&gt;0，那么将i的值加到累加值，如果累加值&gt;最大值，则更新最大值。</p><p>如果需要数组的最大和的下标，对最大值的下标进行记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,-<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,-<span class="number">5</span>&#125;;</span><br><span class="line">        Long begintime = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> result =  FindGreatestSumOfSubArray(array);</span><br><span class="line">        Long endtime = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;连续子数组的最大和为：&quot;</span>+result+<span class="string">&quot;,运行时间：&quot;</span>+(endtime - begintime) + <span class="string">&quot;ns&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] currentsum = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        currentsum[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> greatsetsum = array[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;第1步：累加子数组和：&quot;</span>+currentsum[<span class="number">0</span>]+<span class="string">&quot;，最大子数组和：&quot;</span>+greatsetsum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="comment">//下面是动态规划的状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span>(currentsum[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                currentsum[i] = currentsum[i-<span class="number">1</span>] + array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                currentsum[i] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据currentsum的值更新greatsetsum的值</span></span><br><span class="line">            <span class="keyword">if</span>(currentsum[i] &gt; greatsetsum)&#123;</span><br><span class="line">                greatsetsum  = currentsum[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;步：累加子数组和：&quot;</span>+currentsum[i]+<span class="string">&quot;，最大子数组和：&quot;</span>+greatsetsum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> greatsetsum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？"><a href="#有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？" class="headerlink" title="有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？"></a>有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？</h4><h1 id="模式篇"><a href="#模式篇" class="headerlink" title="模式篇"></a>模式篇</h1><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>饿汉：线程安全，类初始化的时候就会触发类的实例化，所以保证只有一个，</p><p>缺点：但是会浪费内存，如果不使用单例，就会一直存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在静态初始化器中创建单例实例，这段代码保证了线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//Singleton类只有一个构造方法并且是被private修饰的，所以用户无法通过new方法创建该对象实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉：synchronized加锁线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//没有加入synchronized关键字的版本是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span>  Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前单例是否已经存在，若存在则返回，不存在则再建立单例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>双重校验锁：双重加锁（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>双重判断的原因？<ul><li>第一个判断减少锁的使用，提升性能</li><li>多个线程同时等待锁，当第一个创建后，就不需要其他线程重复重建</li></ul></li><li>volatile的理解<ul><li>禁止重排序导致instance获取失败（3）。</li></ul></li><li>new Singleton()方法执行时可能导致分配了空间，并指向了内存空间，但是没有赋值，这样另一个线程拿到后会导致出错</li></ol><p>静态内部类：（线程安全）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span></span>&#123;</span><br><span class="line">        <span class="comment">//声明成员变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供接口获取该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>枚举单例：(线程安全)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">调用方法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.INSTANCE.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">直接通过Singleton.INSTANCE.doSomething()的方式调用即可。方便、简洁又安全。</span><br></pre></td></tr></table></figure><h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><p>生产者添加数据，消费者自己从中间件中获取信息，通过中间件管理数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kangsx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mode1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Queue&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(list.size()&gt;=maxSize)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(i);</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span> (list.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i = list.remove();</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.box = box;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            box.put(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.box = box;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">int</span> i = box.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box();</span><br><span class="line">        <span class="comment">//5个生产者</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Producer(box).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5个消费者</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Consumer(box).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><p>发布者发送数据到订阅者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kangsx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mode2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IObserver</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> temp)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IObservable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(IObserver iObserver)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(IObserver iObserver)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被观察者（发布者）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> <span class="keyword">implements</span> <span class="title">IObservable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;IObserver&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(IObserver iObserver)</span> </span>&#123;</span><br><span class="line">            list.add(iObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(IObserver iObserver)</span> </span>&#123;</span><br><span class="line">            list.remove(iObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                list.get(i).update(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemp</span><span class="params">(<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.temp = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者1（订阅者）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer1</span> <span class="keyword">implements</span> <span class="title">IObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Observable1更新为 = &quot;</span> + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者2(订阅者)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer2</span> <span class="keyword">implements</span> <span class="title">IObserver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Observable2更新为 = &quot;</span> + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Observable observable = <span class="keyword">new</span> Observable();</span><br><span class="line">        Observer1 observer1 = <span class="keyword">new</span> Observer1();</span><br><span class="line">        Observer2 observer2 = <span class="keyword">new</span> Observer2();</span><br><span class="line">        observable.register(observer1);</span><br><span class="line">        observable.register(observer2);</span><br><span class="line">        observable.setTemp(<span class="number">32131232</span>);</span><br><span class="line">        observable.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>提供复杂参数的对象构造，完全由调用方选择参数配置，反之使用默认。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//显示器</span></span><br><span class="line">    String display;</span><br><span class="line">    <span class="comment">//cpu型号</span></span><br><span class="line">    String cpu;</span><br><span class="line">    <span class="comment">//主板型号</span></span><br><span class="line">    String mainBoard;</span><br><span class="line">    <span class="comment">//显卡型号</span></span><br><span class="line">    String gpu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.display = builder.display;</span><br><span class="line">        <span class="keyword">this</span>.cpu = builder.cpu;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = builder.mainBoard;</span><br><span class="line">        <span class="keyword">this</span>.gpu = builder.gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;显示器是&quot;</span> + display + <span class="string">&quot;\ncpu是&quot;</span> + cpu + <span class="string">&quot;\n主板是&quot;</span> + mainBoard + <span class="string">&quot;\n显卡是&quot;</span> + gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="comment">//显示器</span></span><br><span class="line">        String display;</span><br><span class="line">        <span class="comment">//cpu型号</span></span><br><span class="line">        String cpu;</span><br><span class="line">        <span class="comment">//主板型号</span></span><br><span class="line">        String mainBoard;</span><br><span class="line">        <span class="comment">//显卡型号</span></span><br><span class="line">        String gpu;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.display = <span class="string">&quot;三星曲屏&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.cpu = <span class="string">&quot;i5 8400&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = <span class="string">&quot;华硕Z360-B&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.gpu = <span class="string">&quot;GTX 1050Ti&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setcpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMainBoard</span><span class="params">(String mainBoard)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = mainBoard;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setGpu</span><span class="params">(String gpu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.gpu = gpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Computer(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer.Builder()</span><br><span class="line">                .setcpu(<span class="string">&quot;i9 4700u&quot;</span>)</span><br><span class="line">                .setGpu(<span class="string">&quot;GTX 2060Ti&quot;</span>)</span><br><span class="line">                .setMainBoard(<span class="string">&quot;华硕Z480&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(computer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>对原有功能进行封装，访问对象不能直接访问原有功能，只能访问我们的功能传达，我们就是代理，作为原有功能和访问对象之间的中介</p><p>静态代理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>动态代理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">IRetrofit iRetrofit = (IRetrofit) Proxy.newProxyInstance(IRetrofit.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;IRetrofit.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----调用前执行&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----调用前执行Object&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(IRetrofit.class, args);</span><br><span class="line">                &#125;</span><br><span class="line">                IRetrofit iRetrofit1 = <span class="keyword">new</span> IRetrofit() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;------test1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kang</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;------kang1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                Object object = method.invoke(iRetrofit1,args);</span><br><span class="line">                System.out.println(<span class="string">&quot;-------调用后执行&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        iRetrofit.kang();</span><br></pre></td></tr></table></figure><br>打印如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----调用前执行</span><br><span class="line">------kang1</span><br><span class="line">-------调用后执行</span><br></pre></td></tr></table></figure><br>即想调用那个方法都可以，在invoke中做了代理，利用反射执行该类</p><h1 id="设计六种原则"><a href="#设计六种原则" class="headerlink" title="设计六种原则"></a>设计六种原则</h1><h4 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h4><p>接口业务单一</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><h4 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h4><h4 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h4><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>提高复用性，可拓展性，将业务抽取单一获取</p><p>根据业务功能进行划分，功能复杂时考虑分层思想+设计模式，如果业务简单，可以直接套用设计模式进行方案优化，最后业务决定框架选型，细节方面可以面向未来考虑 尽量保证良好的扩展和健壮性</p><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>widget树，skia 2d渲染引擎，</p><p>StatelessWidget：不能更新状态的布局，创建一次，永不可修改外观</p><p>StatefulWidget：可以更新界面，通过setState方法更新布局，外观</p><p>fish-redux</p><h2 id="Kotlin-1"><a href="#Kotlin-1" class="headerlink" title="Kotlin"></a>Kotlin</h2><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>完全兼容Java<br>更少的空指针异常<br>更少的代码量，更快的开发速度</p><h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><p>action：用户触发程序</p><p>reducer：根据action，做不同响应，返回一个新state</p><p>store：存储state的集合，数据是不可变的</p><h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><h3 id="iot触发日志文件上传"><a href="#iot触发日志文件上传" class="headerlink" title="iot触发日志文件上传"></a>iot触发日志文件上传</h3><p>通过bugly埋点，如果无法解决或者问题不全，或者酒店反馈音箱有问题</p><p>存储：监听时间广播，整点会重新存储日志文件，进程设置adb命令存储文件</p><p>每次中断或者时间到了都会触发重新开辟文件存储和老文件删除（只存储72个文件，正常情况下对应72个小时的）</p><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>使用leakcanary检测内存泄漏，绑定生命周期，在onDestroy的时候创建弱引用，放置在弱引用队列中，手动gc，如果查到该Activity，就是造成了内存泄漏，会打印出dump栈堆信息</p><h3 id="selinux权限配置"><a href="#selinux权限配置" class="headerlink" title="selinux权限配置"></a>selinux权限配置</h3><p>ota中遇到的问题，ota升级失败后，再日志中分析问题，再对应的<code>.te</code>文件中添加权限配置，循环往复，最终关闭这个权限校验。</p><p>定义每个用户，进程，应用，文件的访问和转变的权限，使用安全策略组控制这些实体</p><h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><h4 id="如何检测？"><a href="#如何检测？" class="headerlink" title="如何检测？"></a>如何检测？</h4><ol><li><p>AOP（AspectJ）打点</p></li><li><p>程序打点</p></li><li><p>TraceView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始收集</span></span><br><span class="line">Debug.startMethodTracing(<span class="string">&quot;app_trace&quot;</span>);</span><br><span class="line"><span class="comment">//结束收集</span></span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><p>生成app_trace.trace文件，可以查看方法耗时</p></li><li><p>函数插桩（ASM）</p></li></ol><h4 id="具体的优化方案"><a href="#具体的优化方案" class="headerlink" title="具体的优化方案"></a>具体的优化方案</h4><ol><li>替换主题中theme，保证不会出现闪屏</li><li>decroView.post执行延时任务</li><li>IdleHandler闲置时间进行任务执行</li><li>异步线程池处理</li><li>基于dex文件的异步加载，在编译期间对dex按模块进行拆分，把一级页面及配置放置在第一个dex中，二三级页面及配置放置在第二个dex中。</li><li>在app启动过程中，不启动odex转化进程，在app启动后，自己启动一个odex进程，将转化后文件放入odex文件</li></ol><blockquote><p>在app启动过程中，android虚拟机会启动一个odex转化进程，将dex转化为odex，避免这个odex进程对前台app的影响很重要</p></blockquote><h4 id="主旨核心"><a href="#主旨核心" class="headerlink" title="主旨核心"></a>主旨核心</h4><ol><li>减法为主：尽量不影响主线程，能较少的启动就减少启动</li><li>异步为辅：耗时任务在异步调用</li><li>延迟为补：延迟加载增加全面性</li></ol><h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>在使用Aspect进行时间的监测时，发现Application和Activity中的初始化三方进程耗费了大量时间，在初始化时，我们开启了百度OTA服务，Bugly监测服务，咪咕音乐服务，阿里IOT服务，日志监测服务，Linphone语音服务，Ifly语音服务等，这些串行起来是比较耗时的。<br>所以我们采用开启一个线程池的方案，在子线程启动这些服务，对于OTA，IOT，日志检测，Linphone等服务不需要在第一时间初始化，所以放到线程池中根据执行顺序分别初始化。但是对于咪咕、Ifly和bugly来说，需要第一时间初始化，才能进行后边的逻辑，所以我们将这些服务优先初始化，并联合CountDownLatch，当必须的服务初始化完成后，才进入下面的流程。<br>对于必须要在主线程进行初始化的操作，可能会造成主线程繁忙卡顿，所以使用IdleHandler方法，在主线程空闲时执行，</p><p>具体优化了40%，由2.3s压缩到1.4s。</p><p>如果由任务A，B，C，D，要求C在A之后执行，D在B之后执行，那么直接将A,C合并为一个任务，放入线程池中运行，B、D合并为一个任务，放入线池程中执行，如需决定AC和BD的顺序，那么可以按照AC、BD的顺序依次放入子线程中。</p><p>通过异步线程池进行异步加载处理，使用有向无环图算法控制任务进入线程池的顺序，通过CountDownLatch控制线程的执行顺序，进行异步加载</p><h4 id="如何对IDLEHandler进行顺序划分？比如先执行B，在执行A"><a href="#如何对IDLEHandler进行顺序划分？比如先执行B，在执行A" class="headerlink" title="如何对IDLEHandler进行顺序划分？比如先执行B，在执行A"></a>如何对IDLEHandler进行顺序划分？比如先执行B，在执行A</h4><p>规划一个空闲队列，在Handler空闲时进行处理，每次出队优先级最高的，其他等到下次空闲在执行</p><h4 id="2-5是怎么计算的？"><a href="#2-5是怎么计算的？" class="headerlink" title="2-5是怎么计算的？"></a>2-5是怎么计算的？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>CPU_COUNT - 1，是因为为了避免后台任务将 CPU 资源完全耗尽， 减掉的这个1 是留给我们 主线程 使用的。</p><p>cpu密集型的线程选择：n+1<br>io密集型的线程选择：</p><ol><li>2n+1</li><li>线程数 = CPU核心数/(1-阻塞系数)，一般情况下IO密集型的为0.8，0.9，可适当调整这个数值</li></ol><p>在改启动器中，我们存在的大都是cpu密集型任务，理论上选择n+1，但是目前在2-5中间进行选择</p><p>在最新版本的AsyncTask中的线程池已经设置为了5</p><p><a href="https://blog.csdn.net/weixin_44367006/article/details/106717676">如何选择线程池最优线程数</a></p><h4 id="如何看待app-startUp？"><a href="#如何看待app-startUp？" class="headerlink" title="如何看待app startUp？"></a>如何看待app startUp？</h4><p>官方提供的启动优化方案，可以规定初始化模块的运行顺序，配合AndroidManifest+ContentProvider进行初始化。</p><p>在Application的生命周期中，application.attachBaseContext()—-&gt;contentProvider.onCreate()—–&gt;application.onCreate()</p><p>通过创建一个ContentProvider，在ContentProvider中执行初始化事件，减轻application的负担。</p><p>缺点：</p><ol><li>只支持同步事件，没有线程池做异步处理</li><li>需要编写大量的xxInitializer类文件，配置AndroidManifest文</li></ol><h3 id="设计一个模块："><a href="#设计一个模块：" class="headerlink" title="设计一个模块："></a>设计一个模块：</h3><ol><li>接口的易用性，从易用出发</li><li>命名规范</li><li>尽量不依赖第三方库，避免重复引用</li><li>多端使用的一致性，比如都开放同一个端口</li><li>sdk包保证小而精</li><li>保证老旧版本的兼容性</li><li>这类配置项一般就不需要提供 get 方法，防止接口太多</li></ol><h3 id="组件化构件"><a href="#组件化构件" class="headerlink" title="组件化构件"></a>组件化构件</h3><h3 id="布局优化-1"><a href="#布局优化-1" class="headerlink" title="布局优化"></a>布局优化</h3><h4 id="view的布局"><a href="#view的布局" class="headerlink" title="view的布局"></a>view的布局</h4><h5 id="ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别"><a href="#ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别" class="headerlink" title="ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别"></a>ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别</h5><p>ConstraintLayout：约束布局，完美结合RelativeLayout和LinearLayout的属性，可以拖拽，可以放置在相对布局，也可以按比例设置view，很像flex，都是一层布局</p><p>FrameLayout：后一个布局会覆盖前一个布局，可以控制层级</p><p>RelativeLayout：相对位置的布局</p><p>LinearLayout：线性布局，水平，垂直，比例分配</p><h5 id="include，viewstub，merge的区别"><a href="#include，viewstub，merge的区别" class="headerlink" title="include，viewstub，merge的区别"></a>include，viewstub，merge的区别</h5><p>include：复用布局</p><p>viewstub：可以显示网络布局，默认显示一次，更加省cpu和内存，只会构建一次，</p><p>merge：去除不必要的节点嵌套（比如多个LinearLayout的嵌套）</p><p>尽量使用ConstraintLayout，RelativeLayout，使用include，viewstub加载网络异常界面显示，merge去掉不必要的节点</p><h4 id="布局优化-2"><a href="#布局优化-2" class="headerlink" title="布局优化"></a>布局优化</h4><ol><li>针对复杂布局使用ConstraintLayout，减少层级，实现类Flex布局，后期也可拓展为MotionLayout，添加动画</li><li>针对简单布局，使用LinearLayout布局，不增加嵌套层级情况下，性能最优，onMeasure渲染一次</li><li>使用include布局对公共布局进行封装，便于统一修改和查看</li><li>使用merge标签作为根布局进行include内布局的封装，当其他布局引用时，会直接当作include布局的根布局使用，减少嵌套布局层级</li><li>使用viewStub标签，第一次展示时不会进行绘制，他是一个轻量级的view，没有尺寸，当需要使用布局时（调用inflate()方法），才会进行加载</li><li>使用开发者选项中的过度绘制进行检查并优化布局</li></ol><h3 id="apk体积优化"><a href="#apk体积优化" class="headerlink" title="apk体积优化"></a>apk体积优化</h3><p>使用apk Analyzer分析apk，体积主要在lib库，assets库，res库</p><p>从150M压缩到50M，</p><ol><li><p>lib库中存放着三方库，所以需要对三方库进行整理，剔除不需要的库，针对so库，剔除其他架构的so库，只留了armeabi-v7a包。</p></li><li><p>assets库和res库中主要是一些音频文件，帧动画图片，gif图片等</p><ol><li>对图片进行压缩，使用<a href="https://tinypng.com/">tinypng</a>进行图片压缩（支持png和jpg格式）</li><li>大部分图片可以使用webp格式替换，减少体积</li><li>帧动画和gif尽量换成lottie动画</li></ol></li></ol><ol><li>使用lint删除无用资源和代码</li><li>大图换小图</li><li>代码优化整理复用</li><li>view整理复用</li><li>启动shrinkResources，移除不用的资源</li><li>大库换小库，能不用就不用</li><li>减小assets，raw的文件目录大小，尽量放置在网络上</li><li>调整需求，减少体量</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;框架篇&quot;&gt;&lt;a href=&quot;#框架篇&quot; class=&quot;headerlink&quot; title=&quot;框架篇&quot;&gt;&lt;/a&gt;框架篇&lt;/h1&gt;&lt;h2 id=&quot;EventBus&quot;&gt;&lt;a href=&quot;#EventBus&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>茶道</title>
    <link href="http://yoursite.com/2021/05/31/%E9%9A%8F%E7%AC%94/%E8%8C%B6%E9%81%93/"/>
    <id>http://yoursite.com/2021/05/31/随笔/茶道/</id>
    <published>2021-05-31T12:39:47.000Z</published>
    <updated>2021-05-31T12:42:24.066Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="茶的分类"><a href="#茶的分类" class="headerlink" title="茶的分类"></a>茶的分类</h3><p>根据茶的发酵程度去区分茶的种类，目前已知可以分为：<code>绿茶</code>、<code>红茶</code>、<code>青茶</code>、<code>白茶</code>、<code>黄茶</code>、<code>黑茶</code>。</p><h4 id="绿茶"><a href="#绿茶" class="headerlink" title="绿茶"></a>绿茶</h4><p>发酵度：0%（未发酵）</p><p>品种高达3000多种</p><p>绿茶的茶汤多呈现翠绿色、黄绿色等等；茶汤清澈，滋味甘醇。较为出名的绿茶有：西湖龙井、黄山毛峰、碧螺春等。</p><p>冲泡绿茶时宜用80-90度左右的热水冲泡。</p><h4 id="黄茶"><a href="#黄茶" class="headerlink" title="黄茶"></a>黄茶</h4><p>发酵度：10～20%</p><p>黄茶品种比较少</p><p>黄茶属微发酵的茶，其制作工艺和绿茶相似，只增加了一道“闷黄”的工艺，这是制作黄茶的关键，也是造就黄茶“黄叶黄汤”的主要工序。黄茶的茶汤橙中泛黄，没有绿茶的苦涩，更加香醇。</p><p>比较出名的有：君山银针、蒙顶黄芽、沩山毛尖等。</p><p>冲泡黄茶时宜用85-95度左右的热水冲泡。</p><h4 id="白茶"><a href="#白茶" class="headerlink" title="白茶"></a>白茶</h4><p>发酵度：10～30%</p><p>白茶可以说是福建独有，主要生产于福建的政和、福鼎、松溪等</p><p>白茶是轻度发酵的茶，发酵程度仅比黄茶稍多，其制法独特，不炒不揉，成茶外表满披白毫，色泽银白灰绿，故名“白茶“。</p><p>白茶的茶汤一般呈黄绿色，滋味清淡，有较强的回甘。</p><p>比较出名的白茶有：白毫银针、白牡丹、寿眉、福鼎大白茶等。</p><p>冲泡白茶时宜用90-100度左右的热水冲泡。</p><h4 id="青茶"><a href="#青茶" class="headerlink" title="青茶"></a>青茶</h4><p>发酵度：30～70%</p><p>最具代表性的就是“乌龙茶”，属于半发酵茶，介于不发酵茶（绿茶）和全发酵茶（红茶）之间。</p><p>青茶的茶汤呈蜜绿色，香气馥郁，回味甘鲜。</p><p>比较出名的有：铁观音、武夷岩茶（大红袍）、广东大叶青等。</p><p>冲泡青茶时宜用100度左右的热水冲泡。</p><h4 id="红茶"><a href="#红茶" class="headerlink" title="红茶"></a>红茶</h4><p>发酵度：95～100%</p><p>是绿茶后的第二大茶类，产区较为广泛，但比较多的省份为云南、安徽、福建、广东等</p><p>比较有名的品种有：正山小种、祁红、滇红、金骏眉等。</p><p>冲泡红茶时宜用80-85度左右的热水冲泡。</p><h4 id="黑茶"><a href="#黑茶" class="headerlink" title="黑茶"></a>黑茶</h4><p>发酵度：80～100%</p><p>黑茶生产历史悠久，在历史上一直都是供给边疆少数民族地区，目的是为了帮助边疆人民消化食物和平衡营养。</p><p>比较出名的有：云南普洱茶、安化黑茶、广西六堡茶、四川边茶等。</p><p>冲泡黑茶时宜用100度左右的热水冲泡。</p><h3 id="茶的制作流程"><a href="#茶的制作流程" class="headerlink" title="茶的制作流程"></a>茶的制作流程</h3><h4 id="主要制作流程"><a href="#主要制作流程" class="headerlink" title="主要制作流程"></a>主要制作流程</h4><h5 id="采茶"><a href="#采茶" class="headerlink" title="采茶"></a>采茶</h5><p>从茶树上采摘新鲜的茶叶。采摘茶枝顶端的茶尖部分，分为独芽、一芽一叶、一芽两叶。</p><ul><li><p>独芽：采摘最顶端小芽，茶叶品级为极品，茶叶不耐泡，只能品茶叶的清香和甘醇。如龙井茶。</p></li><li><p>一芽一叶：采摘最顶端小芽+一片叶子，味道甘醇</p></li><li><p>一芽两叶：采摘最顶端小芽+两片叶子，较前两者味道更加浓郁些，少了飘逸感，但是价格亲民</p></li></ul><h5 id="摊晾（晾青、晾晒）"><a href="#摊晾（晾青、晾晒）" class="headerlink" title="摊晾（晾青、晾晒）"></a>摊晾（晾青、晾晒）</h5><p>就是将采摘下的茶鲜叶均匀地摊放在篾垫、摊青筛或摊青机上的作业过程。</p><p>使叶子失水（含水量下降5%=70%），变软，便于揉捻成条、球</p><h5 id="萎凋（走水）"><a href="#萎凋（走水）" class="headerlink" title="萎凋（走水）"></a>萎凋（走水）</h5><p>是指鲜叶摊在一定的设备和环境条件下，</p><p>萎凋叶的含水率一般比摊晾后鲜叶的含水率更低，大多在60%~64%。</p><h5 id="杀青"><a href="#杀青" class="headerlink" title="杀青"></a>杀青</h5><p>主要目的是通过高温破坏和钝化鲜叶中的氧化酶活性，抑制鲜叶中的茶多酚等的酶促氧化，蒸发鲜叶部分水分，使茶叶变软，便于<a href="https://baike.baidu.com/item/揉捻/692144">揉捻</a>成形，同时散发青臭味，促进良好香气的形成。</p><p>主要有炒青、烘青、蒸青和晒青：</p><ul><li>炒青用高温铁锅炒制（如龙井、碧螺春、雨花茶等）；</li><li>烘青用烘笼或烘干机直接高温烘焙（如黄山毛峰、太平猴魁、高桥银峰等）；</li><li>蒸青：采用蒸汽杀青工艺制作（如煎茶、玉露、抹茶等）；</li><li>晒青：靠太阳晒干或先晒后烘，先晒后炒干（如滇青、川青、陕青等）。</li></ul><h5 id="闷黄"><a href="#闷黄" class="headerlink" title="闷黄"></a>闷黄</h5><p>是黄茶类制造工艺的特点，是形成黄色黄汤的关键工序。从杀青到黄茶干燥结束，都可以为茶叶的黄变创造适当的湿热工艺条件，但作为一个制茶工序，有的茶在杀青后闷黄，有的则在毛火后闷黄，有的闷炒交替进行。</p><h5 id="发酵（渥红）"><a href="#发酵（渥红）" class="headerlink" title="发酵（渥红）"></a>发酵（渥红）</h5><p>是红茶制作的独特阶段，经过发酵，叶色由绿变红，形成红茶红叶红汤的品质特点。</p><h5 id="揉捻"><a href="#揉捻" class="headerlink" title="揉捻"></a>揉捻</h5><p>通过揉捻使茶叶的细胞壁破裂，是茶叶变得更加柔软，释放出更多的营养成分</p><h5 id="干燥"><a href="#干燥" class="headerlink" title="干燥"></a>干燥</h5><p>除去茶叶中的水分</p><h5 id="覆火"><a href="#覆火" class="headerlink" title="覆火"></a>覆火</h5><p>再次去除茶叶中的水分</p><h5 id="紧压"><a href="#紧压" class="headerlink" title="紧压"></a>紧压</h5><p>将茶叶制成茶饼</p><h4 id="六大茶类的制作流程"><a href="#六大茶类的制作流程" class="headerlink" title="六大茶类的制作流程"></a>六大茶类的制作流程</h4><ul><li>绿茶：采茶—-&gt;晾晒—-&gt;杀青—-&gt;揉捻—-&gt;干燥</li><li>黄茶：采茶—-&gt;晾晒—-&gt;杀青—-&gt;揉捻—-&gt;闷黄—-&gt;干燥</li><li>白茶：采茶—-&gt;晾晒/萎凋—-&gt;杀青—-&gt;干燥</li><li>青茶：采茶—-&gt;萎凋—-&gt;杀青—-&gt;揉捻—-&gt;干燥</li><li>红茶：采茶—-&gt;萎凋—-&gt;揉捻—-&gt;干燥</li><li>黑茶：采茶—-&gt;萎凋—-&gt;炒青—-&gt;揉捻—-&gt;渥堆—-&gt;干燥—-&gt;覆火—-&gt;紧压</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;茶的分类&quot;&gt;&lt;a href=&quot;#茶的分类&quot; class=&quot;headerlink&quot; title=&quot;茶的分类&quot;&gt;&lt;/a&gt;茶的分类&lt;/h3&gt;&lt;p&gt;根据茶的发酵程度去区分茶的种类，目前已知可以分为：&lt;code&gt;绿茶&lt;/code&gt;、&lt;code&gt;红茶
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Butterknife源码解析</title>
    <link href="http://yoursite.com/2020/06/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Butterknife%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/06/04/移动端/Android原生/Butterknife源码解析/</id>
    <published>2020-06-04T08:48:12.000Z</published>
    <updated>2021-05-27T11:40:17.156Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindView(R.id.about_titleView)</span></span><br><span class="line">TitleView aboutTitleView;</span><br><span class="line"><span class="meta">@BindView(R.id.view_about)</span></span><br><span class="line">LinearLayout viewAbout;</span><br><span class="line"></span><br><span class="line">Unbinder mBinder;</span><br><span class="line"></span><br><span class="line">onCreate()&#123;</span><br><span class="line">    mBinder = ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onDestory()&#123;</span><br><span class="line">    mBinder.unbind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法极其简单，减少findViewById的重复代码</p><p>BindView源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(CLASS)</span> <span class="meta">@Target(FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">  <span class="comment">/** View ID to which the field will be bound. */</span></span><br><span class="line">  <span class="meta">@IdRes</span> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ButterKnife.bind(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>进入bind方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span> <span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(<span class="meta">@NonNull</span> Activity target)</span> </span>&#123;</span><br><span class="line">  View sourceView = target.getWindow().getDecorView();</span><br><span class="line">  <span class="keyword">return</span> createBinding(target, sourceView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前该activity的window上的decorView（获取最顶层view），创建绑定操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unbinder <span class="title">createBinding</span><span class="params">(<span class="meta">@NonNull</span> Object target, <span class="meta">@NonNull</span> View source)</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">  <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">&quot;Looking up binding for &quot;</span> + targetClass.getName());</span><br><span class="line">  Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Unbinder.EMPTY;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">return</span> constructor.newInstance(target, source);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入findBindingConstructorForClass方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span> <span class="meta">@CheckResult</span> <span class="meta">@UiThread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    <span class="comment">//从缓存中获取绑定关系（key--class类,value--构造函数）</span></span><br><span class="line">  Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class="line">  <span class="keyword">if</span> (bindingCtor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">&quot;HIT: Cached in binding map.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> bindingCtor;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//获取类名</span></span><br><span class="line">  String clsName = cls.getName();</span><br><span class="line">    <span class="comment">//排除android系统类和java系统类</span></span><br><span class="line">  <span class="keyword">if</span> (clsName.startsWith(<span class="string">&quot;android.&quot;</span>) || clsName.startsWith(<span class="string">&quot;java.&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">&quot;MISS: Reached framework class. Abandoning search.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//加载一个className_ViewBinding类</span></span><br><span class="line">    Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + <span class="string">&quot;_ViewBinding&quot;</span>);</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="comment">//通过反射获取该类的构造函数</span></span><br><span class="line">    bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">&quot;HIT: Loaded binding class and constructor.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">&quot;Not found. Trying superclass &quot;</span> + cls.getSuperclass().getName());</span><br><span class="line">    bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unable to find binding constructor for &quot;</span> + clsName, e);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将构造器信息放入缓存中</span></span><br><span class="line">  BINDINGS.put(cls, bindingCtor);</span><br><span class="line">  <span class="keyword">return</span> bindingCtor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终生成一个_ViewBinding类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AboutActivity_ViewBinding</span> <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AboutActivity target;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AboutActivity_ViewBinding</span><span class="params">(AboutActivity target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(target, target.getWindow().getDecorView());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AboutActivity_ViewBinding</span><span class="params">(AboutActivity target, View source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">    target.aboutTitleView = Utils.findRequiredViewAsType(source, R.id.about_titleView, <span class="string">&quot;field &#x27;aboutTitleView&#x27;&quot;</span>, TitleView.class);</span><br><span class="line">    target.viewAbout = Utils.findRequiredViewAsType(source, R.id.view_about, <span class="string">&quot;field &#x27;viewAbout&#x27;&quot;</span>, LinearLayout.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@CallSuper</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AboutActivity target = <span class="keyword">this</span>.target;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Bindings already cleared.&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    target.aboutTitleView = <span class="keyword">null</span>;</span><br><span class="line">    target.viewAbout = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结：bind方法后，新建一个ViewBinding类，用来做findviewById，onClick等操作，将注解节省的步骤在该类的构造方法中执行，当然这里的构造函数都是注解自动生成的，所以，是怎么样的操作实现这个类？</p><h4 id="ViewBinding类是怎么生成的？"><a href="#ViewBinding类是怎么生成的？" class="headerlink" title="_ViewBinding类是怎么生成的？"></a>_ViewBinding类是怎么生成的？</h4><p>这里要介绍一个注解器，ButterKnifeProcessor，这个注解器是解析注解，生成ViewBinding类的具体代码。</p><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p>初始化调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.init(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取viewBinding类</span></span><br><span class="line">    String sdk = env.getOptions().get(OPTION_SDK_INT);</span><br><span class="line">    <span class="keyword">if</span> (sdk != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.sdk = Integer.parseInt(sdk);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        env.getMessager()</span><br><span class="line">            .printMessage(Kind.WARNING, <span class="string">&quot;Unable to parse supplied minSdk option &#x27;&quot;</span></span><br><span class="line">                + sdk</span><br><span class="line">                + <span class="string">&quot;&#x27;. Falling back to API 1 support.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否是debug模式</span></span><br><span class="line">    debuggable = !<span class="string">&quot;false&quot;</span>.equals(env.getOptions().get(OPTION_DEBUGGABLE));</span><br><span class="line"></span><br><span class="line">    typeUtils = env.getTypeUtils();</span><br><span class="line">    filer = env.getFiler();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      trees = Trees.instance(processingEnv);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ignored) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Get original ProcessingEnvironment from Gradle-wrapped one or KAPT-wrapped one.</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : processingEnv.getClass().getDeclaredFields()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;delegate&quot;</span>) || field.getName().equals(<span class="string">&quot;processingEnv&quot;</span>)) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            ProcessingEnvironment javacEnv = (ProcessingEnvironment) field.get(processingEnv);</span><br><span class="line">            trees = Trees.instance(javacEnv);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ignored2) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法主要是获取注解所要生成的viewBing类并进行绑定，遍历java源代码，获取所有的Element元素</p><h5 id="process"><a href="#process" class="headerlink" title="process"></a>process</h5><p>实际处理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取注解类型Element和程序代码对应关系</span></span><br><span class="line">    Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</span><br><span class="line">      TypeElement typeElement = entry.getKey();</span><br><span class="line">      BindingSet binding = entry.getValue();</span><br><span class="line"></span><br><span class="line">      JavaFile javaFile = binding.brewJava(sdk, debuggable);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        javaFile.writeTo(filer);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        error(typeElement, <span class="string">&quot;Unable to write binding for type %s: %s&quot;</span>, typeElement, e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>BindingSet：对应注解类型的绑定配置</p><ol><li>通过findAndParseTargets获取注解类型Element和配置的相关信息</li><li>遍历Map，生成JavaFile</li><li>生成_ViewBinding文件，将javaFile写入</li></ol><p>进入findAndParseTargets中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; <span class="title">findAndParseTargets</span><span class="params">(RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">   Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">   Set&lt;TypeElement&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   scanForRClasses(env);</span><br><span class="line">   </span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process each @BindView element.</span></span><br><span class="line">   <span class="comment">//获取BindView注解修饰的Element对象</span></span><br><span class="line">   <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;</span><br><span class="line">     <span class="comment">// we don&#x27;t SuperficialValidation.validateElement(element)</span></span><br><span class="line">     <span class="comment">// so that an unresolved View type can be generated by later processing rounds</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       parseBindView(element, builderMap, erasedTargetNames);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       logParsingError(element, BindView.class, e);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   .......</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process each annotation that corresponds to a listener.</span></span><br><span class="line">   <span class="comment">//处理监听器注解类型</span></span><br><span class="line">   <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123;</span><br><span class="line">     findAndParseListener(env, listener, builderMap, erasedTargetNames);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Associate superclass binders with their subclass binders. This is a queue-based tree walk</span></span><br><span class="line">   <span class="comment">// which starts at the roots (superclasses) and walks to the leafs (subclasses).</span></span><br><span class="line">   Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =</span><br><span class="line">       <span class="keyword">new</span> ArrayDeque&lt;&gt;(builderMap.entrySet());</span><br><span class="line">   Map&lt;TypeElement, BindingSet&gt; bindingMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">   <span class="keyword">while</span> (!entries.isEmpty()) &#123;</span><br><span class="line">     <span class="comment">//从队列中取出第一个元素</span></span><br><span class="line">     Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//获取对应的key和value</span></span><br><span class="line">     TypeElement type = entry.getKey();</span><br><span class="line">     BindingSet.Builder builder = entry.getValue();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//查找当前元素的父类元素</span></span><br><span class="line">     TypeElement parentType = findParentType(type, erasedTargetNames);</span><br><span class="line">     <span class="keyword">if</span> (parentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//没找到父类，重新放入队列</span></span><br><span class="line">       bindingMap.put(type, builder.build());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//获取父类Element对应的BindingSet</span></span><br><span class="line">       BindingSet parentBinding = bindingMap.get(parentType);</span><br><span class="line">       <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//设置父类BindingSet并添加到Map中</span></span><br><span class="line">         builder.setParent(parentBinding);</span><br><span class="line">         bindingMap.put(type, builder.build());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Has a superclass binding but we haven&#x27;t built it yet. Re-enqueue for later.</span></span><br><span class="line">         <span class="comment">//具有超类绑定，但我们尚未构建它。重新排队以便稍后使用</span></span><br><span class="line">         entries.addLast(entry);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> bindingMap;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ol><li>获取到所有的bind类注解的Element</li><li>并执行parseBindView()方法，绑定buildingSet和TypeElement的对应关系：</li><li>获取父类BindingSet对象，重新构建绑定关系，并返回该对应关系</li></ol><p>进入parseBindView中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBindView</span><span class="params">(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,</span></span></span><br><span class="line"><span class="params"><span class="function">    Set&lt;TypeElement&gt; erasedTargetNames)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前对象的父类，如果在Activity中使用，那么enclosingElement就是Activity类</span></span><br><span class="line">  TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start by verifying common generated code restrictions.</span></span><br><span class="line">  <span class="comment">//校验对象，不能使用private和static修饰</span></span><br><span class="line">  <span class="keyword">boolean</span> hasError = isInaccessibleViaGeneratedCode(BindView.class, <span class="string">&quot;fields&quot;</span>, element)</span><br><span class="line">      || isBindingInWrongPackage(BindView.class, element);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Verify that the target type extends from View.</span></span><br><span class="line">  TypeMirror elementType = element.asType();</span><br><span class="line">  <span class="keyword">if</span> (elementType.getKind() == TypeKind.TYPEVAR) &#123;</span><br><span class="line">    TypeVariable typeVariable = (TypeVariable) elementType;</span><br><span class="line">    elementType = typeVariable.getUpperBound();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取类名（包名+类名）</span></span><br><span class="line">  Name qualifiedName = enclosingElement.getQualifiedName();</span><br><span class="line">  <span class="comment">//获取成员变量名称</span></span><br><span class="line">  Name simpleName = element.getSimpleName();</span><br><span class="line">  <span class="comment">//判断当前对象是否为view的子类或者接口，不是的话抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementType.getKind() == TypeKind.ERROR) &#123;</span><br><span class="line">      note(element, <span class="string">&quot;@%s field with unresolved type (%s) &quot;</span></span><br><span class="line">              + <span class="string">&quot;must elsewhere be generated as a View or interface. (%s.%s)&quot;</span>,</span><br><span class="line">          BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      error(element, <span class="string">&quot;@%s fields must extend from View or be an interface. (%s.%s)&quot;</span>,</span><br><span class="line">          BindView.class.getSimpleName(), qualifiedName, simpleName);</span><br><span class="line">      hasError = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assemble information on the field.</span></span><br><span class="line">  <span class="comment">//获取注解的value资源id（控件id值）</span></span><br><span class="line">  <span class="keyword">int</span> id = element.getAnnotation(BindView.class).value();</span><br><span class="line">  <span class="comment">//获取父类的BindingSet.Builder</span></span><br><span class="line">  BindingSet.Builder builder = builderMap.get(enclosingElement);</span><br><span class="line">  <span class="comment">//将id和对象进行绑定</span></span><br><span class="line">  QualifiedId qualifiedId = elementToQualifiedId(element, id);</span><br><span class="line">  <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//查询是否重复绑定</span></span><br><span class="line">    String existingBindingName = builder.findExistingBindingName(getId(qualifiedId));</span><br><span class="line">    <span class="keyword">if</span> (existingBindingName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      error(element, <span class="string">&quot;Attempt to use @%s for an already bound ID %d on &#x27;%s&#x27;. (%s.%s)&quot;</span>,</span><br><span class="line">          BindView.class.getSimpleName(), id, existingBindingName,</span><br><span class="line">          enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//将父类和BindingSet.Builder进行绑定并添加到builderMap中，并返回这个binder对象</span></span><br><span class="line">    builder = getOrCreateBindingBuilder(builderMap, enclosingElement);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String name = simpleName.toString();</span><br><span class="line">  TypeName type = TypeName.get(elementType);</span><br><span class="line">  <span class="comment">//判断是否使用Nullable注解</span></span><br><span class="line">  <span class="keyword">boolean</span> required = isFieldRequired(element);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将资源id，（对象名，对象类型，是否使用Nullable添加到builder中</span></span><br><span class="line">  builder.addField(getId(qualifiedId), <span class="keyword">new</span> FieldViewBinding(name, type, required));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the type-erased version to the valid binding targets set.</span></span><br><span class="line">  <span class="comment">//将父元素添加到集合中用来查找父元素信息</span></span><br><span class="line">  erasedTargetNames.add(enclosingElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>校验对象修饰不能是private和static</li><li>校验View是否为对象的超类</li><li>获取资源id并进行绑定，添加到集合中</li></ol><p>在上述分析过程中，生成一个BindingSet类再通过JavaFile生成对应文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JavaFile <span class="title">brewJava</span><span class="params">(<span class="keyword">int</span> sdk, <span class="keyword">boolean</span> debuggable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JavaFile.builder(bindingClassName.packageName(), createType(sdk, debuggable))</span><br><span class="line">        <span class="comment">//添加类头注释</span></span><br><span class="line">        .addFileComment(<span class="string">&quot;Generated code from Butter Knife. Do not modify!&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>将java版本和是否为debug传入，传入包名+类名，根据类型创建不同代码，JavaFile属于javapoet包类，使用javapoet将实现类代码生成文件。</p><h5 id="getSupportedAnnotationTypes"><a href="#getSupportedAnnotationTypes" class="headerlink" title="getSupportedAnnotationTypes"></a>getSupportedAnnotationTypes</h5><p>获得要处理的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; types = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123;</span><br><span class="line">      types.add(annotation.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> types;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123;</span><br><span class="line">    Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    annotations.add(BindAnim.class);</span><br><span class="line">    annotations.add(BindArray.class);</span><br><span class="line">    annotations.add(BindBitmap.class);</span><br><span class="line">    annotations.add(BindBool.class);</span><br><span class="line">    annotations.add(BindColor.class);</span><br><span class="line">    annotations.add(BindDimen.class);</span><br><span class="line">    annotations.add(BindDrawable.class);</span><br><span class="line">    annotations.add(BindFloat.class);</span><br><span class="line">    annotations.add(BindFont.class);</span><br><span class="line">    annotations.add(BindInt.class);</span><br><span class="line">    annotations.add(BindString.class);</span><br><span class="line">    annotations.add(BindView.class);</span><br><span class="line">    annotations.add(BindViews.class);</span><br><span class="line">    annotations.addAll(LISTENERS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> annotations;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ButterknifeProcessor支持的所有注解类型</p><h5 id="getSupportedSourceVersion"><a href="#getSupportedSourceVersion" class="headerlink" title="getSupportedSourceVersion"></a>getSupportedSourceVersion</h5><p>指定java版本<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个是基本写法，一般都这样写</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Butterknife只是针对view的注入框架，在编译过程中，使用自定义注解器的方式解析注解，生成对应关系后，通过BindingSet+JavaFile的javapoet技术将程序类写入文件，生成Activity_ViewBinding文件，在bind方法中，反射获取Activity_ViewBinding类的构造函数，存入缓存，返回构造函数后实例化对象，完成视图的绑定</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>EventBus用法和源码解析</title>
    <link href="http://yoursite.com/2020/04/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/EventBus%E7%94%A8%E6%B3%95%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/04/16/移动端/Android原生/EventBus用法和源码解析/</id>
    <published>2020-04-16T03:03:49.000Z</published>
    <updated>2021-05-27T11:40:17.156Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>参照版本：</p><p>EventBus 3.0以后</p><h4 id="为什么选择EventBus"><a href="#为什么选择EventBus" class="headerlink" title="为什么选择EventBus"></a>为什么选择EventBus</h4><ul><li>简化了 组件交流方式</li><li>对事件通信双方解耦</li><li>灵活指定线程（4种线程模式）</li><li>速度快，性能好</li><li>库比较小，不占内存</li><li>使用方便</li></ul><h4 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h4><p><img src="/img/eventBus1.png" alt="EventBus模式分工图"></p><h5 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h5><ol><li><strong>Event</strong>：事件</li><li><strong>Subscriber</strong>：事件订阅者</li><li><strong>Publisher</strong>：事件发布者</li></ol><h5 id="五种线程模式"><a href="#五种线程模式" class="headerlink" title="五种线程模式"></a>五种线程模式</h5><ol><li><strong>POSTING</strong>：默认，发布和订阅在同一个线程</li><li><strong>MAIN</strong>：事件处理函数的线程在主线程（UI）线程。不能进行<code>耗时</code>操作，订阅者需快速返回以免阻塞主线程</li><li><strong>MAIN_ORDERED</strong>:事件处理函数的线程在主线程（UI）线程。不能进行<code>耗时</code>操作，不会阻塞线程</li><li><strong>BACKGROUND</strong>：处理函数在后台线程，不能进行UI操作。发布在主线程，订阅会开启一个新的后台线程。发布在后台线程，事件处理函数也在该后台线程</li><li><strong>ASYNC</strong>：无论事件发布的线程是哪一个，都会重新开辟一个新的子线程运行，不能进行UI操作</li></ol><blockquote><p><strong>MAIN和MAIN_ORDERED区别</strong></p><ol><li>在<code>MAIN</code>模式下，如果事件发布者post事件也是在主线程的话，会阻塞post事件所在的线程，意思是连续post多个事件，如果接收事件方法执行完，才能post下一个事件</li></ol><p>​         <strong>post(1) ——&gt; onReceiveMsg(1) ——&gt;post(2)——&gt;onReceiveMsg(2)——&gt;post(3)——&gt;onReceiveMsg(3)</strong></p><ol start="2"><li>如果事件发布者post事件不在主线程，连续post多个事件，同事在主线程是接收事件是耗时操作的话，执行的流程是非阻塞的</li></ol><p>​         <strong>post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(3)</strong><br>​         或<br>​         <strong>post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(2)——&gt;onReceiveMsg(3)</strong></p><ol start="3"><li>MAIN_ORDERED模式下，无论什么场景都是非阻塞的</li></ol></blockquote><h5 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h5><p><strong>普通事件</strong>：注册和反注册后，发送EventBus.post()事件，在需要接收的地方使用@Subscribe方法，方法必须是public</p><p><strong>粘性事件</strong>：注册和反注册后，发送EventBus.postSticky()黏性事件，在需要接收的地方使用@Subscribe方法，方法必须是public，添加sticky = true</p><blockquote><p>普通事件是先订阅后发送，粘性事件支持先发送后订阅</p></blockquote><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>说明：优先级高的订阅者优先接收到任务</p><ol><li>threadMode参数相同</li><li>只有走到threadMode参数为POSTING的时候才会<code>停止该事件的继续分发</code>，调用<code>cancelEventDelivery(xx)</code></li></ol><h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes *Annotation*</span><br><span class="line">-keepclassmembers class ** &#123;</span><br><span class="line">    @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line">-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;</span><br><span class="line"></span><br><span class="line"># Only required if you use AsyncExecutor</span><br><span class="line">-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123;</span><br><span class="line">    &lt;init&gt;(java.lang.Throwable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>目的：</p><p>如何使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [ eventBusIndex : <span class="string">&#x27;com.example.myapp.MyEventBusIndex&#x27;</span> ] <span class="comment">##这里要修改为你项目的包名</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.greenrobot:eventbus:3.1.1&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.greenrobot:eventbus-annotation-processor:3.1.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>\app\build\generated\source\apt\debug\package\</code>下可查看生成的MyEventBusIndex文件</p><p>在Application中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).installDefaultEventBus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在整个应用使用默认实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).installDefaultEventBus();</span><br><span class="line"><span class="comment">// Now the default instance uses the given index. Use it like this:</span></span><br><span class="line">EventBus eventBus = EventBus.getDefault();</span><br></pre></td></tr></table></figure><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><img src="/img/eventBus2.png" alt="EventBus源码解析图"></p><p>注册流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Convenience singleton for apps using a process-wide EventBus instance. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getDefault使用单例模式，保证整个app只有唯一实例。初次进入会进入无参构造中初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</span></span><br><span class="line"><span class="comment"> * central bus, consider &#123;<span class="doctag">@link</span> #getDefault()&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br></pre></td></tr></table></figure><p>由此可以看出来DEFAULT_BUILDED是EventBusBuilder实例，具体的初始化在下面这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    logger = builder.getLogger();</span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">    mainThreadPoster = mainThreadSupport != <span class="keyword">null</span> ? mainThreadSupport.createPoster(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">    asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化配置，部分配置从builder中获取，这是典型的建造者模式，查看EventBusBuilder类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Builds an EventBus based on the current configuration. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventBus(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看EventBus类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBusBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以用两种初始化的方法：</p><ul><li>EventBus.builder().build();</li><li>EventBus.getDefault()</li></ul><p>EventBusBuilder中配置如下</p><ol><li>成员变量</li></ol><ul><li><code>logSubscriberExceptions</code> :是否打印订阅者异常信息，默认开启</li><li><code>logNoSubscriberMessages</code> :某个事件没有订阅者时，是否打印信息，默认开启</li><li><code>sendSubscriberExceptionEvent</code> :出现订阅者异常时，是否发送异常事件，默认开启</li><li><code>sendNoSubscriberEvent</code> :某个事件没有订阅者时，是否发送无订阅者的事件，默认开启</li><li><code>throwSubscriberException</code> :是否抛出订阅者异常信息，默认关闭</li><li><code>eventInheritance</code> :事件是否可以继承形式订阅，默认开启</li><li><code>ignoreGeneratedIndex</code> :忽略索引生成，默认关闭</li><li><code>strictMethodVerification</code> :是否开启方法严格验证，默认关闭</li><li><code>executorService</code> :线程池，默认是newCachedThreadPool，即没有核心线程、但最大线程数是Integer.MAX_VALUE的线程池</li><li><code>skipMethodVerificationForClasses</code> :跳过为订阅者类里面的方法进行校验，校验包括注解信息、修饰符是否是public且非static\final的，默认为空</li><li><code>subscriberInfoIndexes</code> :订阅者信息索引，由注解处理器生成</li><li><code>mainThreadSupport</code> :专为Android的主线程定制，持有主线程looper引用</li></ul><ol start="2"><li>方法调用</li></ol><ul><li><p><code>addIndex(SubscriberInfoIndex index)</code>：添加索引 </p></li><li><p><code>eventInheritance(boolean eventInheritance)</code>：是否支持事件继承</p></li><li><p><code>executorService(java.util.concurrent.ExecutorService executorService)</code>：提供用于一部和后台时间传递的自定义线程池</p></li><li><p><code>ignoreGeneratedIndex(boolean ignoreGeneratedIndex)</code>：强制使用反射，即使有生成的索引（默认值：false）。</p></li><li><p><code>skipMethodVerificationFor(java.lang.Class&lt;?&gt; clazz)</code>：对以onEvent开头的方法进行方法名验证，以避免键入错误；使用此方法，可以从此检查中排除订阅服务器类。</p></li><li><p><code>logNoSubscriberMessages(boolean logNoSubscriberMessages)</code>：当调用事件处理函数异常时是否打印异常信息</p></li><li><p><code>logSubscriberExceptions(boolean logSubscriberExceptions)</code>：当没有订阅者订阅该事件时是否打印日志</p></li><li><p><code>sendNoSubscriberEvent(boolean sendNoSubscriberEvent)</code>：当调用事件处理函数异常时是否发送 SubscriberExceptionEvent 事件，若此开关打开，订阅者可通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(SubscriberExceptionEvent event)</span></span></span><br></pre></td></tr></table></figure><p>订阅该事件进行处理，默认为 true。</p></li><li><p><code>sendSubscriberExceptionEvent(boolean sendSubscriberExceptionEvent)</code>：当没有事件处理函数对事件处理时是否发送 NoSubscriberEvent 事件，若此开关打开，订阅者可通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(NoSubscriberEvent event)</span></span></span><br></pre></td></tr></table></figure><p>订阅该事件进行处理，默认为 true。</p></li><li><p><code>strictMethodVerification**(boolean strictMethodVerification)</code>：启用严格的方法验证（默认值：false）。</p></li><li><p><code>throwSubscriberException**(boolean throwSubscriberException)</code>：如果订阅服务器引发异常，则失败（默认值：false）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().throwSubscriberException(<span class="keyword">true</span>).installDefaultEventBus()</span><br></pre></td></tr></table></figure></li></ul><p>根据builder的默认配置统计得出：</p><ul><li>当出现订阅者异常时，打印异常log</li><li>当事件没有订阅者时，打印没有订阅者log</li><li>当出现订阅者异常时，发送异常事件</li><li>当事件没有订阅者时，发送无订阅者事件</li><li>捕获异常信息，防止崩溃</li><li>事件可以继承</li><li>编译时生成索引</li><li>采用最大限制是Integer.MAX_VALUE的缓存线程池</li><li>为每个订阅者类都进行方法校验</li><li>当处于Android平台时，确保可以切换到主线程</li></ul><p>自定义配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().logNoSubscriberMessages(<span class="keyword">false</span>)</span><br><span class="line">                .logSubscriberExceptions(<span class="keyword">false</span>).eventInheritance(<span class="keyword">false</span>)...</span><br><span class="line">                .installDefaultEventBus();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().logNoSubscriberMessages(<span class="keyword">false</span>)</span><br><span class="line">                .logSubscriberExceptions(<span class="keyword">false</span>).eventInheritance(<span class="keyword">false</span>)...</span><br><span class="line">                                .build();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">installDefaultEventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (EventBus.defaultInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Default instance already exists.&quot;</span> +</span><br><span class="line">                        <span class="string">&quot; It may be only set once before it&#x27;s used the first time to ensure consistent behavior.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            EventBus.defaultInstance = build();</span><br><span class="line">            <span class="keyword">return</span> EventBus.defaultInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EventBus(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>installDefaultEventBus调用的也是build（）方法，但是该方法多了一个单例，确保其全局的唯一性，所以使用build方法时需要自己维护其唯一性</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br></pre></td></tr></table></figure><p>进入register方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取订阅者类</span></span><br><span class="line">       Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">       <span class="comment">//获取该订阅类的所有订阅方法</span></span><br><span class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="comment">//挨个订阅</span></span><br><span class="line">           <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">               subscribe(subscriber, subscriberMethod);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>SubscriberMethod是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Method method;   <span class="comment">//订阅方法</span></span><br><span class="line">    <span class="keyword">final</span> ThreadMode threadMode;  <span class="comment">//线程模式</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; eventType;   <span class="comment">//事件类型（传递消息的对象）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> priority;   <span class="comment">//优先级</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;  <span class="comment">//是否为粘性事件</span></span><br><span class="line">    <span class="comment">/** Used for efficient comparison */</span></span><br><span class="line">    String methodString;     <span class="comment">//该并非构造初始成员变量，只是用区分其他的SubscriberMethod。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然该事件是我们订阅方法的详细参数，那么他是从哪里来的，跟踪findSubscriberMethods</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">......</span><br><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从HashMap缓存中根据class获取对应的所有订阅方法</span></span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">        <span class="comment">//不为空，返回</span></span><br><span class="line">        <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在索引（初始化的成员变量）</span></span><br><span class="line">        <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">            <span class="comment">//使用反射技术查询（直译），具体功能，后续追踪</span></span><br><span class="line">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//使用索引查找（直译），具体功能，后续追踪</span></span><br><span class="line">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//为空，报错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Subscriber &quot;</span> + subscriberClass</span><br><span class="line">                    + <span class="string">&quot; and its super classes have no public methods with the @Subscribe annotation&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不为空，将索引判断后查找的值更新到缓存中</span></span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从缓存中根据订阅者的class对象获取对应的所有订阅方法，继续跟踪subscribe()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取订阅事件</span></span><br><span class="line">       Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">       Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">      <span class="comment">//private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span></span><br><span class="line">      <span class="comment">//获取该事件类型对应的所有订阅者信息（Subscription）</span></span><br><span class="line">       CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">       <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果信息为null，初始化subscription，将该订阅信息放入其中</span></span><br><span class="line">           subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">           subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//如果信息不为null，map中包含该订阅信息，则报错，已经被注册了</span></span><br><span class="line">           <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Subscriber &quot;</span> + subscriber.getClass() + <span class="string">&quot; already registered to event &quot;</span></span><br><span class="line">                       + eventType);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//根据priority优先级插入订阅信息subscriptions中</span></span><br><span class="line">       <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">               subscriptions.add(i, newSubscription);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span></span><br><span class="line">       <span class="comment">//根据订阅者，从typeBySubscriber中取出订阅者事件类型</span></span><br><span class="line">       List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">       <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//创建一个空的事件类型集和放入typesBySubscriber</span></span><br><span class="line">           subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">//将事件类型的class对象放入subscribedEvents</span></span><br><span class="line">       subscribedEvents.add(eventType);</span><br><span class="line">    </span><br><span class="line">  .....</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object subscriber;</span><br><span class="line">    <span class="keyword">final</span> SubscriberMethod subscriberMethod;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Becomes false as soon as &#123;<span class="doctag">@link</span> EventBus#unregister(Object)&#125; is called, which is checked by queued event delivery</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EventBus#invokeSubscriber(PendingPost)&#125; to prevent race conditions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> active;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Subscription为记录每个订阅方法和其对应的订阅者类，active在解注册的时候会被置为false，详看<code>解注册</code></p><p>继续讲subscribe()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//如果是粘性事件</span></span><br><span class="line">        <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">            <span class="comment">//如果事件类型是可继承的</span></span><br><span class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">                <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">                <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">                <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">                <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span></span><br><span class="line">                <span class="comment">//stickyEvents存储具体的粘性事件</span></span><br><span class="line">                <span class="comment">//map变化为set</span></span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                <span class="comment">//循环遍历</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    <span class="comment">//判断candidaetEventType是否为eventType的子类</span></span><br><span class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是粘性事件，进入checkPostStickyEventToSubscription()方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></span><br><span class="line">            <span class="comment">// --&gt; Strange corner case, which we don&#x27;t take care of here.</span></span><br><span class="line">            postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>跳转到postToSubscription()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断该事件的线程模式，执行不同操作</span></span><br><span class="line">        <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> POSTING:</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN:</span><br><span class="line">                <span class="comment">//isMainThread判断订阅方法是否在main线程</span></span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//切换到主线程异步执行</span></span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">                <span class="comment">//如果在主线程</span></span><br><span class="line">                <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//主线程异步执行</span></span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                    <span class="comment">//不在主线程</span></span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    <span class="comment">//如果在主线程，切换到后台线程</span></span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                <span class="comment">//开启异步执行方法</span></span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终的enqueue()方法都是调用的invokeSubscriber方法</p><p>总结：通过注解初始化订阅方法后，在register后，在缓存中获取所有该订阅者的方法，循环遍历订阅，新建newSubscription方法，根据priority优先级将newSubscription方法放入subscriptions中，判断如果<code>是粘性事件</code>，则执行其对应的订阅方法。</p><h4 id="解注册"><a href="#解注册" class="headerlink" title="解注册"></a>解注册</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(this);</span><br></pre></td></tr></table></figure><p>进入unregister方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//注册时放入的typesBySubscriber，现在从其中根据订阅者类取出订阅者事件类型</span></span><br><span class="line">       List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">       <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//遍历执行unsubscribeByEventType，并从typesBySubscriber中删除</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">               unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">           &#125;</span><br><span class="line">           typesBySubscriber.remove(subscriber);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           logger.log(Level.WARNING, <span class="string">&quot;Subscriber to unregister was not registered before: &quot;</span> + subscriber.getClass());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入unsubscribeByEventType():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从subscriptionsByEventType中获取所有的订阅者信息</span></span><br><span class="line">        List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Subscription subscription = subscriptions.get(i);</span><br><span class="line">                <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                    <span class="comment">//将active置为false，并移除</span></span><br><span class="line">                    subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                    subscriptions.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：从typesBySubscriber获取订阅事件类型，根据订阅事件类型从subscriptionsByEventType获取订阅者信息，将subscription的active置为false，并移除该subscription</p><p>明显看出时regist的逆过程</p><blockquote><p>typesBySubscriber ：键是订阅者类，值是订阅事件类型的map</p><p>subscriptionsByEventType：键是订阅事件类型，值是订阅者信息</p><p>subscription:订阅信息，封装了订阅者类型和订阅方法，还有判断是否已经注册的active</p></blockquote><h4 id="发布普通事件"><a href="#发布普通事件" class="headerlink" title="发布普通事件"></a>发布普通事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(EventType type);</span><br></pre></td></tr></table></figure><p>进入post：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从线程池中获取线程</span></span><br><span class="line">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">        <span class="comment">//获取线程的事件队列，并将当前事件入队</span></span><br><span class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">        eventQueue.add(event);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//如果事件没有发布</span></span><br><span class="line">        <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">            <span class="comment">//isMainThread（）方法获取发布者当前线程</span></span><br><span class="line">            postingState.isMainThread = isMainThread();</span><br><span class="line">            <span class="comment">//设置事件已发布状态</span></span><br><span class="line">            postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果事件被取消，报错</span></span><br><span class="line">            <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Internal error. Abort state was not reset&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//轮询eventQueue发布事件，最后取消正在发布（设置为false）</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">                postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>详看PostingThreadState是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;&gt;();    <span class="comment">//object集合（队列）</span></span><br><span class="line">        <span class="keyword">boolean</span> isPosting;         <span class="comment">//是否正在发布</span></span><br><span class="line">        <span class="keyword">boolean</span> isMainThread;      <span class="comment">//发布者是否在主线程</span></span><br><span class="line">        Subscription subscription;   <span class="comment">//订阅信息</span></span><br><span class="line">        Object event;               <span class="comment">//当前事件</span></span><br><span class="line">        <span class="keyword">boolean</span> canceled;        <span class="comment">//发布的事件是否被取消了</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>PostingThreadState中包含了eventQueue和其他的标志位</p><p>进入postSingleEvent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">       <span class="comment">//获取事件类型</span></span><br><span class="line">       Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">       <span class="comment">//订阅是否被查找到</span></span><br><span class="line">       <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">//如果事件是可继承的</span></span><br><span class="line">       <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">           <span class="comment">//查找所有事件类型</span></span><br><span class="line">           List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">           <span class="comment">//获取事件类型数量</span></span><br><span class="line">           <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">               Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">               <span class="comment">//是否有被订阅的，postSingleEventForEventTyper若为true，则subscriptionFound为true</span></span><br><span class="line">               subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//如果事件不是被继承的</span></span><br><span class="line">           <span class="comment">//是否有被订阅的，postSingleEventForEventTyper若为true，则subscriptionFound为true</span></span><br><span class="line">           subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//没有发现订阅者</span></span><br><span class="line">       <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">           <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">               logger.log(Level.FINE, <span class="string">&quot;No subscribers registered for event &quot;</span> + eventClass);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                   eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">               <span class="comment">//将他标记为没有订阅者的post</span></span><br><span class="line">               post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入lookupAllEventTypes：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">        <span class="comment">//线程安全写法，访问事件类型缓存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">            <span class="comment">//根据事件类型获取所有其的超类</span></span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">            <span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//初始化，并将事件类型存入</span></span><br><span class="line">                eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">                <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    eventTypes.add(clazz);</span><br><span class="line">                    addInterfaces(eventTypes, clazz.getInterfaces());</span><br><span class="line">                    <span class="comment">//获取其超类</span></span><br><span class="line">                    clazz = clazz.getSuperclass();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//加入缓存</span></span><br><span class="line">                eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> eventTypes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入postSingleEventForEventType：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">       CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="comment">//根据订阅事件类型获取订阅者信息（键-订阅事件类型，值-订阅者信息）</span></span><br><span class="line">           subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">           <span class="comment">//循环遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">               postingState.event = event;</span><br><span class="line">               postingState.subscription = subscription;</span><br><span class="line">               <span class="comment">//是否被取消</span></span><br><span class="line">               <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                   aborted = postingState.canceled;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">//始终会执行</span></span><br><span class="line">                   postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                   postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                   postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//如果被取消，跳出循环,后续不在执行</span></span><br><span class="line">               <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入postToSubscription中，发送事件到订阅者，根据模式不同，不同处理</p><p>总结：事件可继承，获取事件所有超类，挨个发布信息，反之则发布信息，根据不同的模式，在不同线程中做处理。</p><h4 id="发布粘性事件"><a href="#发布粘性事件" class="headerlink" title="发布粘性事件"></a>发布粘性事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(EventType type);</span><br></pre></td></tr></table></figure><p>进入postSticky:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">           <span class="comment">//将粘性事件放置在stickyEvents中</span></span><br><span class="line">           stickyEvents.put(event.getClass(), event);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">       <span class="comment">//执行post方法</span></span><br><span class="line">       post(event);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在postSticky中将粘性事件放置在stickyEvents中，执行post事件，所以是先发送事件，</p><p>总结：在register中普通事件只是注册，而粘性事件多了一个步骤就是走了post的类似方法，在注册时会触发发布事件，这样在注册后就直接发布了。这就是粘性事件的原理。详看register源码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;参照版本：&lt;/p&gt;
&lt;p&gt;EventBus 3.0以后&lt;/p&gt;
&lt;h4 id=&quot;为什么选择EventBus&quot;&gt;&lt;a href=&quot;#为什么选择EventBus&quot; class=&quot;headerlink&quot; title=&quot;为什么选择EventBus&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JAVA泛型整理</title>
    <link href="http://yoursite.com/2019/12/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/JAVA%E6%B3%9B%E5%9E%8B%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/12/25/移动端/Android原生/JAVA泛型整理/</id>
    <published>2019-12-25T10:51:47.000Z</published>
    <updated>2021-05-27T11:40:17.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA泛型整理"><a href="#JAVA泛型整理" class="headerlink" title="JAVA泛型整理"></a>JAVA泛型整理</h2><p>[TOC]</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>泛型的本质是参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</p><p>操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为<code>泛型类</code>、<code>泛型接口</code>、<code>泛型方法</code>。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;类型相同&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>D/泛型测试: 类型相同</code>。</p><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><p>对此总结成一句话：泛型类型在逻辑上可以看成是多个不同的类型，实际上都是相同的基本类型。</p><h4 id="类型与区别"><a href="#类型与区别" class="headerlink" title="类型与区别"></a>类型与区别</h4><ul><li><code>？</code>表示不确定的java类型，是类通配符，代表所有类型。？不会进行类型推断</li><li><code>T</code>(type)表示具体的一个java类型</li><li><code>K V</code>(key value)分别代表java键值中的Key Value</li><li><code>E</code>(element)代表Element</li><li><code>N</code>（number）代表数值类型</li></ul><blockquote><ol><li>List&lt;? <code>extends</code> T&gt;和List &lt;? <code>super</code> T&gt;有什么区别?</li></ol><ul><li>List&lt;? extends T&gt;可以接受任何继承自T的类型的List</li><li>List&lt;? super T&gt;可以接受任何T的父类构成的List</li><li>例如List&lt;? extends Number&gt;可以接受List<Integer>或List<Float></li></ul><ol start="2"><li><code>Object</code>和<code>T</code>的区别？</li></ol><p>​        Object是一个实打实的类，并没有泛指谁，只有指定的Object类的，而T可以泛指Object，指任何java类    型，范围更广</p><ol start="3"><li>泛型的类型只能是类类型，不能是简单类型（简单八大数据类型）</li></ol></blockquote><p><strong>如果有泛型方法和非泛型方法,都满足条件,会执行非泛型方法</strong></p><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这<code>不是</code>一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key value is &quot;</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型类的中的泛型方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>泛型方法和可变参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;t is &quot;</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printMsg(<span class="string">&quot;111&quot;</span>,<span class="number">222</span>,<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;2323.4&quot;</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></figure><p><strong>静态方法与泛型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          &quot;StaticGenerator cannot be refrenced from static context&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，<br>那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。<br>所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</p></blockquote><p><strong>Sun的文档</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br></pre></td></tr></table></figure><blockquote><p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，<br>但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，<br>上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。<br>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p><p><code>编译器</code>：把源码交给编译器编译成计算机可以执行的文件的过程（把java代码编成class文件的过程，编译期只是做一些翻译的功能，并没有把代码放在内存中运行起来，而只是）</p><p><code>运行期</code>：把编译后的文件交给计算机执行</p></blockquote><p><strong>以下是ok的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.    </span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK </span></span><br></pre></td></tr></table></figure><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p><code>形参</code>和<code>实参</code>的区别</p><ul><li>形参是形式参数，接收调用者传递的参数</li><li>实参是实体参数，调用时传递出的参数</li></ul><blockquote><p>T<code>和</code>？`的区别？</p><ul><li><code>T</code>主要用于<code>声明</code>泛型类或泛型方法</li><li><code>？</code>主要用于<code>使用</code>泛型类或泛型方法</li><li><code>T</code>在同一个地方就代表一个具体的类型，而<code>？</code>就代表所有类型，可以理解为所有类型的父类</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JAVA泛型整理&quot;&gt;&lt;a href=&quot;#JAVA泛型整理&quot; class=&quot;headerlink&quot; title=&quot;JAVA泛型整理&quot;&gt;&lt;/a&gt;JAVA泛型整理&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>windows下使用adb命令tab无法补全</title>
    <link href="http://yoursite.com/2019/12/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/windows%E4%B8%8B%E4%BD%BF%E7%94%A8adb%E5%91%BD%E4%BB%A4tab%E6%97%A0%E6%B3%95%E8%A1%A5%E5%85%A8/"/>
    <id>http://yoursite.com/2019/12/17/移动端/Android原生/windows下使用adb命令tab无法补全/</id>
    <published>2019-12-17T06:33:53.000Z</published>
    <updated>2021-05-27T11:40:17.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="windows下使用adb命令tab无法补全"><a href="#windows下使用adb命令tab无法补全" class="headerlink" title="windows下使用adb命令tab无法补全"></a>windows下使用adb命令tab无法补全</h2><p>在windows中使用adb命令时，进入目录按tab没有自动补全，这样用起来很麻烦，不方便，所以做了一下整理：</p><ol><li>查询更换10进制为9的方法不生效</li><li>感觉和adb的版本有关，所以着手去查看使用的adb是否是androidSdk下的platform-tools中的adb进程</li></ol><ul><li>打开一个adb窗口</li><li>在任务管理器中查看adb命令的所在位置</li><li>在环境变量中删除所配置的adb环境，替换为%ANDROID_HOME%\platform-tools，即可</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;windows下使用adb命令tab无法补全&quot;&gt;&lt;a href=&quot;#windows下使用adb命令tab无法补全&quot; class=&quot;headerlink&quot; title=&quot;windows下使用adb命令tab无法补全&quot;&gt;&lt;/a&gt;windows下使用adb命令tab无法
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="adb" scheme="http://yoursite.com/tags/adb/"/>
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>mysql必知必会</title>
    <link href="http://yoursite.com/2019/07/01/%E5%90%8E%E7%AB%AF/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>http://yoursite.com/2019/07/01/后端/mysql必知必会/</id>
    <published>2019-07-01T07:34:26.000Z</published>
    <updated>2021-05-27T11:40:17.155Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>mysql是不区分大小写的</p></blockquote><p>查看数据表的列表 ==== 设计表<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show columns from xxx;</span><br></pre></td></tr></table></figure><br>查看数据表的所有数据<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from xxx;</span><br></pre></td></tr></table></figure></p><h4 id="distinct-（只返回不同的值）"><a href="#distinct-（只返回不同的值）" class="headerlink" title="distinct   （只返回不同的值）"></a>distinct   （只返回不同的值）</h4><p>只返回不同vend_id的vend_id行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select distinct vend_id </span><br><span class="line">from products;</span><br></pre></td></tr></table></figure></p><h4 id="limit-（限制结果）"><a href="#limit-（限制结果）" class="headerlink" title="limit （限制结果）"></a>limit （限制结果）</h4><p>返回前5行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select prod_name </span><br><span class="line">from products limit 5;</span><br></pre></td></tr></table></figure><br>返回从第5行开始的后4行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select prod_name </span><br><span class="line">from products limit 5,4;</span><br></pre></td></tr></table></figure><br>Mysql 5的语法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select prod_name </span><br><span class="line">from products limit 4 offset 3 ;</span><br></pre></td></tr></table></figure></p><h4 id="order-by（排序）"><a href="#order-by（排序）" class="headerlink" title="order by（排序）"></a>order by（排序）</h4><p>按字母顺序排列<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_name </span><br><span class="line">from products </span><br><span class="line">order by prod_name;</span><br></pre></td></tr></table></figure><br>按两个列排序<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_id,prod_price,prod_name </span><br><span class="line">from products </span><br><span class="line">order by prod_proce,prod_name;</span><br></pre></td></tr></table></figure></p><h4 id="desc-（指定排序方向—逆序）-asc（顺序）"><a href="#desc-（指定排序方向—逆序）-asc（顺序）" class="headerlink" title="desc （指定排序方向—逆序）   asc（顺序）"></a>desc （指定排序方向—逆序）   asc（顺序）</h4><p>按字母逆序排</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_id,prod_price,prod_name </span><br><span class="line">from products </span><br><span class="line">order by prod_price desc;</span><br></pre></td></tr></table></figure><p>按价格逆序，产品名顺序排</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_id,prod_price,prod_name </span><br><span class="line">from products </span><br><span class="line">order by prod_price desc,prod_name;</span><br></pre></td></tr></table></figure><h4 id="where（过滤）"><a href="#where（过滤）" class="headerlink" title="where（过滤）"></a>where（过滤）</h4><p>只返回prod_price的值为2.50的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name,prod_price form products where prod_pricce = 2.50;</span><br></pre></td></tr></table></figure><p>返回不是1003的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select vend_id,prod_name </span><br><span class="line">from products </span><br><span class="line">where vend_id != 1003;     // !=   ======  &lt;&gt; </span><br></pre></td></tr></table></figure><h4 id="between（之间）"><a href="#between（之间）" class="headerlink" title="between（之间）"></a>between（之间）</h4><p>加载个5，10美元之间的所有产品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_name,prod_price </span><br><span class="line">from products </span><br><span class="line">where prod_price between 5 and 10;</span><br></pre></td></tr></table></figure><p>检查具有NULL值的列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_name </span><br><span class="line">from products </span><br><span class="line">where prod_price is NULL;</span><br></pre></td></tr></table></figure><h4 id="and（满足所有给定条件的行）-or（满足任意给定条件的行）"><a href="#and（满足所有给定条件的行）-or（满足任意给定条件的行）" class="headerlink" title="and（满足所有给定条件的行） or（满足任意给定条件的行）"></a>and（满足所有给定条件的行） or（满足任意给定条件的行）</h4><p>供应商1003制造且价格小于等于10美元的所有产品的名称和价格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_id,prod_price,prod_name</span><br><span class="line">from products</span><br><span class="line">where vend_id = 1003 and prod_price &lt;= 10;</span><br></pre></td></tr></table></figure><p>供应商1003和1002制造的所有产品的产品名称和价格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_name,prod_price</span><br><span class="line">from products</span><br><span class="line">where vend_id = 1002 or vend_id = 1003;</span><br></pre></td></tr></table></figure><p>价格10美元以上且由1002或1003制造的产品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_name,prod_price</span><br><span class="line">from products</span><br><span class="line">where vend_id = 1002 or vend_id = 1003 or prod_price &gt;= 10;</span><br></pre></td></tr></table></figure><h4 id="in（制定条件范围）"><a href="#in（制定条件范围）" class="headerlink" title="in（制定条件范围）"></a>in（制定条件范围）</h4><p>检索供应商1002和1003制造的所有产品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select prod_name,prod_price </span><br><span class="line">from products</span><br><span class="line">where vend_id in (1002,1003)</span><br><span class="line">order by prod_name;</span><br><span class="line"></span><br><span class="line">等效于</span><br><span class="line"></span><br><span class="line">select prod_name,prod_price </span><br><span class="line">from products</span><br><span class="line">where vend_id = 1002 or vend_id == 1003</span><br><span class="line">order by prod_name;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>在使用长的合法选项清单时，in操作符的语法更清楚更直观</li><li>在使用in时，计算的次序更容易管理（因为使用的操作符更少）</li><li>in操作符一般比or操作符清单执行更快</li><li>in的最大有点事可以包含其他select语句，使得能够更加动态地建立where字句</li></ol><h4 id="not-（否定where之后的所有的任何条件）"><a href="#not-（否定where之后的所有的任何条件）" class="headerlink" title="not （否定where之后的所有的任何条件）"></a>not （否定where之后的所有的任何条件）</h4><p>列出1002和1003之外的所有供应商制造的产品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select prod_name,prod_price</span><br><span class="line">from products </span><br><span class="line">where vend_id not in (1002,1003)</span><br><span class="line">order by prod_name;</span><br></pre></td></tr></table></figure><p>MySQL支持使用<code>NOT</code>对<code>IN</code>、<code>BETWEEN</code>和<code>EXISTS</code>字句取反</p><h4 id="like（用来匹配值的一部分的特殊字符，由字面值、通配符或两者组合构成的搜索条件）"><a href="#like（用来匹配值的一部分的特殊字符，由字面值、通配符或两者组合构成的搜索条件）" class="headerlink" title="like（用来匹配值的一部分的特殊字符，由字面值、通配符或两者组合构成的搜索条件）"></a>like（用来匹配值的一部分的特殊字符，由字面值、通配符或两者组合构成的搜索条件）</h4><h5 id="通配符-：-（任何字符出现的任意次数）"><a href="#通配符-：-（任何字符出现的任意次数）" class="headerlink" title="通配符 ：%（任何字符出现的任意次数）"></a>通配符 ：%（任何字符出现的任意次数）</h5><p>检索任意以<code>jet</code>起头的词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_id,prod_name</span><br><span class="line">from products</span><br><span class="line">where prod_name like &#x27;jet%&#x27;;</span><br></pre></td></tr></table></figure><p>在搜索模式中任意位置是用，并且可以使用多个通配符</p><p>包含<code>anvil</code>值的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_id,prod_name</span><br><span class="line">from products</span><br><span class="line">where prod_name like &#x27;%anvil%&#x27;;</span><br></pre></td></tr></table></figure><h5 id="通配符-：-（与-用途一样，但只能匹配单个字符而不是多个字符）"><a href="#通配符-：-（与-用途一样，但只能匹配单个字符而不是多个字符）" class="headerlink" title="通配符 ：_ （与%用途一样，但只能匹配单个字符而不是多个字符）"></a>通配符 ：_ （与%用途一样，但只能匹配单个字符而不是多个字符）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_id,prod_name</span><br><span class="line">from products</span><br><span class="line">where prod_name like &#x27;_ ton anvil&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>通配符的处理一般花费的时间更长。所以不要过度使用。</li><li>除非绝对必要，否则不要将它们用在搜索模式的开始处，搜索起来是最慢的。</li><li>注意通配符的使用位置</li></ol></blockquote><h4 id="正则表达式nanixie"><a href="#正则表达式nanixie" class="headerlink" title="正则表达式nanixie"></a>正则表达式nanixie</h4><p>检索prod_name包含文本1000的所有行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select prod_name</span><br><span class="line">from products</span><br><span class="line">where prod_name regexp &#x27;1000&#x27;</span><br><span class="line">order by prod_name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select prod_name</span><br><span class="line">from products</span><br><span class="line">where prod_name like &#x27;1000&#x27;</span><br><span class="line">order by prod_name;                    xxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><p><code>like</code>的不会返回数据，<code>like</code>匹配整个列。如果被匹配的文本在列值中出现，<code>like</code>将不会找到他，除非使用<code>通配符</code>。</p><blockquote><p><code>Mysql</code>正则表达式<code>3.23.4</code>后不区分大小写（即，大写和小写都匹配），为了区分可以使用<code>binary</code>关键字</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where prod_name regexp binary &#x27;JetPack .000&#x27;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="Concat-函数-（拼接两个列）"><a href="#Concat-函数-（拼接两个列）" class="headerlink" title="Concat()函数 （拼接两个列）"></a>Concat()函数 （拼接两个列）</h4><p>合并vend_name和vend_country为一个新列 vend_name(vend_country)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select Concat(vend_name,&#x27;(&#x27;,vend_country,&#x27;)&#x27;)</span><br><span class="line">from vendors</span><br><span class="line">order by vend_name;</span><br></pre></td></tr></table></figure><h5 id="RTrim-（删除数据右侧多余的空格）"><a href="#RTrim-（删除数据右侧多余的空格）" class="headerlink" title="RTrim() （删除数据右侧多余的空格）"></a>RTrim() （删除数据右侧多余的空格）</h5><h5 id="LTrim-（删除数据左侧多余的空格）"><a href="#LTrim-（删除数据左侧多余的空格）" class="headerlink" title="LTrim() （删除数据左侧多余的空格）"></a>LTrim() （删除数据左侧多余的空格）</h5><h4 id="as（别名）"><a href="#as（别名）" class="headerlink" title="as（别名）"></a>as（别名）</h4><p>字段命名为vend_title</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select Concat(RTrim(vend_name),&#x27;(&#x27;,RTrim(vend_country),&#x27;)&#x27;) as vend_title</span><br><span class="line">from vendors</span><br><span class="line">order by vend_name;</span><br></pre></td></tr></table></figure><p>数据表使用别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select cust_name,cust_contact</span><br><span class="line">from customers as c,orders as o,orderitems as oi</span><br><span class="line">where c.cust_id = o.cust_id</span><br><span class="line">      and oi.order_num = o.order_num</span><br><span class="line">      and prod_id = &#x27;TNT2&#x27;; </span><br></pre></td></tr></table></figure><h4 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select pro_id,quantity,item_price,</span><br><span class="line">       quantity*item_price as expanded_price</span><br><span class="line">from orderitems</span><br><span class="line">where order_num = 20005;</span><br></pre></td></tr></table></figure><h4 id="Upper-（将文本转换为大写）"><a href="#Upper-（将文本转换为大写）" class="headerlink" title="Upper() （将文本转换为大写）"></a>Upper() （将文本转换为大写）</h4><p>本例子中每个供应商都列出两次，第一次为vendors表中存储的值，第二次作为列vend_name_upcase转换为大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select vend_name,Upper(vend_name) as vend_name_upcase</span><br><span class="line">from vendors</span><br><span class="line">order by vend_name;</span><br></pre></td></tr></table></figure><h4 id="常用文本处理函数"><a href="#常用文本处理函数" class="headerlink" title="常用文本处理函数"></a>常用文本处理函数</h4><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Left()</td><td style="text-align:center">返回串左边的字符</td></tr><tr><td style="text-align:center">Right()</td><td style="text-align:center">返回串右边的字符</td></tr><tr><td style="text-align:center">Length()</td><td style="text-align:center">返回串的长度</td></tr><tr><td style="text-align:center">Locate()</td><td style="text-align:center">找出串的一个字串</td></tr><tr><td style="text-align:center">Lower()</td><td style="text-align:center">将串转换为小写</td></tr><tr><td style="text-align:center">Upper()</td><td style="text-align:center">将串转换为大写</td></tr><tr><td style="text-align:center">RTrim()</td><td style="text-align:center">删除数据右侧多余的空格</td></tr><tr><td style="text-align:center">LTrim()</td><td style="text-align:center">删除数据左侧多余的空格</td></tr><tr><td style="text-align:center">Soundex()</td><td style="text-align:center">返回串的SOUNDEX值（发音类似）</td></tr><tr><td style="text-align:center">SubString()</td><td style="text-align:center">返回字串的字符</td></tr></tbody></table><p><img src="/img/mysql_must1.png" alt="1559722964(1)"></p><blockquote><p>注意：不管是插入或更新表值还是用WHERE字句进行过滤，日期必须为格式<code>yyyy-mm-dd</code></p></blockquote><p><img src="/img/mysql_must2.png" alt="1559723123(1)"></p><p><img src="/img/mysql_must3.png" alt="1559723180(1)"></p><h4 id="DISTINCT-（排除重复的值）"><a href="#DISTINCT-（排除重复的值）" class="headerlink" title="DISTINCT （排除重复的值）"></a>DISTINCT （排除重复的值）</h4><p>从 Company” 列中仅选取唯一不同的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT Company </span><br><span class="line">FROM Orders; </span><br></pre></td></tr></table></figure><h4 id="组合聚合函数"><a href="#组合聚合函数" class="headerlink" title="组合聚合函数"></a>组合聚合函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select COUNT(*) as num_items</span><br><span class="line">   MIN(prod_price) as price_min,</span><br><span class="line">   MAX(prod_price) as price_max,</span><br><span class="line">   AVG(prod_price) as price_avg</span><br><span class="line">from products;</span><br></pre></td></tr></table></figure><h4 id="having（与where非常类似，where过滤行，having过滤组）"><a href="#having（与where非常类似，where过滤行，having过滤组）" class="headerlink" title="having（与where非常类似，where过滤行，having过滤组）"></a>having（与where非常类似，where过滤行，having过滤组）</h4><h4 id="group-by-子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集"><a href="#group-by-子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集" class="headerlink" title="group by 子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集"></a>group by 子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集</h4><h4 id="group-by和order-by的羁绊"><a href="#group-by和order-by的羁绊" class="headerlink" title="group by和order by的羁绊"></a>group by和order by的羁绊</h4><table><thead><tr><th>order by</th><th>group by</th></tr></thead><tbody><tr><td>排序产生的输出</td><td>分组行。但输出可能不是分组的顺序</td></tr><tr><td>任意列都可以使用（甚至非选择的列也可以使用）</td><td>之坑内使用选择列或表达式列，而且必须使用每个选择列表达式</td></tr><tr><td>不一定需要</td><td>如果与聚集函数一期使用列（或表达式），则必须使用</td></tr></tbody></table><blockquote><p>一般在使用group by字句时，应该也给出order by字句。这是保证数据正确排序的唯一方法。千万不要仅依赖group by排序数据</p></blockquote><p>检索总计订单价格大于等于50的订单的订单号和总计订单价格，按照ordertotal排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select order_num,SUM(quantity*item_price) as ordertotal</span><br><span class="line">from orderitems</span><br><span class="line">group by order_num</span><br><span class="line">having SUM(quantity*item_price) &gt;= 50;</span><br><span class="line">order by ordertotal;</span><br></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>定义：是嵌套其他查询的查询  等价于 联结</p><h4 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h4><p>inner join,left join,right join,full join的图</p><p>left join === left outer join</p><p>right join === right outer join</p><p><img src="/img/mysql_must4.png" alt="1161502-20170525223247919-507739436"></p><h5 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h5><p>外键：某个表中存在其他表的主键即为该表的外键</p><p>两个表的关系是inner join指定，on的意义和where相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select vend_name,prod_name,prod_price</span><br><span class="line">from vendors inner join products</span><br><span class="line">on vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure><h5 id="笛卡儿积"><a href="#笛卡儿积" class="headerlink" title="笛卡儿积"></a>笛卡儿积</h5><p>定义：由没有联结条件的表关系返回的结果为笛卡儿积</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select prod_name,vend_name,prod_price,quantity</span><br><span class="line">from orderitems,products,vendors</span><br><span class="line">where products.vend_id = vendors.vend_id</span><br><span class="line">      and orderitems.prod_id = products.prod_id</span><br><span class="line">      and order_num = 20005;</span><br></pre></td></tr></table></figure><blockquote><p>联结的表越多，mysql的性能越差</p></blockquote><h5 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select prod_id,prod_name</span><br><span class="line">from products</span><br><span class="line">where vend_id = (select vend_id</span><br><span class="line">                 from products</span><br><span class="line">                 where prod_id = &#x27;DTNTR&#x27;)</span><br></pre></td></tr></table></figure><p>自己的表和自己的表进行联结查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select p1.prod_id,p1.prod_name</span><br><span class="line">from products as p1,products as p2</span><br><span class="line">where p1.vend_id = p2.vend_id</span><br><span class="line">      and p2.prod_id = &#x27;DTNTR&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>有时候自联结比子查询查询的快得多</p></blockquote><h5 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h5><p>定义：排除多次出现，使每个列只返回一次</p><blockquote><p>迄今为止我们建立的每个内部联结都是自然联结，很有可能我们永远都不会用到不是自然联结的内部联结</p></blockquote><h5 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h5><p>定义：相关表中没有关联行的行。这种类型的联结成为外部联结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select customers.cust_id,orders.order_num</span><br><span class="line">from customers left outer join orders</span><br><span class="line">on customers.cust_id = orders.cust_id</span><br></pre></td></tr></table></figure><p>left outer join ,right outer join 所以存在左外部联结和右外部联结</p><blockquote><p>mysql不支持简化字符<em>=和=\</em>的使用</p></blockquote><h5 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h5><ul><li>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的</li><li>保证使用正确的联结条件，否则将返回不正确的数据</li><li>应该总是提供联结条件，否则会得出<a href="#笛卡儿积">笛卡儿积</a></li></ul><h4 id="select的字句顺序"><a href="#select的字句顺序" class="headerlink" title="select的字句顺序"></a>select的字句顺序</h4><p>select—–&gt;from—–&gt;where—–&gt;group by—–&gt;having—–&gt;order by—–limit</p><h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><p>union操作符组合多条sql查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select vend_id,prod_id,prod_price</span><br><span class="line">from products</span><br><span class="line">where prod_price &lt;= 5</span><br><span class="line">union</span><br><span class="line">select vend_id,prod_id,prod_price</span><br><span class="line">from products</span><br><span class="line">where vend_id in (1001,1002)</span><br></pre></td></tr></table></figure><p>union规则：</p><ul><li>union必须由两条或两条以上的select语句组成，语句之间用关键字union分隔</li><li>union中的每个查询必须包含相同的列、表达式或聚集函数</li><li>列数据类型兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型</li></ul><blockquote><p>union自动去除重复的行，若不想去除重复行应该用union all</p><p>使用order by 会将返回的总结果集进行排序</p></blockquote><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li>性能——通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。</li><li>明确控制——使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配地情况下才可以匹配或者才可以不匹配</li><li>智能化地结果——虽然基于通配符和正则表达式地搜索提供了非常灵活地搜索，但他们都不能提供一种智能化的选择结果的方法。例如，一个特殊词的搜索将会返回包含该词的所有行，而不区分包含单个匹配的行和包含多个匹配的行（按照可能是最好的匹配来排列他们）。类似，一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE productnotes</span><br><span class="line">(</span><br><span class="line">note_id    int        NOT NULL AUTO_INCREMENT,</span><br><span class="line">prod_id   char(10)    NOT NULL,</span><br><span class="line">note_date datetime    NOT NULL,</span><br><span class="line">note_text  text       NULL,</span><br><span class="line">PRIMARY KEY(note_id),</span><br><span class="line">FULLTEXT(note_text)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>MySQL根据字句FULLTEXT(note_text)的指示对它进行索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select note_text</span><br><span class="line">from productnotes</span><br><span class="line">where Macth(note_text) Against(&#x27;rabbit&#x27;);</span><br></pre></td></tr></table></figure><p>查找productnotes中note_text中包含rabbit的note_text</p><p>等效于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select note_text</span><br><span class="line">from productnotes</span><br><span class="line">where note_text like &#x27;%rabbit%&#x27;;</span><br></pre></td></tr></table></figure><p>…………………………………………………………</p><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><ul><li>插入完整的行</li><li>插入行的一部分</li><li>插入多行</li><li>插入某些查询的结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into Customers</span><br><span class="line">values(NULL,&#x27;USA&#x27;,&#x27;zhangsan&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into Customers(cust_no,cust_country,cust_name) </span><br><span class="line">values(NULL,&#x27;USA&#x27;,&#x27;zhangsan&#x27;);</span><br></pre></td></tr></table></figure><blockquote><p>在很多索引需要更新时，insert的操作可能会很耗时，而且他可能降低等待处理的select语句的性能。</p><p>如果数据检索式最重要的，则你可以通过在insert和into之间添加关键字LOW_PRIORITY，指示MySQL降低insert语句的优先级，如下所示：</p><p>INSERT LOW_PRIORITY INTO</p><p>顺便说一下，这也适用update和delete</p></blockquote><p>多条insert语句，一次提交他们，每条语句用一个分号结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert xxxxx;</span><br><span class="line">insert xxxxx;</span><br></pre></td></tr></table></figure><p>只要insert中列名相同，则可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into A(xx)</span><br><span class="line">values(xx),(xx);</span><br></pre></td></tr></table></figure><p>插入检索出的数据：把custnew中的数据参加到customers中,不会校验列名和类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into customers(xxxx)</span><br><span class="line">select xxxx</span><br><span class="line">from custnew</span><br><span class="line">where xxx;</span><br></pre></td></tr></table></figure><h4 id="更新和插入数据"><a href="#更新和插入数据" class="headerlink" title="更新和插入数据"></a>更新和插入数据</h4><ul><li>更新表中特定行</li><li>更新表中所有行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update customers</span><br><span class="line">set cust_email = &#x27;xxx@163.com&#x27;</span><br><span class="line">where cust_id = 10005;</span><br></pre></td></tr></table></figure><p>update中可以使用子查询，</p><p>若更新多个数据，一旦出现一个错误，则整个update操作被取消（错误发生前更新的所有行被恢复到他们原来的值）。所以为了及时发生错误，也要继续进行更新，可以使用ignore关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update ignore customers...</span><br></pre></td></tr></table></figure><p>delete删除整行，删除整列需要使用update语句</p><p>遵循的规则：</p><ul><li>除非确实打算更新和删除每一行，否则绝对不要使用不带where字句的update或delete语句</li><li>保证每个表都有主键，尽可能像where字句那样使用它（可以指定各主键、多个值或值的范围）。</li><li>在对update或delete语句使用where子句前，应该先用select进行测试，保证它过滤的是正确的记录，以防编写的where字句不正确。</li><li>使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。</li></ul><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE productnotes</span><br><span class="line">(</span><br><span class="line">note_id    int        NOT NULL AUTO_INCREMENT,</span><br><span class="line">prod_id   char(10)    NOT NULL,</span><br><span class="line">note_date datetime    NOT NULL,</span><br><span class="line">note_text  text       NULL,</span><br><span class="line">PRIMARY KEY(note_id),</span><br><span class="line">FULLTEXT(note_text)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>AUTO_INCREMENT       自增列</p><p>DEFAULT                        默认值</p><h4 id="MySQL引擎"><a href="#MySQL引擎" class="headerlink" title="MySQL引擎"></a>MySQL引擎</h4><ul><li>InnoDB是一个可靠的事务处理引擎，他不支持全文本搜索</li><li>MEMORY在功能等同于MyISAM，但由于数据存储在内存中，速度很快（特别适合于临时表）</li><li>MyISAM是一个性能极高的引擎，他支持全文本搜索，但不支持事务处理</li></ul><h4 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//给表添加一个列</span><br><span class="line">alter table vendors</span><br><span class="line">add vend_phone char(20);</span><br><span class="line"></span><br><span class="line">//删除刚刚添加的列</span><br><span class="line">alter table vendors</span><br><span class="line">drop column vend_phone;</span><br><span class="line"></span><br><span class="line">//定义外键</span><br><span class="line">alter table orderitems</span><br><span class="line">add constraint fk_orderitems_orders</span><br><span class="line">foreign key (order_num) references orders (order_num);</span><br></pre></td></tr></table></figure><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><p>多个表的重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rename table backup_customers to customers,</span><br><span class="line">             backup_vendors to vendors,</span><br><span class="line">             backup_products to products;</span><br></pre></td></tr></table></figure><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><ul><li>重用SQL语句</li><li>简化复杂的SQL操作。在编写查询后，可以方便地重用他而不必知道他地基本查询细节</li><li>使用表的组成部分而不是整个表</li><li>保护数据。可以给用户授予表地特定部分地访问权限而不是整个表地访问权限。<code>（我的理解————封装）</code></li><li>更改数据格式和表示。视图可返回于底层表地表示和格式不同地数据</li></ul><blockquote><p>视图本身并不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索</p></blockquote><p>规则和限制：</p><ul><li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）</li><li>对于可以创建的视图数目没有限制</li><li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图</li><li>order by可以用在视图中，但如果从该视图检索数据select中也含有order by，那么该视图中的order by将被覆盖</li><li>视图不能索引，也不能有关联的触发器或默认值</li><li>视图可以和表一期使用。例如，编写一条联结表和视图的select语句</li></ul><p>创建一个名为productcustomers的视图，他联结了3个表，以返回已订购了任意产品的所有客户的列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create view productcustomers as</span><br><span class="line">select cust_name,cust_contact,prod_id</span><br><span class="line">from customers,orders,orderitems</span><br><span class="line">where customers.cust_id = orders.cust_id</span><br><span class="line">and orderitems.order_num = orders.order_num;</span><br></pre></td></tr></table></figure><p>为了检索订购了产品TNT2的客户，可如下进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select cust_name,cust_contact</span><br><span class="line">from productcustomers</span><br><span class="line">where prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>视图极大地简化了复杂SQL语句地使用</p></blockquote><h5 id="视图重新格式化检索出地数据"><a href="#视图重新格式化检索出地数据" class="headerlink" title="视图重新格式化检索出地数据"></a>视图重新格式化检索出地数据</h5><p>就是重新一直获取该数据，该数据可能随时变化</p><p>如果视图定义中存在以下操作，则不能进行视图地更新：</p><ul><li>分组（使用group by和having）</li><li>联结</li><li>子查询</li><li>并</li><li>聚集函数</li><li>distinct</li><li>导出（计算）列</li></ul><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>定义：为以后的使用而保存的一条或多条MySQL语句的集合</p><p>优势：</p><ul><li>把处理封装在容易使用的单元中，简化复杂的操作</li><li>由于不要求反复建立一系列处理步骤，这保证了数据的完整性</li><li>简化对变动的管理（封装后的安全性，改动少）</li><li>提高性能，因为使用存储过程比使用单独的SQL语句要快</li><li>存在一些只能在单个请求中的MySQL元素和特性，存储过程可以使用他们来编写功能更强更灵活的代码</li></ul><p>总结：<code>简单</code>、<code>安全</code>、<code>高性能</code></p><p>缺陷：</p><ul><li>存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验</li><li>你可能没有创建存储过程的访问安全权限</li></ul><p><strong>执行存储过程</strong>            <code>函数式的mysql，存在参数</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call productprcing(@pricelow</span><br><span class="line">                   @pricehigh</span><br><span class="line">                   @priceaverage);</span><br></pre></td></tr></table></figure><p>其中，执行名为productpricing的存储过程，他计算并返回产品的最低、最高和平均价格</p><p><strong>创建存储过程</strong></p><p>一个返回产品平均价格的存储过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create procedure productpricing()</span><br><span class="line">begin </span><br><span class="line">     select avg(prod_price) as priceaverage</span><br><span class="line">     from products;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h4 id="mysql命令行客户机的分隔符"><a href="#mysql命令行客户机的分隔符" class="headerlink" title="mysql命令行客户机的分隔符"></a>mysql命令行客户机的分隔符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELTMITER //</span><br><span class="line"></span><br><span class="line">create procedure productpricing()</span><br><span class="line">begin </span><br><span class="line">     select avg(prod_price) as priceaverage</span><br><span class="line">     from products;</span><br><span class="line">end //</span><br><span class="line"></span><br><span class="line">DELTMITER ;</span><br></pre></td></tr></table></figure><p>DELIMITER  //    告诉命令行使用程序使用//作为新的语句结束分割符</p><p>删除存储过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop procedure productpricing;</span><br></pre></td></tr></table></figure><blockquote><p>如果制定的过程不存在，则drop procedure将产生一个错误。当过程在想删除它时（如果过程不存在也不产生错误）可使用drop procedure if exists</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREARE PROCEDURE productpricing(</span><br><span class="line">    OUT pl DECIMAL(8,2),               </span><br><span class="line">    OUT ph DECIMAL(8,2),</span><br><span class="line">    OUT pa DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Min(prod_price)</span><br><span class="line">    INTO pl</span><br><span class="line">    FROM products;</span><br><span class="line">    SELECT Max(prod_price)</span><br><span class="line">    INTO ph</span><br><span class="line">    FROM products;</span><br><span class="line">    SELECT Avg(prod_price)</span><br><span class="line">    INTO pa</span><br><span class="line">    FROM products:</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>IN（传递给存储过程）、OUT（从存储过程传出，如这里使用）、INOUT（对存储过程传入和传出）</p><p>变量：内存中一个特定的位置，用来临时存储数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">@pricehigh,</span><br><span class="line">@proceaverage);</span><br><span class="line"></span><br><span class="line">SELECT @priceaverage;</span><br><span class="line"></span><br><span class="line">SELECT @pricehigh,@pricelow,@priceaverage</span><br><span class="line"></span><br><span class="line">CREAT PROCEDURE ordertotal(</span><br><span class="line">    IN onumber INT,</span><br><span class="line">    OUT ototal DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Sum(item_price * quantity)</span><br><span class="line">    FROM orderitems</span><br><span class="line">    WHERE order_num = onumber</span><br><span class="line">    INTO ototal;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">CALL ordertotal(20005,@total);</span><br></pre></td></tr></table></figure><p>智能存储过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- NAME：ordertotal</span><br><span class="line">-- Parameters: onumber = order number</span><br><span class="line">--             texable = 0 if not taxable,l if taxable</span><br><span class="line">--             ototal  = order total variable </span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">    IN onumber INT,</span><br><span class="line">    IN taxable BOOLEAN,</span><br><span class="line">    OUT ototal DECIMAL(8,2)</span><br><span class="line">) COMMENT &#x27;Obtain order total, optionlly adding tax&#x27;</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">    -- Declare variable for total</span><br><span class="line">    DECLARE total DECIMAL(8,2);</span><br><span class="line">    -- Declare tax percentage</span><br><span class="line">    DECLARE taxrate INT DEFAULT 6;</span><br><span class="line">    </span><br><span class="line">    -- GET the order total</span><br><span class="line">    SELECT Sum(item_price*quantity)</span><br><span class="line">    FROM orderitems</span><br><span class="line">    WHERE order_num = onumber</span><br><span class="line">    INTO total;</span><br><span class="line">    </span><br><span class="line">    -- IS this taxable?</span><br><span class="line">    IF taxable THEN</span><br><span class="line">        -- Yes, so add taxrate to the total</span><br><span class="line">        SELECT total+(total/100*taxrate) INTO total;</span><br><span class="line">    END IF;</span><br><span class="line">    </span><br><span class="line">    -- And finally, save to out variable</span><br><span class="line">    SELECT total INTO ototal;</span><br><span class="line">    </span><br><span class="line">END;</span><br></pre></td></tr></table></figure><blockquote><p><strong>COMMENT</strong></p><p>他不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示</p><p><strong>SHOW PROCEDURE STATUS</strong></p><p>获得包括何时、由谁创建等详细信息的存储过程列表</p><p>为限制其输出，可使用LIKE制定一个过滤模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROCEDURE STATUS LIKE &#x27;ordertotal&#x27;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="游标（cursor）"><a href="#游标（cursor）" class="headerlink" title="游标（cursor）"></a>游标（cursor）</h4><p>只能用于存储过程（函数）</p><p>使用过程：</p><ul><li>在能够使用游标前，必选声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句</li><li>一旦声明后，必须打开游标以供使用。这个过程用前面定义的select语句把数据实际检索出来</li><li>对于填有数据的游标，根据需要取出（检索）各行</li><li>在结束使用时，必须关闭游标</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE ordernumbers CURSOR</span><br><span class="line">    FOR</span><br><span class="line">    SELECT order_num FROM orders;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">OPEN ordernumbers;</span><br><span class="line">CLOSE ordernumbers;</span><br></pre></td></tr></table></figure><p>example：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">    -- Declare local variables</span><br><span class="line">    DECLARE o INT;</span><br><span class="line">    </span><br><span class="line">    -- Declare the cusor</span><br><span class="line">    DECLARE ordernumbers CURSOR</span><br><span class="line">    FOR</span><br><span class="line">    SELECT order_num FROM orders;</span><br><span class="line">    </span><br><span class="line">    -- Open the cursor</span><br><span class="line">    OPEN ordernumbers;</span><br><span class="line">    </span><br><span class="line">    -- Get oder number</span><br><span class="line">    FETCH ordernumbers INTO 0;</span><br><span class="line">    </span><br><span class="line">    -- Close the cursor</span><br><span class="line">    CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>其中FETCH用来检索当前行的order_num列（将自动从第一行开始）到一个名为o的局部声明变量中。</p><p>将获取的结果存储在游标中。</p><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p> DELETE、INSERT、UPDATE中触发，其他MySQL语句都不支持触发器</p><p>创建时：</p><ul><li>唯一的触发器名</li><li><p>触发器关联的表</p></li><li><p>触发器应该响应的活动（ DELETE、INSERT或UPDATE）</p></li><li>触发器何时执行（处理之前或之后）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT &#x27;Product added&#x27;;</span><br></pre></td></tr></table></figure><p>创建名为newproduct的新触发器，此触发器将在INSERT语句成功执行后执行，还指定FOR EACH ROW，因此代码对每个插入行执行。</p><p>使用INSERT语句添加一行或多行到products中，你将看到对每个成功的插入，显示Product added消息</p><blockquote><p>只有表才支持触发器，视图和临时表都不支持</p><p>每个表最多支持6个触发器</p></blockquote><p>触发器失败：</p><p>如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）</p><p>删除触发器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER newproduct;</span><br></pre></td></tr></table></figure><h5 id="INSERT触发器（适用于UPDATE）"><a href="#INSERT触发器（适用于UPDATE）" class="headerlink" title="INSERT触发器（适用于UPDATE）"></a>INSERT触发器（适用于UPDATE）</h5><ul><li>在INSERT触发器大麻中，可引用一个名为NEW的虚拟表，访问被插入的行</li><li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）</li><li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW SELECT NEW.order_num;</span><br></pre></td></tr></table></figure><p>触发器名为neworder ，在orders的INSERT方法中返回NEW.order_num数值</p><blockquote><p>BEFORE或AFTER？</p><p>通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）</p></blockquote><h5 id="DELETE触发器"><a href="#DELETE触发器" class="headerlink" title="DELETE触发器"></a>DELETE触发器</h5><ul><li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行</li><li>OLD中的值全都是只读的，不能更新</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    INSERT INTO archive_orders(order_num,order_date,cust_id)</span><br><span class="line">    VALUES(OLD.order_num,OLD.order_date,OLD.cust_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>在任意订单删除前将执行此触发器，它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）</p><p>使用BEFORE EDLETE触发器的优点（相对于AFTER DELETE触发器来说）为，如果由于某种原因，订单不能存档，SELETE本身将被废弃</p><blockquote><p>使用BEGIN和END语句标记触发器体。在这个例子中并不是必需的，不过也没有害处，使用BEGIN END块的好处是触发器能容纳多条SQL语句</p></blockquote><h5 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h5><ul><li>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值</li><li>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）</li><li>OLD中的值全都是只读的，不能更新</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors</span><br><span class="line">FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state);</span><br></pre></td></tr></table></figure><p>每次更新一个行时，NEW.vend_state中的值（将用来更新表行的值）都用Upper（NEW.vend_state）替换</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li>与其他DBMS想比，MYSQL 5中支持的触发器相当初级。未来的MySQL版本中有一些改进和增强触发器支持的计划</li><li>创建触发器可能需要特殊的安全访问权限，但是，触发器的执行是自动的。如果INSERT、UPDATE或DELETE语句能够执行，则相关的触发器也能执行</li><li>应该用触发器来保证数据的一致性（大小写、格式等）。在触发器中执行这种类型的处理的有点是它总是进行这种处理，而且是透明地进行，与客户机应用无关</li><li>触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易</li><li>遗憾的是，MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。</li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>定义：事务处理可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行</p><ul><li>事务（transaction）指一组SQL语句</li><li>回退（rollback）指撤销指定SQL语句的过程</li><li>提交（commit）指将未存储的SQL语句结果写入数据库表</li><li>保留点（savepoint）指事务处理中设置的临时占位符（place-holder），你可以对它发布回退（与回退整个事务处理不同）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM ordertotals;</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM ordertotals;</span><br></pre></td></tr></table></figure><blockquote><p>ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后）</p><p>事务处理用来管理INSERT、UPDATE和DELETE语句。SELECT、CREATE、DROP无法被回退</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num = 20010;</span><br><span class="line">DELETE FROM orders WHERE order_num = 20010;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，他是被自动撤销的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 新建保留点</span><br><span class="line">SAVEPOINT delete1；</span><br><span class="line"></span><br><span class="line">-- 回退到保留点</span><br><span class="line">ROLLBACK TO delete1；</span><br></pre></td></tr></table></figure><blockquote><p><strong>保留点越多越好</strong>，就能案子的意愿灵活的进行回退</p><p><strong>释放保留点</strong>，事务完成（执行一条ROLLBACK或COMMIT）后自动释放，</p><p>​                也可用 RELEASE SAVEPORINT 明确地释放保留点</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 指示MySQL不自动提交更改</span><br><span class="line">SET autocommit=0;</span><br></pre></td></tr></table></figure><h4 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a>全球化和本地化</h4><p><strong>字符集</strong>：字母和符号地集合</p><p><strong>编码</strong>：某个字符集成员地内部表示</p><p><strong>校对</strong>：规定字符如何比较地指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 显示所有可用地字符集以及每个字符集的描述和默认校对</span><br><span class="line">SHOW CHARACTER SET;</span><br><span class="line"></span><br><span class="line">-- 显示所有可用的校对，以及他们使用的字符集</span><br><span class="line">SHOW COLLATION;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">CREATE TABLE mytable</span><br><span class="line">(</span><br><span class="line">    columnn1 INT,</span><br><span class="line">    columnn2 VARCHAR(10)</span><br><span class="line">)DEFAULT CHARACTER SET hebrew</span><br><span class="line">COLLATE hebrew_general_ci;</span><br></pre></td></tr></table></figure><p>此语句创建一个包含两列的表，并且指定一个字符集和一个校对顺序</p><p>这个例子中指定了CHARACTER SET和COLLATE两者。一般，MySQL如下确定使用什么样的字符集和校对</p><ul><li>如果指定CHARACTER SET和COLLATE两者，则使用这些值。</li><li>如果只指定CHARACTER SET，则使用此字符集及其默认的校对</li><li>如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认</li></ul><h4 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h4><h4 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h4><h4 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h4><h4 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h4><h5 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h5><p>数据库表的每一列都是不可分割的原子数据项，无重复的域</p><h5 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h5><p>满足第二范式，则必定符合第一范式。数据库表中的每个实例或记录必须可以被唯一的区分。</p><p>要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性</p><h5 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h5><p>在2NF的基础上，任何非主属性不依赖于其他非主属性，表中不能存在非其它表中非主键的字段。（排除冗余）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql是不区分大小写的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看数据表的列表 ==== 设计表&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0简单理解</title>
    <link href="http://yoursite.com/2019/07/01/%E5%90%8E%E7%AB%AF/OAuth2-0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/07/01/后端/OAuth2-0简单理解/</id>
    <published>2019-07-01T07:19:45.000Z</published>
    <updated>2021-05-27T11:40:17.154Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><p>一个关于授权的开放网络标准。</p><p>允许用户让第三方应用访问该用户在某一网站上存储的私密的资源，而无须将用户名和密码提供给第三方应用</p><h4 id="二、授权方式"><a href="#二、授权方式" class="headerlink" title="二、授权方式"></a>二、授权方式</h4><p>四种授权方式：</p><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）</li><li>客户端凭证（client credentials）</li></ul><h5 id="1-授权码"><a href="#1-授权码" class="headerlink" title="1.授权码"></a>1.授权码</h5><p><strong>第三方应用先申请和一个授权码，然后再用该码获取令牌</strong></p><p>最常用流程，安全性也高。<code>授权码</code>通过<code>前端</code>传送，<code>令牌</code>则是存储在<code>后端</code>，而且所有与资源服务器的通信都在后端完成。这样前后端分离，可以避免<code>令牌</code>泄露</p><p>（类似于微信登录）</p><ol><li>A跳转B，请求授权码。</li><li>B提示登录授权，授权后回跳到A，返回授权码</li><li>A拿到授权码，向B的后端请求令牌</li><li>A拿到令牌，正常访问B的资源</li></ol><h5 id="2-隐藏式"><a href="#2-隐藏式" class="headerlink" title="2.隐藏式"></a>2.隐藏式</h5><p><strong>允许直接向前端办法令牌，这中方式没有授权码这个中间步骤</strong></p><ol><li>A跳转B，请求令牌</li><li>A拿到令牌，正常访问B的资源</li></ol><h5 id="3-密码式"><a href="#3-密码式" class="headerlink" title="3.密码式"></a>3.密码式</h5><p><strong>允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌</strong></p><ol><li>A带上B的用户名和密码访问，返回令牌</li><li>A拿到令牌，正常访问B的资源</li></ol><blockquote><p>风险很大，除特殊情况一般不考虑吧使用，必须是用户高度信任的用户</p></blockquote><h5 id="4-凭证式"><a href="#4-凭证式" class="headerlink" title="4.凭证式"></a>4.凭证式</h5><p><strong>没有前端的命令行应用，在命令下请求令牌</strong></p><ol><li>A在命令行请求B（client_id、client_secret）</li><li>B验证通过，直接返回令牌，A正常请求B的资源</li></ol><blockquote><p>此方式不是针对用户的，二十针对第三方应用的，所以存在多用户共享同一令牌</p></blockquote><h4 id="三、更新令牌"><a href="#三、更新令牌" class="headerlink" title="三、更新令牌"></a>三、更新令牌</h4><p>一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌。令牌到期前，用户使用refresh token发送一个请求，去更新令牌</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;一、定义&lt;/h4&gt;&lt;p&gt;一个关于授权的开放网络标准。&lt;/p&gt;
&lt;p&gt;允许用户让第三方应用访问该用户在某一网站上存储的私密的
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="OAuth2.0" scheme="http://yoursite.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>flask项目使用</title>
    <link href="http://yoursite.com/2019/05/29/%E5%89%8D%E7%AB%AF/flask%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/29/前端/flask项目使用/</id>
    <published>2019-05-29T05:51:08.000Z</published>
    <updated>2021-05-27T11:40:17.154Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Flask简介"><a href="#Flask简介" class="headerlink" title="Flask简介"></a>Flask简介</h4><p>Flask是一个使用 Python 编写的轻量级 Web 应用框架。</p><h4 id="Flask环境配置"><a href="#Flask环境配置" class="headerlink" title="Flask环境配置"></a>Flask环境配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//添加flask</span><br><span class="line">pip3 install Flask</span><br><span class="line">//添加python3的mysql支持</span><br><span class="line">pip3 install pymysql</span><br><span class="line">//添加Flask-SQLAlchemy链接mysql</span><br><span class="line">pip3 install Flask-SQLAlchemy</span><br><span class="line">//添加tornado线上管理</span><br><span class="line">pip3 install tornado</span><br><span class="line">//python网络请求框架</span><br><span class="line">pip3 install requests</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="FLask基本使用"><a href="#FLask基本使用" class="headerlink" title="FLask基本使用"></a>FLask基本使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def hello_world():</span><br><span class="line">    return &#x27;Hello World!&#x27;</span><br><span class="line"> </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h4 id="Flask项目的目录"><a href="#Flask项目的目录" class="headerlink" title="Flask项目的目录"></a>Flask项目的目录</h4><p><img src="/img/flask_content.png" alt="目录"></p><p>其中 scss是进行屏幕适配的，使用vw进行适配</p><p>templates中存放的是html文件，前端界面</p><p>app中是网站的路由管理及后台处理</p><p>model是数据库的设置</p><p>tornado_sever是使用tornado进行线上部署管理</p><ol><li>本项目连接的是mysql数据库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DIALECT = &#x27;&#x27;  # 要用的什么数据库</span><br><span class="line">DRIVER = &#x27;&#x27; # 连接数据库驱动</span><br><span class="line">USERNAME = &#x27;&#x27;  # 用户名</span><br><span class="line">PASSWORD =&#x27;&#x27;  # 密码</span><br><span class="line">HOST = &#x27;&#x27;  # 服务器</span><br><span class="line">PORT =&#x27;&#x27; # 端口</span><br><span class="line">DATABASE = &#x27;&#x27; # 数据库名</span><br><span class="line">SQLALCHEMY_DATABASE_URI = &quot;&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8&quot;.format(DIALECT, DRIVER, USERNAME, PASSWORD, HOST, PORT, DATABASE)</span><br><span class="line">SQLALCHEMY_TRACK_MODIFICATIONS = False</span><br></pre></td></tr></table></figure><ol start="2"><li>使用torndo进行线上管理</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># tornado_server.py</span><br><span class="line"># coding=utf-8</span><br><span class="line"></span><br><span class="line">from tornado.wsgi import WSGIContainer</span><br><span class="line"></span><br><span class="line">from tornado.httpserver import HTTPServer</span><br><span class="line"></span><br><span class="line">from tornado.ioloop import IOLoop</span><br><span class="line"></span><br><span class="line">from app import app</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    http_server = HTTPServer(WSGIContainer(app))</span><br><span class="line">    http_server.listen(5000)</span><br><span class="line">    IOLoop.instance().start()</span><br></pre></td></tr></table></figure><h4 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h4><ol><li>https网页中解决http请求</li></ol><p>问题：在线上环境，本项目成为https的网页链接，其中牵扯到http的网络请求交互，在游览器    中，这种行为       是被禁止的，所以http请求都被终止</p><p>解决方案： 在前端js中的http请求映射到python后台接口中，通过python请求http请求后将结果返回给js前端页面进行交互</p><ol start="2"><li><p>路由接口重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect(url_for(&#x27;&#x27;))</span><br></pre></td></tr></table></figure></li><li><p>版本更新前端静态资源没有更新</p></li></ol><p>问题：前端页面更新后，修改的样式，逻辑没有更新，是因为游览器存在缓存导致，加载的是上一个版本的静态资源。</p><p>解决方案：在必要的css和js文件在html中引用时，需要添加后缀，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../static/js/city.js?v=&#123;&#123; version &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过统一处理，在开发环境中version为一个随机数，在正式环境中version为版本号，这样在上线后，直接可以查看本项目是否已经更新到最新版本</p><p><img src="/img/flask_example.png" alt="截图"></p><ol start="4"><li><p>手机端网页适配</p><p>添加scss生成css的适配方案</p></li><li><p>ajax中多次请求后，需要获取最后一次的请求数据，请求频繁导致先请求的数据后面请求成功，则顺序被改变，</p><p>所以需要对请求的接口进行判断处理，在请求成功后，如果二次进入了，则关闭上次的请求，在返回成功和失败的接口处进行close的处理</p></li><li><p>微信pc端无法加载es6的js代码，需要转化为es5，去掉let  =&gt;等es6标识，即可</p></li></ol><h4 id="Flask运行"><a href="#Flask运行" class="headerlink" title="Flask运行"></a>Flask运行</h4><p>在生产环境中运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python app.py</span><br></pre></td></tr></table></figure><p>在开发环境中运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tornado_server.py</span><br></pre></td></tr></table></figure><p>Flask中默认启用的是5000端口，所以链接地址为localhost:5000/xxx<br>如果不想使用5000端口，需要在app.run中进行设定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.run(</span><br><span class="line">        host=&#x27;0.0.0.0&#x27;,</span><br><span class="line">        port=5000,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Flask简介&quot;&gt;&lt;a href=&quot;#Flask简介&quot; class=&quot;headerlink&quot; title=&quot;Flask简介&quot;&gt;&lt;/a&gt;Flask简介&lt;/h4&gt;&lt;p&gt;Flask是一个使用 Python 编写的轻量级 Web 应用框架。&lt;/p&gt;
&lt;h4 id=&quot;Fla
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Android学习笔记</title>
    <link href="http://yoursite.com/2019/05/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/05/24/移动端/Android原生/Android学习笔记/</id>
    <published>2019-05-24T08:20:48.000Z</published>
    <updated>2021-05-27T11:40:17.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ViewStub的应用"><a href="#1-ViewStub的应用" class="headerlink" title="1. ViewStub的应用"></a>1. ViewStub的应用</h2><p>&emsp;&emsp;在不显示布局时我们会使用<font color=#00099> <em>View.GONE</em> </font>和<font color=#00099> <em>View.VISIBLE</em> </font>属性去控制View的布局显示，但是在该使用过程中，该View的对象还是会被建立（只要通过inflate就会创建对象），被实例化，所以会耗费内存。</p><p>&emsp;&emsp;这时候就会引入ViewStub这个控件，该控件是一个轻量级的View，它是一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。</p><p>&emsp;&emsp;其原理就是通过控制ViewStub来控制View的对象的创建和渲染</p><p>特点：</p><ol><li>ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了。</li><li><p>ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。</p><p>因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。</p><p>所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。ViewStub是能被使用一次。一旦被指定infate后，其存在的特性就会消失。</p></li></ol><h2 id="2-SurfaveView控件的理解"><a href="#2-SurfaveView控件的理解" class="headerlink" title="2. SurfaveView控件的理解"></a>2. SurfaveView控件的理解</h2><h2 id="3-AOSP-Android-OPen-Source-Project-Android开源工程"><a href="#3-AOSP-Android-OPen-Source-Project-Android开源工程" class="headerlink" title="3. AOSP(Android OPen Source Project)Android开源工程"></a>3. AOSP(Android OPen Source Project)Android开源工程</h2><h2 id="4-内存泄露："><a href="#4-内存泄露：" class="headerlink" title="4.内存泄露："></a>4.内存泄露：</h2><p> <strong>static所修饰的方法和变量拥有和app一样长的生命周期</strong></p><ul><li>静态变量导致的内存泄漏：<br>静态变量（方法）中对context的使用，导致Activity不能被回收</li><li>单例模式导致的内存泄露：<br>单例中同样使用了static方法，对context的使用不能被释放</li></ul><p>上述两种的解决方法都为传入context.getApplicationContext()，其存在的生命周期和app生命周期一样长。</p><ul><li>非静态内部类持有外部引用导致的内存泄漏：（非静态内部类和外部类相互绑定，而静态内部类与外部类相互分离）<br>内部类持有外部类的引用，外部类无法正常回收（将其改为静态内部类）<br>  Handler引起的内存泄漏：<ol><li>静态内部类+弱引用：<br>static  +   WeakReference&lt;&gt;()</li><li>Handler.Callback的方式</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  Handler mHandler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">                mTV_incloud_merge.setText((String) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>流文件打开后要close()，动画要cancel()，数据库的使用要关闭</li><li>Listview的优化，ViewHolder对item的复用</li><li>Bitmap的三级缓存和压缩技术</li></ul><h2 id="5-Android进阶——Android消息机制之Looper、Handler、MessageQueen"><a href="#5-Android进阶——Android消息机制之Looper、Handler、MessageQueen" class="headerlink" title="5. Android进阶——Android消息机制之Looper、Handler、MessageQueen"></a>5. <a href="https://blog.csdn.net/qq_30379689/article/details/53394061">Android进阶——Android消息机制之Looper、Handler、MessageQueen</a></h2><p><img src="/img/handler.png" alt="最好的流程图"></p><h4 id="1-Handler涉及哪些类，各自功能是什么？"><a href="#1-Handler涉及哪些类，各自功能是什么？" class="headerlink" title="1. Handler涉及哪些类，各自功能是什么？"></a>1. Handler涉及哪些类，各自功能是什么？</h4><ul><li>Handler：将Message对象发送到MessageQueue中去，同时将自己的引用赋值给Message#target.</li><li>Lopper：将Message对象从MessageQueue中取出来，并交给Handler#dispatchMessage(Message)方法，不是调用Handler#handleMessage(Message)方法</li><li>MessageQueue：负责插入和取出Message</li><li>Message：所传递的信息的载体</li><li>ThreadLocal:</li></ul><h4 id="2-发送消息的方式"><a href="#2-发送消息的方式" class="headerlink" title="2. 发送消息的方式"></a>2. 发送消息的方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//常用</span><br><span class="line">sendMessage(Message msg)</span><br><span class="line">sendMessageDelayed(Message msg, long uptimeMillis)</span><br><span class="line">post(Runnable r)</span><br><span class="line">postDelayed(Runnable r, long uptimeMillis)</span><br><span class="line">sendMessageAtTime(Message msg,long when)</span><br><span class="line">//不常用</span><br><span class="line">sendEmptyMessage(int what)</span><br><span class="line">sendEmptyMessageDelayed(int what, long uptimeMillis)</span><br><span class="line">sendEmptyMessageAtTime(int what, long when)</span><br></pre></td></tr></table></figure><h4 id="3-MessageQueue中的Message是有序的吗？根据什么排序"><a href="#3-MessageQueue中的Message是有序的吗？根据什么排序" class="headerlink" title="3. MessageQueue中的Message是有序的吗？根据什么排序?"></a>3. MessageQueue中的Message是有序的吗？根据什么排序?</h4><ul><li>是有序的，根据Message#when排序的</li><li>Message#when是一个时间，用于表示Message期望被分发的时间，该值是SystemClock#uptimeMillis()与delayMillis之和</li><li>因为System.currentTimemillis()可以被修改，所以不用此表示</li></ul><h4 id="4-子线程可以创建Handler对象吗？"><a href="#4-子线程可以创建Handler对象吗？" class="headerlink" title="4. 子线程可以创建Handler对象吗？"></a>4. 子线程可以创建Handler对象吗？</h4><p> 不能直接调用Handler的无参构造方法</p><ul><li>先要调用Looper.prepare()在当前线程初始化一个Looper</li><li>通过构造方法传入一个Looper</li><li>主线程调用Handler的无参构造会存在一个自动绑定的过程</li></ul><h4 id="5-Looper是如何与Thread关联的"><a href="#5-Looper是如何与Thread关联的" class="headerlink" title="5. Looper是如何与Thread关联的?"></a>5. Looper是如何与Thread关联的?</h4><p>通过ThreadLocal关联的</p><h4 id="6-Handler有哪些构造方法"><a href="#6-Handler有哪些构造方法" class="headerlink" title="6.Handler有哪些构造方法"></a>6.Handler有哪些构造方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">    this(null, false);</span><br><span class="line">&#125;</span><br><span class="line">public Handler(Callback callback) &#123;</span><br><span class="line">    this(callback, false);</span><br><span class="line">&#125;</span><br><span class="line">public Handler(Looper looper) &#123;</span><br><span class="line">    this(looper, null, false);</span><br><span class="line">&#125;</span><br><span class="line">public Handler(Looper looper, Callback callback) &#123;</span><br><span class="line">    this(looper, callback, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-子线程如何获取当前线程的Looper"><a href="#7-子线程如何获取当前线程的Looper" class="headerlink" title="7. 子线程如何获取当前线程的Looper"></a>7. 子线程如何获取当前线程的Looper</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.myLooper()</span><br></pre></td></tr></table></figure><p>内部原理就是同过上面提到的sThreadLocal#get()来获取Looper</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Looper.java:203</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-如何在任意先成获取主线程的Looper"><a href="#8-如何在任意先成获取主线程的Looper" class="headerlink" title="8. 如何在任意先成获取主线程的Looper"></a>8. 如何在任意先成获取主线程的Looper</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper()</span><br></pre></td></tr></table></figure><h4 id="9-如何判断当前线程是不是主线程"><a href="#9-如何判断当前线程是不是主线程" class="headerlink" title="9. 如何判断当前线程是不是主线程"></a>9. 如何判断当前线程是不是主线程</h4><p>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.myLooper() == Looper.getMainLooper()</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().getThread() == Thread.currentThread()</span><br></pre></td></tr></table></figure><p>方法三： 方法二的简化版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().isCurrentThread()</span><br></pre></td></tr></table></figure><h4 id="10-Looper-loop-会退出吗？"><a href="#10-Looper-loop-会退出吗？" class="headerlink" title="10. Looper.loop()会退出吗？"></a>10. Looper.loop()会退出吗？</h4><p>不会自动推出，通过调用Looper#quit()或者Looper#quitSafely()让他退出</p><p>两个方法都是调用了 MessageQueue#quit(boolean) 方法，当 MessageQueue#next() 方法发现已经调用过  MessageQueue#quit(boolean)  时会 return null 结束当前调用，否则的话即使 MessageQueue 已经是空的了也会阻塞等待。</p><h4 id="11-Looper-loop-方法是一个死循环为什么不会阻塞APP"><a href="#11-Looper-loop-方法是一个死循环为什么不会阻塞APP" class="headerlink" title="11. Looper.loop() 方法是一个死循环为什么不会阻塞APP"></a>11. Looper.loop() 方法是一个死循环为什么不会阻塞APP</h4><h2 id="6-Http协议"><a href="#6-Http协议" class="headerlink" title="6. Http协议"></a>6. Http协议</h2><blockquote><ul><li>HTTP 0.9 这个版本只有GET方法</li><li>1.0 这个版本有GET HEAD POST这三个方法</li><li>HTTP 1.1 这个版本是当前版本，包含GET HEAD POST OPTIONS PUT DELETE TRACE CONNECT这8个方法</li></ul></blockquote><ul><li>报文：HTTP应用程序之间发送的数据块（起始行，首部，主体）</li></ul><p>Http请求所经历的过程</p><p>建立tcp连接（三次握手） &gt;&gt; 客户端向服务端发送请求命令 &gt;&gt; 客户端发送请求头信息 &gt;&gt; 服务器应答 &gt;&gt; 服务器应答头信息 &gt;&gt; 服务器向客户端发送数据 &gt;&gt; 服务器关闭tcp连接</p><p><img src="/img/tcp.png" alt=""></p><ul><li><p>请求方法（Method）：GET和POST、 不常用的有PUT，DELETE、HEAD、options</p><p>HEAD 与 GET 的使用方式完全相同。<br>区别在于，HEAD 请求的返回响应中没有 Body<br>用途：比如下载需求，返回的 Headers 中有下载内容的大小，可以用于显示进度。</p></li></ul><p>GET、PUT、DELETE 都是幂等操作，POST不是幂等的，不安全</p><p>PUT、DELETE除第一种方法外，只能通过先在服务端重写HTTP请求方法（自定义HttpMessageHandler来实现），然后再在客户端请求报文头指定“X-HTTP-Method-Override”值为PUT或DELETE来实现；</p><p>PUT 请求，客户端方法与POST方法相同，只是TYPE指定为：PUT；服务器端与POST方法相同；</p><p>DELETE请求，客户端方法与GET方法相同，只是TYPE指定为：DELETE；服务器端与GET方法相</p><h3 id="PUT和POST的区别"><a href="#PUT和POST的区别" class="headerlink" title="PUT和POST的区别"></a>PUT和POST的区别</h3><p>1、PUT请求时，如果用相同参数访问二次接口，Post 仅会产生一条记录</p><p>使用场合例如：</p><p>用户的账户二维码只和用户关联，而且是一一对应的关系，此时这个api就可以用PUT</p><p>2、POST请求时，如果用相同参数访问二次接口，Post 会产生多条记录</p><p>使用场合例如：</p><p>在我们的支付系统中，一个api的功能是创建收款金额二维码，它和金额相关，每个用户可以有多个二维码，如果连续调用则会创建新的二维码，这个时候就用POST</p><h3 id="Get请求添加body请求吗？"><a href="#Get请求添加body请求吗？" class="headerlink" title="Get请求添加body请求吗？"></a>Get请求添加body请求吗？</h3><p>在规定 HTTP 语义及内容的 RFC 7231 中，并未限制 GET 请求中是否允许携带交互数据！所以，有些 HTTP 服务允许这种行为，而另外一些（特别是缓存代理）则不允许这种行为。</p><p>Apache Http Client 和  OkHttpClient 都不支持  GET 请求发送 Body 数据，而 AsyncHttpClient 是可以的。</p><p>所以一般情况下，get请求不使用body进行数据传输，一般是拼接到url中实现</p><h3 id="options的主要用途"><a href="#options的主要用途" class="headerlink" title="options的主要用途"></a>options的主要用途</h3><p>OPTIONS请求方法的主要用途有两个：</p><p>1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。</p><p>2、用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。</p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>TRACE方法被用于激发一个远程的，应用层的请求消息回路（译注：TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路，）。最后的接收者或者是接收请求里Max-Forwards头域值为0源服务器或者是代理服务器或者是网关。TRACE请求不能包含一个实体。</p><p>TRACE方法允许客户端知道请求链的另一端接收什么，并且利用那些数据去测试或诊断。Via头域值（见14.45）有特殊的用途，因为它可以作为请求链的跟踪信息。利用Max-Forwards头域允许客户端限制请求链的长度去测试一串代理服务器是否在无限回路里转发消息。</p><p>如果请求是有效的，响应应该在响应实体主体里包含整个请求消息，并且响应应该包含一个Content-Type头域值为”message/http”的头域。TRACE方法的响应不能不缓存。</p><h3 id="CONNECT（连接）"><a href="#CONNECT（连接）" class="headerlink" title="CONNECT（连接）"></a>CONNECT（连接）</h3><p>HTTP1.1协议规范保留了CONNECT方法，此方法是为了能用于能动态切换到隧道的代理服务器（proxy，译注：可以为代理，也可以是代理服务器）。</p><ul><li>状态码：</li></ul><p>1xx:临时性消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100：继续发送</span><br><span class="line">101：正在切换协议</span><br></pre></td></tr></table></figure><p>2xx:成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200：OK (最常见) </span><br><span class="line">201：创建成功</span><br></pre></td></tr></table></figure><p>3xx:重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">301：域名永久移动</span><br><span class="line">302：暂时移动</span><br><span class="line">304：内容未改变，请求被重定向到客户端本地缓存</span><br></pre></td></tr></table></figure><p>4xx:客户端错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">400：客户端请求错误，服务器不理解请求的语法。</span><br><span class="line">401：未授权，要求进行身份验证。</span><br><span class="line">403：被禁止，服务器拒绝请求。</span><br><span class="line">404：找不到内容，服务器找不到请求的网页。(最常见)</span><br></pre></td></tr></table></figure><p>5xx:服务器错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">500：服务器内部错误 (最常见)</span><br><span class="line">503：服务不可用</span><br></pre></td></tr></table></figure><p>http协议osi七层协议和TCP/IP五层协议<br><img src="/img/https.png" alt=""></p><blockquote><p>HTTP使用80端口 <br/><br>HTTPS使用443端口</p></blockquote><h2 id="7-Https协议"><a href="#7-Https协议" class="headerlink" title="7.Https协议"></a>7.Https协议</h2><h4 id="协议过程，中间人攻击"><a href="#协议过程，中间人攻击" class="headerlink" title="协议过程，中间人攻击"></a>协议过程，中间人攻击</h4><p>缺点：</p><blockquote><p>证书费用高 <br/> 访问速度慢</p></blockquote><p>Hypertext Transfer Protocol Secure  缩写：HTTPS<br>Https经Http进行通信，但利用SSL/TLS来加密数据包</p><p><img src="/img/https1.png" alt=""></p><p>TLS/SSL协议主要依赖于三类基本算法：散列函数Hash、对称加密和非对称加密。</p><blockquote><p>非对称加密：身份认证和密钥协商（RSA）<br>  对称加密：对数据进行加密（AES） <br> 散列函数加密：验证信息的完整性（MD5,SHA1,SHA256）</p></blockquote><p><img src="/img/tts.png" alt=""></p><p>CA证书验证机制，解决中间人攻击的方式</p><p><img src="/img/ca.png" alt=""></p><p>https的SSL/TSL密钥是在应用层和传输层之间的<br><img src="/img/encode.png" alt=""></p><ul><li>申请证书不需要提供私钥，<strong>确保私钥永远只能服务器掌握</strong></li><li>证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名</li><li>内置CA对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书</li><li><strong>证书=公钥+申请者与颁发者信息+签名</strong></li><li><strong>公钥放在数字证书中。只有证书是可信的，公钥就是可信的。</strong></li></ul><p><img src="/img/ca1.png" alt=""></p><ul><li>服务器证书server.pem的签发者为中间证书机构inter，inter根据证书inter.pem验证server.pem确实为自己签发的有效证书</li><li>中间证书inter.pem的签发CA为root,root根据root.pem验证inter.pem为自己签发的合法证书</li><li>客户端内置新人CA的root.pem证书，因此服务器证书server.pem的被信任</li></ul><p>https的加密过程<br><img src="/img/https-encode.png" alt=""></p><h2 id="8-Gradle"><a href="#8-Gradle" class="headerlink" title="8.Gradle"></a>8.Gradle</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ant: 长江后浪推前浪，前浪已经over了</span><br><span class="line">|---编译、测试、打包</span><br><span class="line"></span><br><span class="line">Maven:使用xml标记构建脚本</span><br><span class="line">|---依赖管理、编译、测试、打包、发布</span><br><span class="line"></span><br><span class="line">Gradle:使用Groovy语言构建脚本</span><br><span class="line">|---依赖管理、编译、测试、打包、发布、灵活的脚本</span><br></pre></td></tr></table></figure><p>Gradle：是一个基于Groovy语言的开源项目自动化构建工具</p><p>Groovy: 基于java虚拟机的动态语言、面向对象/脚本，完全兼容Java语法</p><p><img src="/img/gradle.png" alt="构建的生命周期"></p><h2 id="9-ClassLoader"><a href="#9-ClassLoader" class="headerlink" title="9. ClassLoader"></a>9. ClassLoader</h2><h3 id="插件化技术的核心"><a href="#插件化技术的核心" class="headerlink" title="插件化技术的核心"></a>插件化技术的核心</h3><ol><li>作用：<br>Android虚拟机运行的Dex字节码（将Class文件合并优化生成的产物），ClassLoader用来加载dex文件。</li><li>委托双亲机制：顶层（父类）无法加载这个类，则由由自己加载，如果还加载不到，则会报ClassNotFound错误。（可以用爸爸的钱就绝对不用自己的钱，如果爸爸没有钱，再用自己的， 如果自己还是没有钱，那么就classnotfound异常）</li></ol><h2 id="10-Android原生与js交互"><a href="#10-Android原生与js交互" class="headerlink" title="10. Android原生与js交互"></a>10. Android原生与js交互</h2><h3 id="一、js调用Android方法"><a href="#一、js调用Android方法" class="headerlink" title="一、js调用Android方法"></a>一、js调用Android方法</h3><h4 id="方法一：通过-Webview-的-addJavascriptInterface-进行对象映射"><a href="#方法一：通过-Webview-的-addJavascriptInterface-进行对象映射" class="headerlink" title="方法一：通过 Webview 的 addJavascriptInterface() 进行对象映射"></a>方法一：通过 Webview 的 addJavascriptInterface() 进行对象映射</h4><blockquote><p>优点：使用简单，仅将Android对象和JS对象映射即可 <br> 缺点：存在漏洞问题</p></blockquote><p>1）允许WebView加载JS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.getSettings().setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure><p>2）编写JS接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class JsInterface &#123;</span><br><span class="line">    private static final String TAG = &quot;JsInterface&quot;;</span><br><span class="line">    private JsBridge jsBridge;</span><br><span class="line">    public JsInterface(JsBridge jsBridge) &#123;</span><br><span class="line">        this.jsBridge = jsBridge;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 这个方法由 JS 调用， 不在主线程执行</span><br><span class="line">     *</span><br><span class="line">     * @param value</span><br><span class="line">     */</span><br><span class="line">    @JavascriptInterface</span><br><span class="line">    public void callAndroid(String value) &#123;</span><br><span class="line">        Log.i(TAG, &quot;value = &quot; + value);</span><br><span class="line">        jsBridge.setTextValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3）给WebView添加JS接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">webView.addJavascriptInterface(new JsInterface(this), &quot;launcher&quot;);// 此处的 launcher 可以自定义，最终是 JS 中要使用的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4）js代码中调用java方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (window.launcher)&#123; // 判断 launcher 对象是否存在</span><br><span class="line">// 此处的 launcher 要和 第3步中定义的 launcher 保持一致</span><br><span class="line">    // JS 调用 Android 的方法</span><br><span class="line">    launcher.callAndroid(str);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    alert(&quot;launcher not found!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法二：通过-WebViewClient-的-shouldOverrideUrlLoading-方法回调拦截-url"><a href="#方法二：通过-WebViewClient-的-shouldOverrideUrlLoading-方法回调拦截-url" class="headerlink" title="方法二：通过 WebViewClient 的 shouldOverrideUrlLoading() 方法回调拦截 url"></a>方法二：通过 WebViewClient 的 shouldOverrideUrlLoading() 方法回调拦截 url</h4><blockquote><p>优点：不存在方式一的漏洞 <br> 缺点：JS获取Android方法的返回值复杂</p></blockquote><p>1）JS代码中，约定协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function callAndroid()&#123;</span><br><span class="line">    // 约定的 url 协议为：js://webview?arg1=111&amp;arg2=222</span><br><span class="line">    document.location = &quot;js://webview?arg1=&quot;+inputEle.value+&quot;&amp;arg2=222&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）Android 代码中，通过设置 WebViewClient 对协议进行拦截处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">        // 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span><br><span class="line">        // 例如：url = &quot;js://webview?arg1=111&amp;arg2=222&quot;</span><br><span class="line">        Uri uri = Uri.parse(url);</span><br><span class="line">        // 如果url的协议 = 预先约定的 js 协议</span><br><span class="line">        if (uri.getScheme().equals(&quot;js&quot;)) &#123;</span><br><span class="line">            // 拦截url,下面JS开始调用Android需要的方法</span><br><span class="line">            if (uri.getAuthority().equals(&quot;webview&quot;)) &#123;</span><br><span class="line">                // 执行JS所需要调用的逻辑</span><br><span class="line">                Log.e(&quot;TAG&quot;, &quot;JS 调用了 Android 的方法&quot;);</span><br><span class="line">                Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">                Iterator&lt;String&gt; it = collection.iterator();</span><br><span class="line">                String result = &quot;&quot;;</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    result += uri.getQueryParameter(it.next()) + &quot;,&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                tv_result.setText(result);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.shouldOverrideUrlLoading(view, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法三：通过-WebChromeClient-的-onJsAlert-、-onJsConfirm-、-onJsPrompt（）方法回调拦截-JS-对话框-alert-、-confirm-、-prompt（）-消息"><a href="#方法三：通过-WebChromeClient-的-onJsAlert-、-onJsConfirm-、-onJsPrompt（）方法回调拦截-JS-对话框-alert-、-confirm-、-prompt（）-消息" class="headerlink" title="方法三：通过 WebChromeClient 的 onJsAlert() 、 onJsConfirm() 、 onJsPrompt（）方法回调拦截 JS 对话框 alert() 、 confirm() 、 prompt（） 消息"></a>方法三：通过 WebChromeClient 的 onJsAlert() 、 onJsConfirm() 、 onJsPrompt（）方法回调拦截 JS 对话框 alert() 、 confirm() 、 prompt（） 消息</h4><p>1）JS代码中，约定协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 调用 prompt()</span><br><span class="line">var result=prompt(&quot;js://prompt?arg1=&quot;+inputEle.value+&quot;&amp;arg2=222&quot;);</span><br><span class="line">alert(&quot;prompt：&quot; + result);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）Android 代码中，通过设置 WebChromeClient 对协议进行拦截处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebChromeClient(new WebChromeClient() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;</span><br><span class="line">        // 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span><br><span class="line">        // 例如：url = &quot;js://webview?arg1=111&amp;arg2=222&quot;</span><br><span class="line">        Uri uri = Uri.parse(message);</span><br><span class="line">        Log.e(&quot;TAG&quot;, &quot;----onJsPrompt---&gt;&gt;&quot; + url + &quot;,&quot; + message);</span><br><span class="line">        // 如果url的协议 = 预先约定的 js 协议</span><br><span class="line">        if (uri.getScheme().equals(&quot;js&quot;)) &#123;</span><br><span class="line">            // 拦截url,下面JS开始调用Android需要的方法</span><br><span class="line">            if (uri.getAuthority().equals(&quot;prompt&quot;)) &#123;</span><br><span class="line">                // 执行JS所需要调用的逻辑</span><br><span class="line">                Log.e(&quot;TAG&quot;, &quot;JS 调用了 Android 的方法&quot;);</span><br><span class="line">                Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">                Iterator&lt;String&gt; it = collection.iterator();</span><br><span class="line">                String result2 = &quot;&quot;;</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    result2 += uri.getQueryParameter(it.next()) + &quot;,&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                tv_result.setText(result2);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onJsPrompt(view, url, message, defaultValue, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123;</span><br><span class="line">        Log.e(&quot;TAG&quot;, &quot;----onJsAlert---&gt;&gt;&quot; + url+ &quot;,&quot; + message);</span><br><span class="line">        return super.onJsAlert(view, url, message, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123;</span><br><span class="line">        Log.e(&quot;TAG&quot;, &quot;----onJsConfirm---&gt;&gt;&quot; + url+ &quot;,&quot; + message);</span><br><span class="line">        return super.onJsConfirm(view, url, message, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、Android调用JS方法"><a href="#二、Android调用JS方法" class="headerlink" title="二、Android调用JS方法"></a>二、Android调用JS方法</h3><h4 id="方法一：通过WebView的loadUrl"><a href="#方法一：通过WebView的loadUrl" class="headerlink" title="方法一：通过WebView的loadUrl()"></a>方法一：通过WebView的loadUrl()</h4><p>1）编写JS方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var callJS = function(str)&#123;</span><br><span class="line">    inputEle.value = str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）使用webView.loadUrl()调用JS方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Android 调用 JS 方法</span><br><span class="line">webView.loadUrl(&quot;javascript:if(window.callJS)&#123;window.callJS(&#x27;&quot; + str + &quot;&#x27;);&#125;&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法二：-通过-WebView-的-evaluateJavascript"><a href="#方法二：-通过-WebView-的-evaluateJavascript" class="headerlink" title="方法二： 通过 WebView 的 evaluateJavascript()"></a>方法二： 通过 WebView 的 evaluateJavascript()</h3><blockquote><ul><li>该方法比第一种方法效率更高，使用更简洁；</li><li>该方法执行不会刷新页面，而第一种方法（ loadUrl ）则会；</li><li>Android 4.4 以后才能使用。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    webView.evaluateJavascript(&quot;javascript:if(window.callJS)&#123;window.callJS(&#x27;&quot; + str + &quot;&#x27;);&#125;&quot;, new ValueCallback&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onReceiveValue(String value) &#123;</span><br><span class="line">            Log.e(&quot;TAG&quot;, &quot;---------&gt;&gt;&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-RecyclerView缓存机制"><a href="#11-RecyclerView缓存机制" class="headerlink" title="11.RecyclerView缓存机制"></a>11.<a href="https://juejin.im/post/5c696ba9e51d457f136d24ff?utm_source=gold_browser_extension#heading-6">RecyclerView缓存机制</a></h2><h4 id="缓存优先级（从高到低）"><a href="#缓存优先级（从高到低）" class="headerlink" title="缓存优先级（从高到低）"></a>缓存优先级（从高到低）</h4><ul><li>mAttachedScrap获取</li><li>mCachedViews获取</li><li>mRecyclerPool获取</li></ul><ol><li>在RecyclerView中，并不是每次绘制表项，都会重新创建ViewHolder对象，也不是每次都会重新绑定ViewHolder数据</li><li>RecyclerView通过Recycler获得下一个待绘制表项</li><li>Recycler有4个层次用于缓存ViewHolder对象、优先级从高到低依次为ArrayList<ViewHolder> mAttachedScrap、ArrayList<ViewHolder> mCachedViews、ViewCacheExtension mViewCacheExtension、RecycledViewPool mRecyclerPool。如果四层缓存都未命中，则重新创建饼绑定ViewHolder对象</li><li>RecyclerViewPool对ViewHolder按viewType分类存储（通过SparseArray），同类ViewHolder存储在默认大小为5的ArrayList中</li><li>葱mRecyclerPool中复用的ViewHolder需要重新绑定数据，从mAttachedScrap中复用的ViewHolder不需要重新创建也不需要重新绑定数据。</li></ol><h2 id="12-性能优化"><a href="#12-性能优化" class="headerlink" title="12.性能优化"></a>12.性能优化</h2><ul><li>启动速度</li></ul><p><img src="/img/speed.png" alt=""></p><ul><li>页面显示速度<br>优化原因（即 页面显示速度慢的原因） a. 页面需绘制的内容（布局 &amp; 控件）太多，从而导致页面测量时间过长 b. 绘制效率过低，从而导致绘制时间过长</li></ul><ol><li>降低onDraw()方法的复杂度</li><li>避免过度绘制(Overdraw)</li><li>避免嵌套布局，复杂布局，简化布局，使用 &lt; viewStub/&gt; &lt; include/&gt; &lt; merge/&gt;等标签布局</li><li>布局属性 wrap_content 会增加布局测量时计算成本，应尽可能少用</li></ol><ul><li>响应速度</li></ul><blockquote><p>优化方案：使用多线程，将大量 &amp; 耗时操作放在工作线程中执行</p></blockquote><ol><li>多线程的方式 包括：AsyncTask、继承 Thread类、实现 Runnable接口、Handler消息机制、HandlerThread等</li><li>注：实际开发中，当一个进程发生了ANR后，系统会在 /data/anr目录下创建一个文件 traces.txt，通过分析该文件可定位出ANR的原因</li></ol><p><img src="/img/thread.png" alt=""></p><ul><li>稳定性<br><img src="/img/android1.png" alt="稳定性的性能优化"></li><li>内存优化          <ol><li>优化原因 避免因不正确使用内存 &amp; 缺乏管理，从而出现 内存泄露（ML）、内存溢出（OOM）、内存空间占用过大 等问题，最终导致应用程序崩溃（Crash）</li></ol></li></ul><p><img src="/img/android2.png" alt="">   </p><ol start="2"><li>内存回收策略<br><img src="/img/android3.png" alt=""></li><li>内存分配策略</li></ol><p><img src="/img/android4.png" alt=""></p><p>注：用1个实例讲解 内存分配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;    </span><br><span class="line">    // 该类的实例对象的成员变量s1、mSample1 &amp; 指向对象存放在堆内存中</span><br><span class="line">    int s1 = 0;</span><br><span class="line">    Sample mSample1 = new Sample();   </span><br><span class="line"></span><br><span class="line">    // 方法中的局部变量s2、mSample2存放在 栈内存</span><br><span class="line">    // 变量mSample2所指向的对象实例存放在 堆内存</span><br><span class="line">    public void method() &#123;        </span><br><span class="line">        int s2 = 0;</span><br><span class="line">        Sample mSample2 = new Sample();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    // 变量mSample3的引用存放在栈内存中</span><br><span class="line">    // 变量mSample3所指向的对象实例存放在堆内存</span><br><span class="line">    // 该实例的成员变量s1、mSample1也存放在堆内存中</span><br><span class="line">    Sample mSample3 = new Sample();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>内存回收策略</li></ol><p>GC垃圾回收机制</p><p><img src="/img/gc1.png" alt=""></p><ul><li>常见问题<br>bitmap图片资源<br><img src="/img/gc2.png" alt=""></li></ul><p><img src="/img/gc3.png" alt=""></p><p>内存抖动</p><p><img src="/img/gc4.png" alt=""></p><p>优化方案： 尽量避免频繁创建大量、临时的小对象</p><p>代码质量&amp;数量</p><p><img src="/img/gc5.png" alt=""></p><p>常见内存问题</p><p><img src="/img/gc6.png" alt=""></p><p>总结</p><p><img src="/img/gc7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-ViewStub的应用&quot;&gt;&lt;a href=&quot;#1-ViewStub的应用&quot; class=&quot;headerlink&quot; title=&quot;1. ViewStub的应用&quot;&gt;&lt;/a&gt;1. ViewStub的应用&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在不显示布局时我们会使用
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>flutter listview和adapter</title>
    <link href="http://yoursite.com/2019/05/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF/flutter/flutter-listview%E5%92%8Cadapter/"/>
    <id>http://yoursite.com/2019/05/24/移动端/flutter/flutter-listview和adapter/</id>
    <published>2019-05-24T08:18:16.000Z</published>
    <updated>2021-05-27T11:40:17.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ListView-Builder"><a href="#1-ListView-Builder" class="headerlink" title="1. ListView.Builder()"></a>1. ListView.Builder()</h3><p>builder属性详细介绍</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置滑动方向 Axis.horizontal 水平  默认 Axis.vertical 垂直</span></span><br><span class="line">        scrollDirection: Axis.vertical,</span><br><span class="line">        <span class="comment">//内间距</span></span><br><span class="line">        padding: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">        <span class="comment">//是否倒序显示 默认正序 false  倒序true</span></span><br><span class="line">        reverse: <span class="keyword">false</span>,</span><br><span class="line">        <span class="comment">//false，如果内容不足，则用户无法滚动 而如果[primary]为true，它们总是可以尝试滚动。</span></span><br><span class="line">        primary: <span class="keyword">true</span>,</span><br><span class="line">        <span class="comment">//确定每一个item的高度 会让item加载更加高效</span></span><br><span class="line">        itemExtent: <span class="number">50.0</span>,</span><br><span class="line">        <span class="comment">//内容适配</span></span><br><span class="line">        shrinkWrap: <span class="keyword">true</span>,</span><br><span class="line">        <span class="comment">//item 数量</span></span><br><span class="line">        itemCount: list.length,</span><br><span class="line">        <span class="comment">//滑动类型设置</span></span><br><span class="line">        physics: <span class="keyword">new</span> ClampingScrollPhysics(),</span><br><span class="line">         <span class="comment">//cacheExtent  设置预加载的区域 </span></span><br><span class="line">         cacheExtent: <span class="number">30.0</span>, </span><br><span class="line">        <span class="comment">//滑动监听</span></span><br><span class="line"><span class="comment">//        controller ,</span></span><br></pre></td></tr></table></figure><p><strong>shrinkWrap</strong>特别推荐<br>child 高度会适配 item填充的内容的高度,我们非常的不希望child的高度固定，因为这样的话，如果里面的内容超出就会造成布局的溢出。<br>shrinkWrap多用于嵌套listView中 内容大小不确定 比如 垂直布局中 先后放入文字 listView （需要Expend包裹否则无法显示无穷大高度 但是需要确定listview高度 shrinkWrap使用内容适配不会有这样的影响）</p><p><strong>primary</strong><br>If the [primary] argument is true, the [controller] must be null.<br>在构造中默认是false 它的意思就是为主的意思，primary为true时，我们的controller 滑动监听就不能使用了</p><p><strong>physics</strong><br>这个属性几个滑动的选择<br>AlwaysScrollableScrollPhysics() 总是可以滑动<br>NeverScrollableScrollPhysics禁止滚动<br>BouncingScrollPhysics 内容超过一屏 上拉有回弹效果<br>ClampingScrollPhysics 包裹内容 不会有回弹</p><p><strong>cacheExtent</strong><br>这个属性的意思就是预加载的区域<br>设置预加载的区域 cacheExtent 强制设置为了 0.0，从而关闭了“预加载”</p><p><strong>controller</strong></p><p>滑动监听，我们多用于上拉加载更多，通过监听滑动的距离来执行操作。</p><h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><p>listview需要添加父布局，flex;1做到全屏拉伸，才会显示<br>Expanded下的listview无法置顶，需要设置padding:EdgeInsets.only(top: 0)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-ListView-Builder&quot;&gt;&lt;a href=&quot;#1-ListView-Builder&quot; class=&quot;headerlink&quot; title=&quot;1. ListView.Builder()&quot;&gt;&lt;/a&gt;1. ListView.Builder()&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
      <category term="listview" scheme="http://yoursite.com/tags/listview/"/>
    
      <category term="adapter" scheme="http://yoursite.com/tags/adapter/"/>
    
  </entry>
  
</feed>
