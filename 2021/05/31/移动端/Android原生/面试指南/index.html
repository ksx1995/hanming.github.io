<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="纳兰寒明的博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->

<meta name="keywords" content="Android" />


<meta name="description" content="[TOC]
框架篇EventBus简述EventBus的理解EventBus作为通信事件传递的总线，你无需控制值的传递，也无需通过广播等低效实现，通过EventBus在你需要发送的地方post信..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    面试指南 |
    
    纳兰寒明的博客
</title>

<link rel="alternate" href="/atom.xml" title="纳兰寒明的博客" type="application/atom+xml">


<link rel="icon" href="/avatar.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 5.4.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='纳兰寒明'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <h2>
                我有一个梦想
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">
                        纳兰寒明的博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/前端/"><i class="fa "></i>
                                前端</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/后端/"><i class="fa "></i>
                                后端</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/移动端/"><i class="fa "></i>
                                移动端</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/随笔/"><i class="fa "></i>
                                随笔</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时光轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="面试指南">
            
            面试指南
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-none-link" href="/tags/Android/" rel="tag">Android</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2021/05/31</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <p>[TOC]</p>
<h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><h4 id="简述EventBus的理解"><a href="#简述EventBus的理解" class="headerlink" title="简述EventBus的理解"></a>简述EventBus的理解</h4><p>EventBus作为通信事件传递的总线，你无需控制值的传递，也无需通过广播等低效实现，通过EventBus在你需要发送的地方post信息，在你需要接收的地方接收信息处理即可，（前提是register过）</p>
<h4 id="EventBus的五种线程模式"><a href="#EventBus的五种线程模式" class="headerlink" title="EventBus的五种线程模式"></a>EventBus的五种线程模式</h4><ul>
<li><strong>POSTING</strong>：默认，发布和订阅在同一个线程，同发布者一个线程（主—&gt;主 , 子—&gt;子），最小的开销，因为不用切换线程，避免了线程的完全切换，使用此模式的事件处理程序必须快速返回，以避免阻塞可能是主线程的发布线程。</li>
<li><strong>MAIN</strong>：事件处理函数的线程在主线程（UI）线程。不能进行<code>耗时</code>操作，订阅者需快速返回以免阻塞主线程</li>
<li><strong>MAIN_ORDERED</strong>:事件处理函数的线程在主线程（UI）线程。不会阻塞线程</li>
<li><strong>BACKGROUND</strong>：处理函数在后台线程，不能进行UI操作。发布在主线程，订阅会开启一个新的后台线程。发布在后台线程，事件处理函数也在该后台线程</li>
<li><strong>ASYNC</strong>：无论事件发布的线程是哪一个，都会重新开辟一个新的子线程运行，不能进行UI操作</li>
</ul>
<h4 id="EventBus的事件类型"><a href="#EventBus的事件类型" class="headerlink" title="EventBus的事件类型"></a>EventBus的事件类型</h4><p>接收事件必须是public修饰符修饰，不能用static关键字修饰，不能是抽象的（abstract）</p>
<ol>
<li>普通事件：先订阅在发布，发布到订阅者后进行处理</li>
<li>粘性事件：支持先发布在订阅，当订阅者订阅后会自动发送到订阅者进行处理，发送粘性事件EventBus.postSticky()，接收粘性事件sticky = true</li>
</ol>
<h4 id="为什么必须是public？"><a href="#为什么必须是public？" class="headerlink" title="为什么必须是public？"></a>为什么必须是public？</h4><p>因为源码定义</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>优先级高的订阅者优先接收到任务</p>
<h4 id="简述源码分析事件"><a href="#简述源码分析事件" class="headerlink" title="简述源码分析事件"></a>简述源码分析事件</h4><ul>
<li>register：通过注解初始化订阅方法后，在register后，在缓存中获取所有该订阅者的方法，循环遍历订阅，新建newSubscription方法，根据priority优先级将newSubscription方法放入subscriptions中，判断如果<code>是粘性事件</code>，则执行其对应的订阅方法。</li>
<li>unregister：从typesBySubscriber获取订阅事件类型，根据订阅事件类型从subscriptionsByEventType获取订阅者信息，将subscription的active置为false，并移除该subscription</li>
</ul>
<h4 id="索引如何理解？"><a href="#索引如何理解？" class="headerlink" title="索引如何理解？"></a>索引如何理解？</h4><p>EventBus 3.0以后，采用Subscribe注解配置事件订阅方法，采用反射的方式来查找订阅事件的方法，我们都知道反射对性能是有影响的，所以提出了索引的概念。</p>
<p>在项目编译时，通过配置，生成一个辅助类用来存储订阅信息，原理是HashMap，存储注册类的class类型和事件订阅方法的信息，提高速度3-4倍</p>
<h4 id="MAIN和MAIN-ORDERED的区别？"><a href="#MAIN和MAIN-ORDERED的区别？" class="headerlink" title="MAIN和MAIN_ORDERED的区别？"></a>MAIN和MAIN_ORDERED的区别？</h4><ol>
<li><p>在<code>MAIN</code>模式下，如果事件发布者post事件也是在主线程的话，会阻塞post事件所在的线程，意思是连续post多个事件，如果接收事件方法执行完，才能post下一个事件</p>
<pre><code>**post(1) ——&gt; onReceiveMsg(1) ——&gt;post(2)——&gt;onReceiveMsg(2)——&gt;post(3)——&gt;onReceiveMsg(3)**
</code></pre></li>
<li><p>如果事件发布者post事件不在主线程，连续post多个事件，同时在主线程是接收事件是耗时操作的话，执行的流程是非阻塞的</p>
<pre><code>**post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(3)**
或
**post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(2)——&gt;onReceiveMsg(3)**
</code></pre></li>
<li><p>MAIN_ORDERED模式下，无论什么场景都是非阻塞的</p>
</li>
</ol>
<h4 id="EventBus可否跨进程问题？"><a href="#EventBus可否跨进程问题？" class="headerlink" title="EventBus可否跨进程问题？"></a>EventBus可否跨进程问题？</h4><p>不能，单进程间通信</p>
<p>HermesEventBus——&gt;饿了吗开发框架，可应用于单进程和多进程。</p>
<p>使用IPC机制，首先选择一个主进程，其他则为子进程，每一个event会经过4步：</p>
<ol>
<li>使用Hermes库将event传递给主进程。</li>
<li>主进程使用EventBus在主进程内部发送event。</li>
<li>主进程使用Hermes库将event传递给所有的子进程。</li>
<li>每个子进程使用EventBus在子进程内部发送event。</li>
</ol>
<h4 id="BackgroundThread和Async区别"><a href="#BackgroundThread和Async区别" class="headerlink" title="BackgroundThread和Async区别"></a>BackgroundThread和Async区别</h4><p>BackgroundThread：发布在主线程，新开辟子线程中执行。发布在子线程，则在子线程中执行，这个子线程是阻塞式的,按顺序交付所有事件，所以也不适合做耗时任务，因为多个事件共用这一个后台线程</p>
<p>Async：无论发布在哪一个线程，都会在重新开辟一个子线程执行</p>
<h4 id="EventBus的优缺点："><a href="#EventBus的优缺点：" class="headerlink" title="EventBus的优缺点："></a>EventBus的优缺点：</h4><p><code>优点</code>:<br>EventBus是greenrobot公司出的另一款开源框架，这个框架是针对Android优化的发布/订阅事件总线，使用EventBus可以极大的减少我们程序的耦合度。<br>调度灵活。不依赖于 Context，使用时无需像广播一样关注 Context 的注入与传递。<br>使用简单。<br>快速且轻量。<br>完全解耦了请求链之间的关系，避免了请求者被长持有，<br>比广播更轻量<br>可以定义在调用线程、主线程、后台线程、异步。</p>
<p>粘性事件</p>
<p>优先级概念</p>
<p>为了避免频繁的向主线程 <code>sendMessage()</code>(Handler机制)，EventBus 的做法是在一个消息里尽可能多的处理更多的消息事件，所以使用了 while 循环，持续从消息队列 queue 中获取消息。</p>
<p>同时为了避免长期占有主线程，间隔 10ms （maxMillisInsideHandleMessage = 10ms）会重新发送 <code>sendMessage()</code>，用于让出主线程的执行权，避免造成 UI 卡顿和 ANR。</p>
<p><code>缺点</code>:<br>各种Event的定义工作量大。每次传的内容不一样,就需要重新定义一个JavaBean</p>
<p>单向传播</p>
<p>需要显性注册</p>
<h4 id="EventBus如何做到线程切换"><a href="#EventBus如何做到线程切换" class="headerlink" title="EventBus如何做到线程切换"></a>EventBus如何做到线程切换</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010457514/article/details/101771245">EventBus发送的消息，如何做到线程切换？</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> POSTING:</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">                <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>主要分为主线程执行和子线程执行，当为主线程时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HandlerPoster</span><span class="params">(EventBus eventBus, Looper looper, <span class="keyword">int</span> maxMillisInsideHandleMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="keyword">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">                handlerActive = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//循环处理消息事件，避免重复sendMessage()</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                PendingPost pendingPost = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">                <span class="comment">//避免长期占用主线程，间隔10ms重新sendMassage()</span></span><br><span class="line">                <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rescheduled = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            handlerActive = rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用HandlerPoster将任务通过sendMessage方法发送到主线程执行，通过消息队列存储该handler的任务，通过10ms发送一次任务，防止主线程卡顿，MAIN情况下，如果在主线程，直接执行。MAIN_ORDER的情况下，全部交给handler异步执行，所以区别于MAIN不是同步的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</span><br><span class="line"></span><br><span class="line">    BackgroundPoster(EventBus eventBus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!executorRunning) &#123;</span><br><span class="line">                executorRunning = <span class="keyword">true</span>;</span><br><span class="line">                eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    PendingPost pendingPost = queue.poll(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                            <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                            pendingPost = queue.poll();</span><br><span class="line">                            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                executorRunning = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + <span class="string">&quot; was interruppted&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorRunning = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    AsyncPoster(EventBus eventBus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No pending post available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子线程执行是通过线程池进行管理，内部也存在一个消息队列，按顺序执行任务，对于BACKGROUND情况下，同时只会使用线程池中的一个线程，而Async直接放入线程池，让线程池去规划线程。当线程池中等待任务过多时，会触发oom（线程池是newCachedThreadPool()，则线程为非核心线程MAX）</p>
<h4 id="粘性事件的原理"><a href="#粘性事件的原理" class="headerlink" title="粘性事件的原理"></a>粘性事件的原理</h4><p>普通事件是先注册后发布，而粘性事件可以先发布后注册，实现方式上是这样的：</p>
<p>发送时会将粘性事件的事件类型和对应事件保存起来，在执行post方法，在注册后，如果是粘性事件，会多走一步类似于post的方法，触发进行分发</p>
<h4 id="如何判断当前线程是否为主线程？"><a href="#如何判断当前线程是否为主线程？" class="headerlink" title="如何判断当前线程是否为主线程？"></a>如何判断当前线程是否为主线程？</h4><p>在发布事件的地方判断发送线程和主线程的Looper对象是否相等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Looper.getMainLooper() == Looper.myLooper();</span><br></pre></td></tr></table></figure></p>
<h4 id="如何优化EventBus"><a href="#如何优化EventBus" class="headerlink" title="如何优化EventBus"></a>如何优化EventBus</h4><ol>
<li>尽量使用索引功能，避免不必要的反射，提升性能</li>
<li>增加EventBus的进程间通信</li>
</ol>
<h4 id="为什么使用ConcurrentHashMap保存数据"><a href="#为什么使用ConcurrentHashMap保存数据" class="headerlink" title="为什么使用ConcurrentHashMap保存数据"></a>为什么使用ConcurrentHashMap保存数据</h4><p><a href="#ConcurrentHashMap和HashMap的区别">ConcurrentHashMap和HashMap的区别</a></p>
<p>因为EventBus是单进程、多线程间通信，可能涉及到线程安全问题，使用ConcurrentHashMap可以有效解决线程安全和效率。</p>
<h2 id="Okhttp3"><a href="#Okhttp3" class="headerlink" title="Okhttp3"></a>Okhttp3</h2><p><img src="/imageMd/okhttp-1.png" alt="okhttp3"></p>
<h4 id="简述OkHttp"><a href="#简述OkHttp" class="headerlink" title="简述OkHttp"></a>简述OkHttp</h4><p>是基于Socket的封装，主要有三个类：Response、Request、Call</p>
<p>同步使用client.excute();  异步使用client.enqueue();</p>
<p>OkHttp的高效在于内部有一个Dispatcher，是okhttp维护的一个线程池，对最大连接数（并发），host最大访问量做了定义，维护了3个队列（同步正在执行，准备执行，异步正在执行）和一个线程池（0~max）</p>
<p>内部还维护了连接池，实现了复用机制，减少重复握手</p>
<p>提供缓存机制。</p>
<h4 id="有几个拦截器，分别是干什么的？"><a href="#有几个拦截器，分别是干什么的？" class="headerlink" title="有几个拦截器，分别是干什么的？"></a>有几个拦截器，分别是干什么的？</h4><p><code>client.intercepters()：应用拦截器</code></p>
<p>RetryAndFollowUpIntercepter：重试和重定向机制，最大重试次数为20，构造StreamAllocation，创建缓存池，复用</p>
<p>BridgeIntercepter：将用户构造的请求转化为服务器识别的请求，将服务器返回的响应转化为用户识别的响应，添加keep-alive，供连接池复用</p>
<p>CacheIntercepter：缓存读取和更新</p>
<p>ConnectIntercepter：dns解析与服务器建立连接(握手结束)，它利用 Okio 对 Socket 的读写操作进行封装，它对 java.io 和 java.nio 进行了封装，让我们更便捷高效的进行 IO 操作</p>
<p><code>client.networkIntercepter：网络拦截器</code></p>
<p>CallServerIntercepter：最后一个拦截器，负责向服务器发送请求和接收服务器的响应</p>
<p>采用责任链模式，将请求和发送分别处理，并且可以动态添加中间的处理方实现对请求的处理、短路等操作。</p>
<p>addNetworkInterceptor() （网络拦截器）和addInterceptor() （应用拦截器）</p>
<p>区别就是一个靠前一个靠后，其中经过的拦截器会导致不一样的结果</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liyutian/p/9489016.html">自定义拦截器区别</a></p>
<h4 id="RetryAndFollowUpIntercepter中怎么进行重定向？"><a href="#RetryAndFollowUpIntercepter中怎么进行重定向？" class="headerlink" title="RetryAndFollowUpIntercepter中怎么进行重定向？"></a>RetryAndFollowUpIntercepter中怎么进行重定向？</h4><p>最大重试次数为20次<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> HTTP_PERM_REDIRECT:<span class="comment">//307</span></span><br><span class="line"><span class="keyword">case</span> HTTP_TEMP_REDIRECT:<span class="comment">//308</span></span><br><span class="line">  <span class="comment">// &quot;If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">  <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request&quot;</span></span><br><span class="line">  <span class="keyword">if</span> (!method.equals(<span class="string">&quot;GET&quot;</span>) &amp;&amp; !method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// fall-through</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MULT_CHOICE:<span class="comment">//300</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_PERM:<span class="comment">//301</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_TEMP:<span class="comment">//302</span></span><br><span class="line"><span class="keyword">case</span> HTTP_SEE_OTHER:<span class="comment">//303</span></span><br><span class="line">  <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">  <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  String location = userResponse.header(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t follow redirects to unsupported protocols.</span></span><br><span class="line">  <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If configured, don&#x27;t follow redirects between SSL and non-SSL.</span></span><br><span class="line">  <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">  <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Most redirects don&#x27;t include a request body.</span></span><br><span class="line">  Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">      requestBuilder.method(<span class="string">&quot;GET&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="keyword">null</span>;</span><br><span class="line">      requestBuilder.method(method, requestBody);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">  <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">  <span class="comment">// way to retain them.</span></span><br><span class="line">  <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">    requestBuilder.removeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> requestBuilder.url(url).build();</span><br></pre></td></tr></table></figure><br>如果返回响应code是307和308，则只对get和head类型的请求进行重定向。<br>如果返回请求为PROPFIND，则重新发送的请求都为保持原状，如果不是propFind，则重新请求的都会被设置为<code>get</code>请求，且请求信息为空</p>
<blockquote>
<p>RetryAndFollowUpInterceptor的intercept中先是创建了StreamAllocation对象，然后开启while(true)无限循环。接着在这个循环中先调用下层拦截器去网络请求，若请求期间发生异常，判断能否重试，能就continue进行下一轮循环，否则抛异常退出循环结束方法。如果下层拦截器请求完成返回response，通过response的状态码判断是否需要重定向，若需要重定向，修改request后进行下一轮循环，否则返回response结束方法。</p>
</blockquote>
<h4 id="什么是连接池？"><a href="#什么是连接池？" class="headerlink" title="什么是连接池？"></a>什么是连接池？</h4><p>OkHttp的底层是通过Java的Socket发送HTTP请求与接受响应的(这也好理解，HTTP就是基于TCP协议的)，但是OkHttp实现了连接池的概念，</p>
<p>即对于同一主机的多个请求，其实可以公用一个Socket连接，而不是每次发送完HTTP请求就关闭底层的Socket，这样就实现了连接池的概念。</p>
<h4 id="简述连接池的复用？"><a href="#简述连接池的复用？" class="headerlink" title="简述连接池的复用？"></a>简述连接池的复用？</h4><p>okhttp中所有的请求都被抽象为RealConnection，而ConnectionPool就是管理这些connection的，共享一个Address的链接可以复用</p>
<p>ConnectionPool，默认大小是5，每个链接存储5分钟，使用keep-alive，达到久连接，所以默认keep-alive是5分钟，也可以自定义</p>
<p>excutor：线程池，监测时间并释放连接的后台线程</p>
<p>connections：缓存池。是一个双端列表，这里用作栈</p>
<p>routeDatabase：记录连接失败router（路由）</p>
<p>使用put方法将连接放入缓存池，并清除闲置的线程，对缓存池进行排序（对比最大闲置时间），使用StreamAllocation复用请求</p>
<p>StreamAllocation的初始化在RetryAndFllowUpIntercepter。</p>
<p>在StreamAllocation调用newStream进行初始化，其中使用get方法在缓存池中查找相同的请求，如果找到就复用这条请求，没找到就新建连接并put到缓存池</p>
<blockquote>
<p>连接池的工作就这么多，并不负责，主要就是管理双端队列Deque<RealConnection>，可以用的连接就直接用，然后定期清理连接，同时通过对StreamAllocation的引用计数实现自动回收。</p>
</blockquote>
<h4 id="简述StreamAllocation"><a href="#简述StreamAllocation" class="headerlink" title="简述StreamAllocation"></a>简述StreamAllocation</h4><p>StreamAllocation是用来协调connections，stream和Call(请求)的。</p>
<p>HTTP通信执行网络请求<code>Call</code>需要在连接<code>Connection</code>上建立一个新的流<code>Stream</code>，我们将<code>StreamAllocation</code>称之流 的桥梁，它负责为一次<code>请求</code>寻找<code>连接</code>并建立<code>流</code>，从而完成远程通信。</p>
<p>其初始化在RetryAndFllowUpIntercepter，再次使用在CallServerInterceptor，复用机制使用该方法调用，减少一个三次握手的时间（不需要握手）</p>
<h4 id="OKIO的优势"><a href="#OKIO的优势" class="headerlink" title="OKIO的优势"></a>OKIO的优势</h4><ol>
<li>更加轻便，速度更快，使用更快</li>
<li>实现缓存结构，对cpu和内存进行优化，避免频繁gc（Segment链表实现）</li>
<li>功能强大，支持阻塞和非阻塞IO</li>
<li>支持多种类型，想比较于java.io和java.nio，不需要庞大的装饰类</li>
</ol>
<h4 id="Dispatcher的理解"><a href="#Dispatcher的理解" class="headerlink" title="Dispatcher的理解"></a>Dispatcher的理解</h4><p><img src="/imageMd/okhttp-2.png" alt="img"><br>内部维护了三个队列，分别为：</p>
<ul>
<li>runningAsyncCalls：正在请求的异步队列</li>
<li>readyAsyncCalls：准备请求的异步队列\等待请求的异步队列</li>
<li>runningSyncCalls：正在请求的同步队列</li>
</ul>
<blockquote>
<p>maxRequest：默认64。这是okhttp允许的最大请求数量。<br>maxRequestsPerHost ：默认5。这是okhttp对同一主机允许的最大请求数量。</p>
</blockquote>
<p><strong>同步执行源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="comment">//此处除去一些其他代码</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//通知Dispatcher这个Call正在被执行,同时将此Call交给Dispatcher</span></span><br><span class="line">    <span class="comment">//Dispatcher可以对此Call进行管理</span></span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//请求的过程，注意这行代码是阻塞的，直到返回result！</span></span><br><span class="line">    Response result = getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//此时这个请求已经执行完毕了，通知Dispatcher，不要再维护这个Call了</span></span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>try 中的return执行完成后，执行finally语句，所以不论请求成功或者失败，都会关闭这个请求</p>
<p><strong>异步执行源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="comment">//判断是否已经执行过了</span></span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//捕获调用栈的信息，用来分析连接泄露</span></span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  <span class="comment">//封装一个AsyncCall交给Dispatcher调度</span></span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断正在执行的异步请求数没有达到阈值，并且每一个Host的请求数也没有达到阈值</span></span><br><span class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">    <span class="comment">//加入到正在执行队列，并立即执行</span></span><br><span class="line">    runningAsyncCalls.add(call);</span><br><span class="line">    executorService().execute(call);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//加入到等待队列</span></span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简述OKhttp的缓存机制"><a href="#简述OKhttp的缓存机制" class="headerlink" title="简述OKhttp的缓存机制"></a>简述OKhttp的缓存机制</h4><p>okhttp有具备网络缓存机制，短时间内重复请求会复用缓存的数据，这样节省流量，应用也会很流畅。但是okhttp本身默认是不打开缓存机制的，需要配置后才能启动。</p>
<p>okhttp的缓存机制是以DiskLruCache（最近最少使用算法（Least recently used））为基础的，仅支持文件存储。</p>
<p>MD5(url)作为key，value是存储的服务端响应数据</p>
<p>默认不开启缓存机制</p>
<p>文件存储</p>
<p>DiskLruCache写入是依赖于okio的，内部实现类似于LinkedHashMap，键值对获取。</p>
<p>使用DiskLruCache，仅支持get请求的缓存</p>
<ol>
<li>如果服务器支持缓存，即response携带Cache-control属性，则当你打开okhttp缓存即开始缓存，通过属性控制类型</li>
<li>如果服务器不支持缓存或者okhttp不想按照服务器缓存策略来存储，通过自定义拦截器重写response的头部即可</li>
<li>客户端不支持缓存，则可以不缓存，不理会服务器的cache-control属性</li>
</ol>
<p>可以直接使用CacheControl类，包含</p>
<ul>
<li><strong>CacheControl.FORCE_NETWORK</strong>，即强制使用网络请求</li>
<li><strong>CacheControl.FORCE_CACHE</strong>，即强制使用本地缓存，如果无可用缓存则返回一个code为504的响应</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</span><br><span class="line">no-cache：不做缓存。</span><br><span class="line">max-age：这个参数告诉浏览器将页面缓存多长时间，超过这个时间后才再次向服务器发起请求检查页面是否有更新。对于静态的页面，比如图片、CSS、Javascript，一般都不大变更，因此通常我们将存储这些内容的时间设置为较长的时间，这样浏览器是不会向服务器反复发起请求，也不会去检查是否更新了。</span><br></pre></td></tr></table></figure>
<p>添加自定义网络拦截器，在其中改变Response的响应头，添加Cache-control，后续回到CacheIntercepter中时，就会执行缓存策略。</p>
<p>CacheControl.Builder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- noCache();<span class="comment">//不使用缓存，用网络请求</span></span><br><span class="line">- noStore();<span class="comment">//不使用缓存，也不存储缓存</span></span><br><span class="line"></span><br><span class="line">- onlyIfCached();<span class="comment">//只使用缓存</span></span><br><span class="line">- noTransform();<span class="comment">//禁止转码</span></span><br><span class="line">- maxAge(<span class="number">10</span>, TimeUnit.MILLISECONDS);<span class="comment">//设置超时时间为10ms。</span></span><br><span class="line">- maxStale(<span class="number">10</span>, TimeUnit.SECONDS);<span class="comment">//超时之外的超时时间为10s</span></span><br><span class="line">- minFresh(<span class="number">10</span>, TimeUnit.SECONDS);<span class="comment">//超时时间为当前时间加上10秒钟。</span></span><br></pre></td></tr></table></figure>
<p>CacheStrategy：缓存策略类，通过响应头信息与服务器端信息进行对比，最后返回是否使用新的网络请求还是直接使用缓存。其中存储的是Request请求体和Response响应体的具体内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 如果不使用网络，则 networkRequest为 null */</span></span><br><span class="line"><span class="comment">//客户端请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Request networkRequest;</span><br><span class="line"><span class="comment">/** 如果不使用缓存，则 cacheResponse为 null */</span></span><br><span class="line"><span class="comment">//服务端返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Response cacheResponse;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据输出的networkRequest和cacheResponse的值是否为null给出不同的策略，如下：</p>
<table>
<thead>
<tr>
<th>networkRequest</th>
<th>cacheResponse</th>
<th>result 结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>null(不使用网络)</td>
<td>null（不使用缓存）</td>
<td>only-if-cached (表明不进行网络请求，且缓存不存在或者过期，一定会返回<strong>503</strong>错误)</td>
</tr>
<tr>
<td>null</td>
<td>non-null</td>
<td>不进行网络请求，直接返回缓存，不请求网络</td>
</tr>
<tr>
<td>non-null</td>
<td>null</td>
<td>需要进行网络请求，而且缓存不存在或者过去，直接访问网络</td>
</tr>
<tr>
<td>non-null</td>
<td>non-null</td>
<td>Header中包含ETag/Last-Modified标签，需要在满足条件下请求，还是需要访问网络（根据情况使用）</td>
</tr>
</tbody>
</table>
<p>如果网络不为null，则使用网络请求，如果网络为null，当缓存不为null，则使用缓存，当缓存为null时，返回503错误</p>
<h4 id="为什么只做get的缓存？"><a href="#为什么只做get的缓存？" class="headerlink" title="为什么只做get的缓存？"></a>为什么只做get的缓存？</h4><p>其他响应成本大，效率低</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>okhttp其中有一个dispatcher对最大连接数（并发），host最大访问量做了定义，维护了3个队列（同步正在执行，准备执行，异步正在执行）和一个线程池（0~max）</p>
<p>该线程池类似于CachedThreadPool，没有核心线程，全是非核心线程，超时时间是60s，即60s后回收该线程，其队列为空，没有容量，是一种特殊的队列，适用于执行短时的大量任务。</p>
<h4 id="okhttp的优势？"><a href="#okhttp的优势？" class="headerlink" title="okhttp的优势？"></a>okhttp的优势？</h4><p>最大特点是，intercepter拦截器，连接池复用，okio io处理，线程池处理（全是非核心线程），支持http1.0，1.1，2.0</p>
<p>okio内部封装链表数据存储，比较之前的数组存储，更加节省空间，还可以复用</p>
<h4 id="长连接（websocket）和久连接（keep-alive）的区别"><a href="#长连接（websocket）和久连接（keep-alive）的区别" class="headerlink" title="长连接（websocket）和久连接（keep-alive）的区别"></a>长连接（websocket）和久连接（keep-alive）的区别</h4><p>调用的是equeue异步方法，将长连接放入线程池中不会被释放掉</p>
<ol>
<li>1.1推出keep-alive机制，服务器不会主动发送请求，一个request返回一个response。</li>
<li>减少了握手的次数而已</li>
<li>久连接是同步串行处理的，当某一个请求因为网络，服务器等原因阻塞时，那么后面的请求都得不到处理</li>
<li>http头部太大，传输耗时</li>
<li>实时性得不到保证</li>
</ol>
<blockquote>
<p>http是单向的，websocket属于应用层协议，使用http1.1的101码进行握手状态判断</p>
</blockquote>
<p>websocket建立连接是使用https连接，三次握手，在通信过程中</p>
<ul>
<li>以ws开头</li>
<li>握手成功后，复用连接发送请求和接收</li>
<li>不需要发送header信息</li>
<li>服务端客户端平等，可以相互建立连接，http久连接是基于http的，符合http协议。</li>
</ul>
<p>最开始使用<strong>get</strong>请求进行握手，携带Upgrade: websocket ，告知服务器上升为websocket协议，成功后，使用web socket数据流（帧）进行通信，设置超时时间为永不超时，客户端设置循环，一直从服务端取消息。</p>
<p>使用http的get请求进行3次握手协议，使用http1.1版本的101状态码返回成功后，就不需要http交互了，后续采用web socket流进行通信，减少包体</p>
<blockquote>
<p>使用标准的HTTP协议无法实现WebSocket，只有支持那些协议的专门浏览器才能正常工作。</p>
</blockquote>
<h4 id="websocket的握手和http的握手有什么区别？"><a href="#websocket的握手和http的握手有什么区别？" class="headerlink" title="websocket的握手和http的握手有什么区别？"></a>websocket的握手和http的握手有什么区别？</h4><p>使用http的get请求进行握手，基本一致，额外传输了header的信息标记为websocket。</p>
<h4 id="MQTT理解"><a href="#MQTT理解" class="headerlink" title="MQTT理解"></a>MQTT理解</h4><p>发布订阅者模式，低带宽，低开销的即时通信协议，基于tcp/ip协议，成为IOT通讯标准</p>
<p>消息体如下：<strong>固定头部+可变头部+消息体</strong>，整个消息体比较轻便，便于交互及时</p>
<table>
<thead>
<tr>
<th>固定报头（fixed header）</th>
<th>可变报头（variable header）</th>
<th>荷载（payload）</th>
</tr>
</thead>
<tbody>
<tr>
<td>所有报文都包含，数据包类型及数据包的分组类标识</td>
<td>部分报文包含，数据包类型决定了可变头是否存在及其具体内容</td>
<td>部分报文包含，表示客户端收到的具体内容</td>
</tr>
</tbody>
</table>
<p>基于二进制实现，MQTT运行于http上，所以明文传输，如果位于https中，则可以使用TLS加密传输</p>
<p>发布者，订阅者模式：客户端是发布者和订阅者，服务端是代理服务器</p>
<h4 id="MQTT和websocket的区别？"><a href="#MQTT和websocket的区别？" class="headerlink" title="MQTT和websocket的区别？"></a>MQTT和websocket的区别？</h4><p>MQTT面向原生设备，基于二进制实现，提供一对多的通信方式，采用发布/订阅模式传输</p>
<p>websocket面向web设备，是全双工通信</p>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>基于Okhttp的RESTFUL Api请求工具，Retrofit可以让你简单到调用一个Java方法的方式去请求一个api，这样App中的代码就会很简洁方便阅读</p>
<p><img src="/imageMd/retrofit-1.png" alt="img"></p>
<p>Retrofit通过java接口及注解来描述网络请求，并用动态代理的方式生成网络请求的Request，通过调用相应的网络框架（默认Okhttp）去发起网络请求，并将返回的Response通过converterFactory转化成相应的model，最后通过CallAdapter转换成其他的数据方式（Rxjava Observable）</p>
<p>Retrofit.create()方法是Retrofit的核心，其中，使用Proxy.newProxyInstance()方法创建ServiceMethod，具体实现是在InvocationHandler类中的invoke方法，实现了动态代理的形式，而这个InvocationHandler对象就是代理对象，这个对象是在运行时动态生成的。</p>
<h4 id="Retrofit中的动态代理"><a href="#Retrofit中的动态代理" class="headerlink" title="Retrofit中的动态代理"></a>Retrofit中的动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            ...</span><br><span class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过动态代理生成InvocationHandler类，在内部，创建一个ServiceMethod，存储接口的请求信息，构建一个OKhttpCall对象，初始化网络请求</p>
<h4 id="Retrofit的优势"><a href="#Retrofit的优势" class="headerlink" title="Retrofit的优势"></a>Retrofit的优势</h4><p>Retrofit是对okhttp的二次封装，解决okhttp中接口请求、数据结果返回和接口调用的短板。</p>
<ol>
<li>规划了interface接口类，整合所有接口调用的详细内容，便于调用，降低耦合性。</li>
<li>配合RxJava，okhttp，职责明确。RxJava负责异步处理，Retrofit负责请求的数据和结果的展示，okhttp负责接口请求和返回的具体过程</li>
</ol>
<ul>
<li>Retrofit主要负责应用层面的封装，就是说主要面向开发者，方便使用，比如请求参数，响应数据的处理，错误处理等等。</li>
<li>OkHttp主要负责socket部分的优化，比如多路复用，buffer缓存，数据压缩等等。</li>
</ul>
<ol start="3">
<li>相对于okhttp来说，使用动态代理生成Request对象，不用每次调用自己实现</li>
<li>网络结果线程切换库（RxJava，普通），网络结果格式化库（Gson，xml）等可以做到随意替换和支持</li>
</ol>
<h4 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h4><p>静态代理：<br>由程序员创建或工具生成的代理类，在运行前就存在代理类的字节码文件，代理类和委托类的关系已经确定</p>
<p>动态代理：<br>在程序运行过程中，通过反射实现对代理类的动态创建，可以代理多个方法。（InvocationHandler、CGLib）</p>
<h2 id="Butterknife———view的注入"><a href="#Butterknife———view的注入" class="headerlink" title="Butterknife———view的注入"></a>Butterknife———view的注入</h2><h4 id="简述Butterknife"><a href="#简述Butterknife" class="headerlink" title="简述Butterknife"></a>简述Butterknife</h4><p>初始化控件会写大量的findViewById()，setOnClickListener()方法，很繁琐，该框架使用注解的方式实现辅助代码的生成，简化这些代码。</p>
<p>该框架是基于java注解机制实现的，也就是在<code>编译期间</code>就初始化好了一个viewBinding类（view和点击事件的处理），生成findViewById来绑定布局，不用开发者每次去初始化</p>
<h4 id="Butterknife为什么初始化控件不能用private和static"><a href="#Butterknife为什么初始化控件不能用private和static" class="headerlink" title="Butterknife为什么初始化控件不能用private和static"></a>Butterknife为什么初始化控件不能用private和static</h4><p>因为在编译期间构建view的绑定事件会报错，无法访问private变量，否则，要加入反射，导致性能问题</p>
<p>static可能会导致内存泄漏，而且外部可以访问。</p>
<h4 id="ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么"><a href="#ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么" class="headerlink" title="ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么"></a>ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么</h4><p>解析注解处理器， 对比Butterknife，Dagger2，DBFlow。</p>
<p>没有反射机制，使用自定义注解框架</p>
<h4 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h4><p>butterknife继承后，子类可以使用父类控件，但是<strong>必须在setContView之后</strong>进行绑定。如果在子view进行绑定控件，但是父类找不到子类的控件，因为生成的是子view_ViewBinding类，父类获取不到</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>每个Activity会生成一个类，增大包体积</li>
<li>butterknife可以称之为view的注入，对findviewById包装更加简单，功能单一</li>
</ul>
<h2 id="ViewBinding最终最好的解决方案"><a href="#ViewBinding最终最好的解决方案" class="headerlink" title="ViewBinding最终最好的解决方案"></a>ViewBinding最终最好的解决方案</h2><h4 id="简析ViewBinding"><a href="#简析ViewBinding" class="headerlink" title="简析ViewBinding"></a>简析ViewBinding</h4><p>在build.gradle中开启ViewBinding<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    viewBinding.enabled = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>android studio会将xml文件中所有文件在编译过程中生成<strong>xxxBinding</strong>类，这个类有三种初始化方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binding = LayoutSecondBinding.inflate(getLayoutInflater());</span><br></pre></td></tr></table></figure><br>在Activity或Fragment中调用inflate方法进行初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inflate(LayoutInflater inflater)</span><br><span class="line">inflate(LayoutInflater inflater,ViewGroup parent,<span class="keyword">boolean</span> attachToParent)</span><br><span class="line">bind(View rootView)</span><br></pre></td></tr></table></figure><br>最终三个方法都会走到bind方法中，在这个方法中，对View进行findViewById操作</p>
<h4 id="ViewBinding和Butterknife的区别"><a href="#ViewBinding和Butterknife的区别" class="headerlink" title="ViewBinding和Butterknife的区别"></a>ViewBinding和Butterknife的区别</h4><p>ViewBinding会处理空安全，类型安全，还可以兼容java和kotlin。最新版本Gradle中设置对R文件的修改，R文件中的id不再是final的，(Fragment中R文件不是final的时候，Butterknife使用生成R2文件的做法围魏救赵)这样就会影响注解的使用，butterknife就被迫下台<br>Viewbinding根正苗红，官方支持就是最大优势</p>
<h4 id="Viewbinding如何处理include布局？"><a href="#Viewbinding如何处理include布局？" class="headerlink" title="Viewbinding如何处理include布局？"></a>Viewbinding如何处理include布局？</h4><p>xml布局中存在include布局的，需要给include布局添加id，生成一个includexxxBinding文件，在xxxBinding类中做映射体现。</p>
<blockquote>
<p>内部view由final修饰，保证view不能被重新创建的view替换（引用不可修改），但是其内部的值可以修改</p>
</blockquote>
<h2 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h2><h4 id="简析"><a href="#简析" class="headerlink" title="简析"></a>简析</h4><p>元注解：修饰注解的注解，</p>
<ul>
<li>@Target：注解的作用目标（修饰方法，类还是字段）</li>
<li>@Retention：注解的生命周期<ul>
<li>SOURCE：仅存在java源文件中，经过编译器后就丢弃，适用于一些检查行的操作，比如@Override</li>
<li>CLASS：编译class文件时生效，适用于在编译时做一些预处理操作，比如Butterknife的@BindView，在编译时，通过注解器生成一些辅助代码，完成完整的功能</li>
<li>RUNTIME：保留在运行时VM中可以通过反射获取注解。适用于一些需要运行时动态获取注解信息，类似反射获取注解等，比如EventBus的@Subscribe</li>
</ul>
</li>
<li>@Documented：注解是否应当被包含在JavaDoc文档中</li>
<li>@Inherited：是否允许子类继承该注解</li>
<li>AnnotationInvocationHandler：专门处理注解的Handler</li>
</ul>
<p>代码的生命周期包含：编码(SOURCE)—-&gt;编译(CLASS)—-&gt;运行(RUNTIME)</p>
<blockquote>
<p>默认时注解在编译阶段，即CLASS阶段</p>
</blockquote>
<p>本质：一个继承了Annotation接口的接口</p>
<ul>
<li>运行时处理：使用反射获取当前的所需要的东西</li>
<li>编译时处理：APT技术，即编译期扫描java文件的注解，并传递到注解处理器，注解处理器可根据注解生成新的java文件</li>
</ul>
<blockquote>
<p>APT(Annotation Processing Tool)编译期解析注解</p>
</blockquote>
<h4 id="注解的种类"><a href="#注解的种类" class="headerlink" title="注解的种类"></a>注解的种类</h4><ul>
<li>JDK提供的注解（源码注解）</li>
<li>自定义注解</li>
<li>元注解</li>
</ul>
<h4 id="注解的用处"><a href="#注解的用处" class="headerlink" title="注解的用处"></a>注解的用处</h4><ol>
<li>降低项目的耦合</li>
<li>自动完成一些规律性代码</li>
<li>自动生成java代码，减少开发工作量</li>
</ol>
<h4 id="注解器"><a href="#注解器" class="headerlink" title="注解器"></a>注解器</h4><p>注解器通常是以Java代码（或者编译过的字节码）作为输入，生成.java文件作为输出</p>
<p>AbstractProcessor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源于javax.annotation.processing;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合中指定支持的注解类型的名称（这里必须时完整的包名+类名)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            SupportedAnnotationTypes sat = <span class="keyword">this</span>.getClass().getAnnotation(SupportedAnnotationTypes.class);</span><br><span class="line">            <span class="keyword">if</span>  (sat == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isInitialized())</span><br><span class="line">                    processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,</span><br><span class="line">                                                             <span class="string">&quot;No SupportedAnnotationTypes annotation &quot;</span> +</span><br><span class="line">                                                             <span class="string">&quot;found on &quot;</span> + <span class="keyword">this</span>.getClass().getName() +</span><br><span class="line">                                                             <span class="string">&quot;, returning an empty set.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> arrayToSet(sat.value());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 指定当前正在使用的Java版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SupportedSourceVersion ssv = <span class="keyword">this</span>.getClass().getAnnotation(SupportedSourceVersion.class);</span><br><span class="line">        SourceVersion sv = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ssv == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sv = SourceVersion.RELEASE_6;</span><br><span class="line">            <span class="keyword">if</span> (isInitialized())</span><br><span class="line">                processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,</span><br><span class="line">                                                         <span class="string">&quot;No SupportedSourceVersion annotation &quot;</span> +</span><br><span class="line">                                                         <span class="string">&quot;found on &quot;</span> + <span class="keyword">this</span>.getClass().getName() +</span><br><span class="line">                                                         <span class="string">&quot;, returning &quot;</span> + sv + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            sv = ssv.value();</span><br><span class="line">        <span class="keyword">return</span> sv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot call init more than once.&quot;</span>);</span><br><span class="line">        Objects.requireNonNull(processingEnv, <span class="string">&quot;Tool provided null ProcessingEnvironment&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.processingEnv = processingEnv;</span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这些注解是否由此 Processor 处理，该方法返回ture表示该注解已经被处理, 后续不会再有其他处理器处理; 返回false表示仍可被其他处理器处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    RoundEnvironment roundEnv)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>如果是单一属性，可以使用value字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> MyAnno1 &#123;</span><br><span class="line">    <span class="comment">//格式：类型名 属性名（）</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnno1(&quot;kang&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> MyAnno2 &#123;</span><br><span class="line">    <span class="comment">//格式：类型名 属性名（）</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnno2(name = &quot;kang&quot;)</span></span><br></pre></td></tr></table></figure>
<p>如果不是value字段的话，需要（指定属性 = 值）</p>
<blockquote>
<p>注解中只允许八种基本数据类型、字符串、类类型，注解类型，枚举类型及其一维数组</p>
</blockquote>
<h2 id="Glide和Picasso"><a href="#Glide和Picasso" class="headerlink" title="Glide和Picasso"></a>Glide和Picasso</h2><h4 id="简述LruCache和DiskLruCache"><a href="#简述LruCache和DiskLruCache" class="headerlink" title="简述LruCache和DiskLruCache"></a>简述LruCache和DiskLruCache</h4><p>内部都实现了LRU算法，即：优先淘汰那些最近最少使用的缓存对象</p>
<p>LruCache：</p>
<p>内部采用LinkedHashMap，是线程安全的（get、put、remove方法都是用synchronized），双向链表（保持LinkedList规定顺序+HashMap便于查找）<br>将最近使用的节点放置在链表尾部，当超过大小时，删除第一个头节点。</p>
<p>存储了前一个元素和后一个元素的引用，get方法后，就查出值删除，然后放置在头部，如果超过Lru算法的大小，直接遍历删除尾节点，直到大小在范围内</p>
<h4 id="简述Glide的缓存过程"><a href="#简述Glide的缓存过程" class="headerlink" title="简述Glide的缓存过程"></a>简述Glide的缓存过程</h4><p>默认打开缓存，内存缓存使用LruCache+弱引用实现，磁盘缓存使用DiskLruCache实现</p>
<p>使用内存缓存+磁盘缓存的策略，生成key时，图片只要发生变化，就算长宽发生变化也会导致缓存不同的key。Glide将内存缓存划分为两个区域：</p>
<ul>
<li>LruResourceCache：使用LruCache算法，LinkedHashMap（不在使用的）</li>
<li>activeResources：添加弱引用机制，HashMap（正在使用的图片）</li>
</ul>
<p>磁盘缓存之存在DiskLruCache，因为Glide可以压缩图片（尺寸压缩），所以磁盘缓存中可以设置缓存原始图片还是压缩后的图片，压缩图片可以有效避免大图和超大图带来的OOM，Glide没有使用google提供的DiskLruCache，而是使用自己开发的，不过原理都一样</p>
<p>在首次访问时，将正在使用的图片信息会存储在activeResources的弱引用中，当引用次数为0时（调用release方法），会将其放入LruResourceCache中，执行Lru算法，移除后会存入DiskLruCache中。</p>
<p>所以，先去activeResources中寻找，找到后，将引用对象索引+1（active.aquire();）（计算引用次数）。然后去LruResourceCache中寻找了，若找到了，在LruResourceCache中移除，并将其放入activeResources中。然后去DiskLruCache中寻找，若找到了，在DiskLruCache中删除，并将其放入activeResources中。</p>
<blockquote>
<p>Glide 缓存的是imageView的所需图片的大小，若大小不同，重新缓存</p>
<p>Picasse 缓存图片原图大小</p>
</blockquote>
<h4 id="Glide是如何绑定生命周期的？"><a href="#Glide是如何绑定生命周期的？" class="headerlink" title="Glide是如何绑定生命周期的？"></a>Glide是如何绑定生命周期的？</h4><ul>
<li>Application参数:如果传入的是Application对象,那么这里就会调用带有Context参数的get()方法重载，调用getApplicationManager()方法来获取一个RequestManager对象。其实这是最简单的一种情况，因为Application对象的生命周期即应用程序的生命周期，因此Glide并不需要做什么特殊的处理，它自动就是和应用程序的生命周期是同步的，如果应用程序关闭的话，Glide的加载也会同时终止。</li>
<li>非Application参数:不管传入的是Activity、FragmentActivity、v4包下的Fragment、还是app包下的Fragment，最终的流程都是一样的，那就是会向当前的Activity当中添加一个隐藏的Fragment。因为Glide需要知道加载的生命周期。很简单的一个道理，如果你在某个Activity上正在加载着一张图片，结果图片还没加载出来，Activity就被用户关掉了，那么图片还应该继续加载吗？当然不应该。可是Glide并没有办法知道Activity的生命周期，于是Glide就使用了添加隐藏Fragment的这种小技巧，因为Fragment的生命周期和Activity是同步的，如果Activity被销毁了，Fragment是可以监听到的，这样Glide就可以捕获这个事件并停止图片加载了。</li>
<li>如果我们是在<strong>非主线程</strong>当中使用的Glide，那么不管你是传入的Activity还是Fragment，都会被强制当成Application来处理。</li>
</ul>
<ol>
<li>RequestManagerFragment：实现一个无UI的fragment。</li>
<li>ActivityFragmentLifecycle：无UI的fragment通过它，去调用RequestManager</li>
<li>RequestManager：实现关键的几个方法，去调用glide 的操作</li>
<li>RequestManagerRetriever：作为一个桥梁，将RequestManagerFragment<br>和RequestManager给联系起来</li>
</ol>
<blockquote>
<p>空RequestManagerFragment 的生命周期调用 ActivityFragmentLifecycle，然后ActivityFragmentLifecycle 调用 RequestManager ，RequestManager 再去调用RequestTracker 的glide操作，最终实现gilde的操作，能够根据页面的生命周期做相应的处理。</p>
</blockquote>
<h4 id="Glide中Fragment中是怎么绑定生命周期的？"><a href="#Glide中Fragment中是怎么绑定生命周期的？" class="headerlink" title="Glide中Fragment中是怎么绑定生命周期的？"></a>Glide中Fragment中是怎么绑定生命周期的？</h4><h4 id="Glide中into指定view，再次刷新view会发生什么？"><a href="#Glide中into指定view，再次刷新view会发生什么？" class="headerlink" title="Glide中into指定view，再次刷新view会发生什么？"></a>Glide中into指定view，再次刷新view会发生什么？</h4><blockquote>
<p>Glide内部通过HttpUrlConnection进行通信，也可切换为okhttp/volley</p>
</blockquote>
<ol>
<li>根据ScaleType进行相应的设置</li>
<li>根据传入的类型对Glide加载进行配置，asBitmap，asGif，asDrawable</li>
<li>根据target（View）创建Request请求，根据生命周期管控Request的暂停和下载</li>
</ol>
<p><code>target</code>就是<code>view</code>，先判断<code>target</code>是之前已经绑定了请求，如果旧请求和新请求一样且处于请求完成或者正在请求状态就直接复用旧请求。如果不复用,就<code>RequestManager</code>先移除和旧请求绑定的<code>target</code>对象，<code>Target</code>再重新和<code>Request</code>对象进行一个绑定，调用<code>requestManager.track(target, request)</code>再加入请求队列，开启请求，最后返回经过处理的<code>traget</code>对象。</p>
<h4 id="Glide和Picasso对比"><a href="#Glide和Picasso对比" class="headerlink" title="Glide和Picasso对比"></a>Glide和Picasso对比</h4><ol>
<li>Glide较Picasso庞大的多</li>
<li>Glide绑定生命周期，onPause时暂停加载，onResume时再启动，Picasso只存在context</li>
<li>Glide会缓存imageView图片大小，尺寸不同，key不同，会缓存两份，Picasso是缓存完整大小，使用时会重新设置大小</li>
<li>Glide首次加载快于Picasso，而后每次加载慢于Picasso，因为Glide需要改变图片的大小再缓存到内存，时间会慢。picasso拿到缓存后需要对图片重新设置大小，耗时较长。</li>
<li>Glide支持gif</li>
<li>Glide加载的图片质量略差，因为bitmap的格式内存开销小，但是很难察觉</li>
<li>Glide可以配置图片显示的动画，而picasso只有默认的一种动画</li>
<li>Glide缓存方式更优，减少OOM的发生</li>
</ol>
<blockquote>
<p>Glide：RGB565<br>Picasso：ARGB8888</p>
</blockquote>
<h4 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h4><p>缓存机制：LruCache，DiskLruCache</p>
<p>内存缓存占用一个app的15%内存</p>
<p>网络请求使用的okhttp，内部缓存也使用okhttp，一般大小不超过50M</p>
<p>网络机制：network</p>
<h4 id="Fresco比较"><a href="#Fresco比较" class="headerlink" title="Fresco比较"></a>Fresco比较</h4><p>缓存机制：</p>
<ol>
<li><p><strong>BitmapMemoryCache</strong>缓存，已解码的内存缓存</p>
</li>
<li><p><strong>EncodedMemoryCache</strong>缓存，</p>
</li>
<li><h3 id="CountingLruMap，Lru算法清除缓存"><a href="#CountingLruMap，Lru算法清除缓存" class="headerlink" title="CountingLruMap，Lru算法清除缓存"></a>CountingLruMap，Lru算法清除缓存</h3></li>
</ol>
<p>分层处理，producer层层处理，每层处理结果通过Consumer向上传递，Producer-consumer链</p>
<ol>
<li>从已编码缓存中获取bitmap缓存</li>
<li>从未编码缓存中获取EncodedImage类型</li>
<li>从磁盘中获取</li>
<li>从网络中获取</li>
</ol>
<p>DraweeView：</p>
<p>动图播放，多级图层，渐进显示，画面剪裁</p>
<p><img src="/imageMd/fresco-1.png" width="70%"/></p>
<ol>
<li>解码器优化，避免频繁解码导致内存抖动，使用pool内存池复用</li>
</ol>
<p>适合各个android版本的解码器</p>
<p>优点：</p>
<ol>
<li>内存管理，LRU算法，缓存和磁盘管理</li>
<li>加载大图和高清图时可以先加载低清晰度图和缩略图</li>
<li>加载gif</li>
<li>图片渐进式处理：，渐进式图片格式先呈现大致的图片轮廓，然后随着图片下载的继续，呈现逐渐清晰的图片</li>
</ol>
<h4 id="包体积"><a href="#包体积" class="headerlink" title="包体积"></a>包体积</h4><p>Fresco&gt;Glide&gt;Picasso</p>
<h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p>检测内存泄漏</p>
<h4 id="ActivityLifecycleCallbacks-与-FragmentLifeCycleCallbacks"><a href="#ActivityLifecycleCallbacks-与-FragmentLifeCycleCallbacks" class="headerlink" title="ActivityLifecycleCallbacks 与 FragmentLifeCycleCallbacks"></a>ActivityLifecycleCallbacks 与 FragmentLifeCycleCallbacks</h4><p>通过application.registerActivityLifecyleCallbacks获取Activity的生命周期</p>
<p>通过fragmentManager.registerFragmentLifecyleCallbacks获取Fragment的生命周期</p>
<p>注册接口，拿到Activity和Fragment的各种生命周期回调信息</p>
<h4 id="如何做到内存泄漏检测"><a href="#如何做到内存泄漏检测" class="headerlink" title="如何做到内存泄漏检测"></a>如何做到内存泄漏检测</h4><p>Activity在onDestory后会将Activity生成一个唯一的key后存储在弱引用队列中，在主线程空闲时（IdleHandler）触发gc机制，垃圾回收，整理弱引用队列，查看弱引用队列中没有被回收的对象，即是内存泄漏的对象，打印出栈堆信息以供分析dump</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>只能监听Activity和Fragment的内存泄漏检测，无法检测Service</p>
<h4 id="其他内存泄漏检测工具"><a href="#其他内存泄漏检测工具" class="headerlink" title="其他内存泄漏检测工具"></a>其他内存泄漏检测工具</h4><p>Profiler：android studio自带，可以查看内存的整体过程，分析是否发生内存泄漏</p>
<h2 id="ASM函数插桩"><a href="#ASM函数插桩" class="headerlink" title="ASM函数插桩"></a>ASM函数插桩</h2><h4 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h4><p>简析为字节码插桩，可以直接修改已经存在的class文件或者生成class文件，相比较于AspectJ，ASM更加偏向于底层，他是直接操作字节码的，在设计中更小，更快</p>
<blockquote>
<p>class文件本质是16进制数据</p>
</blockquote>
<p>ClassVisitor</p>
<p>MethodVistor</p>
<h1 id="Android基础篇"><a href="#Android基础篇" class="headerlink" title="Android基础篇"></a>Android基础篇</h1><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><h4 id="简述Application"><a href="#简述Application" class="headerlink" title="简述Application"></a>简述Application</h4><p>作用：做初始化工作，提供上下文。继承自ContextWarpper，获取的是ContextWrapper中的context对象</p>
<ul>
<li>一个应用中有且只有一个</li>
<li>其生命周期和应用程序一样长</li>
<li>Application的onCreate方法才是整个应用程序的入口</li>
<li>只会实例化一次，所以天生就是一个单例</li>
</ul>
<p>生命周期：</p>
<ul>
<li>onCreate：创建时执行</li>
<li>onTerminate：终止时执行</li>
<li>onLowMemory：低内存时执行</li>
</ul>
<h4 id="Application的初始化流程"><a href="#Application的初始化流程" class="headerlink" title="Application的初始化流程"></a>Application的初始化流程</h4><p>通过AMS协调，ActivityThread优先建立后，会新建一个ApplicationThread，用作和AMS通过Binder通信，之后AMS通知ActivityThread去bindApplication，将消息返送到messageQueue，进行初始化Application的任务，然后调用<code>attachBaseContext</code>将Context绑定到Application，最后调用Application.onCreate()方法进行后续Activity的初始化</p>
<blockquote>
<p>AMS 来通知 zygote 进程来 fork 一个新进程，来开启我们的目标 App 的</p>
</blockquote>
<h4 id="ActivityLifecycleCallbacks理解"><a href="#ActivityLifecycleCallbacks理解" class="headerlink" title="ActivityLifecycleCallbacks理解"></a>ActivityLifecycleCallbacks理解</h4><p>ActivityLifecycleCallback是Application中的一个接口，可以监听应用中所有Activity的生命周期，可以通过该方法完成一些特殊的需求，比如监测当前App显示的Activity是那个？App是否存在前台</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> ActivityLifecycleCallbacks activityLifecycleCallbacks = <span class="keyword">new</span> ActivityLifecycleCallbacks() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Bundle outState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册Callback</span></span><br><span class="line">        registerActivityLifecycleCallbacks(callbacks);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h4 id="简述生命周期"><a href="#简述生命周期" class="headerlink" title="简述生命周期"></a>简述生命周期</h4><p><img src="https://developer.android.google.cn/guide/components/images/activity_lifecycle.png?hl=zh-cn" alt="img"></p>
<h5 id="Activity："><a href="#Activity：" class="headerlink" title="Activity："></a>Activity：</h5><ul>
<li>onCreate()   正在被创建</li>
<li>onRestart()    不可见到可见</li>
<li>onStart()    Activity正在启动，已经可见了</li>
<li>onResume()   Acitivty已经可见，并在前台显示</li>
<li>onPause()    Acitivty正在停止，之后会不可见</li>
<li>onStop()    Activity即将停止</li>
<li>onDestory()    Activity被销毁</li>
</ul>
<blockquote>
<p>onStart和onResume都为可见，onStart不在前台显示，onResume在前台显示</p>
<p>onPause后已经不可见，会进入onResume或者另一个onResume，所以不能做耗时操作，会影响界面显示</p>
<p>onPause和onStop中不能太耗时</p>
<p>如果新的Activity采用了透明主题，那么当前Activity不会回调onStop</p>
<p>onStart和onStop对应Activity是否可见</p>
<p>onResume和onPause对应Activity是否在前台显示</p>
</blockquote>
<p>异常情况下会执行onSaveInstance方法进行数据保存</p>
<h4 id="简述启动模式"><a href="#简述启动模式" class="headerlink" title="简述启动模式"></a>简述启动模式</h4><ul>
<li>standard：标准模式，来一个添加一个</li>
<li>singleTop：栈顶复用，如果在栈顶，就复用这个Activity，<code>onNewIntent</code>会被执行，替代onCreate()</li>
<li>singleTask：栈内复用，如果在栈内，就复用这个Activity，该Activity之上的全部出栈，onNewIntent会被执行</li>
<li>singleInstance：单实例模式。加强版singleTask，会为自己新建一个栈，在该栈中栈内复用</li>
</ul>
<h4 id="LauncherMode和startActivityForResult"><a href="#LauncherMode和startActivityForResult" class="headerlink" title="LauncherMode和startActivityForResult"></a>LauncherMode和startActivityForResult</h4><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180103/a3b5ebe0294548348fe4d18bf3fcb0e0.jpeg" width="70%"/></p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180103/f5357e8487474ae2b5e17f08725778c2.jpeg" width="70%"/></p>
<p>在5.0之前，当启动一个Activity时，系统将首先检查Activity的launchMode，如果为A页面设置为SingleInstance或者B页面设置为singleTask或者singleInstance,则会在LaunchFlags中加入FLAG_ACTIVITY_NEW_TASK标志，而如果含有FLAG_ACTIVITY_NEW_TASK标志的话，onActivityResult将会立即接收到一个cancle的信息，而5.0之后这个方法做了修改，修改之后即便启动的页面设置launchMode为singleTask或singleInstance，onActivityResult依旧可以正常工作，也就是说无论设置哪种启动方式，StartActivityForResult和onActivityResult()这一组合都是有效的</p>
<h4 id="什么时候会启动一个新的Activity栈？"><a href="#什么时候会启动一个新的Activity栈？" class="headerlink" title="什么时候会启动一个新的Activity栈？"></a>什么时候会启动一个新的Activity栈？</h4><ul>
<li>allowTaskReparenting：</li>
</ul>
<ol>
<li>singleInstance单独使用，会新建一个栈</li>
<li>singleTask配合taskAffinity使用</li>
<li>taskAffinity配合Intent.FLAG_ACTIVITY_NEW_TASK修饰Activity（AMS先处理LauncherMode，在处理FLAG_ACTIVITY_NEW_TASK）</li>
<li>taskAffinity配合allowTaskReparenting属性，使Activity从启动栈移动到正在使用的栈中并显示出来</li>
</ol>
<h4 id="如何控制Activity的动画切换"><a href="#如何控制Activity的动画切换" class="headerlink" title="如何控制Activity的动画切换"></a>如何控制Activity的动画切换</h4><ol>
<li>通过overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_left)方法控制<br>再startActivity方法后或者finish方法之后调用即可生效</li>
<li>使用style定义切换动画</li>
</ol>
<h4 id="如何控制Fragment的动画切换"><a href="#如何控制Fragment的动画切换" class="headerlink" title="如何控制Fragment的动画切换"></a>如何控制Fragment的动画切换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FragmentTransaction fragmentTransaction = mFragmentManager</span><br><span class="line">                .beginTransaction();</span><br><span class="line"></span><br><span class="line">fragmentTransaction.setCustomAnimations(</span><br><span class="line">                R.anim.in_from_right,</span><br><span class="line">                R.anim.out_to_left);</span><br></pre></td></tr></table></figure>
<p>使用FragmentTransaction开启Fragment动画，设置自定义动画切换，进入动画和推出动画</p>
<h4 id="ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？"><a href="#ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？" class="headerlink" title="ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？"></a>ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？</h4><p>ActivityA跳转到ActivityB：onPauseA()—–&gt;onCreateB()—–&gt;onStartB()—–&gt;onResumeB()—–&gt;onStopA()</p>
<p>ActivityB按back键返回ActivityA：</p>
<p>onPauseB()—–&gt;onRestartA()—–&gt;onStartA()—–&gt;onResumeA()—–&gt;onStopB()—–&gt;onDestoryB()</p>
<h4 id="如果ActivityB是窗口Activity呢？"><a href="#如果ActivityB是窗口Activity呢？" class="headerlink" title="如果ActivityB是窗口Activity呢？"></a>如果ActivityB是窗口Activity呢？</h4><p>ActivityA跳转到ActivityB：onPauseA()—–&gt;onCreateB()—–&gt;onStartB()—–&gt;onResumeB()</p>
<p>ActivityB按back键返回ActivityA：onPauseB()—–&gt;onResumeA()—–&gt;onStopB()—–&gt;onDestoryB()</p>
<h4 id="Activity的生命周期会受Dialog影响吗？"><a href="#Activity的生命周期会受Dialog影响吗？" class="headerlink" title="Activity的生命周期会受Dialog影响吗？"></a>Activity的生命周期会受Dialog影响吗？</h4><p>不会，Activity生命周期不会随Dialog的显示而变化</p>
<p>Activity的生命周期受AMS调用，而dialog不是Activity，所以不受AMS控制，所以不会触发Activity的生命周期</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h4 id="Service有几种创建方式？有什么区别？"><a href="#Service有几种创建方式？有什么区别？" class="headerlink" title="Service有几种创建方式？有什么区别？"></a>Service有几种创建方式？有什么区别？</h4><ol>
<li>startService()，在不需要的时候stopService()</li>
<li>bindService()，与生命周期相绑定，在销毁的时候进行回收unbind()</li>
</ol>
<p><img src="/imageMd/service-1.png" alt="生命周期"></p>
<h4 id="如何理解IntentService？生命周期是什么？HandlerThread-是什么？"><a href="#如何理解IntentService？生命周期是什么？HandlerThread-是什么？" class="headerlink" title="如何理解IntentService？生命周期是什么？HandlerThread 是什么？"></a>如何理解IntentService？生命周期是什么？HandlerThread 是什么？</h4><p>intentService继承自Service，持有Service的功能，同时，他是一个处理异步操作的类，当异步执行结束后会自动关闭intentService，多次执行startService()，只是执行onStartCommand方法，将消息加入到消息队列中。</p>
<p>其本质就是启动了一个类似于主线程Handler的机制去维护异步操作。</p>
<p>生命周期：onStartCommand()中执行onStart()方法，在onstart()方法中添加handler.sendMessage()方法</p>
<p>HandlerThread：就是将Handler+looper进行封装，允许直接在子线程中使用handler的一套逻辑。</p>
<blockquote>
<p>IntentService更像是一个后台线程，但是他又是一个服务，不容易被回收，这是他的优点</p>
</blockquote>
<h4 id="JobIntentService"><a href="#JobIntentService" class="headerlink" title="JobIntentService"></a>JobIntentService</h4><p>是IntentService的子类，在android 8.0（26）以上，IntentService的所有后台执行任务都会受到限制约束，所以要使用JobIntentService。</p>
<blockquote>
<p>service不能使用后台服务，需要使用ContextCompat.startForegroundService启动前台服务，这样就会启动一个notification，对用户来说体验不是很好，所以就要使用<br>JobIntentService启动一个后台服务</p>
</blockquote>
<p>在使用JobIntentService的时候不需要startService，stopService，在需要的时候调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DownLoadJobIntentService.enqueueWork(MainActivity.<span class="keyword">this</span>,DownLoadJobIntentService.class,jobId(<span class="number">8</span>),intent);</span><br></pre></td></tr></table></figure><br>而后会执行onHandleWork方法中的逻辑，执行完毕后自动销毁</p>
<h4 id="onStartCommand中三个回调分别是什么？"><a href="#onStartCommand中三个回调分别是什么？" class="headerlink" title="onStartCommand中三个回调分别是什么？"></a>onStartCommand中三个回调分别是什么？</h4><ul>
<li>START_NOT_STICKY：Service被回收后不做处理</li>
<li>START_STICKY：Service在被回收后，重新创建Service，但是<code>不保存</code>intent</li>
<li>START_REDELIVER_INTENT：Service在被回收后，重新创建Service，<code>保存</code>intent</li>
<li>START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但不保证服务被kill后一定能重启。</li>
</ul>
<h4 id="Service保活"><a href="#Service保活" class="headerlink" title="Service保活"></a>Service保活</h4><ol>
<li>设置成前台服务，绑定Notification， startForeground(1, getNotification());</li>
<li>单独设置为服务进程</li>
<li>onStartCommand返回START_STICKY，START_REDELIVER_INTENT，保证服务被干掉后重启</li>
<li>在onDestory发送一个广播，广播接收器接收广播后拉起服务</li>
<li>添加系统广播拉起</li>
<li>提升服务的优先级</li>
</ol>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="http://img-blog.csdnimg.cn/20190717110219153.png" width="400" height="700"/></p>
<h4 id="FragmentPagerAdapter和FragmentStatePagerAdapter的区别？"><a href="#FragmentPagerAdapter和FragmentStatePagerAdapter的区别？" class="headerlink" title="FragmentPagerAdapter和FragmentStatePagerAdapter的区别？"></a>FragmentPagerAdapter和FragmentStatePagerAdapter的区别？</h4><p>FragmentPagerAdapter：切换页面只是将Fragment分离，适合Fragment较少的情况不影响内存</p>
<p>FragmentStatePagerAdapter：切换页面将Fragment回收，适合Fragment较多的情况，这样不会消耗太多内存资源</p>
<h4 id="Fragment的3种切换方式"><a href="#Fragment的3种切换方式" class="headerlink" title="Fragment的3种切换方式"></a>Fragment的3种切换方式</h4><ol>
<li>add方法：只是重新回到fragment</li>
<li>replace方法：每次都会重新构建fragment</li>
</ol>
<h4 id="为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？"><a href="#为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？" class="headerlink" title="为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？"></a>为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？</h4><p>Fragment在异常崩溃后重建时，默认会调用Fragment无参构造，这样会导致Fragment中的有参构造的值不会被执行，这样数据就会异常</p>
<p>Fragment中调用setArguments来传递参数，在Activity构造Fragment时会通过反射午餐构造实例化一个新的Fragment，并且给mArguments初始化为原先的值</p>
<h4 id="Fragment的重建在那个生命周期中？"><a href="#Fragment的重建在那个生命周期中？" class="headerlink" title="Fragment的重建在那个生命周期中？"></a>Fragment的重建在那个生命周期中？</h4><p>在FragmentActivity的onSaveInstanceState中做存储，将Framgent通过序列化Parcelable进行存储，在Activity的onCreate中进行恢复</p>
<p>当配置发生变化时，Activity进入销毁过程，FragmentManager先销毁队列中Fragment的视图，然后检查每个Fragment的retainInstance属性。如果retainInstance为false，FragmentManager会销毁该Fragment实例；如果retainInstance为true，则不会销毁该Fragment实例，Activity重建后，新的FragmentManager会找到保留的Fragment并为其创建视图。</p>
<h2 id="BroadCastReceiver"><a href="#BroadCastReceiver" class="headerlink" title="BroadCastReceiver"></a>BroadCastReceiver</h2><h4 id="简述广播的启动方式和区别"><a href="#简述广播的启动方式和区别" class="headerlink" title="简述广播的启动方式和区别"></a>简述广播的启动方式和区别</h4><ul>
<li>静态注册：在AndroidManifest中注册，常驻型广播</li>
<li>动态注册：使用intentFilter过滤广播，registerReceiver注册广播，跟随生命周期</li>
</ul>
<blockquote>
<p>Android8.0以上部分广播不允许静态注册</p>
</blockquote>
<h4 id="无序广播和有序广播的区别"><a href="#无序广播和有序广播的区别" class="headerlink" title="无序广播和有序广播的区别"></a>无序广播和有序广播的区别</h4><ul>
<li>无序广播：所有广播接收器都可以获得，不可以拦截，不可以修改</li>
<li>有序广播：按照优先级向下传递，可拦截广播，修改广播</li>
</ul>
<h4 id="本地广播和全局广播"><a href="#本地广播和全局广播" class="headerlink" title="本地广播和全局广播"></a>本地广播和全局广播</h4><p>本地广播接收器只接收本地广播，减少应用外广播干扰，高效<br>androidx中1.1.0-alpha01中弃用本地广播，官方推荐该用LiveData或响应式流</p>
<h2 id="IPC机制"><a href="#IPC机制" class="headerlink" title="IPC机制"></a>IPC机制</h2><h4 id="简述android中的IPC机制"><a href="#简述android中的IPC机制" class="headerlink" title="简述android中的IPC机制"></a>简述android中的IPC机制</h4><p>进程间通信</p>
<p>架构：Client/Server架构，Binder机制，之间通过代理接口通信</p>
<p>client，server，serverManager</p>
<p>AndroidManifest中指定Android:process属性</p>
<ul>
<li>包名:remote为应用私有进程，其他应用不可访问</li>
<li>包名.remote为全局进程，其他应好通过ShareUID可以和他跑在同一个进程</li>
</ul>
<p>多进程带来的问题：四大组件共享数据失败，每个进程会单独开辟内存空间存储信息</p>
<ol>
<li>静态成员和单例模式完全失效</li>
<li>线程同步机制完全失效</li>
<li>SharedPreferences可靠性下降，不支持多进程</li>
<li>Application会多次创建</li>
</ol>
<h4 id="Serializable和parcelable区别"><a href="#Serializable和parcelable区别" class="headerlink" title="Serializable和parcelable区别"></a>Serializable和parcelable区别</h4><p>serializable:java自带，反射后产生大量临时变量，容易引起gc，主要用于持久化存储和网络传输的序列化</p>
<p>parcelable:android专用，性能强，将完整对象分解为部分对象，每一部分进行intent传输，可用于ipc，内部实现Bundle，主要用于内存的序列化</p>
<h4 id="Android为什么引入Parcelable？"><a href="#Android为什么引入Parcelable？" class="headerlink" title="Android为什么引入Parcelable？"></a>Android为什么引入Parcelable？</h4><ol>
<li>serializable通过反射，性能不好，</li>
<li>serializable反射产生大量临时变量，容易gc，导致内存抖动</li>
<li>serializable使用了大量的IO操作，也影响了耗时</li>
</ol>
<p>parcelable使用复杂，但高效，适用于内存序列化</p>
<h4 id="Parcelable一定比Serializable快吗？"><a href="#Parcelable一定比Serializable快吗？" class="headerlink" title="Parcelable一定比Serializable快吗？"></a>Parcelable一定比Serializable快吗？</h4><p>单论内存中的传输速度，Parcelable一定快于Serializable，但是Parcelable没有缓存的概念<br>Serializable存在缓存，会将解析过的内容放置在HandleTable，下次解析到同一类型的对象时就可以直接复用</p>
<h4 id="为什么java使用Serializable序列化对象，而不是json或者xml？"><a href="#为什么java使用Serializable序列化对象，而不是json或者xml？" class="headerlink" title="为什么java使用Serializable序列化对象，而不是json或者xml？"></a>为什么java使用Serializable序列化对象，而不是json或者xml？</h4><p>因为历史遗留问题，在json和xml出来之前，java已经设计了Serializable，对于Java的庞大体系，并不容易修改这个问题。java官方文档也推荐使用json库，因为他简单、易读、高效</p>
<h4 id="简析Binder机制"><a href="#简析Binder机制" class="headerlink" title="简析Binder机制"></a>简析Binder机制</h4><blockquote>
<p>在Android通信中并不是所有的进程通信都使用Binder，当fork()进程时，使用的是Socket()通信，因为fork不允许多线程，Binder是多线程模式，所以不被允许</p>
</blockquote>
<h4 id="进程空间划分"><a href="#进程空间划分" class="headerlink" title="进程空间划分"></a>进程空间划分</h4><p>一个进程空间分为<strong>用户空间</strong>和<strong>内核空间</strong></p>
<p>用户空间：数据独享，其他进程无法访问</p>
<p>内核空间：数据共享，其他进程可以访问</p>
<blockquote>
<p>所有的进程共用1个内核空间</p>
</blockquote>
<h4 id="如何看待ServiceManager？"><a href="#如何看待ServiceManager？" class="headerlink" title="如何看待ServiceManager？"></a>如何看待ServiceManager？</h4><p>ServiceManager管理系统中所有的服务，服务需要使用时都要在ServiceManager中进行注册，他的存在类似于DNS，提供client访问某一个服务的查询。</p>
<h4 id="Binder原理"><a href="#Binder原理" class="headerlink" title="Binder原理"></a>Binder原理</h4><p>binder驱动属于进程中的内核空间，即共享空间，在client发起请求时，需要将数据从用户空间拷贝到内核空间，binder通过传输内核空间中数据存储的引用映射给服务端，供服务端调用，服务端处理后，将返回值放在内核空间，通过binder传递引用映射给客户端进行处理</p>
<p><img src="/imageMd/binder-1.webp" alt="img"></p>
<h5 id="简述通信流程"><a href="#简述通信流程" class="headerlink" title="简述通信流程"></a>简述通信流程</h5><p>总体通信流程就是：</p>
<ul>
<li>客户端通过代理对象向服务器发送请求。</li>
<li>代理对象通过Binder驱动发送到服务器进程</li>
<li>服务器进程处理请求，并通过Binder驱动返回处理结果给代理对象</li>
<li>代理对象将结果返回给客户端。</li>
</ul>
<h5 id="详细的通信过程"><a href="#详细的通信过程" class="headerlink" title="详细的通信过程"></a>详细的通信过程</h5><ul>
<li>服务端跨进程的类都要继承Binder类，所以也就是服务端对应的Binder实体。这个类并不是实际真实的远程Binder对象，而是一个Binder引用(即服务端的类引用)，会在Binder驱动里还要做一次映射。</li>
<li>客户端要调用远程对象函数时，只需把数据写入到Parcel，在调用所持有的Binder引用的transact()函数</li>
<li>transact函数执行过程中会把参数、标识符（标记远程对象及其函数）等数据放入到Client的共享内存，Binder驱动从Client的共享内存中读取数据，根据这些数据找到对应的远程进程的共享内存。</li>
<li>然后把数据拷贝到远程进程的共享内存中，并通知远程进程执行onTransact()函数，这个函数也是属于Binder类。</li>
<li>远程进程Binder对象执行完成后，将得到的写入自己的共享内存中，Binder驱动再将远程进程的共享内存数据拷贝到客户端的共享内存，并唤醒客户端线程。</li>
</ul>
<p>通过Binder将客户端，服务端的共享内存中的数据进行读写，放入对方的共享内存中，并通知。</p>
<h5 id="Binder在Android中的应用？"><a href="#Binder在Android中的应用？" class="headerlink" title="Binder在Android中的应用？"></a>Binder在Android中的应用？</h5><ul>
<li><strong>系统服务及四大组件的启动调用工作</strong>：系统服务是通过getSystemService获取的服务，内部也就是通过ServiceManager。例如四大组件的启动调度等工作，就是通过Binder机制传递给ActivityManagerService，再反馈给Zygote。而我们自己平时应用中获取服务也是通过getSystemService(getApplication().WINDOW_SERVICE)代码获取。</li>
<li>AIDL（Android Interface definition language）。例如我们定义一个IServer.aidl文件，aidl工具会自动生成一个IServer.java的java接口类（包含Stub，Proxy等内部类）。</li>
<li>前台进程通过bindService绑定后台服务进程时，onServiceConnected(ComponentName name, IBinder service)传回IBinder对象，并且可以通过IServer.Stub.asInterface(service)获取IServer的内部类Proxy的对象，其实现了IServer接口。</li>
</ul>
<h4 id="为什么选择Binder机制？他的优势是什么？"><a href="#为什么选择Binder机制？他的优势是什么？" class="headerlink" title="为什么选择Binder机制？他的优势是什么？"></a>为什么选择Binder机制？他的优势是什么？</h4><ol>
<li>性能高，效率高：<br>传统的IPC（socket，管道，消息队列）需要拷贝两次内存，Binder只需要拷贝一次内存、共享内存不需要拷贝数据，只需要传递引用</li>
<li>安全性好：<br>C/S通信添加UID/PID，方便验证，安全机制完善。</li>
<li>利用C/S架构，通过多线程控制一个服务端多个客户端的情况</li>
</ol>
<h4 id="Android中IPC的几种方式详细分析与优缺点分析"><a href="#Android中IPC的几种方式详细分析与优缺点分析" class="headerlink" title="Android中IPC的几种方式详细分析与优缺点分析"></a>Android中IPC的几种方式详细分析与优缺点分析</h4><ol>
<li>Bundle</li>
<li>文件共享</li>
<li>Messenger：内部实现AIDL机制，c/s架构，通过handler接收message对象</li>
<li>AIDL</li>
<li>ContentProvider</li>
<li>Binder连接池</li>
</ol>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/43bb31d8a742">Android Handler机制之总目录</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/songzi1228/article/details/82835982">Android面试题：Handler</a></p>
<blockquote>
<p>其实并不是每一次添加消息时，都会唤醒线程。当该消息插入到队列头时，会唤醒该线程；如果有延迟消息，插入到头部，也会唤醒线程后在休眠</p>
</blockquote>
<h4 id="一句话概括Handler，并简述其原理"><a href="#一句话概括Handler，并简述其原理" class="headerlink" title="一句话概括Handler，并简述其原理"></a>一句话概括Handler，并简述其原理</h4><p>android中用于主线程和子线程之间通信的工具</p>
<p>主要包含Handler,Looper,MessageQueue,ThreadLocal.</p>
<p><strong>Handler</strong>：封装了消息的发送和接收looper分发过来的Message</p>
<p><strong>Looper</strong>：协调Handler和MessageQueue之间的桥梁，Looper的作用是循环从MessageQueue中取出message，并分发</p>
<p>给相应的Handler，Handler则存储在Message中的target中</p>
<p><strong>message</strong>：单节点，存储handler传输的数据</p>
<p><strong>MessageQueue</strong>：内部结构为单链表，由Looper创建，具体代码为Looper.prepare()；先进先出原则(队列)，根据                                Message.when进行插入队列（队列中是按时间执行顺序排序）</p>
<p><strong>ThreadLocal</strong>：负责存储和获取本线程的Looper</p>
<p>handler.sendMessage(message)将message发送到MessageQueue，MessageQueue执行enqueueMessage()方法入队，Looper执行looper.loop()方法从MessageQueue中取出message，执行message.target.dispatchMessage(message)方法将消息发送到Handler中，在handleMessage()方法中拿到回调</p>
<h4 id="Looper-loop-是在主线程的死循环，为什么没有造成线程阻塞？"><a href="#Looper-loop-是在主线程的死循环，为什么没有造成线程阻塞？" class="headerlink" title="Looper.loop()是在主线程的死循环，为什么没有造成线程阻塞？"></a>Looper.loop()是在主线程的死循环，为什么没有造成线程阻塞？</h4><p>真正的ANR是在生命周期的回调中等待的时间过长导致的，深层次的讲，就是Looper.loop()没有及时取出消息进行分发导致的。一旦没有消息，Linux的epoll机制则会通过管道写<strong>文件描述符</strong>的方式来对主线程进行唤醒与沉睡，Android里调用了linux层的代码实现在适当时会睡眠主线程。</p>
<p>MessageQueue包含jni调用，无消息时，通知epoll休眠，来消息时，线程启动</p>
<h4 id="looper-loop-中循环，判空退出怎么理解？"><a href="#looper-loop-中循环，判空退出怎么理解？" class="headerlink" title="looper.loop()中循环，判空退出怎么理解？"></a>looper.loop()中循环，判空退出怎么理解？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ....</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Message msg = queue.next(); <span class="comment">// might block（可能会阻塞）</span></span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>在queue.next中，会通过jni调用，通过Linux的epoll机制则会通过管道写文件描述符的方式来对主线程进行唤醒与沉睡，只有当应用程序退出时，才会执行if语句退出循环。</p>
<h4 id="为什么不能在子线程更新UI？"><a href="#为什么不能在子线程更新UI？" class="headerlink" title="为什么不能在子线程更新UI？"></a>为什么不能在子线程更新UI？</h4><p>因为如果要在子线程中更新UI，势必要考虑线程安全，加锁机制，这样很耗时，不加锁又很容易发生错误，这些错误是致命的，所以在设计时只允许UI线程更新UI，避免这些错误。</p>
<h4 id="真的不能在子线程更新UI吗？"><a href="#真的不能在子线程更新UI吗？" class="headerlink" title="真的不能在子线程更新UI吗？"></a>真的不能在子线程更新UI吗？</h4><p>ViewRootImpl中会进行通过checkThread()进行线程检测</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                    <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由此得出：viewRootImpl在那个线程被初始化，就会在那个线程更新UI，大部分情况下，ViewRootImpl都是在UI线程中初始化的，所以只能在UI线程更新UI，部分情况下可以在子线程更新UI（比如Dialog是在addView中初始化ViewRootImpl）</p>
<p>SurfaceView可以在子线程中更新</p>
<h4 id="ViewRootImpl是什么时候被创建的？"><a href="#ViewRootImpl是什么时候被创建的？" class="headerlink" title="ViewRootImpl是什么时候被创建的？"></a>ViewRootImpl是什么时候被创建的？</h4><p>在Acitivty中，ViewRootImpl是在<strong>onResume</strong>中创建的，所以在onCreate中进行子线程更新是可以绕过checkThread()检测的。</p>
<h4 id="一个Thread中可以有几个Looper-几个Handler"><a href="#一个Thread中可以有几个Looper-几个Handler" class="headerlink" title="一个Thread中可以有几个Looper?几个Handler"></a>一个Thread中可以有几个Looper?几个Handler</h4><p>一个Thread中只有一个Looper，可以存在无数个Handler，但是使用MessageQueue都是同一个，也就是一个Looper</p>
<h4 id="可以在子线程直接new一个Handler吗？那该怎么做？"><a href="#可以在子线程直接new一个Handler吗？那该怎么做？" class="headerlink" title="可以在子线程直接new一个Handler吗？那该怎么做？"></a>可以在子线程直接new一个Handler吗？那该怎么做？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thread= new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                //创建Looper，Looper再创建MessageQueue</span><br><span class="line">                Looper.prepare();</span><br><span class="line">                //新建Handler</span><br><span class="line">                handler=new Handler();</span><br><span class="line">                //循环取出消息并执行</span><br><span class="line">                Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br></pre></td></tr></table></figure>
<p>需要创建Looper，Looper会创建MessageQueue，循环从MessageQueue中取消息。</p>
<h4 id="Message可以如何创建？哪种效果更好，为什么？"><a href="#Message可以如何创建？哪种效果更好，为什么？" class="headerlink" title="Message可以如何创建？哪种效果更好，为什么？"></a>Message可以如何创建？哪种效果更好，为什么？</h4><p><strong>享元模式</strong></p>
<p>数据重复利用</p>
<ol>
<li>Message msg = new Message();</li>
<li>Message msg2 = Message.obtain();</li>
<li>Message msg1 = handler1.obtainMessage();</li>
</ol>
<p>2，3从整个Messge池中返回一个新的Message实例，通过obtainMessage能避免重复Message创建对象。</p>
<p>所以2，3都可以避免重复创建Message对象，所以建议用第二种或者第三种任何一个创建Message对象。</p>
<p>messge就是一个节点，存在就是一条链表，链表中存储的都是可以复用的message，在handleMessage和callback</p>
<p>方法执行完成后执行message.recycle()方法，进行信息重置后加入闲置链表头部中，每次调用obtain方法会从闲置链表中取出头节点，如果闲置链表为空，则新建message。</p>
<blockquote>
<p>Message缓存池大小为50</p>
</blockquote>
<h4 id="使用Hanlder的postDelay-后消息队列会发生什么变化？"><a href="#使用Hanlder的postDelay-后消息队列会发生什么变化？" class="headerlink" title="使用Hanlder的postDelay()后消息队列会发生什么变化？"></a>使用Hanlder的postDelay()后消息队列会发生什么变化？</h4><p>postDelay()内部调用sendMessageDelayed()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>时间：<strong>SystemClock.uptimeMillis() + delayMillis</strong></p>
<p>SystemClock.uptimeMills()是<strong>从开机到现在</strong>的时间，不使用currentMills，因为其是可变的，uptimeMills()期间不包括休眠的时间，是一个相对时间</p>
<ol>
<li>Handler.postDelayed(Runnable r, long delayMillis)</li>
<li>Handler.sendMessageDelayed(getPostMessage(r), delayMillis)</li>
<li>Handler.sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)</li>
<li>Handler.enqueueMessage(queue, msg, uptimeMillis)</li>
<li>MessageQueue.enqueueMessage(msg, uptimeMillis)</li>
</ol>
<blockquote>
<p>消息入队的时候会根据when判断时间，最终按照时间大小排序，时间短的在链表头，时间长的在链表尾部。</p>
</blockquote>
<p>案例如下：</p>
<ol>
<li><code>postDelay()</code>一个10秒钟的Runnable A、消息进队，MessageQueue调用<code>nativePollOnce()</code>阻塞，Looper阻塞；</li>
<li>紧接着<code>post()</code>一个Runnable B、消息进队，判断现在A时间还没到、正在阻塞，把B插入消息队列的头部（A的前面），然后调用<code>nativeWake()</code>方法唤醒线程；</li>
<li><code>MessageQueue.next()</code>方法被唤醒后，重新开始读取消息链表，第一个消息B无延时，直接返回给Looper；</li>
<li>Looper处理完这个消息再次调用<code>next()</code>方法，MessageQueue继续读取消息链表，第二个消息A还没到时间，计算一下剩余时间（假如还剩9秒）继续调用<code>nativePollOnce()</code>阻塞；</li>
<li>直到阻塞时间到或者下一次有Message进队；</li>
</ol>
<h4 id="同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？"><a href="#同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？" class="headerlink" title="同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？"></a>同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？</h4><p>同步消息：handler默认无参构造的形式是同步消息</p>
<p>异步消息：async传入true，则为异步消息</p>
<p>屏障消息：<code>msg.target == null</code>，使用postSyncBarrier()方法打开同步屏障，导致同步消息不执行，优先执行异步消息，规则同同步消息一样，当执行完毕后关闭同步屏障。</p>
<p>应用场景：在view的更新过程中，draw，requestLayout、invalidate中都用到这个方法，系统会优先处理这些异步消息，等处理结束后再处理同步消息。这样可以优先处理我们指定的系统消息。</p>
<blockquote>
<p>postSyncBarrier()该方法为私有方法，所以api不允许我们在开发中调用，我们只要知道原理就好了</p>
<p>调用该方法，会直接发送一个屏障消息进入messageQueue，则队列头部为屏障消息</p>
</blockquote>
<h4 id="ThreadLocal，谈谈你的理解"><a href="#ThreadLocal，谈谈你的理解" class="headerlink" title="ThreadLocal，谈谈你的理解"></a>ThreadLocal，谈谈你的理解</h4><p>跟HashMap功能类似，为什么不直接用HashMap呢？<br>原因：</p>
<ol>
<li>HashMap太大了，太臃肿了。ThreadLocal的key值只有Thread，value为looper，而HashMap的key值则可以<br>是string、int等数据类型，我们可以不用考虑这些数据类型;</li>
<li>线程隔离：我们的线程是系统中唯一的，用ThreadLocal来管理这些唯一的线程和其对应的value值会非常方便，</li>
<li>ThreadLocal参照了HashMap,简化了HashMap,便于我们使用。</li>
<li>HashMap线程不安全</li>
</ol>
<p><a href="#ThreadLocal的理解">ThreadLocal的理解</a></p>
<h4 id="为什么子线程中不能使用Handler，而UI线程可以？"><a href="#为什么子线程中不能使用Handler，而UI线程可以？" class="headerlink" title="为什么子线程中不能使用Handler，而UI线程可以？"></a>为什么子线程中不能使用Handler，而UI线程可以？</h4><p>UI线程就是ActivityThread，他在初始化的时候创建了Looper,MessageQueue，所以可以直接使用Handler，而新创建的子线程没有创建Looper，所以创建了就可以使用了</p>
<p>Handler的构造方法中使用Looper.myLooper()获取了looper，但是在子线程中并没有looper</p>
<h4 id="Handler如何引起内存泄露？怎么解决？"><a href="#Handler如何引起内存泄露？怎么解决？" class="headerlink" title="Handler如何引起内存泄露？怎么解决？"></a>Handler如何引起内存泄露？怎么解决？</h4><p>非静态内部类或匿名内部类默认持有外部类的引用，当外部类被回收时，因为内部类持有外部类的引用，导致外部类不能被回收，造成内存泄露。</p>
<ol>
<li>Activity销毁时及时清理消息队列；</li>
<li>自定义静态Handler类+弱引用。</li>
</ol>
<h4 id="MessageQueue-next-会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？"><a href="#MessageQueue-next-会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？" class="headerlink" title="MessageQueue.next()会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？"></a>MessageQueue.next()会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？</h4><p>首先非延时消息会入队，并且插入链表头，这时唤醒线程，进行循环取出message，非延时消息出队，到延迟消息后，如果事件未到，触发next的阻塞机制，如果时间到了，取出message，执行消息</p>
<h4 id="Handler延时机制保时吗？"><a href="#Handler延时机制保时吗？" class="headerlink" title="Handler延时机制保时吗？"></a>Handler延时机制保时吗？</h4><p><code>不保时</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">chatIflyHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       chatIflyHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               Log.e(<span class="string">&quot;handler&quot;</span>,<span class="string">&quot;执行延时1s操作&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>首先一个非延时消息入队，紧接着一个延时消息入队，执行第一个非延时消息，用时3s后执行延时消息，对比when，然后直接执行，测试总共耗时3420ms</p>
<h4 id="Handler的入队机制是线程安全的（synchronized）"><a href="#Handler的入队机制是线程安全的（synchronized）" class="headerlink" title="Handler的入队机制是线程安全的（synchronized）"></a>Handler的入队机制是线程安全的（synchronized）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">messageQueue.equeue()&#123;</span><br><span class="line">    synchronized(this)&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何精确计时？"><a href="#如何精确计时？" class="headerlink" title="如何精确计时？"></a>如何精确计时？</h4><ul>
<li><p>使用timer（子线程处理TimerThread）</p>
</li>
<li><p>误差补偿算法(TextClock控件方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mTicker = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            onTimeChanged();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">long</span> next = now + (<span class="number">1000</span> - now % <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            getHandler().postAtTime(mTicker, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>整秒数执行，当上次执行累积到1200，在下次执行时，通过next的计算后保证下次执行的时间不被累加到2200，而是同样在2000</p>
</li>
</ul>
<h4 id="IdleHandler是什么？用处是什么？"><a href="#IdleHandler是什么？用处是什么？" class="headerlink" title="IdleHandler是什么？用处是什么？"></a>IdleHandler是什么？用处是什么？</h4><p>messageQueue中有一个addIdleHandler()方法，添加IdleHandler接口</p>
<ul>
<li>添加时messageQueue不为空，则在线程休眠（没有消息，延时消息）时回掉方法</li>
<li>添加时messageQueue为空，则当时不会触发回掉，当线程被唤醒时才会执行</li>
</ul>
<blockquote>
<p>就是在启用IdleHandler的时候，如果线程处于休眠状态，要等到下次休眠状态才会生效。如果不是休眠状态，则下一次休眠立即生效。</p>
</blockquote>
<blockquote>
<p>启用IdleHandler后，主线程下次休眠时会通知<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">//do something</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>如果return <strong>true</strong>，则表示这个IdleHandler可多次使用<br>如果return <strong>false</strong>，则表示这个IdleHandler只能使用一次</p>
<h4 id="主线程的Looper何时退出？能否手动退出？"><a href="#主线程的Looper何时退出？能否手动退出？" class="headerlink" title="主线程的Looper何时退出？能否手动退出？"></a>主线程的Looper何时退出？能否手动退出？</h4><p>在app退出或者异常终止时，会退出Looper。在正常退出时，ActivityThread主线程中的mH（Handler）会接收到回调信息，调用quit()方法，强制退出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">    <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInitialApplication.onTerminate();</span><br><span class="line">    &#125;</span><br><span class="line">    Looper.myLooper().quit();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>Looper.quit():调用后直接终止Looper，不在处理任何Message，所有尝试把Message放进消息队列的操作都会失败，比如Handler.sendMessage()会返回 false，但是存在不安全性，因为有可能有Message还在消息队列中没来的及处理就终止Looper了。</p>
</li>
<li><p>Looper.quitSafely():调用后会在所有消息都处理后再终止Looper，所有尝试把Message放进消息队列的操作也都会失败。</p>
</li>
</ul>
<p>当尝试在主线程手动退出looper时，会报错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Main thread not allowed to quit.</span><br><span class="line">    at android.os.MessageQueue.quit(MessageQueue.java:<span class="number">428</span>)</span><br><span class="line">    at android.os.Looper.quit(Looper.java:<span class="number">354</span>)</span><br><span class="line">    at com.jackie.testdialog.Test2Activity.onCreate(Test2Activity.java:<span class="number">29</span>)</span><br><span class="line">    at android.app.Activity.performCreate(Activity.java:<span class="number">7802</span>)</span><br><span class="line">    at android.app.Activity.performCreate(Activity.java:<span class="number">7791</span>)</span><br><span class="line">    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:<span class="number">1299</span>)</span><br><span class="line">    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:<span class="number">3245</span>)</span><br><span class="line">    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:<span class="number">3409</span>) </span><br><span class="line">    at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:<span class="number">83</span>) </span><br><span class="line">    at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:<span class="number">135</span>) </span><br><span class="line">    at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:<span class="number">95</span>) </span><br><span class="line">    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:<span class="number">2016</span>) </span><br><span class="line">    at android.os.Handler.dispatchMessage(Handler.java:<span class="number">107</span>) </span><br><span class="line">    at android.os.Looper.loop(Looper.java:<span class="number">214</span>) </span><br><span class="line">    at android.app.ActivityThread.main(ActivityThread.java:<span class="number">7356</span>) </span><br><span class="line">    at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">    at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">492</span>) </span><br><span class="line">    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">930</span>) </span><br></pre></td></tr></table></figure></p>
<p>因为主线程退出意味着app的关闭，这种操作不和规范，需要使用正式的退出操作</p>
<h4 id="如何退出app"><a href="#如何退出app" class="headerlink" title="如何退出app"></a>如何退出app</h4><ol>
<li>记录Activity任务栈，全部finish</li>
<li>System.exit(0);//正常退出<br>System.exit(1);//非正常退出</li>
<li>android.os.Process.killProcess(android.os.Process.myPid()); 关闭进程，如果系统发现进程未正常关闭，会重新启动进程</li>
<li>在Intent中直接加入标识Intent.FLAG_ACTIVITY_CLEAR_TOP，这样开启B时，会清除该进程空间的所有Activity。</li>
<li><p>2.2版本之前使用ActivityManager关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager am = (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE);</span><br><span class="line">am.restartPackage(getPackageName());</span><br></pre></td></tr></table></figure>
<p>2.2版本以后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager am = (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE);</span><br><span class="line">am.killBackgroundProcesses(getPackageName());</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>该方法只是结束后台进程的方法，不能结束当前应用移除所有的 Activity。如果需要退出应用，需要添加System.exit(0)方法一起使用，并且只限栈内只有一个Activity，如果有多个Activity时，正如上面 方法 2 所说，就不起作用了。</p>
</li>
<li><p>将MainActivity设置为singleTask，返回MainActivity后会清空所有的Activity，这样直接在MainActivity执行finish()方法即可</p>
</li>
</ol>
<h4 id="如何看待sendMessageAtFrontOfQueue"><a href="#如何看待sendMessageAtFrontOfQueue" class="headerlink" title="如何看待sendMessageAtFrontOfQueue()"></a>如何看待sendMessageAtFrontOfQueue()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入的延迟时间为0，头插入消息队列，即消息队列下一次立即执行的消息，</p>
<h5 id="如何看待Handler构造中的CallBack方法？"><a href="#如何看待Handler构造中的CallBack方法？" class="headerlink" title="如何看待Handler构造中的CallBack方法？"></a>如何看待Handler构造中的CallBack方法？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里的 callback 是 Runnable</span></span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage</span></span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可以看出构造函数中传入Callback参数，调用dispatch方法时，会优先调用callback方法，在调用handleMessage方法，即</p>
<blockquote>
<p>Callback接口可以在handleMessage前收到消息，如果返回true，则不会调用handleMessage方法</p>
</blockquote>
<p><strong>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</strong></p>
<h4 id="Looper-prepareMain-和Looper-perpare的区别？"><a href="#Looper-prepareMain-和Looper-perpare的区别？" class="headerlink" title="Looper.prepareMain()和Looper.perpare的区别？"></a>Looper.prepareMain()和Looper.perpare的区别？</h4><p>区别是一个boolean值，主线程的looper永不退出，除非调用</p>
<h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><h4 id="如何理解AsyncTask？"><a href="#如何理解AsyncTask？" class="headerlink" title="如何理解AsyncTask？"></a>如何理解AsyncTask？</h4><ul>
<li>必须创建在主线程</li>
</ul>
<p>AscncTask内部封装了Handler+线程池</p>
<p>包含两个线程池，一个是用来排队的 ，一个才是真正的执行，通过Handler将状态回掉到主线程</p>
<ul>
<li>核心线程数，最少两个，最多四个</li>
<li>最大线程数= cpu核心数*2+1</li>
<li>核心线程无超时限制，非核心线程在闲置时的超时时间为1s</li>
<li>任务队列容量为128</li>
</ul>
<p>execute方法执行，加入排队线程池排队，等待任务执行后通过handler通知主线程，调用状态回调方法，内部实现因为排队线程池阻塞，导致任务是串行的，即同时只有一个任务会进入线程池执行</p>
<p>executeOnExecutor执行调用异步操作</p>
<h4 id="谷歌为何弃用AsyncTask"><a href="#谷歌为何弃用AsyncTask" class="headerlink" title="谷歌为何弃用AsyncTask"></a>谷歌为何弃用AsyncTask</h4><ol>
<li>使用多线程更加复杂，使bug难以定位</li>
<li>太过复杂</li>
<li>滥用继承，effic java推荐“使用组合而不是继承”，使类多，且低效</li>
<li>默认的THREAD_POOL_EXECUTOR线程池配置不太合适</li>
</ol>
<h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><p><a href="#线程">线程</a></p>
<h4 id="简述线程池"><a href="#简述线程池" class="headerlink" title="简述线程池"></a>简述线程池</h4><p>android中线程池主要实现是ThreadPoolExecutor</p>
<p>参数：</p>
<ul>
<li><strong>核心线程数</strong>：如果指定ThreadPoolExecutor的allowCoreThreadTimeOut这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间，就会被销毁掉</li>
<li><strong>最大线程数</strong>： = 核心线程数 + 非核心线程数</li>
<li><strong>超时时间</strong>：非核心线程的闲置超时时间</li>
<li><strong>超时时间单位</strong>：非核心线程的闲置超时时间<strong>单位</strong></li>
<li><strong>线程等待队列</strong>：当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务</li>
<li><strong>线程创建工厂</strong>：线程池的拒绝策略，可以出错，也可以顾虑</li>
</ul>
<blockquote>
<p>allowCoreThreadTimeOut设置为true，非核心线程超时时间同样用于核心线程，如果为false，核心线程永远不会终止</p>
</blockquote>
<ol>
<li><p><strong>SynchronousQueue</strong>（空集合）：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong>（大小无限）：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong>（大小可以设置）：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误</p>
</li>
<li><p><strong>DelayQueue</strong>（延迟出队，大小可以设置）：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</p>
</li>
</ol>
<p>规则：</p>
<ol>
<li>未达到核心线程数，新建核心线程</li>
<li>达到或者大于核心线程数，任务被插入任务队列等待执行</li>
<li>步骤2中无法插入队列（队列满了），线程数量小于线程池最大值，启动一个非核心线程执行任务</li>
<li>步骤3 中线程数量达到最大值，则拒绝执行此任务</li>
</ol>
<h4 id="android主要分为几种线程池？"><a href="#android主要分为几种线程池？" class="headerlink" title="android主要分为几种线程池？"></a>android主要分为几种线程池？</h4><p>四种</p>
<p>FixedThreadPool：全是核心线程，没有超时机制，任务队列没有大小限制</p>
<p>CachedThreadPool：全是非核心线程，最大为Integer.MAX_VALUE，空闲线程60s超时（60s内可以复用，60s后回收），适用于执行短时的大量任务，空闲时也不占用cpu资源</p>
<p>ScheduledThreadPool：核心线程固定，非核心线程为Interger.MAX_VALUE，非核心线程无超时机制（执行完就被回收），适用执行定时任务和固定周期任务</p>
<p>SingleThreadExecutor：只有一个核心线程，无超时机制，保证只在一个线程中执行任务</p>
<h4 id="线程池中一个线程崩溃会导致线程池崩溃吗？"><a href="#线程池中一个线程崩溃会导致线程池崩溃吗？" class="headerlink" title="线程池中一个线程崩溃会导致线程池崩溃吗？"></a>线程池中一个线程崩溃会导致线程池崩溃吗？</h4><p>不会，线程池存在两种方式去执行线程任务，submit和execute方式。  当发生线程崩溃时，execute下会将线程关闭，开辟新的线程，submit会返回异常，但不会关闭线程。</p>
<p>submit：</p>
<ul>
<li>继承自ExecutorService</li>
<li>不会抛出栈堆异常，通过Future.get方法获取异常信息</li>
<li>submit通过构造一个RunnableFuture后，执行execute方法，RunnableFuture内部使用状态管理，通过死循环判断任务执行状态，在执行完或者cancle后返回，</li>
</ul>
<blockquote>
<p><code>get()</code>方法是一个阻塞方法，在调用时需要注意</p>
</blockquote>
<p>execute：</p>
<ul>
<li>继承自Executor</li>
<li>会抛出堆栈异常信息，关闭该线程并创建新的线程</li>
</ul>
<h4 id="如何检测线程池中的崩溃问题呢？"><a href="#如何检测线程池中的崩溃问题呢？" class="headerlink" title="如何检测线程池中的崩溃问题呢？"></a>如何检测线程池中的崩溃问题呢？</h4><p>submit的get()方法可以获取崩溃，但是该方法是阻塞的，可用性不高，于是我们使用另一种方法</p>
<ol>
<li>execute+ThreadFactory.UncaughtExceptionHandler<br>在submit下UncaughtExceptionHandler失效，因为FutureTask会捕获异常并保存不会放入UncaughtExceptionHandler中</li>
<li>在run方法中自行捕获</li>
<li>重写ThreadLocalExecutor.afterExecute方法</li>
<li>submit+get方法</li>
</ol>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h4 id="触摸事件传递"><a href="#触摸事件传递" class="headerlink" title="触摸事件传递"></a>触摸事件传递</h4><p><img src="https://pic1.zhimg.com/80/v2-5fdce519c134bdb81a38e9feb31ffb2c_1440w.jpg" width="300" height="400"/></p>
<p>DecorView为最顶层的view，DecorView、TitleView和ContentView都为FrameLayout</p>
<blockquote>
<p>如果一个view处理了down事件，那么后续的move，up都会交给他处理</p>
</blockquote>
<h5 id="点击事件的传递流程"><a href="#点击事件的传递流程" class="headerlink" title="点击事件的传递流程"></a>点击事件的传递流程</h5><p>onTouchListener(onTouch)&gt;onTouchEvent()&gt;onClickListener(onClick)</p>
<p>onTouchListener的onTouch返回为false，则onTouchEvent被调用</p>
<h5 id="简述view的事件传递"><a href="#简述view的事件传递" class="headerlink" title="简述view的事件传递"></a>简述view的事件传递</h5><p>事件传递从父类向子类传递，其中包含3个方法，在一个类中顺序执行，</p>
<ul>
<li>dispatchEvent：事件的分发，true—-&gt;分发给自己</li>
<li>onIntercepterEvent：事件拦截，true—-&gt;拦截后交给自己的onTouchEvent处理，false —-&gt;传递给子View</li>
<li>onTouchEvent：事件的执行。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2018110610205215.jpg" width="50%"/></p>
<p>如果View没有对ACTION_DOWN进行消费，之后的事件也不会传递过来。</p>
<p>事件的传递是从Activity开始的，Activity –&gt;PhoneWindow–&gt;DectorView–&gt;ViewGroup–&gt;View；主要操作在ViewGroup和View中；</p>
<p>ViewGroup类主要调用：dispatchTouchEvent()–&gt;onInterceptTouchEnent()–&gt;dispatchTransformedTouchEvent()；<strong>ViewGroup不直接调用onTouchEvent()方法；</strong></p>
<table>
<thead>
<tr>
<th>类</th>
<th>相关子类</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Activity类</td>
<td>Activity……</td>
<td>dispatchTouchEvent(); onTouchEvent();</td>
</tr>
<tr>
<td>View容器（ViewGroup的子类）</td>
<td>FrameLayout、LinearLayout、ListView、ScrollVIew……</td>
<td>dispatchTouchEvent(); onInterceptTouchEvent(); onTouchEvent();</td>
</tr>
<tr>
<td>View控件（非ViewGroup子类）</td>
<td>Button、TextView、EditText……</td>
<td>dispatchTouchEvent(); onTouchEvent();</td>
</tr>
</tbody>
</table>
<blockquote>
<p>onIntercepterTouchEvent()方法之只存在ViewGroup中，Activity为最顶层，不需要拦截，直接分发，view为最底层，不需要拦截，直接分发</p>
</blockquote>
<ul>
<li>以ACTION_DOWN为开始，UP或者CANCEL为结束</li>
<li>如果dispatch不处理ACTION_DOWN事件，那么就不会继续接收到后续的ACTION_xxxx事件</li>
</ul>
<h5 id="如何让只执行onTouch事件，不执行onClick事件？"><a href="#如何让只执行onTouch事件，不执行onClick事件？" class="headerlink" title="如何让只执行onTouch事件，不执行onClick事件？"></a>如何让只执行onTouch事件，不执行onClick事件？</h5><p>将onTouch方法的返回值改为true，就会只执行onTouch事件，不执行onClick事件。</p>
<h5 id="如果截取了事件，还会往下传吗？那会走到哪里？"><a href="#如果截取了事件，还会往下传吗？那会走到哪里？" class="headerlink" title="如果截取了事件，还会往下传吗？那会走到哪里？"></a>如果截取了事件，还会往下传吗？那会走到哪里？</h5><p>如果截取了事件就不会往下传递了，只会执行本Viewgroup的onTouchEvent。</p>
<h5 id="如果截取了事件并处理了事件还会返回父级吗？"><a href="#如果截取了事件并处理了事件还会返回父级吗？" class="headerlink" title="如果截取了事件并处理了事件还会返回父级吗？"></a>如果截取了事件并处理了事件还会返回父级吗？</h5><p>会返回父类，因为父类需要确认子级是否已经处理了事件</p>
<h5 id="requestDisallowInterceptTouchEvent"><a href="#requestDisallowInterceptTouchEvent" class="headerlink" title="requestDisallowInterceptTouchEvent"></a>requestDisallowInterceptTouchEvent</h5><p>子view让其父view不做事件拦截，<br>在子view的onTouchEvent方法中调用parent.requestDisallowInterceptTouchEvent(true)方法，</p>
<p>如果父view拦截事件，是怎么通知到子view的onInterceptTouchEvent中调用disallowIntercepter？</p>
<p>在ScrollView中进行源码分析：<br>在onIntercepterTouchEvent中返回true，则进行拦截，在按下滑动一小部分距离后设置为false（ACTION_MOVE），可以进行事件传递，当然就可以调用disallowIntercepter方法进行处理，后续的值触发父view的机制，直接过滤掉了onIntercepterTouchEvent</p>
<p>所以在ScrollView中默认的onClickListener是不生效的</p>
<p>onIntercepterTouchEvent不执行，直接返回false，然后向下dispatch到子类</p>
<blockquote>
<p>该方法生效的前提是父view不拦截ACTION_DOWN事件，第一次的ACTION_DOWN事件可以传递到子view中，则后续的ACTION事件父view无法拦截</p>
</blockquote>
<h5 id="如何解决滑动冲突"><a href="#如何解决滑动冲突" class="headerlink" title="如何解决滑动冲突"></a>如何解决滑动冲突</h5><ol>
<li><p>外部拦截法：</p>
<p>重写父view的onIntercepterTouchEvent，在其中对触摸的坐标进行控制，在父view要拦截的时候拦截，在子view想要调用的时候不进行拦截</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (满足父容器的拦截要求) &#123;</span><br><span class="line">                    intercepted = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastXIntercept = x;</span><br><span class="line">        mLastYIntercept = y;</span><br><span class="line">        <span class="keyword">return</span> intercepted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>内部拦截法：</p>
<p>在子view的dispatchTouchEvent中在ACTION_DOWN事件下调用parent.requestDisallowInterceptTouchEvent(true);，设置不允许父view的拦截</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">                <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">                <span class="keyword">if</span> (父容器需要此类点击事件) &#123;</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLastX = x;</span><br><span class="line">        mLastY = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该条件需要在父view的ACTION_DOWN事件可以传递到子view中才可以实现，所以需要在父view的onInterceptTouchEvent中不拦截父View的ACTION_DOWN事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="ACTION-CANCEL怎么理解？"><a href="#ACTION-CANCEL怎么理解？" class="headerlink" title="ACTION_CANCEL怎么理解？"></a>ACTION_CANCEL怎么理解？</h5><ul>
<li>在划出子view的布局后，onIntercepterTouchEvent进行拦截ACTION_MOVE事件，并将其转化为ACTION_CANCEL交给子view的处理，表示手指划出view所在区域</li>
<li>在父view进行拦截的时候，子view有可能接收到ACTION_CANCEL事件</li>
</ul>
<p>触摸事件的结束有两种状态，一种时ACTION_UP事件，另一种就是ACTION_CANCEL事件，正常在view的事件传递中，抬起手指的ACTION_UP事件会被监听，当父view认为不需要将后续的ACTION_MOVE事件传递给子View的时候，就会将ACTION_MOVE事件转化为ACTION_CANCEL事件，子View就会认为事件结束</p>
<blockquote>
<p>主要是父view在拦截中做了处理影响子view的触摸，不需要触摸就直接传ACTION_CANCEL。</p>
</blockquote>
<p><strong>使用TouchTarget（具体实现时mFirstTouchTarget）单链表存储触摸事件的，当置为CANCLE时，将触摸view在mFirstTouchEvent删除</strong></p>
<h5 id="事件到底是先到DecorView还是先到Window的？"><a href="#事件到底是先到DecorView还是先到Window的？" class="headerlink" title="事件到底是先到DecorView还是先到Window的？"></a>事件到底是先到DecorView还是先到Window的？</h5><p>ViewRootImpl——&gt;DecorView——&gt;Activity——&gt;PhoneWindow——&gt;DecorView——&gt;ViewGroup</p>
<p>为什么绕来绕去的呢，光DecorView就走了两遍。</p>
<ul>
<li>ViewRootImpl并不知道有Activity这种东西存在，它只是持有了DecorView。所以先传给了DecorView，而DecorView知道有Activity，所以传给了Activity。</li>
<li>Activity也不知道有DecorView，它只是持有PhoneWindow，所以这么一段调用链就形成了。</li>
</ul>
<h4 id="多点触控-非重点"><a href="#多点触控-非重点" class="headerlink" title="多点触控(非重点)"></a>多点触控(非重点)</h4><p>使用TouchTarge（mFirstTouchTarget）管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchTarget</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The touched child view.</span></span><br><span class="line">        <span class="keyword">public</span> View child;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> pointerIdBits;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The next target in the target list.</span></span><br><span class="line">        <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>view：触摸目标view</li>
<li>pointerIdBits：位运算（与、或）</li>
<li>next：链表指针</li>
</ul>
<p>第一个触摸目标，在ACTION_DOWN、ACTION_POINTER_DOWN时会触发寻找触摸目标过程（事件分发），所以DOWN事件会重置mFirstTouchTarget。</p>
<ul>
<li>单点触控，mFirstTouchEvent为单个对象</li>
<li>多点触控，在一个view上，也是单个对象</li>
<li>多点触控，在多个view上，会成为一个链表</li>
</ul>
<p>传入的view消耗了事件，则构建一个TouchTarget，并发至在mFirstTouchTarget的头部。多个view目标会头插在链表中。</p>
<blockquote>
<p>即便是多指触控，也都是使用ACTION_MOVE，不做区分，可以使用index获取</p>
</blockquote>
<h4 id="如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？"><a href="#如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？" class="headerlink" title="如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？"></a>如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？</h4><p>当使用纵向滑动，默认事件传递是viewPager到RecyclerView，即后续的所有事件都由RecyclerView进行处理，那么RecycleView没有横向事件，所以不会做处理，所以不会出现横向的滑动。</p>
<h4 id="View的加载流程"><a href="#View的加载流程" class="headerlink" title="View的加载流程"></a>View的加载流程</h4><h5 id="简述View的加载流程"><a href="#简述View的加载流程" class="headerlink" title="简述View的加载流程"></a>简述View的加载流程</h5><ol>
<li>通过Activity的setContentView方法间接调用Phonewindow的setContentView（），在PhoneWindow中通过getLayoutInflate（）得到LayoutInflate对象</li>
<li>通过LayoutInflate对象去加载View，主要步骤是</li>
</ol>
<p>（1）通过xml的Pull方式去解析xml布局文件，获取xml信息，并保存缓存信息，因为这些数据是静态不变的</p>
<p>（2）根据xml的tag标签通过反射创建View逐层构建View</p>
<p>（3）递归构建其中的子View，并将子View添加到父ViewGroup中</p>
<p>加载结束后就开始绘制view了</p>
<h4 id="View的绘制机制"><a href="#View的绘制机制" class="headerlink" title="View的绘制机制"></a>View的绘制机制</h4><p><img src="https://pic1.zhimg.com/80/v2-5fdce519c134bdb81a38e9feb31ffb2c_1440w.jpg" width="300"/></p>
<p>DecorView为最顶层的view，DecorView、TitleView和ContentView都为FrameLayout，</p>
<blockquote>
<p>当Activity对象被创建完毕后，会将DecorView添加到PhoneWindow中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，view的绘制过程是由ViewRootImpl完成的。</p>
</blockquote>
<p><strong>所有的view都是依附在window上的，比如PopupWindow、菜单。</strong></p>
<blockquote>
<p>Window是个概念性的东西，你看不到他，如果你能感知它的存在，那么就是通过View，所以View是Window的存在形式，有了View，你才感知到View外层有一个皇帝的新衣——window</p>
</blockquote>
<p><strong>有视图的地方就有window</strong></p>
<h5 id="简述View的绘制流程"><a href="#简述View的绘制流程" class="headerlink" title="简述View的绘制流程"></a>简述View的绘制流程</h5><p><strong>深度便利</strong><br>主要分为3个方法，顺序执行：</p>
<ul>
<li>measure()：测量视图的大小，根据MeasureSpec进行计算大小</li>
<li>layout()：确定view的位置</li>
<li>draw()：绘制view。创建Canvas对象。六个步骤：①、绘制视图的背景；②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用；⑤、还原图层（Layer）；⑥、绘制滚动条。</li>
</ul>
<h4 id="draw-中的具体流程是什么？"><a href="#draw-中的具体流程是什么？" class="headerlink" title="draw()中的具体流程是什么？"></a>draw()中的具体流程是什么？</h4><ol>
<li>绘制背景：drawBackground(canvas)</li>
<li>绘制自己的内容：onDraw(canvas)</li>
<li>绘制Children：dispatchDraw(canvas)</li>
<li>绘制装饰：onDrawForeground(canvas)</li>
</ol>
<h5 id="MeasureSpec分析"><a href="#MeasureSpec分析" class="headerlink" title="MeasureSpec分析"></a>MeasureSpec分析</h5><p>MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求，子view依据该值进行大小的绘制</p>
<p>MeasureSpec是个大小和模式的组合值。是一个32位的整型，将size（大小）和mode（模式）打包成一个int，其中高两位是mode，其余30位存储size（大小）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取测量模式</span></span><br><span class="line"><span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取测量大小</span></span><br><span class="line"><span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Mode 和 Size 生成新的SpecMode</span></span><br><span class="line"><span class="keyword">int</span> measureSpec=MeasureSpec.makeMeasureSpec(size, mode);</span><br></pre></td></tr></table></figure><br>测量模式有三种：</p>
<ul>
<li>EXACTLY: 相等于MATCH_CONTENT</li>
<li>AT_MOST: 相等于WRAP_CONTENT</li>
<li>UNSPECIFIED: 相等于具体的值</li>
</ul>
<h4 id="RelativeLayout、LinearLayout和ConstraintLayout"><a href="#RelativeLayout、LinearLayout和ConstraintLayout" class="headerlink" title="RelativeLayout、LinearLayout和ConstraintLayout"></a>RelativeLayout、LinearLayout和ConstraintLayout</h4><p>LinearLayout：</p>
<ul>
<li>weight设置导致二次测量，首先测量一遍大小onMeasure（非weight），然后根据weight在次测量，调整大小</li>
</ul>
<p>RelativeLayout：</p>
<ul>
<li>onMeasure执行两遍，对横向和纵向分别测量，所以是2遍</li>
</ul>
<p>ConstraintLayout：</p>
<ul>
<li>可以不使用嵌套，提供相对布局，并且支持权重布局，尽可能减少层级，提高性能，类似于flex布局</li>
</ul>
<p>对比</p>
<ol>
<li>同层级的布局，LinearLayout&lt;RelatvieLayout=ConstraintLayout，因为LinearLayout执行onMeasure一遍，RelativeLayout执行两遍</li>
<li>LinearLayout会增加层级深度，RelativeLayout减少层级，所以通常下使用RelativeLayout，如果层级简单则使用LinearLayout</li>
</ol>
<blockquote>
<p>RelativeLayout的子View如果高度和RelativeLayout不同，会引发效率问题</p>
</blockquote>
<h4 id="setContentView的执行过程"><a href="#setContentView的执行过程" class="headerlink" title="setContentView的执行过程"></a>setContentView的执行过程</h4><ol>
<li>初始化windows</li>
<li>绑定ui布局</li>
</ol>
<h4 id="什么时候可以获得view的宽高"><a href="#什么时候可以获得view的宽高" class="headerlink" title="什么时候可以获得view的宽高"></a>什么时候可以获得view的宽高</h4><p>因为onMeasure和生命周期不同步，所以不能在onCreate，onStart，onResume中进行获取操作，</p>
<ol>
<li>在view.post方法中进行获取，内部实现是handler机制，回调的时候已经执行完了</li>
<li>在onWindowFocusChanged获取焦点后，view的绘制完成，可以在这里拿到view的宽高</li>
<li>使用ViewTreeObserver的回调也可以解决这个问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ViewTreeObserver observer = tv1.getViewTreeObserver();</span><br><span class="line">        observer.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</span><br><span class="line">                    tv1.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> width = tv1.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">int</span> height = tv1.getMeasuredHeight();</span><br><span class="line">                Log.d(<span class="string">&quot;tv1Width&quot;</span>, String.valueOf(width));</span><br><span class="line">                Log.d(<span class="string">&quot;tv1Height&quot;</span>, String.valueOf(height));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li>
<li>手动调用measure方法后，获取宽高</li>
</ol>
<h4 id="什么时候开始绘制Activity的view的？"><a href="#什么时候开始绘制Activity的view的？" class="headerlink" title="什么时候开始绘制Activity的view的？"></a>什么时候开始绘制Activity的view的？</h4><p>在DecorView添加(addView)到phoneWindows中时，触发measure，layout，draw方法</p>
<h4 id="PhoneWindow是在什么时候创建的？"><a href="#PhoneWindow是在什么时候创建的？" class="headerlink" title="PhoneWindow是在什么时候创建的？"></a>PhoneWindow是在什么时候创建的？</h4><p>在Activity的attch方法时，创建了PhoneWindow</p>
<h4 id="View的刷新机制"><a href="#View的刷新机制" class="headerlink" title="View的刷新机制"></a>View的刷新机制</h4><h5 id="requestLayout和invalidate区别是什么"><a href="#requestLayout和invalidate区别是什么" class="headerlink" title="requestLayout和invalidate区别是什么"></a>requestLayout和invalidate区别是什么</h5><p><strong>requestLayout</strong>：触发onMeasure,onLayout方法，大小和位置变化，不一定触发onDraw</p>
<p><strong>invalidate</strong>：触发performTraversals机制，导致view重绘，调用onDraw方法，主要是内容发生变化</p>
<p><strong>postInvalidate</strong>：异步调用invalidate方法</p>
<blockquote>
<p>invalidate如果是个view，那就只有自己本身会draw，如果是ViewGroup就是对子view进行重绘</p>
</blockquote>
<h4 id="简析Activity、Window、DecorView以及ViewRoot之间的错综关系"><a href="#简析Activity、Window、DecorView以及ViewRoot之间的错综关系" class="headerlink" title="简析Activity、Window、DecorView以及ViewRoot之间的错综关系"></a>简析Activity、Window、DecorView以及ViewRoot之间的错综关系</h4><ul>
<li><p>Activity是控制器</p>
</li>
<li><p>windows装载DecorView，并将DecorView交给ViewRoot进行绘制和交互，其唯一实现子类就是PhoneWindow，在attach中创建，是Activity和View交互的中间层，帮助Activity管理View。</p>
</li>
<li>DecorView是FrameLayout的子类，是视图的顶级view</li>
<li>viewRoot负责view的绘制和交互，实际的viewRoot就是ViewRootImpl类，是连接WMS和DecorView的纽带</li>
</ul>
<h4 id="setContentView执行的具体过程"><a href="#setContentView执行的具体过程" class="headerlink" title="setContentView执行的具体过程"></a>setContentView执行的具体过程</h4><ol>
<li>Activity实例化，执行<strong>attach</strong>方法，在attach中创建<strong>PhoneWindow</strong></li>
<li>执行onCreate方法，执行<strong>setContentView</strong>，先调用phoneWindow.setContentView(),然后开始根据不同的主题创建<strong>DecorView</strong>的结构，传入我们的<strong>xml</strong>文件，生成一个多结构的View</li>
<li>Activity调用<strong>onResume</strong>方法，调用<strong>WindowManager.addView</strong>()方法，随后在addView()方法中创建<strong>ViewRootImpl</strong></li>
<li>接着调用ViewRootImpl的setView方法，最终触发meaure，layout，draw方法进行渲染绘制，其中和WMS通过Binder交互，最终显示在界面上</li>
</ol>
<h4 id="四者的创建时机？"><a href="#四者的创建时机？" class="headerlink" title="四者的创建时机？"></a>四者的创建时机？</h4><ul>
<li>Activity：startActivity后，performLaunchActivity方法中创建</li>
<li>PhoneWindow：Activity的attach方法</li>
<li>DecorView：setConentView中创建</li>
<li>ViewRootImpl：onResume中调用WM.addView方法创建</li>
</ul>
<h4 id="dialog为什么不能用application创建？"><a href="#dialog为什么不能用application创建？" class="headerlink" title="dialog为什么不能用application创建？"></a>dialog为什么不能用application创建？</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6873669458742525960">Android-Window机制原理之Token验证(为什么Application的Context不能show dialog)</a></p>
<blockquote>
<p>token是WMS唯一用来标识系统中的一个窗口</p>
</blockquote>
<p>Dialog有一个PhoneWindow实例，属于应用窗口。Dialog最终也是通过系统的WindowManager把自己的Window添加到WMS上。Dialog是一个子Window，需要依附一个父window。</p>
<p>Dialog创建PhoneWindow时，token是null。只有传入Activity中的Context对象，Activity才会将自己的token给Dialog，这样，才会被WMS所识别，如果使用的不是Activit的token，就会报错BadTokenException</p>
<p>在application的情况下，将Dialog的window升级为系统window即可显示</p>
<h2 id="RecyclerView和ListView"><a href="#RecyclerView和ListView" class="headerlink" title="RecyclerView和ListView"></a>RecyclerView和ListView</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ListerCi/article/details/105480322">Android—RecyclerView进阶(4)—复用机制及性能优化</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37700275/article/details/89839599">RecyclerView问题汇总</a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/u/2458461/blog/4870218">老大爷都能看懂的RecyclerView动画原理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/smileiam/article/details/88396546">RecyclerView性能优化及高级使用</a></p>
<h4 id="简述RecyclerView的刷新和缓存机制"><a href="#简述RecyclerView的刷新和缓存机制" class="headerlink" title="简述RecyclerView的刷新和缓存机制"></a>简述RecyclerView的刷新和缓存机制</h4><p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c09a12ec1bd3ba?imageslim" alt="img"></p>
<p>recyclerView中有三个重要方：</p>
<ul>
<li>Adapter：负责与数据集交互</li>
<li>LayoutManager：负责ItemView的布局，接管Measure，Layout，Draw过程</li>
<li>Recycler：负责管理ViewHolder</li>
<li>ViewHolder：视图的创建和显示在Recycler中有多个缓存池，</li>
</ul>
<p>mAttachedScrap被称为一级缓存，在重新layout时使用，主要是数据集发生变化的场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//屏幕内缓存scrap</span><br><span class="line">// mAttachedScrap在重新layout时使用，表示未与RecyclerView分离的ViewHolder</span><br><span class="line">final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;();</span><br><span class="line">// mChangedScrap用于数据变化等</span><br><span class="line">ArrayList&lt;ViewHolder&gt; mChangedScrap = null;</span><br><span class="line">//屏幕外缓存cache</span><br><span class="line">// mCachedViews和RecycledViewPool用于滑动时的缓存</span><br><span class="line">final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();</span><br><span class="line">// 用户自定义缓存，一般不用</span><br><span class="line">private ViewCacheExtension mViewCacheExtension;</span><br><span class="line">//屏幕外缓存pool，数据会被重置，虚之行onBindViewHolder</span><br><span class="line">RecycledViewPool mRecyclerPool;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>mAttachedScrap：mAttachedScrap用于屏幕中可见表项的回收和复用，没有大小限制<br>mAttachedScrap生命周期起始于RecyclerView布局开始，终止于RecyclerView布局结束，无论mAttachedScrap中是否存在数据，都会清空，存储到mCacheView或者mRecyclerPool</li>
</ul>
<blockquote>
<p>插入或是删除itemView时，先把屏幕内的ViewHolder保存至AttachedScrap中</p>
</blockquote>
<blockquote>
<p>mAttachView和mCacheView都是通过比对position或者id（setStableIds（true）+getItemId复写）来确定是否复用的</p>
</blockquote>
<h4 id="缓存存储结构区别"><a href="#缓存存储结构区别" class="headerlink" title="缓存存储结构区别"></a>缓存存储结构区别</h4><ul>
<li>mAttachedScrap：ArrayList<ViewHolder></li>
<li>mCachedView：ArrayList<ViewHolder></li>
<li>mRecyclerPool：SparseArray<ScrapData>，ScrapData中包含ArrayList<ViewHolder>和其他标记位。<h5 id="数据集发生变化"><a href="#数据集发生变化" class="headerlink" title="数据集发生变化"></a>数据集发生变化</h5>当数据集发生变化后，我们会调用notifyDataSetChanged()方法进行刷新布局操作，这时LayouManager通过调用detachAndScrapAttachedViews方法，将布局中正在显示的ItemView缓存到mAttachScrap中，重新构建ItemView时，LayoutManager会首先到mAttachScrap中进行查找<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDMzMTg0LTljYmYwNTQ3YTNjN2JkZDYucG5n?x-oss-process=image/format,png" alt="img"><br>如图所示，如果只是删除Data1数据，执行NotifyDataSetChanged()方法时，layoutManager将Data0到Data4缓存到mAttachScrap中，重新渲染布局时，会直接复用mAttachScrap中的四个布局，而得不到复用的布局会被放置在mRecyclerPool中。</li>
</ul>
<blockquote>
<p>通过比较Position确定mAttachScrap中ItemView的复用，因为2的位置从2变为1，位置发生变化，但是还是通过比对position进行复用，那是因为在recyclerView重新渲染时，执行dispatchLayoutStep1()对position进行了校正。</p>
</blockquote>
<h5 id="滑动类型"><a href="#滑动类型" class="headerlink" title="滑动类型"></a>滑动类型</h5><p>在滑出可视区域后，会将ViewHolder存储在mCachedView中，当超出大小（默认大小为2+预加载item）后会将最先放进来的放在RecyclerViewPool中，根据viewType进行缓存，每个viewType缓存最多5个，从RecyclerViewPool中取出的数据，最终会调用onBindViewHolder()方法重新绑定</p>
<p>当发现有新的构建时，会去缓存找，找不到就去mRecyclerPool中寻找，如果有viewType相同的就取出来绑定并复用。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDMzMTg0LWRmYTljNDZmZmI1NDJkZTAucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>RecyclerView滑动时，刚开始的时候回收了Position0和Position1，它们被添加到了mCachedViews中。随后回收Position2时，达到数量上限，最先进入mCachedViews的Position0被放进了mRecyclerPool中。<br>再看下方进入可视区域的3个Item，最初的Position6和Position7找不到对应的缓存，只能新建ViewHolder并绑定。当Position8滑入可视区域时，发现mRecyclerPool中有一个ViewType相等的缓存，则将其取出并绑定数据进行复用。</p>
<p>当有数据进行变动时，数据的position会发生变化。</p>
<p>stableId</p>
<blockquote>
<p>mChangedScrap—–&gt;mAttachedScrap—–&gt;mCachedViews—–&gt;ViewCacheExtension—–&gt;RecycledViewPool——–&gt;onCreatViewHolder</p>
<p>如果是单个viewType的RecyclerView，在滑动过程中，RecyclerPool最多可能存在一个数据</p>
</blockquote>
<p>假设一屏幕显示7个，向上滑动10个，总共bindView10个，又下滑10个（滑回去），总共8个（cacheView复用两个），一共18个</p>
<blockquote>
<p>在RecyclerView的v25版本中，引入<strong>预取机制</strong>，在初始化时，初始化8个，提前缓存一个数据</p>
</blockquote>
<h4 id="RecyclerView的优化"><a href="#RecyclerView的优化" class="headerlink" title="RecyclerView的优化"></a>RecyclerView的优化</h4><h5 id="放大缓存大小和缓存池大小"><a href="#放大缓存大小和缓存池大小" class="headerlink" title="放大缓存大小和缓存池大小"></a>放大缓存大小和缓存池大小</h5><ol>
<li>再滑动过程中，不论上滑还是下滑都会从<strong>mCachedViews</strong>中查找缓存，如果滑动频繁，可以通过<code>RecyclerView.setItemViewCacheSize(...)</code>方法增大<strong>mCachedViews</strong>的大小，减少onBindViewHolder()和onCreateViewHolder()调用</li>
<li>放大RecyclerViewPool的默认大小，现在是每个viewType中默认大小为5，如果显示数据过多，可放大默认大小<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置viewType类型的默认存储大小为10</span></span><br><span class="line">recyclerview.getRecycledViewPool().setMaxRecycledViews(viewType,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
如果多个RecyclerView中存在相同ViewType的ItemView，那么这些RecyclerView可以公用一个mRecyclerPool。</li>
</ol>
<h5 id="优化onBindViewHolder-耗时"><a href="#优化onBindViewHolder-耗时" class="headerlink" title="优化onBindViewHolder()耗时"></a>优化onBindViewHolder()耗时</h5><p>尽量少的在onBindViewHolder中执行操作，减少新建对象对内消耗</p>
<h5 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h5><p>多使用include,merage，viewStub,LinearLayout,FrameLayout</p>
<h5 id="measure-优化和减少requestLayout-调用"><a href="#measure-优化和减少requestLayout-调用" class="headerlink" title="measure()优化和减少requestLayout()调用"></a>measure()优化和减少requestLayout()调用</h5><p>当RecyclerView宽高的测量模式都是EXACTLY（精确数据）时，onMeasure()方法不需要执行dispatchLayoutStep1()等方法来进行测量。而当RecyclerView的宽高不确定并且至少一个child的宽高不确定时，要measure两遍。<br>因此将RecyclerView的宽高模式都设置为EXACTLY有助于优化性能。</p>
<p>如果RecyclerView的宽高都不会变，大小不变,方法<code>RecyclerView.setHasFixedSize(true)</code>可以避免数据改变时重新计算RecyclerView的大小，优化性能</p>
<h4 id="notifyDataSetChanged-与-notifyItemRangeChanged-的区别？"><a href="#notifyDataSetChanged-与-notifyItemRangeChanged-的区别？" class="headerlink" title="notifyDataSetChanged 与 notifyItemRangeChanged 的区别？"></a>notifyDataSetChanged 与 notifyItemRangeChanged 的区别？</h4><p>当notifyItemRangeChanged的区间在mRecyclerpool的大小的间隔内，则会通过mRecyclerpool复用viewholder，响应快速。</p>
<p>notifyItemInsert()和notifyItemRemove()方法，会通过RecyclerView的预加载流程，会将ViewHolder缓存到mAttachView中，避免重新create和bind。</p>
<p>notifyItemChanged(int)方法更新固定item</p>
<p>notifyDataSetChanged 会将所有viewholder放置在pool中，但是只能放置5个，其他就回收了，再构建时，需要重新绘制测量，界面会导致闪烁等</p>
<p>如果使用SetHasStableIds（true）,会将数据缓存到scrap中，复用时直接使用</p>
<h4 id="调用-notifyDataSetChanged-时闪烁的原因？"><a href="#调用-notifyDataSetChanged-时闪烁的原因？" class="headerlink" title="调用 notifyDataSetChanged 时闪烁的原因？"></a>调用 notifyDataSetChanged 时闪烁的原因？</h4><p>itemView重新测量和布局导致的(bindViewHolder)，并非createViewHolder。数据存储在RecyclerViewPool中，拿出需要重新BindView，itemView重新进行测量和布局，导致出现UI线程耗时，出现闪烁</p>
<p>如果使用SetHasStableIds（true）,会将数据缓存到scrap中，复用时直接使用</p>
<blockquote>
<p><strong>如果你的列表能够容纳很多行，而且使用 notifyDataSetChanged 方法比较频繁，那么你应该考虑设置一下容量大小。</strong></p>
</blockquote>
<h4 id="RecyclerView相对于ListView的优势是什么？"><a href="#RecyclerView相对于ListView的优势是什么？" class="headerlink" title="RecyclerView相对于ListView的优势是什么？"></a>RecyclerView相对于ListView的优势是什么？</h4><ol>
<li>屏幕外缓存可以直接在mCacheView()中复用，不需要重新BindView</li>
<li>recyclerPool可以提供给多个RecyclerView使用，在特定场景下，如viewpaper+多个列表页下有优势.</li>
<li>ListView缓存<strong>View</strong>，RecyclerView缓存<strong>ViewHolder</strong></li>
</ol>
<h4 id="adapter，viewHolder的作用-adapter中常用方法的作用是什么？"><a href="#adapter，viewHolder的作用-adapter中常用方法的作用是什么？" class="headerlink" title="adapter，viewHolder的作用?adapter中常用方法的作用是什么？"></a>adapter，viewHolder的作用?adapter中常用方法的作用是什么？</h4><ul>
<li>Adapter：负责与数据集交互</li>
<li>ViewHolder：视图的创建和显示，持有所有的用于绑定数据或者需要操作的View</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Item视图，并返回相应的ViewHolder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> VH <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span></span></span><br><span class="line"><span class="function"><span class="comment">//绑定数据到正确的Item视图上。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(VH holder, <span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回该Adapter所持有的Item数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//用来获取当前项Item(position参数)是哪种类型的布局</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<h4 id="RecyclerPool为何使用SparseArray？"><a href="#RecyclerPool为何使用SparseArray？" class="headerlink" title="RecyclerPool为何使用SparseArray？"></a>RecyclerPool为何使用SparseArray？</h4><p>在RecyclerView中，第四级缓存，mRecyclerPool中存储是通过SparseArray存储ViewHolder，根据不同的ViewType的int值为键，ScrapData为值，ScrapData也是ArrayList<ViewHolder>及其标志位组成的，在进行put和get方法时，都是通过ViewType值获取。<br>不使用HashMap的原因是：</p>
<ul>
<li>我们定义了viewType为int值，则不用HashMap中较为繁重的类型，减少装箱问题耗时</li>
<li>量级较小，不需要HashMap的大量级处理</li>
<li>节省内存</li>
</ul>
<p>使用SparseArray存储空间id和空间对象关系。</p>
<p>HashMap更加复杂，SparseArray减少开销</p>
<h4 id="LayoutManager样式有哪些？setLayoutManager源码里做了什么？"><a href="#LayoutManager样式有哪些？setLayoutManager源码里做了什么？" class="headerlink" title="LayoutManager样式有哪些？setLayoutManager源码里做了什么？"></a>LayoutManager样式有哪些？setLayoutManager源码里做了什么？</h4><ul>
<li>LinearLayoutManager 水平或者垂直的Item视图。</li>
<li>GridLayoutManager 网格Item视图。</li>
<li>StaggeredGridLayoutManager 交错的网格Item视图。</li>
</ul>
<p>当之前设置过 LayoutManager 时，移除之前的视图，并缓存视图在 Recycler 中，将新的 mLayout 对象与 RecyclerView 绑定，更新缓存 View 的数量。最后去调用 requestLayout ，重新请求 measure、layout、draw。</p>
<h4 id="ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration-源码？"><a href="#ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration-源码？" class="headerlink" title="ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration()源码？"></a>ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration()源码？</h4><p>用途：来改变Item之间的偏移量或者对Item进行装饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装饰的绘制在Item条目绘制之前调用，所以这有可能被Item的内容所遮挡</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c, RecyclerView parent)</span></span></span><br><span class="line"><span class="function"><span class="comment">//装饰的绘制在Item条目绘制之后调用，因此装饰将浮于Item之上</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawOver</span><span class="params">(Canvas c, RecyclerView parent)</span></span></span><br><span class="line"><span class="function"><span class="comment">//与padding或margin类似，LayoutManager在测量阶段会调用该方法，计算出每一个Item的正确尺寸并设置偏移量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffsets</span><span class="params">(Rect outRect, <span class="keyword">int</span> itemPosition, RecyclerView parent)</span></span></span><br></pre></td></tr></table></figure>
<p>当通过这个方法添加分割线后，会指定添加分割线在集合中的索引，然后再重新请求 View 的测量、布局、(绘制)</p>
<h4 id="mChangedScrap和mAttachedScrap的区别是什么？"><a href="#mChangedScrap和mAttachedScrap的区别是什么？" class="headerlink" title="mChangedScrap和mAttachedScrap的区别是什么？"></a>mChangedScrap和mAttachedScrap的区别是什么？</h4><p>因为mChangedScrap表示item变化了，有可能是数据变化，有可能是类型变化，所以它的viewHolder无法重用，只能去RecycledViewPool中重新取对应的，然后再重新绑定。</p>
<p>mChangedScrap与mAttachedScrap，作用差不多。</p>
<p>mChangedScrap更多的用于pre-layout的动画处理。</p>
<p>然后一点需要注意：mChangedScrap只能在pre-layout中使用，mAttachedScrap可以在pre-layout与post-layout中使用。</p>
<p>mChangedScrap：ViewHolder.isUpdated() == true</p>
<p>mAttachedScrap：1.被同时标记为<code>remove</code>和<code>invalid</code>；2.完全没有改变的<code>ViewHolder</code></p>
<p>在notifyItemRangeChanged，将数据变化的放置在mChangedScrap，没有变化的存储在mAttachScrap中，然后再取出来，mChangedScrap的数据会被移动到RecyclerPool中，进行重新绑定后再放回mChangedScrap中</p>
<p>mAttachScrap中得不到复用的会放置在recyclerpool中</p>
<h4 id="onMeasure过程"><a href="#onMeasure过程" class="headerlink" title="onMeasure过程"></a>onMeasure过程</h4><p>过程中包含mAttachedScrap的使用</p>
<p>dispatchLayoutStep1：预布局</p>
<p>dispatchLayoutStep2：实际布局</p>
<p>dispatchLayoutStep3：执行动画信息</p>
<h4 id="如何解决Glide错乱问题"><a href="#如何解决Glide错乱问题" class="headerlink" title="如何解决Glide错乱问题"></a>如何解决Glide错乱问题</h4><p>因为存在复用机制，8可能会复用1，在网络不好或者图片过大的情况下，8的图片加载缓慢，会先显示1的图片，加载后才会刷新掉。</p>
<p>方案：imageView设置tag，判断是否复用，如果是复用，就清除该控件上Glide的缓存</p>
<h4 id="RecyclerView卡顿优化"><a href="#RecyclerView卡顿优化" class="headerlink" title="RecyclerView卡顿优化"></a>RecyclerView卡顿优化</h4><p>通过BlockCanary进行主线程卡顿检测，打印出任务耗时，在卡顿时，打印出栈堆信息</p>
<p>原理是在looper.loop()死循环中，执行任务都是dispatchMessage方法，如果该方法超过一个任务的常规耗时，就会导致主线程卡顿</p>
<p>解决方法：</p>
<ol>
<li><p>放大mCacheView和RecyclerPool的大小，提高复用率，减少渲染</p>
</li>
<li><p>图片在滑动结束后再进行加载，避免在滑动的时候向主线程做更新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.addOnScrollListener(<span class="keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE) &#123;</span><br><span class="line">            Glide.with(mContext).resumeRequests();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Glide.with(mContext).pauseRequests();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在滑动过程中停止加载，在滑动结束后恢复加载</p>
</li>
<li><p>使用DiffUtil进行局部刷新优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DiffUtil会自动计算新老数据的差异，自动调用notifyxxx方法，将无脑的notifyDataSetChanged()进行优化</span></span><br><span class="line"><span class="comment">//并且伴随动画</span></span><br><span class="line">adapter.notifyItemRangeInserted(position, count);</span><br><span class="line">adapter.notifyItemRangeRemoved(position, count);</span><br><span class="line">adapter.notifyItemMoved(fromPosition, toPosition);</span><br><span class="line">adapter.notifyItemRangeChanged(position, count, payload);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文艺青年新宠</span></span><br><span class="line"><span class="comment">//利用DiffUtil.calculateDiff()方法，传入一个规则DiffUtil.Callback对象，和是否检测移动item的 boolean变量，得到DiffUtil.DiffResult 的对象</span></span><br><span class="line">DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(<span class="keyword">new</span> DiffCallBack(mDatas, newDatas), <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//利用DiffUtil.DiffResult对象的dispatchUpdatesTo（）方法，传入RecyclerView的Adapter，轻松成为文艺青年</span></span><br><span class="line">diffResult.dispatchUpdatesTo(mAdapter);</span><br><span class="line"><span class="comment">//别忘了将新数据给Adapter</span></span><br><span class="line">mDatas = newDatas;</span><br><span class="line">mAdapter.setDatas(mDatas);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>减少布局的嵌套和层级，减少过度绘制，尽量自定义view</p>
</li>
<li><p>如果Item高度固定，调用<code>RecyclerView.setHasFixedSize(true);</code>来避免<code>requestLayout</code>浪费资源</p>
</li>
<li><p>可以关闭动画，减少RecyclerView的渲染次数</p>
</li>
</ol>
<h4 id="RecyclerView的自适应高度"><a href="#RecyclerView的自适应高度" class="headerlink" title="RecyclerView的自适应高度"></a>RecyclerView的自适应高度</h4><ol>
<li>使用瀑布流布局StaggeredGridLayoutManager</li>
<li>重写LinearLayoutManager，onMeasure中重新测量子布局的大小</li>
</ol>
<h4 id="RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView"><a href="#RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView" class="headerlink" title="RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView"></a>RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView</h4><ol>
<li>同方向的情况下会造成滑动冲突，默认外层的RecyclerView可滑动<br>一般有两种处理方案：<strong>内部拦截法</strong>和<strong>外部拦截法</strong><br>这里推荐内部拦截法，通过设置requestDisallowInterceptTouchEvent(true)时，不让父RecyclerView拦截子类的事件</li>
<li>ScrollView嵌套RecyclerView同样可以使用这个方法解决。也可以使用NestedScrollView，该类就是为了解决滑动冲突问题，可以保证两View类都可以滑动，但是需要设置RecyclerView.setNestedScrollingEnabled(false)，取消RecyclerView本身的滑动效果。解决滑动的卡顿感</li>
</ol>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h4 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h4><p>帧动画：一连串的图片进行连贯的播放，形成动画。</p>
<p>补间动画：通过xml文件实现，实现 <strong>alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）</strong>，通过不断的绘制view，看起来移动了效果，实际上view没有变化，还在原地</p>
<p>属性动画：对于对象属性的动画，也可以使用xml配置，但是推荐代码配置，比xml更加方便。通过不断改变自己view的属性值，真正的改变view</p>
<blockquote>
<p>所有的补间动画都可以用属性动画实现</p>
</blockquote>
<h4 id="属性动画和补间动画的区别"><a href="#属性动画和补间动画的区别" class="headerlink" title="属性动画和补间动画的区别"></a>属性动画和补间动画的区别</h4><ol>
<li>补间动画虽然移动了，但是点击的还是原来的位置，点击事件允许触发。而属性动画不是，所以我们可以确认，属性动画才是真正实现了View的移动，补间动画的view其实只是在其他地方绘制了一个影子</li>
<li>Activity退出时，没有关闭动画，属性动画会导致Activity无法释放的内存泄漏，而补间动画不会发生这样的情况</li>
<li>xml的补间动画复用率极高，在页面切换过程中都有很好的效果</li>
</ol>
<blockquote>
<p>帧动画避免大图，否则会带来oom</p>
</blockquote>
<h4 id="属性动画中的差值器和估值器是什么？"><a href="#属性动画中的差值器和估值器是什么？" class="headerlink" title="属性动画中的差值器和估值器是什么？"></a>属性动画中的差值器和估值器是什么？</h4><p>差值器：定义动画随时间流逝的变化规律。通俗点就是动画的执行速度的变化，可以是由缓即快，由快即缓，也可以是匀速，也可以是弹性动画效果 ，LinearInterpolator（匀速差值器）</p>
<p>估值器：定义从初始值过渡到结束值的规则定义，TypeEvaluator，可以通俗的理解为位置的移动</p>
<h2 id="android系统启动流程"><a href="#android系统启动流程" class="headerlink" title="android系统启动流程"></a>android系统启动流程</h2><h4 id="android系统架构"><a href="#android系统架构" class="headerlink" title="android系统架构"></a>android系统架构</h4><h4 id="简述系统启动流程"><a href="#简述系统启动流程" class="headerlink" title="简述系统启动流程"></a>简述系统启动流程</h4><p>从系统层看：</p>
<ol>
<li>linux 系统层</li>
<li>Android系统服务层</li>
<li>Zygote</li>
</ol>
<p>从开机启动到Home Launcher：</p>
<ol>
<li>启动bootloader （小程序；初始化硬件）</li>
<li>加载系统内核 （先进入实模式代码在进入保护模式代码）</li>
<li>启动init进程（用户级进程 ，进程号为1）</li>
<li>启动Zygote进程（初始化Dalvik VM等）</li>
<li>启动Runtime进程</li>
<li>启动本地服务（system service）</li>
<li>启动 HomeLauncher</li>
</ol>
<h4 id="第一个启动的进程是什么？"><a href="#第一个启动的进程是什么？" class="headerlink" title="第一个启动的进程是什么？"></a>第一个启动的进程是什么？</h4><p>init进程，其他进程都是fork这个进程的</p>
<h4 id="init进程孵化出了什么进程？"><a href="#init进程孵化出了什么进程？" class="headerlink" title="init进程孵化出了什么进程？"></a>init进程孵化出了什么进程？</h4><ul>
<li>守护进程</li>
<li>Zygote进程，负责孵化应用进程</li>
<li>MediaServer进程</li>
</ul>
<h4 id="Zygote进程做了什么？"><a href="#Zygote进程做了什么？" class="headerlink" title="Zygote进程做了什么？"></a>Zygote进程做了什么？</h4><ul>
<li>创建Socket服务端</li>
<li>加载虚拟机</li>
<li>SystemServer进程</li>
<li>fork第一个应用进程—Launcher</li>
</ul>
<h4 id="为什么要创建Socket服务端？"><a href="#为什么要创建Socket服务端？" class="headerlink" title="为什么要创建Socket服务端？"></a>为什么要创建Socket服务端？</h4><ul>
<li>ServiceManager不能保证在孵化Zygote进程时就初始化好了，所以无法使用Binder</li>
<li>Binder属于多线程操作，fork不允许多线程操作，容易发生死锁，所以使用Socket<h2 id="app启动流程"><a href="#app启动流程" class="headerlink" title="app启动流程"></a>app启动流程</h2></li>
</ul>
<ol>
<li>用户点击 icon</li>
<li>系统开始加载和启动应用</li>
<li>应用启动：开启空白(黑色)窗口</li>
<li>创建应用进程</li>
<li>初始化Application</li>
<li>启动 UI 线程</li>
<li>创建第一个 Activity</li>
<li>解析(Inflater)和加载内容视图</li>
<li>布局(Layout)</li>
<li>绘制(Draw)</li>
</ol>
<p>源码分析</p>
<ol>
<li>LauncherActivity.startActivitySafely(intent)：使用intent启动</li>
<li>Activity.startActivity(intent)：</li>
<li>Activity.startActivityForResult(intent)：获取ApplicationThread成员变量，是一个Binder对象</li>
<li>Instrumentation.execStartActivity：ActivityManagerService的远程接口</li>
<li>ActivityManagerProxy.startActivity：通过Binder进入AMS</li>
<li>ActivityManagerService.startActivity</li>
<li>ActivityStack.startActivityMayWait：解析MainActivity的信息</li>
<li>ActivityStack.startActivityLocked：创建即将要启动的Activity的相关信息</li>
<li>ActivityStack.startActivityUncheckedLocked：获取intent标志位，新建Task栈，添加到AMS中</li>
<li>Activity.resumeTopActivityLocked：查看LauncherActivity状态，新建Activity的状态</li>
<li>ActivityStack.startPausingLocked：停止LauncherActivity，onPause</li>
<li>ApplicationThreadProxy.schedulePauseActivity</li>
<li>ApplicationThread.schedulePauseActivity</li>
<li>ActivityThread.queueOrSendMessage：在主线程通过Handler发送消息</li>
<li>H.handleMessage：Handler的回调</li>
<li>ActivityThread.handlePauseActivity：pause LauncherActivity</li>
<li>ActivityManagerProxy.activityPaused：进入AMS中的onPause事件</li>
<li>ActivityManagerService.activityPaused</li>
<li>ActivityStack.activityPaused</li>
<li>ActivityStack.completePauseLocked</li>
<li>ActivityStack.resumeTopActivityLokced：LauncherActivity已经onPause了</li>
<li>ActivityStack.startSpecificActivityLocked</li>
<li>ActivityManagerService.startProcessLocked：创建新进程</li>
<li>ActivityThread.main：app入口，添加looper循环</li>
<li>ActivityManagerProxy.attachApplication：通过Binder进入AMS中</li>
<li>ActivityManagerService.attachApplication</li>
<li>ActivityManagerService.attachApplicationLocked</li>
<li>ActivityStack.realStartActivityLocked</li>
<li>ApplicationThreadProxy.scheduleLaunchActivity：进入ApplicationThread</li>
<li>ApplicationThread.scheduleLaunchActivity</li>
<li>ActivityThread.queueOrSendMessage</li>
<li>H.handleMessage</li>
<li>ActivityThread.handleLaunchActivity</li>
<li>ActivityThread.performLaunchActivity：进入onCreat方法</li>
<li>MainActivity.onCreate</li>
</ol>
<p>总结：</p>
<p>1～11：Launcher通过Binder进程通知ActivityManagerService，他要启动一个Activity</p>
<p>12～16：ActivityManagerService通过Binder进程通知Launcher进入Pause阶段</p>
<p>17～24：Launcher告知我已进入pause阶段，ActivityManagerService创建新进程，用来启动ActivityThread。</p>
<p>25～27：ActivityThread通过Binder进程将ApplicationThread的Binder传递给ActivityManagerService，以便AMS可以直接用这个Binder通信</p>
<p>28～35：AMS通过Binder通知ActivityThread，你可以启动</p>
<p>这里以启动微信为例子说明</p>
<ol>
<li>Launcher通知AMS 要启动微信了，并且告诉AMS要启动的是哪个页面也就是首页是哪个页面</li>
<li>AMS收到消息告诉Launcher知道了，并且把要启动的页面记下来</li>
<li>Launcher进入Paused状态，告诉AMS，你去找微信吧</li>
</ol>
<p>上述就是Launcher和AMS的交互过程</p>
<ol>
<li>AMS检查微信是否已经启动了也就是是否在后台运行，如果是在后台运行就直接启动，如果不是，AMS会在新的进程中创建一个ActivityThread对象，并启动其中的main函数。</li>
<li>微信启动后告诉AMS，启动好了</li>
<li>AMS通过之前的记录找出微信的首页，告诉微信应该启动哪个页面</li>
<li>微信按照AMS通知的页面去启动就启动成功了。</li>
</ol>
<h2 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h2><p>参照app的启动流程</p>
<ul>
<li>ApplicationThread：ActivityThread的内部类，负责和AMS进行Binder通信</li>
<li>ActivityManagerService：服务端对象，负责管理系统中所有的Activity</li>
</ul>
<p>Activity 启动过程是由 ActivityMangerService（AMS) 来启动的，底层 原理是 Binder实现的 最终交给 ActivityThread 的 performActivity 方法来启动她</p>
<p>ActivityThread大概可以分为以下五个步骤</p>
<ol>
<li>通过ActivityClientRecord对象获取Activity的组件信息</li>
<li>通过Instrument的newActivity使用类加载器创建Activity对象</li>
<li>检验Application是否存在，不存在的话，创建一个，保证 只有一个Application</li>
<li>通过ContextImpl和Activity的attach方法来完成一些初始化操作</li>
<li>调用oncreat方法</li>
</ol>
<p>Android开启新进程的方式是通过复制第一个zygote（受精卵）进程实现，所以像受精卵一样快速分裂</p>
<h4 id="SystemServer是什么？有什么作用？他和zygote的关系是什么？"><a href="#SystemServer是什么？有什么作用？他和zygote的关系是什么？" class="headerlink" title="SystemServer是什么？有什么作用？他和zygote的关系是什么？"></a>SystemServer是什么？有什么作用？他和zygote的关系是什么？</h4><p>SystemServer也是一个进程，并且复制于zygote，系统中重要的服务都是在这个进程中开启的，如：AMS，PMS，WMS等</p>
<h4 id="ActivityManagerService是什么？什么时候初始化的？有什么作用？"><a href="#ActivityManagerService是什么？什么时候初始化的？有什么作用？" class="headerlink" title="ActivityManagerService是什么？什么时候初始化的？有什么作用？"></a>ActivityManagerService是什么？什么时候初始化的？有什么作用？</h4><p>简称AMS，负责系统中所有Activity的生命周期，控制其开启、关闭、暂停等<br>是在SystemServer进程开启时进行初始化的</p>
<h4 id="App-和-AMS-SystemServer-进程-还有-zygote-进程是如何通信的？"><a href="#App-和-AMS-SystemServer-进程-还有-zygote-进程是如何通信的？" class="headerlink" title="App 和 AMS(SystemServer 进程)还有 zygote 进程是如何通信的？"></a>App 和 AMS(SystemServer 进程)还有 zygote 进程是如何通信的？</h4><p>App 与 AMS 通过 <strong>Binder</strong> 进行 IPC 通信，AMS(SystemServer 进程)与 zygote 通过 <strong>Socket</strong> 进行 IPC 通信。</p>
<h4 id="AMS-PMS-WMS运行在一个线程中还是进程中？"><a href="#AMS-PMS-WMS运行在一个线程中还是进程中？" class="headerlink" title="AMS/PMS/WMS运行在一个线程中还是进程中？"></a>AMS/PMS/WMS运行在一个线程中还是进程中？</h4><p>运行在System_server进程中的线程中</p>
<h2 id="apk打包流程"><a href="#apk打包流程" class="headerlink" title="apk打包流程"></a>apk打包流程</h2><p><img src="/imageMd/package-1.png" width="50%" /></p>
<ol>
<li>aapt阶段，打包res目录，生成R.java</li>
<li>AIDL阶段，生成java文件</li>
<li>java编译器。将java文件通过javac编译生成<code>.class</code>文件</li>
<li>dex阶段，生成<code>.dex</code>文件</li>
<li>apk打包阶段，将文件打包成为apk文件</li>
<li>签名阶段，对apk进行签名</li>
<li>整理apk文件</li>
</ol>
<h4 id="aapt和aapt2的区别？"><a href="#aapt和aapt2的区别？" class="headerlink" title="aapt和aapt2的区别？"></a>aapt和aapt2的区别？</h4><p>aapt是全量编译，打包res目录，生成R文件</p>
<p>aapt2是差量编译，将变化的res目录进行重新打包，修改R文件</p>
<blockquote>
<p>aapt2中存在两部分，编译和链接</p>
<p>编译：将资源文件编译为二进制文件</p>
<p>链接：将编译后二进制文件进行合并，生成独立的文件</p>
</blockquote>
<p>在需要差量的时候，只需要重新编译二进制文件，再将这些二进制文件生成新的文件即可</p>
<h2 id="apk的组成"><a href="#apk的组成" class="headerlink" title="apk的组成"></a>apk的组成</h2><ol>
<li>AndroidManifest.xml</li>
<li>assets（项目中assets目录）</li>
<li>classes.dex</li>
<li>lib库</li>
<li>META-INF（校验文件）</li>
<li>res（资源文件）</li>
<li>resources.arsc（资源文件映射，索引文件）</li>
</ol>
<h2 id="apk安装流程"><a href="#apk安装流程" class="headerlink" title="apk安装流程"></a>apk安装流程</h2><h4 id="存在多少种安装方式，分别是什么？"><a href="#存在多少种安装方式，分别是什么？" class="headerlink" title="存在多少种安装方式，分别是什么？"></a>存在多少种安装方式，分别是什么？</h4><p>四种</p>
<ul>
<li>系统应用安装——————开机时完成安装，没有安装界面</li>
<li>网络下载安装——————通过市场应用完成，没有安装界面</li>
<li>adb命令安装——————没有安装界面</li>
<li>第三方应用安装——————sdk卡导入apk，点击安装，存在安装界面</li>
</ul>
<h4 id="安装过程中的重要路径"><a href="#安装过程中的重要路径" class="headerlink" title="安装过程中的重要路径"></a>安装过程中的重要路径</h4><p>应用安装涉及到如下几个目录：</p>
<p>system/app —————系统自带的应用程序，获得adb root权限才能删除</p>
<p>data/app  —————用户程序安装的目录。安装时把      apk文件复制到此目录</p>
<p>data/data —————存放应用程序的数据</p>
<p>data/dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)</p>
<h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><ol>
<li>将apk文件复制到/data/app目录</li>
<li>解析apk信息</li>
<li>dexopt操作（将dex文件优化为odex文件）</li>
<li>更新权限信息</li>
<li>发送安装完成广播</li>
</ol>
<h4 id="Android虚拟机发展史"><a href="#Android虚拟机发展史" class="headerlink" title="Android虚拟机发展史"></a>Android虚拟机发展史</h4><ol>
<li>android初期，Dalvik负责加载dex/odex文件</li>
<li>2.2版本，JIT（即时编译）初次加入，每次启动的时候编译，耗时，耗电</li>
<li>4.4版本引入ART（Android RunTime）和AOT（Ahead-of-time）（运行前编译成机器码），与Dalvik共存</li>
<li>5.0版本全部采用ART编译器，不耗时，不耗电，在安装期间比较慢而已，而且会占用额外的控件存储机器码</li>
<li>7.0版本JIT回归，再用JIT/AOT并用，即初次启动使用JIT，在手机空闲时，使用AOT生成机器码（只编译热点函数信息，用户操作次数越多，性能越高），这样保证了安装迅速，启动迅速，耗电少</li>
</ol>
<h4 id="Dalvik和ART是什么，有啥区别？"><a href="#Dalvik和ART是什么，有啥区别？" class="headerlink" title="Dalvik和ART是什么，有啥区别？"></a>Dalvik和ART是什么，有啥区别？</h4><h5 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h5><p>Dalvik是Google公司自己设计用于Android平台的虚拟机。支持已转换为<code>.dex格式</code>的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。<br>Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。<br>很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。<br>2014年6月25日，Android L 正式亮相于召开的谷歌I/O大会，Android L 改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART。</p>
<h5 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h5><p>即Android Runtime<br>ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。</p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>Dalvik是基于寄存器的，而JVM是基于栈的。<br>Dalvik运行dex文件，而JVM运行java字节码<br>自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）。<br>优化后的Dalvik较其他标准虚拟机存在一些不同特性:<br>1.占用更少空间<br>2.为简化翻译，常量池只使用32位索引<br>3.标准Java字节码实行8位堆栈指令,Dalvik使用16位指令集直接作用于局部变量。局部变量通常来自4位的“虚拟寄存器”区。这样减少了Dalvik的指令计数，提高了翻译速度。<br>当Android启动时，Dalvik VM 监视所有的程序（APK），并且创建依存关系树，为每个程序优化代码并存储在Dalvik缓存中。Dalvik第一次加载后会生成Cache文件，以提供下次快速加载，所以第一次会很慢。<br>Dalvik解释器采用预先算好的Goto地址，每个指令对内存的访问都在64字节边界上对齐。这样可以节省一个指令后进行查表的时间。为了强化功能, Dalvik还提供了快速翻译器（Fast Interpreter）。</p>
<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>ART有什么优缺点呢？</p>
<p>优点：<br>1、系统性能的显著提升。<br>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。<br>3、更长的电池续航能力。<br>4、支持更低的硬件。<br>缺点：<br>1.机器码占用的存储空间更大，字节码变为机器码之后，可能会增加10%-20%<br>2.应用的安装时间会变长</p>
<h4 id="dex-class-odex的区别"><a href="#dex-class-odex的区别" class="headerlink" title=".dex .class .odex的区别"></a>.dex .class .odex的区别</h4><p>.dex是谷歌对.class文件进行了优化后得到的文件格式</p>
<ol>
<li>.dex去除了.class中冗余的信息，更加轻量</li>
<li>.class内存占用大，不适合移动端，堆栈的加栈模式，加载速度慢，文件IO操作多，类查找慢</li>
</ol>
<p>.dex文件在虚拟机进行加载时，会预加载成.odex文件，.odex文件对.dex文件进行了优化，避免了重复验证和优化处理，启动时，可直接接在odex文件，提升app启动的速度</p>
<h4 id="简述安装流程"><a href="#简述安装流程" class="headerlink" title="简述安装流程"></a>简述安装流程</h4><ol>
<li>使用installPackageAsUser判断安装来源</li>
<li>校验后（权限，存储空间，安全）将apk文件copy至data/app目录</li>
<li>解析apk信息，覆盖安装或者安装新应用</li>
<li><p>Dalvik中将dex优化为odex文件</p>
<pre><code>ART将dex翻译为oat文件（机器码）预编译过程
</code></pre></li>
<li><p>创建/data/data/包名    存放应用数据，发送广播结束安装</p>
</li>
</ol>
<h2 id="接口加密"><a href="#接口加密" class="headerlink" title="接口加密"></a>接口加密</h2><h4 id="项目中的接口加密技巧"><a href="#项目中的接口加密技巧" class="headerlink" title="项目中的接口加密技巧"></a>项目中的接口加密技巧</h4><p>在版本中写死一个密钥，首个接口请求后返回该app的密钥。</p>
<p>对上传的get，post请求的参数以ASCII码进行排序+密钥后生成md5值，添加到header中，传递给服务器</p>
<p>服务器端根据获取到的参数依据同样的规则生成md5后进行比较，如果相同，比较时间戳是否在5秒内，通过则成功</p>
<p>不使用token机制的原因是本产品不存在账号密码等机制，应用可能一直保持在线状态，不会下线，需要协调token的时效性，所以不使用该方案。</p>
<p>缺点：token机制一台机子只允许一个token进行访问，而上述方案没有该限制</p>
<h4 id="常规token校验机制"><a href="#常规token校验机制" class="headerlink" title="常规token校验机制"></a>常规token校验机制</h4><p><img src="/imageMd/token-1.png" width="60%"/></p>
<p>适用于存在账户名密码的应用</p>
<h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><h4 id="ANR条件？"><a href="#ANR条件？" class="headerlink" title="ANR条件？"></a>ANR条件？</h4><p>Service执行的操作最多是20s，BroadcastReceiver是10s，Activity是5s，超过时间发生ANR</p>
<h4 id="ANR原理解析"><a href="#ANR原理解析" class="headerlink" title="ANR原理解析"></a>ANR原理解析</h4><p>Application Not Responding</p>
<ol>
<li>主线程频繁进行IO操作，比如读写文件或者数据库；</li>
<li>硬件操作如进行调用照相机或者录音等操作；</li>
<li>多线程操作的死锁，导致主线程等待超时；</li>
<li>主线程操作调用join()方法、sleep()方法或者wait()方法；</li>
<li>耗时动画/耗资源行为导致CPU负载过重</li>
<li>system server中发生WatchDog ANR；</li>
<li>service binder的数量达到上限</li>
</ol>
<p>在应用程序运行过程中，通过send一个延迟的handler，延迟时间为设置的anr时间，如果到时间，没有执行完任务/没有移除handler任务，就会调用appNotResponding方法，触发anr</p>
<blockquote>
<p>主要在AMS和WMS中进行控制，通过获取/data/anr/trace.txt进行分析</p>
</blockquote>
<h4 id="什么情况下会导致oom？"><a href="#什么情况下会导致oom？" class="headerlink" title="什么情况下会导致oom？"></a>什么情况下会导致oom？</h4><ol>
<li>大图片存储导致oom，内存溢出<ul>
<li>使用软弱引用，当内存不足时，删除Bitmap缓存</li>
<li>调用Bitmap.recycle()快速回收，但是慎用，容易报错</li>
</ul>
</li>
<li>除了程序计数器之外的内存模型都会发生oom<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError:死循环/递归调用产生的</span><br></pre></td></tr></table></figure></li>
<li>关闭流文件、数据库cursor等对象关闭</li>
<li>创建很多线程会导致oom，因为开辟线程需要对虚拟机栈，本地方法栈，程序计数器，开辟内存，线程数量过多，会导致OOM</li>
</ol>
<h4 id="如何将应用设置为Launcher？"><a href="#如何将应用设置为Launcher？" class="headerlink" title="如何将应用设置为Launcher？"></a>如何将应用设置为Launcher？</h4><p>设置HOME，DEFAULT。</p>
<h4 id="MVC-MVP-MVVM"><a href="#MVC-MVP-MVVM" class="headerlink" title="MVC,MVP,MVVM"></a>MVC,MVP,MVVM</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lmj623565791/article/details/46596109">浅谈MVP in Android</a></p>
<h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><ul>
<li>View：对应于布局文件</li>
<li>Model：业务逻辑和实体模型</li>
<li>Controller：对应于Activity</li>
</ul>
<p><strong>缺点</strong>：</p>
<ol>
<li>Controller（Activity）中处理的逻辑过于繁重，原因是在Activity有太多操作View的代码，View和Controller绑定太过紧密</li>
</ol>
<blockquote>
<p>android中算不上mvc模式，Activity可以叫View层，也可以叫Controller层，所有代码基本都在Activity中</p>
</blockquote>
<h5 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h5><ul>
<li>View 对应于Activity，负责View的绘制以及与用户交互</li>
<li>Model 依然是业务逻辑和实体模型</li>
<li>Presenter 负责完成View于Model间的交互</li>
</ul>
<p><img src="http://img-blog.csdn.net/20150622212916054" alt="img"></p>
<p>因为Activity任务过于繁重，所以在Activity中提炼出一个Presenter层，该层主要通过接口和View层交互，同时获得View层的反馈</p>
<p><strong>优点</strong></p>
<ol>
<li>大大减轻了Activity的逻辑，将View和Presenter做分离，让项目更加简单明确</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>每个功能需要添加一个Presenter类，添加各种借口，增加开发量</li>
<li>Presenter层持有Activity层的引用，需要注意内存泄漏或空指针的问题</li>
</ol>
<h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><ol>
<li>View：View层</li>
<li>ViewModel层：JetPack中的ViewModel组件，配合LiveData+DataBinding，保证View和ViewModel之间的交互，双向绑定，数据的更新可以实时绑定到界面中。</li>
<li>Model层：数据层</li>
</ol>
<p>ViewModel层中代替了Presenter的作用，里边做具体的逻辑，ViewModel与Activity的绑定通过反射构建，通过LiveData达到响应式，在Activity中调用ViewModel的逻辑，并实时更新到界面。</p>
<p><strong>优点</strong></p>
<ol>
<li>ViewModel+LiveData同Activity的生命周期绑定，当Avtivity不存在后，会销毁ViewModel，减少内存泄漏</li>
<li>提供Activity中多个Fragment的数据共享和逻辑调用</li>
<li>提供响应式编程，提供解决问题新方向</li>
<li>优秀的架构思想+官方支持=强大</li>
<li>代码量少，双向绑定减少UI的更新代码</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>降低了View的复用性，因为添加了很多DataBinding的代码，绑定到Activity中</li>
<li>难以定位bug，流程许多地方都是自动化更新，执行，无法确定当中哪一个环节出现问题（数据逻辑问题还是界面显示问题）</li>
</ol>
<h4 id="SharedPreferences-commit-apply使⽤区别"><a href="#SharedPreferences-commit-apply使⽤区别" class="headerlink" title="SharedPreferences commit apply使⽤区别"></a>SharedPreferences commit apply使⽤区别</h4><ol>
<li><p>commit具有回调</p>
</li>
<li><p>apply将信息推送到主存，异步提交到文件，commit同步提交到文件</p>
</li>
</ol>
<h4 id="Bitmap解析"><a href="#Bitmap解析" class="headerlink" title="Bitmap解析"></a>Bitmap解析</h4><h5 id="Bitmap是怎么存储图片的？"><a href="#Bitmap是怎么存储图片的？" class="headerlink" title="Bitmap是怎么存储图片的？"></a>Bitmap是怎么存储图片的？</h5><p>Bitmap是图片在内存中的表达形式，存储的是有限个像素点，每个像素点存储着ARGB值，代表每个像素所代表的颜色（RGB）和透明度（A）</p>
<h5 id="Bitmap图片的内存是怎么计算的？"><a href="#Bitmap图片的内存是怎么计算的？" class="headerlink" title="Bitmap图片的内存是怎么计算的？"></a>Bitmap图片的内存是怎么计算的？</h5><p>图片内存 = 宽 <em> 高 </em> 每个像素所占字节<br>每个像素所占字节和Bitmap.Config有关：</p>
<ul>
<li>ARGB_8888：常用类型，总共32位，<strong>4</strong>个字节，分别表示透明度和RGB通道。</li>
<li>ARGB_4444：<strong>2</strong>个字节</li>
<li>RGB_565：16位，<strong>2</strong>个字节，只能描述RGB通道。</li>
<li>ALPHA_8：<strong>1</strong>个字节</li>
</ul>
<h5 id="Bitmap加载优化？不改变图片质量的情况下怎么优化？"><a href="#Bitmap加载优化？不改变图片质量的情况下怎么优化？" class="headerlink" title="Bitmap加载优化？不改变图片质量的情况下怎么优化？"></a>Bitmap加载优化？不改变图片质量的情况下怎么优化？</h5><ol>
<li>修改Bitmap.Config，降低bitmap每个像素所占用的字节大小，替换格式为RGB_565，这样，内存直接缩小1倍</li>
<li>修改inSampleSize采样率，降低图片的大小，不影响图片的质量，控制每隔inSampleSize个像素进行一次采集</li>
</ol>
<blockquote>
<p>inSampleSize为1时，为原图大小。大于1时，比如2时，宽高就会缩小为原来的1/2</p>
<p>inSampleSize进行2的幂取整操作，1，2，4，8等</p>
</blockquote>
<h5 id="Bitmap内存复用怎么实现？"><a href="#Bitmap内存复用怎么实现？" class="headerlink" title="Bitmap内存复用怎么实现？"></a>Bitmap内存复用怎么实现？</h5><p>如果在一个imageView中加载多种不同的Bitmap图片，如果频繁的去创建bitmap，获取内存，释放内存，从而导致大量GC，内存抖动。<br>在使用Bitmap时，使用inBitmap配合inMutable参数，复用Bitmap内存。在4.4之前，只能复用内存大小相同的Bitmap，4.4之后，新Bitmap内存大小小于或等于复用Bitmap空间的，可以复用</p>
<h5 id="高清大图如何加载？"><a href="#高清大图如何加载？" class="headerlink" title="高清大图如何加载？"></a>高清大图如何加载？</h5><p>使用BitmapRegionDecoder属性进行部分加载，根据界面滑动，不断更新部分图片的位置</p>
<h5 id="intent可以传递bitmap吗？"><a href="#intent可以传递bitmap吗？" class="headerlink" title="intent可以传递bitmap吗？"></a>intent可以传递bitmap吗？</h5><p>可以，bitmap是parcelable序列化过的，也可以转化成byte[]进行传递</p>
<p>大小受限1M，因为binder的大小是1M，binder的线程数不大于16</p>
<h5 id="Bitmap内存在各个android版本的存储？"><a href="#Bitmap内存在各个android版本的存储？" class="headerlink" title="Bitmap内存在各个android版本的存储？"></a>Bitmap内存在各个android版本的存储？</h5><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d5714e8987f3">Android Bitmap变迁与原理解析（4.x-8.x）</a></p>
<ol>
<li>2.3版本之前：存储在本地内存中，不及时回收（recycler()方法），会触发OOM</li>
<li>2.3版本到7.0版本：像素数据和对象数据都存储在堆中</li>
<li>8.0以后：将对象存储在本地内存中（非java内存），通过NativeAllocationRegistry对bitmap进行回收<blockquote>
<p>Fresco 对这个有详细的描述</p>
</blockquote>
</li>
</ol>
<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>深拷贝：拷贝堆区中值<br>浅拷贝：拷贝堆区中的引用地址</p>
<h4 id="创建一个对象的方式？"><a href="#创建一个对象的方式？" class="headerlink" title="创建一个对象的方式？"></a>创建一个对象的方式？</h4><ol>
<li>使用new关键字创建</li>
<li>Class.newInstance反射创建</li>
<li>Constructor.newInstance反射创建</li>
<li>利用clone方法实现（浅拷贝）</li>
<li>通过反序列化实现（深拷贝）</li>
</ol>
<h4 id="界面卡顿的原因"><a href="#界面卡顿的原因" class="headerlink" title="界面卡顿的原因"></a>界面卡顿的原因</h4><ol>
<li>UI线程存在耗时操作</li>
<li>视图渲染时间过长，导致卡顿</li>
<li>频繁gc，内存抖动</li>
</ol>
<h4 id="冷启动、温启动、热启动"><a href="#冷启动、温启动、热启动" class="headerlink" title="冷启动、温启动、热启动"></a>冷启动、温启动、热启动</h4><p>冷启动：app首次启动，或者上次正常关闭后的启动，需要创建app的进程</p>
<ol>
<li>启动系统进程。加载启动app进程，创建app进程</li>
<li>启动app进程任务。渲染屏幕，加载布局等</li>
</ol>
<p>温启动：系统进程存在，app非正常关闭，只需要执行第二步，需要创建Activity或者重新布局等</p>
<p>热启动：热启动就是App进程存在，并且Activity对象仍然存在内存中没有被回收。所以热启动的开销最少，这个过程只会把Activity从后台展示到前台，无需初始化，布局绘制等工作</p>
<blockquote>
<p>冷启动可以认为是android标准启动流程</p>
</blockquote>
<h4 id="Android类加载器"><a href="#Android类加载器" class="headerlink" title="Android类加载器"></a>Android类加载器</h4><p>Android从ClassLoader中派生出两个类加载器：PathClassLoader和DexClassLoader</p>
<p>DexClassLoader：是一个可以从包含classes.dex实体的.jar或.apk文件中加载classes的类加载器。可以用于实现dex的动态加载、代码热更新等等。</p>
<p>PathClassLoader：可以操作在本地文件系统的文件列表或目录中的classes</p>
<blockquote>
<p>DexClassLoader：能够加载未安装的jar/apk/dex<br>PathClassLoader：只能加载系统中已经安装过的apk</p>
</blockquote>
<h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>当一个类需要被初始化加载时，总会先把加载请求传递给父加载器，最终会传递到最高层加载器进行加载。父类加载器会检查是否加载过该类，如果没有加载过，则加载，若无法加载，会传递给子类加载器加载。</p>
<h5 id="为何要使用双亲委派"><a href="#为何要使用双亲委派" class="headerlink" title="为何要使用双亲委派"></a>为何要使用双亲委派</h5><ol>
<li>首先明确，jvm认为不同加载器加载的类为两个不同的对象，所以为了系统安全性，需要保证相同的类要被同一个类加载器加载</li>
<li>避免了重复加载，如果父类加载过，直接使用父类加载过的类。</li>
</ol>
<h5 id="能不能自己写个类叫java-lang-System？"><a href="#能不能自己写个类叫java-lang-System？" class="headerlink" title="能不能自己写个类叫java.lang.System？"></a>能不能自己写个类叫java.lang.System？</h5><p>不可以，通过双亲委派该类名被加载为系统类，不会加载自己写的类。<br>如果非要实现这个效果，需要绕过双亲委派机制，实现自己的类加载器进行加载</p>
<h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><p><img src="https://upload-images.jianshu.io/upload_images/1115031-70a55fecac4da43b.png" width="60%"/></p>
<p><strong>PathClassLoader</strong>:只能加载已经安装到Android系统中的apk文件（/data/app目录），是Android默认使用的类加载器。</p>
<p><strong>DexClassLoader</strong>:可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现热修复的重点。</p>
<p>阿里系：DeXposed、andfix：从底层二进制入手（c语言）。阿里andFix hook 方法在native的具体字段。<br>art虚拟机上是一个叫ArtMethod的结构体。通过修改该结构体上有bug的字段来达到修复bug方法的目的，<br>但这个artMethod是根据安卓原生的结构写死的，国内很多第三方厂家会改写ArtMethod结构，导致替换失效。<br>腾讯系：tinker：从java加载机制入手。qq的dex插装就类似上面分析的那种。通过将修复的dex文件插入到app的dexFileList的前面，达到更新bug的效果，但是不能及时生效，需要重启。<br>但虚拟机在安装期间会为类打上CLASS_ISPREVERIFIED标志，是为了提高性能的，我们强制防止类被打上标志是否会有些影响性能<br>美团robust：是在编译器为每个方法插入了一段逻辑代码，并为每个类创建了一个ChangeQuickRedirect静态成员变量，当它不为空会转入新的代码逻辑达到修复bug的目的。<br>优点是兼容性高,但是会增加应用体积</p>
<ol>
<li>startActivity 的时候最终会走到 AMS 的 startActivity 方法</li>
<li>系统会检查一堆的信息验证这个 Activity 是否合法。</li>
<li>然后会回调 ActivityThread 的 Handler 里的 handleLaunchActivity</li>
<li>在这里走到了 performLaunchActivity 方法去创建 Activity 并回调一系列生命周期的方法</li>
<li>创建 Activity 的时候会创建一个 LoaderApk对象，然后使用这个对象的 getClassLoader 来创建 Activity</li>
<li>我们查看 getClassLoader() 方法发现返回的是 PathClassLoader，然后他继承自 BaseDexClassLoader</li>
<li>然后我们查看 BaseDexClassLoader 发现他创建时创建了一个 DexPathList 类型的 pathList对象，然后在 findClass 时调用了 pathList.findClass 的方法</li>
<li>然后我们查看 DexPathList类 中的 findClass 发现他内部维护了一个 Element[] dexElements的dex 数组，findClass 时是从数组中遍历查找的</li>
</ol>
<h4 id="sqlite怎么保证数据可见性和线程安全性？"><a href="#sqlite怎么保证数据可见性和线程安全性？" class="headerlink" title="sqlite怎么保证数据可见性和线程安全性？"></a>sqlite怎么保证数据可见性和线程安全性？</h4><p>sqlite不支持多个数据库连接进行写操作，但是使用同一个SQLiteHelper连接，可以进行多线程读和写，同一个连接下，sqlite内部有锁机制，不会出现异常，由于有锁的机制，所以是阻塞的，并不是真正的并发</p>
<p>延伸：SharedPreference是线程安全的，内部使用sychronized的</p>
<h4 id="bundle的数据结构，为什么intent要使用bundle？"><a href="#bundle的数据结构，为什么intent要使用bundle？" class="headerlink" title="bundle的数据结构，为什么intent要使用bundle？"></a>bundle的数据结构，为什么intent要使用bundle？</h4><p>内部存储ArrayMap，key是int数组，value是object数组，使用Bundle传递对象和对象数组的时候会默认使用序列化，不用我们做处理。</p>
<p>key是hash值，value[]是存储的数据key值，和value值，采用二分法排序，使用二分法查找</p>
<p>优势：省内存，小数据上占优势。</p>
<h4 id="大图传输"><a href="#大图传输" class="headerlink" title="大图传输"></a>大图传输</h4><blockquote>
<p>文件描述符是一个简单的整数，用以标明每一个被进程所打开的文件和socket。第一个打开的文件是0，第二个是1，依此类推。<br>socket：如果是网络中，会使用ip号+port号方式为<strong>套接字地址</strong>，但是如果同一台主机上两个进程间通信用套接字,还需要指定ip地址,有点过于繁琐. 这个时候就需要用到UNIX Domain Socket, 简称UDS,UDS不需要IP和Port, 而是通过一个文件名来表示<br>（int,  (AF_UNIX,文件路径)）</p>
<ol>
<li>直接传输Bitmap，Bitmap实现Parcelable序列化，所以可以直接在内存中传输，所以可以直接通过Bundle传输过去，但是限制大小为1M。</li>
<li>可以存储在文件中，传输一个文件路径过去</li>
<li>使用Bundle的putBinder方法，通过Binder发送，其实putBinder传输过去的只是一个文件描述符fd，获取到fd后，从共享内存中获取到Bitmap</li>
</ol>
</blockquote>
<blockquote>
<p>而用Intent/bundle直接传输的时候，会禁用文件描述符fd，只能在parcel的缓存区中分配空间来保存数据，所以无法突破1M的大小限制</p>
</blockquote>
<h4 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h4><h5 id="android调用js代码"><a href="#android调用js代码" class="headerlink" title="android调用js代码"></a>android调用js代码</h5><ol>
<li>通过loadUrl的方法直接调用js方法，会刷新页面，没有返回值</li>
<li>evaluateJavascript()方法，android4.4以后使用，不会刷新页面，有返回值</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-30f095d4c9e638fd.png" width="100%" /></p>
<h5 id="js调用android代码"><a href="#js调用android代码" class="headerlink" title="js调用android代码"></a>js调用android代码</h5><ol>
<li><p>addJavascriptInterface()方法进行对象映射，<code>存在漏洞</code> 4.2以下</p>
<p>创建一个类，使用@JavascriptInterface注解标识方法，使用addJavascriptInterface()为js创建对象</p>
<p>漏洞：</p>
<ul>
<li>通过反射获取到这个类的所有方法和系统类，进行获取信息泄漏</li>
<li>4.2后添加注解避免漏洞攻击</li>
</ul>
</li>
<li><p>webViewClient.shouldOverrideUrlLoading()拦截url    <code>不存在漏洞</code></p>
<p>在js中传入url，携带参数，拼接到url中，在shouldOverrideUrlLoading获取</p>
</li>
<li><p>触发js弹窗向android发消息。之后再回调中通过2方式的url传输消息</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-8c91481325a5253e.png" width="100%"/></p>
<p>内存泄漏：加弱引用即可</p>
<h4 id="要实现可以拖动的View该怎么做？"><a href="#要实现可以拖动的View该怎么做？" class="headerlink" title="要实现可以拖动的View该怎么做？"></a>要实现可以拖动的View该怎么做？</h4><p>使用windowManager的updateViewLayout方法吗，实时传入手指的坐标就可以移动window<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">btn.setOnTouchListener &#123; v, event -&gt;</span><br><span class="line">    <span class="keyword">val</span> index = event.findPointerIndex(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">        ACTION_MOVE -&gt; &#123;</span><br><span class="line">            windowParams.x = event.getRawX(index).toInt()</span><br><span class="line">            windowParams.y = event.getRawY(index).toInt()</span><br><span class="line">            windowManager.updateViewLayout(btn, windowParams)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Android新知识"><a href="#Android新知识" class="headerlink" title="Android新知识"></a>Android新知识</h2><h4 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h4><p>响应式编程：根据响应去触发动作</p>
<p>使用观察者模式调用，使用于逻辑复杂的操作可以使用Rxjava做异步处理</p>
<ol>
<li>按钮短300ms内不允许重复点击</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RxView.clicks(button).debounce(<span class="number">300</span>, TimeUnit.MILLISECONDS).subscribe(<span class="keyword">new</span> Action1&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Void aVoid)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;clicked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>轮询，定时执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每隔两秒执行一次</span></span><br><span class="line">   Observable.interval(<span class="number">2</span>, <span class="number">2</span>, TimeUnit.SECONDS).subscribe(<span class="keyword">new</span> Action1&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//TODO WHAT YOU WANT</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>消息传递，可取代EventBus</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//发布消息</span><br><span class="line">RxBus.getInstance().post(&quot;SomeChange&quot;);</span><br><span class="line"></span><br><span class="line">//接收消息并处理</span><br><span class="line">Subscription mSubscription = RxBus.getInstance().toObserverable(String.class).subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(String s) &#123;</span><br><span class="line">                handleRxMsg(s);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//取消订阅</span><br><span class="line">mSubscription.unsubscribe();</span><br></pre></td></tr></table></figure>
<h4 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h4><p>一系列辅助android开发者的使用工具，统称Jetpack</p>
<p>提供新组件，比如导航组件，分页组件，切片组件等，例如mvvm中的LiveData，viewmodel都属于Jetpack组件</p>
<p>paging,room,livedata,viewmodel,lifecycler,compose,databinding,viewbinding</p>
<p>Jetpack在androidx中进行发布，androidx也属于Jetpack</p>
<h4 id="AndroidX"><a href="#AndroidX" class="headerlink" title="AndroidX"></a>AndroidX</h4><p>androidx空间中包含Jetpack库，</p>
<p>之前使用android-support-v4(最低支持1.6) 和 android-support-v7（最低支持2.1）库做支持，androidx提出后，对support-v4 和 support-v7库不再做维护</p>
<h4 id="MVVM-1"><a href="#MVVM-1" class="headerlink" title="MVVM"></a>MVVM</h4><p><img src="https://upload-images.jianshu.io/upload_images/1813550-356c0729e43b8148.jpg" width="70%"/></p>
<p>LiveData使用观察者模式观察生命周期，在onStart和onResume时回调onChanged，确保liveData对象内存泄漏。</p>
<p>DataBind   双向绑定，将view和model进行绑定，一方变化会导致另一方变化。</p>
<p>缺点：</p>
<ol>
<li>难以排查bug，不知道是view的bug还是model的bug，bug会转移</li>
<li>不能复用view，因为绑定不同的model</li>
</ol>
<h4 id="LiveData-ViewModel替换EventBus"><a href="#LiveData-ViewModel替换EventBus" class="headerlink" title="LiveData+ViewModel替换EventBus"></a>LiveData+ViewModel替换EventBus</h4><h4 id="ViewBinding替换Butterknife"><a href="#ViewBinding替换Butterknife" class="headerlink" title="ViewBinding替换Butterknife"></a>ViewBinding替换Butterknife</h4><h4 id="组件化，插件化，热修复"><a href="#组件化，插件化，热修复" class="headerlink" title="组件化，插件化，热修复"></a>组件化，插件化，热修复</h4><h4 id="Kotlin理解"><a href="#Kotlin理解" class="headerlink" title="Kotlin理解"></a>Kotlin理解</h4><h4 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h4><h1 id="Java基础篇"><a href="#Java基础篇" class="headerlink" title="Java基础篇"></a>Java基础篇</h1><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h4><p>不管指令怎么重排序，在单线程下执行结果不能改变</p>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>一个操作的执行结果需要对另一个操作可见，则两个操作之间必须存在happens-before关系，主要强调在多线程情况中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlDep</span></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  	</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">      	a = <span class="number">1</span>; <span class="comment">//1</span></span><br><span class="line">      	flag = <span class="keyword">true</span>; <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>&#123;</span><br><span class="line">      	<span class="keyword">if</span>(flag)&#123; <span class="comment">//3</span></span><br><span class="line">          	<span class="keyword">int</span> i = a * a; <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在两个线程A，B，当A执行init发生了重排序，即先执行2，在执行1，当执行2时，B执行了use方法，但是B拿到的a还是0，所以i = 0，而正确的答案应该是i = 1</p>
<p>解决上面问题有两种方案：</p>
<ol>
<li>内存屏障（volatile），禁止关于a的指令重排</li>
<li>synchronized锁，锁住该对象或者该类</li>
</ol>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p><img src="https://img-blog.csdnimg.cn/20210302003053823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1NjAwMA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>本地方法栈，程序计数器，虚拟机栈都是线程私有的，不存在线程安全<br>方法区和堆区，所有线程共享的，需要加锁保证线程安全</p>
<ul>
<li>程序计数器：占用内存小，线程私有，生命周期与线程相同，大致为字节码行号指示器</li>
<li>虚拟机栈：java方法执行的内存模型，包含局部变量表，操作栈，动态链接，方法出口等信息，用于管理java方法的调用，使用连续的内存空间</li>
<li>本地方法栈：本地方法栈用于管理<strong>本地方法</strong>的调用</li>
</ul>
<hr>
<ul>
<li>堆区：与jvm生命周期相同，存储所有的对象实例（包括数组）</li>
<li>方法区：存储已被加载的类信息，常量池，静态变量，即使编译器编译后的代码</li>
</ul>
<blockquote>
<p>静态变量创建在方法区，程序结束后回收，与堆无关</p>
</blockquote>
<blockquote>
<p>stack的大小默认为1M，如果是递归调用，大概只支持800多次</p>
</blockquote>
<h4 id="JVM内存模型的三大特性"><a href="#JVM内存模型的三大特性" class="headerlink" title="JVM内存模型的三大特性"></a>JVM内存模型的三大特性</h4><p><strong>原子性</strong>：多线程情况下，一旦一个线程开始执行，就不能被其他线程干扰</p>
<p>可见行：当一个线程修改了变量后及时更新到主存</p>
<p>有序性：处理器在执行运算的时候，会对程序代码进行乱序执行优化，也叫做重排序优化</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p><img src="https://pic4.zhimg.com/80/v2-40cbacd540b1555badbbf89132aace5f_1440w.jpg" alt="img"></p>
<h4 id="如何判断对象是个垃圾？"><a href="#如何判断对象是个垃圾？" class="headerlink" title="如何判断对象是个垃圾？"></a>如何判断对象是个垃圾？</h4><ol>
<li>引用计数法<br>要操作对象必须使用引用，所以通过引用计数来判断对象是否需要被回收。因为无法解决循环引用的问题，所以JAVA中并没有采用这种方式（python中采用）</li>
<li>可达性分析法<br>为了解决循环引用的问题，使用可达性分析。通过一系列的”GC ROOT”对象作为起点进行搜索，如果在”GC ROOT”和对象之间没有可达路径，那么该对象为不可达对象，并标记一次，标记两次后就会被回收。<br>“GC ROOT”：<ul>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表）；</li>
<li>方法区中的常量引用的对象；</li>
<li>方法区中的类静态属性引用的对象；</li>
<li>本地方法栈中JNI（Native方法）的引用对象。</li>
<li>活跃线程对象<blockquote>
<p>垃圾回收机制是针对堆区的回收</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="比较常见的将对象判定为可回收变量"><a href="#比较常见的将对象判定为可回收变量" class="headerlink" title="比较常见的将对象判定为可回收变量"></a>比较常见的将对象判定为可回收变量</h4><ol>
<li>某个引用对象为null<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
<li>已经指向某个对象的引用指向新的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">obj1 = obj2;</span><br></pre></td></tr></table></figure></li>
<li>局部引用所指向的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">.....</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
循环每执行完一次，生成的Object对象都会成为可回收的对象。</li>
<li>只有弱引用修饰的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wr = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ol>
<li>标记清除算法<br>将可回收对象标记后指定删除对象<br>缺点：产生大量内存碎片</li>
<li>复制算法<br>为了解决内存碎片的问题，提出复制算法。把内存按容量分成两份，当一份用完了，将还存活的对象复制在另一块对象中，把已使用的内存空间一次性清理掉<br>缺点：空间上的两倍消耗，可使用内存空间减半</li>
<li>标记整理算法<br>为了充分利用内存空间，在标记回收对象后，将存活对象向一端移动，然后清理掉端边界以外的内存</li>
<li>分代回收算法<br>将内存分为新生代，老年代和永久代。<br>新生代：<br>使用复制算法，回收大量对象，但不是按照1:1分配内存空间，将内存空间分为3份，较大的Eden和两块较小的Survivor空间，每次使用Eden和一块Survivor，当进行回收时，会将Eden和一块Survivor中存活的对象复制到另一个Survivor中。（比例为8:1:1）<br>老年代：<br>使用标记整理算法（和标记清除算法—-垃圾收集器种说），回收少量对象<br>永久代：<br>存在于方法区，不属于堆区，用来存储class类，常量，方法描述等，对永久代的回收主要包含两种：废弃常量和无用的类</li>
</ol>
<p>注意: 在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</p>
<blockquote>
<p>新生代 = 1/3的堆空间大小，老年代 = 2/3的对空间大小</p>
</blockquote>
<blockquote>
<p>新创建的对象都是在Eden区，<strong>大对象</strong>因为在新生代复制会影响性能，则直接创建在老年代</p>
</blockquote>
<blockquote>
<p>在Survivor中复制一次，就年龄计数+1，当年龄大大于15岁时，会移动到老年区</p>
</blockquote>
<h4 id="jdk7和jdk8上的JVM内存结构的变化？"><a href="#jdk7和jdk8上的JVM内存结构的变化？" class="headerlink" title="jdk7和jdk8上的JVM内存结构的变化？"></a>jdk7和jdk8上的JVM内存结构的变化？</h4><p>jdk7:</p>
<ol>
<li><img src="https://pic4.zhimg.com/80/v2-d3426c78d9d7f20874b25377bd37c193_720w.jpg" alt="堆和方法区的物理存储"><br>在物理存储上，堆区和方法区是连续的，但是在逻辑上是分离的，因为物理存储上是存在一起的，所以在Full GC时，会触发堆永久代的回收</li>
</ol>
<p>jdk8:</p>
<ol>
<li>取消永久代，将类的结构等信息放入Native内存区，常量池和静态变量/全局变量存储在堆区</li>
<li>方法区存在元空间中，Native内存区就是元空间区</li>
</ol>
<blockquote>
<p>Native Memory（本地内存），空间不足，不会触发gc</p>
</blockquote>
<h4 id="为什么使用元空间替代永久代？"><a href="#为什么使用元空间替代永久代？" class="headerlink" title="为什么使用元空间替代永久代？"></a>为什么使用元空间替代永久代？</h4><p>避免永久代的OOM发生，因为需要加载的类的总数，方法总数难以确定，分配的空间也难以确定，为了避免OOM，使用元空间，理论上可以获得本地内存中所有可用的空间</p>
<h4 id="字符常量池存在那？"><a href="#字符常量池存在那？" class="headerlink" title="字符常量池存在那？"></a>字符常量池存在那？</h4><p>1.6：存储在方法区<br>1.7：对象存储在堆区中，引用存在字符串常量池，都在堆中<br>1.8：存储在堆区中</p>
<h4 id="运行时常量池在哪？"><a href="#运行时常量池在哪？" class="headerlink" title="运行时常量池在哪？"></a>运行时常量池在哪？</h4><p>1.8的时候移动到元空间中，之前都在方法区中</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p><img src="https://pic3.zhimg.com/80/v2-f5426caf176fac7d2d7edcf43e127eaa_1440w.jpg" alt="img"><br>java种使用的是HotSpot虚拟机，HotSpot一共7种垃圾收集器，大致分为3类：<br>新生代收集器：Serial，ParNew，Parllel Scavenge<br>老年代收集器：Serial Old，CMS，Parllel Old<br>回收整个堆的G1收集器</p>
<ul>
<li>Serial（复制）：新生代单线程收集器，在标记和清理都是单线程，优点是效率高，缺点是停留时间长。</li>
<li>ParNew（复制）：新生代并行收集器，Serial的多线程版本，在多核cpu环境下比Serial表现更好（只有他能和CMS配合）</li>
<li>Parllel Scavenge（复制）：新生代并行收集器，追求高吞吐量，高效利用CPU。尽快完成程序的运算任务，适合后台应用等对交互场景要求不高的场景。<br>吞吐量 = 用户线程时间/（用户线程时间+GC线程时间），缩短工作线程的等待时间</li>
<li>Serial Old（标记-整理）：老年代的单线程收集器，老年版的单线程</li>
<li>Parllel Old（标记-整理）：老年代的并行收集器，老年版的Parllel Scavenge</li>
<li>CMS（Concurrent Mark Sweep）（标记-清除）：老年代并行收集器，以获取最短回收停顿时间为目标，具有高并发，低停顿的特点。追求最短GC回收停顿时间，就是GC的时间更短<br>缺点：<ol>
<li>对CPU资源异常敏感，应用程序变慢，吞吐率下降</li>
<li>无法处理浮动垃圾。因为在标记和清除的时候，工作线程是运行的，所以期间会产生新的垃圾，但是本次无法回收。</li>
<li>产生大量内存碎片，会提前触发Full GC</li>
</ol>
</li>
<li>G1（Garbage First）(标记-整理)：java并行收集器，G1的回收范围包含新生代和老年代。他用来作为下一代的收集器，保存新生代和老年代的概念，但是内部将Java堆划分为多个大小相等Region独立区域<br>优点：<ol>
<li>并行和并发。使用多个CPU缩短回收停顿时间，与用户线程并发执行</li>
<li>分带收集。独立去管理整个堆区间，能够采用不同的方式去处理<strong>新创建对</strong>象和<strong>已经存活了一段时间、熬过多次GC的旧对象</strong>，以获取更好的收集效果</li>
<li>使用标记-整理算法。无内存碎片产生。</li>
<li>可预测的停顿。可以使开发者制定一个时间长度，在该时间长度内，需要完成垃圾回收。</li>
</ol>
</li>
</ul>
<blockquote>
<p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合</p>
</blockquote>
<h4 id="gc的种类和方式"><a href="#gc的种类和方式" class="headerlink" title="gc的种类和方式"></a>gc的种类和方式</h4><ol>
<li>Minor GC：新生代GC<ul>
<li>当Eden（[‘id(ə)n]）区放满的时候，触发Minor GC</li>
</ul>
</li>
<li>Major GC：老年代GC</li>
<li>Full GC：全局GC（青年+老年）<ul>
<li>System.gc()方法有可能触发Full GC</li>
<li>老年代存储满了</li>
<li>永久代存储满了，触发Full GC，针对常量池的回收和类型的卸载</li>
<li>Minor GC后放入老年代大小&gt;老年代可用内存，即老年代放不下</li>
<li>Minor GC后，放入一个1区中时，放不下，溢出来部分放入老年区，老年区放不下就会触发Full GC<blockquote>
<p>GC会触发“stop-the-world”，即工作线程全部关闭，进行gc回收，当gc回收结束后，才会执行任务</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36520235/article/details/82417949">（1）美团面试题：Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析</a></p>
<h4 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h4><p>影响性能的两个参数：</p>
<ul>
<li>初始容量：2的幂，默认是16</li>
<li>加载因子：什么时候扩容的标志，默认0.75，即16*0.75=12的时候开始hashmap扩容（容量为原来的2倍）</li>
</ul>
<ul>
<li>最大容量：2的30次方，如果大于，则使用2的30次方的大小</li>
<li>可以存储key == null，value == null，key == null则存储在table[0]位置</li>
<li>删除元素的本质是“删除单向链表的节点”</li>
<li>Entry是单向链表</li>
</ul>
<p>计算key的hash值，并将hash值添加到对应的链表中，若key存在，则更新vlaue值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">//计算出来的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;     <span class="comment">//key</span></span><br><span class="line">    V value;         <span class="comment">//value</span></span><br><span class="line">    Node&lt;K,V&gt; next;  <span class="comment">//链表next引用</span></span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>和修改</p>
<ul>
<li>因为是非synchronized的，非线程安全，所以比较快</li>
<li>HashMap可以接受null键和null值</li>
</ul>
<h4 id="数组下标index的计算过程"><a href="#数组下标index的计算过程" class="headerlink" title="数组下标index的计算过程"></a>数组下标index的计算过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组长度-1 &amp; hash值</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>
<p>同等于hash值对数组长度的求余</p>
<h4 id="描述一下具体的put过程"><a href="#描述一下具体的put过程" class="headerlink" title="描述一下具体的put过程"></a>描述一下具体的put过程</h4><ol>
<li>对key求hash值，然后计算数组下标</li>
<li>如果数组下标没有碰撞，将Node放置在数组中</li>
<li>如果碰撞，将Node以链表的形式连接在后面</li>
<li>如果链表长度超过阈值（8），将链表转化为红黑树，链表长度低于6，则将红黑树转回链表</li>
<li>如果节点存在，则替换旧值</li>
<li>如果数组快满了（最大容量16*加载因子0.75），就需要resize（扩容两倍）</li>
</ol>
<h4 id="为什么选择6和8-？"><a href="#为什么选择6和8-？" class="headerlink" title="为什么选择6和8 ？"></a>为什么选择6和8 ？</h4><p>因为中间7的位置放置频繁的数据结构切换后，影响性能</p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><ol>
<li>计算key的hash，在计算index值</li>
<li>在数组中查找index值，在比对key值，取出value，复杂度最好是O(1)，最坏为O(n)</li>
</ol>
<h4 id="为什么不直接使用红黑树？"><a href="#为什么不直接使用红黑树？" class="headerlink" title="为什么不直接使用红黑树？"></a>为什么不直接使用红黑树？</h4><p>空间和时间的选择，链短的时候空间上占用小，时间还好，转化为红黑树后，便于查找，但是耗费空间。</p>
<h4 id="处理hash冲突的方法有以下几种："><a href="#处理hash冲突的方法有以下几种：" class="headerlink" title="处理hash冲突的方法有以下几种："></a>处理hash冲突的方法有以下几种：</h4><ol>
<li>开放地址法（线性探测再散列（碰撞后，位置后挪，数组长度+x）x可为正数，二次探测再散列（数组长度+x的平方）x可为正负数，平方后均为正数）</li>
<li>再哈希法（多种计算哈希的方法，相同则替换方法，直到算出不重复的哈希值）</li>
<li>链地址法（链表）</li>
<li>建立公共溢出区（建立一个溢出表，存放冲突的数据）</li>
</ol>
<h4 id="HashMap的性能慢原因？"><a href="#HashMap的性能慢原因？" class="headerlink" title="HashMap的性能慢原因？"></a>HashMap的性能慢原因？</h4><ul>
<li>数据类型自动装箱问题</li>
<li>resize扩容重新计算index值和hashcode，重新赋值（1.7）<br>1.8后，扩容位置 = hash值 &amp; 数组长度，如果为0，则不动，反之则反</li>
</ul>
<h4 id="线程不安全会导致什么"><a href="#线程不安全会导致什么" class="headerlink" title="线程不安全会导致什么"></a>线程不安全会导致什么</h4><p>环状链表，resize（扩容）时头插法导致环形链表（1.7版本）</p>
<p>都存在数据丢失的问题数据丢失，1.8版本修复环形链表（尾插）</p>
<h4 id="HashMap中默认容量为什么是2的幂？"><a href="#HashMap中默认容量为什么是2的幂？" class="headerlink" title="HashMap中默认容量为什么是2的幂？"></a>HashMap中默认容量为什么是2的幂？</h4><p>因为如果不是2的幂，可能会造成更多的hash碰撞（index 下标碰撞）<br>假设n为17，n-1的二进制为10000，01001和01101算出的index值均为0<br>假设n为16，n-1的二进制为01111，01001和01101算出的index值不同</p>
<h4 id="hashcode计算原理"><a href="#hashcode计算原理" class="headerlink" title="hashcode计算原理"></a>hashcode计算原理</h4><p>对于int类型，hashcode为它本身，eg：int i = 1;   hashcode = 1;<br>对于对象来说，hashcode是内部地址和对象值的一个映射</p>
<h4 id="hash-算法原理"><a href="#hash-算法原理" class="headerlink" title="hash()算法原理"></a>hash()算法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到key的hashCode()，在将该值与该值的高16位（h无符号右移16位）进行亦或运算（相同为0，不同为1）</p>
<h4 id="HashTable的理解"><a href="#HashTable的理解" class="headerlink" title="HashTable的理解"></a>HashTable的理解</h4><p>put和get方法是用了synchronized修饰，锁住了整个map，同一时刻只有一个线程可以操作</p>
<p>不可以存储null值和null健</p>
<h4 id="SparseArray理解"><a href="#SparseArray理解" class="headerlink" title="SparseArray理解"></a>SparseArray理解</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>装箱，int数据类型—-&gt;Integer对象，拆箱，Integer对象—-&gt;int数据类型</p>
<p>默认容量是10</p>
<ul>
<li>key是int值（避免装箱问题），使用二分查找寻找key，同样也是用二分插入，从小到大排列好的</li>
<li>两个数组，一组存放key（int []），一组存放value(object [])</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mKeys[i] = key;</span><br><span class="line">mValues[i] = value;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果冲突，直接替换value的值</li>
</ul>
<p>二分插入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标处的值</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值小，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的中后部部分，所以当前下标取值为mid + 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               lo = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值大，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的前中部部分，所以当前下标取值为mid - 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               hi = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//数组中间处的值与要找的值相等，直接返回数组中部的下标mid</span></span><br><span class="line">               <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>第一个值放到最中间位置</p>
<p>第二个值如果大于中间的值放置在左边的中间位置</p>
<p>………….</p>
<p>put方法中，容量充足，计算key值所需存放的index，如果key相同，就直接替换value，如果不同，就insert数组，后续index元素后移，新key放置在index上</p>
<h5 id="较HashMap的优点"><a href="#较HashMap的优点" class="headerlink" title="较HashMap的优点"></a>较HashMap的优点</h5><ul>
<li>节省内存</li>
<li>性能更好，避免装箱问题</li>
<li>数据量不达到千级，key为int值，可以用SparseArray替换HashMap</li>
</ul>
<h4 id="SparseArray与HashMap的比较，应用场景是？"><a href="#SparseArray与HashMap的比较，应用场景是？" class="headerlink" title="SparseArray与HashMap的比较，应用场景是？"></a>SparseArray与HashMap的比较，应用场景是？</h4><ol>
<li>SparseArray采用的不是哈希算法，HashMap采用的是哈希算法</li>
<li>SparseArray采用的是两个一维数组分别用于存储键和值，HashMap采用的是一维数组+单向链表/红黑树</li>
<li>SparseArray key只能是int类型，而HashMap可以任何类型</li>
<li>SparseArray  key是有序存储（升序），而HashMap不是</li>
<li>SparseArray 默认容量是10，而HashMap默认容量是16</li>
<li>SparseArray 内存使用要优于HashMap，因为：<ul>
<li>SparseArray key是int类型，而HashMap是Object</li>
<li>SparseArray value的存储被不像HashMap一样需要额外的需要一个实体类（Node）进行包装</li>
</ul>
</li>
<li>SparseArray查找元素总体而言比HashMap要逊色，因为SparseArray查找是需要经过二分法的过程，而HashMap不存在冲突的情况其技术处的hash对应的下标直接就可以取到值</li>
</ol>
<p>针对上面与HashMap的比较，采用SparseArray还是HashMap，建议根据如下需求选取：</p>
<ol>
<li>如果对内存要求比较高，而对查询效率没什么大的要求，可以是使用SparseArray</li>
<li>数量在百级别的SparseArray比HashMap有更好的优势</li>
<li>要求key是int类型的，因为HashMap会对int自定装箱变成Integer类型</li>
<li>要求key是有序的且是升序</li>
</ol>
<h4 id="ArrayMap的理解"><a href="#ArrayMap的理解" class="headerlink" title="ArrayMap的理解"></a>ArrayMap的理解</h4><p>内部也使用二分算法进行存储和查找，设计上更多考虑了内存中的优化</p>
<ul>
<li>int []存储hash值，array[index]存储key，array[index+1]存储value</li>
</ul>
<blockquote>
<p>数据量最好在千级以内</p>
</blockquote>
<h4 id="ArrayMap和SparseArray怎么进行选取？"><a href="#ArrayMap和SparseArray怎么进行选取？" class="headerlink" title="ArrayMap和SparseArray怎么进行选取？"></a>ArrayMap和SparseArray怎么进行选取？</h4><ol>
<li>如果key为int，那么选取SparseArray进行存储， 不存在封/拆箱问题</li>
<li>如果key不为int，则使用ArrayMap</li>
</ol>
<h4 id="TreeMap的理解"><a href="#TreeMap的理解" class="headerlink" title="TreeMap的理解"></a>TreeMap的理解</h4><p>TreeMap是一个二叉树的结构，红黑树</p>
<p>不允许重复的key</p>
<p>TreeMap没有调优选项，因为其红黑树总保持在平衡状态</p>
<h4 id="TreeMap和HashMap的区别？"><a href="#TreeMap和HashMap的区别？" class="headerlink" title="TreeMap和HashMap的区别？"></a>TreeMap和HashMap的区别？</h4><ol>
<li>TreeMap由红黑树构成，HashMap由数组+链表/红黑树构成</li>
<li>HashMap元素没有顺序，TreeMap元素会根据可以进行升序排序</li>
<li>HashMap进行插入，查找，删除最好，TreeMap进行自然顺序便利或者自定义顺序便利比较好</li>
</ol>
<h4 id="ThreadLocal的理解"><a href="#ThreadLocal的理解" class="headerlink" title="ThreadLocal的理解"></a>ThreadLocal的理解</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wang-meng/p/12856648.html#:~:text=ThreadLocalMap%20%E6%9C%89%E7%82%B9%E7%B1%BB%E4%BC%BC%20HashMap%20%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8F%AA%E6%98%AF%20HashMap%20%E6%98%AF%E7%94%B1%20%E6%95%B0%E7%BB%84%2B%E9%93%BE%E8%A1%A8%20%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E8%80%8C,key%20%E6%98%AF%20ThreadLocal%3C%3F%3E%20k%20%EF%BC%8C%E7%BB%A7%E6%89%BF%E8%87%AA%20WeakReference%20%EF%BC%8C%20%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E5%B8%B8%E8%AF%B4%E7%9A%84%E5%BC%B1%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E3%80%82">面试官：小伙子，听说你看过ThreadLocal源码？（万字图文深度解析ThreadLocal）</a></p>
<p>线程隔离，数据不交叉</p>
<ul>
<li>ThreadLocalMap，每个thread都存在一个变量ThreadLocalMap threadLocals</li>
<li>threadLocalMap中存在Entry，同ThreadLocal之间为弱引用关系</li>
<li>ThreadLocalMap中key为ThreadLocal的弱引用，value为Entry，内部为一个object对象</li>
<li>table默认大小为16，存在初始容量（16）和阈值（16*2/3）</li>
<li>在ThreadLocal中使用get()和set()方法初始化threadLocals</li>
<li>get、set、remove方法将key==null的数据清除</li>
<li>table是环形数组</li>
</ul>
<p>线性探测法避免哈希冲突，增量查找没有被占用的地方</p>
<p>通过hashcode计算索引位置，如果key值相同，则替换，不同就nextIndex，继续判断，直到插入数据</p>
<p>ThreadLocal就是管理每个线程中的ThreadLocalMap，所以线程隔离了。</p>
<h4 id="ThreadLocalMap的理解"><a href="#ThreadLocalMap的理解" class="headerlink" title="ThreadLocalMap的理解"></a>ThreadLocalMap的理解</h4><p>新建ThreadLcoal的时候，创建一个ThreadLocalMap对象，计算hash的时候使用0x61c88647这个值，他是黄金分割数，导致计算出来的hash值比较均匀，这样回大大减少hash冲突，内部在采用线性探测法解决冲突<br>set：</p>
<ol>
<li>根据key计算出数组索引值</li>
<li>遍历该索引值的链表，如果为空，直接将value赋值，如果key相等，直接更新value，如果key不相等，使用线性探测法再次检测。</li>
</ol>
<h4 id="ThreadLocal使用弱引用的原因"><a href="#ThreadLocal使用弱引用的原因" class="headerlink" title="ThreadLocal使用弱引用的原因"></a>ThreadLocal使用弱引用的原因</h4><p>key使用了弱引用，如果key使用强引用，那么当ThreadLocal的对象被回收了，但ThreadLocalMap还持有ThreadLocal的强引用，回导致ThreadLocal不会被回收，导致内存泄漏</p>
<h4 id="ThreadLocal的内存泄漏"><a href="#ThreadLocal的内存泄漏" class="headerlink" title="ThreadLocal的内存泄漏"></a>ThreadLocal的内存泄漏</h4><ul>
<li>避免使用static修饰ThreadLocal：延长生命周期，可能造成内存泄漏</li>
<li>ThreadLocal弱引用被gc回收后，则key为null，object对象没有被回收，只有当再次调用set，get，remove方法的时候才会清楚key为null的对象</li>
</ul>
<h4 id="ThreadLocalMap清理过期key的方式"><a href="#ThreadLocalMap清理过期key的方式" class="headerlink" title="ThreadLocalMap清理过期key的方式"></a>ThreadLocalMap清理过期key的方式</h4><ol>
<li>探测式清理<br>本该放在4的位置上的值，放到了7的位置上，当5过时后，将7的数据挪到5的位置上</li>
<li>启发式清理<br>遍历数组，清理数据</li>
</ol>
<h4 id="ConcurrentHashMap和HashMap的区别"><a href="#ConcurrentHashMap和HashMap的区别" class="headerlink" title="ConcurrentHashMap和HashMap的区别"></a>ConcurrentHashMap和HashMap的区别</h4><p>jdk  1.7 ReentrantLock+segments + hashEntry(不可变)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2843224-25151c12024f0bfb.png" width="50%"/></p>
<ul>
<li>线程安全，分段线程锁，hashtable是整段锁，所以性能有所提高</li>
<li>默认分配16个锁，比Hashtable效率高16倍</li>
<li>hashEnty是final的，不能被修改，只要被修改，该节点之前的链就要重新创建，采用头插插入，所以顺序反转</li>
<li>获取size，因为是多线程访问，所以size会获取三遍，如果前后两个相等就返回，假设不相等，就将Segment加锁后计算。</li>
</ul>
<p>jdk 1.8 ： synchronized +node+volatile+红黑树</p>
<p>put：</p>
<ol>
<li>根据key的hash值算出Node数组的相应位置</li>
<li>如果该Node不为空，且当前该节点不处于移动状态，则对节点加synchronized锁，进行遍历节点插入操作</li>
<li>如果是红黑树节点，向红黑树插入操作</li>
<li>如果大于8个，拓展为红黑树</li>
</ol>
<p>get：</p>
<ol>
<li>计算hash值，定位到该table索引位置，如果是首节点符合就返回</li>
<li>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，通知在新表中查找该节点，匹配就返回</li>
<li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</li>
</ol>
<p>1.7和1.8的区别：</p>
<ol>
<li><p>1.7：ReentrantLock+segments + hashEntry(不可变)</p>
<pre><code>1.8：synchronized +node+volatile+红黑树
</code></pre></li>
<li><p>1.8的锁的粒度更低，锁的是一个链表（table[i]），而1.7锁的是一个小的hashmap（segement）</p>
</li>
<li>ReentrantLock性能比synchronized差</li>
</ol>
<p>扩容：</p>
<p>1.7下进行小HashMap（segement）扩容操作</p>
<p>1.8下使用synchrozied节点加锁，所以可以通过多个线程扩容处理。一个线程创建新的ConcurrentHashMap，并设置大小，多个线程将旧的内容添加到新的map中，如果添加过的内容就会设置标记，其他线程就不会处理</p>
<h4 id="为什么只有hashmap可以存储null值和null键"><a href="#为什么只有hashmap可以存储null值和null键" class="headerlink" title="为什么只有hashmap可以存储null值和null键"></a>为什么只有hashmap可以存储null值和null键</h4><p>因为hashmap是线程不安全的，而在其他中都是线程安全的，在多线程访问时，无法判断key为null是没有找到，还是key为null</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="常见锁"><a href="#常见锁" class="headerlink" title="常见锁"></a>常见锁</h3><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ol>
<li><p>公平锁/非公平锁</p>
<ul>
<li>公平锁：多个线程按照申请锁的顺序获取锁。</li>
<li>非公平锁：多个线程申请锁并不是按照顺序获取锁，有可能先申请后获取锁。（Synchronized）</li>
</ul>
<blockquote>
<p>ReentrantLock默认是非公平锁，通过构造传参可设置为公平锁。非公平锁的优点在于吞吐量比公平锁大</p>
</blockquote>
</li>
<li>可重入锁：又名递归锁，指在外层方法获取锁以后，在进入内层方法也会自动获取锁。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title">Exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title">Exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果不是可重入锁，那么setB方法不会被当前线程执行，容易造成死锁<blockquote>
<p>synchronized是可重入锁</p>
</blockquote>
</li>
<li>独享锁/共享锁<ul>
<li>独享锁：一个锁一次只能被一个线程所持有（ReentrantLock，synchronized）</li>
<li>共享锁：一个锁被多个线程所持有。（ReadWriteLock）</li>
</ul>
</li>
<li>互斥锁/读写锁<br>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。<br>互斥锁在Java中的具体实现就是ReentrantLock<br>读写锁在Java中的具体实现就是ReadWriteLock</li>
<li>乐观锁/悲观锁<ul>
<li>悲观锁：对同一数据的并发操作，一定会发生修改的。（利用各种锁实现）</li>
<li>乐观锁：对同一数据的并发操作，一定不会发生修改的。（无锁编程，CAS算法，自旋实现原子操作的更新）</li>
</ul>
</li>
<li>分段锁<br>是一种锁的设计，并不是具体的锁，在1.7版本的ConcurrentHashMap中，使用分段锁设计，该分段锁又称为Segment，map中每一个链表由ReentrantLock修饰</li>
<li><p>偏向锁/轻量级锁/重量级锁<br>这三种锁是描述synchronized的三种状态。</p>
<ul>
<li>偏向锁：一段同步代码一直被一个线程访问，那么会自动获取锁，降低获取锁的代价</li>
<li>轻量级锁：当锁是偏向锁的时候，被另一个线程访问，偏向锁会升级为轻量级锁，其他线程通过自旋的方式获取锁，不会阻塞，提高性能</li>
<li>重量级锁：在轻量级锁的基础上，自旋达到上限就会阻塞，升级为重量级锁，会让其他线程进入阻塞，影响性能。</li>
</ul>
<blockquote>
<p>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后无法降为偏向锁，这种升级无法降级的策略目的就是为了提高获得锁和释放锁的效率。</p>
</blockquote>
</li>
<li>自旋锁<br>获取锁的过程中，不会立即阻塞，会采用循环的方式获取锁，<strong>减少线程切换上下文的消耗</strong>，缺点是循环会<strong>消耗cpu</strong></li>
</ol>
<h4 id="java中常用锁的类型"><a href="#java中常用锁的类型" class="headerlink" title="java中常用锁的类型"></a>java中常用锁的类型</h4><ol>
<li>synchronized：非公平，悲观，独享，互斥，可重入，重量级锁</li>
<li>ReentrantLock：默认非公平（可公平），悲观，独享，互斥，可重入，重量级锁</li>
</ol>
<blockquote>
<p>CAS，全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM 只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p>
</blockquote>
<h3 id="synchronized和volatile"><a href="#synchronized和volatile" class="headerlink" title="synchronized和volatile"></a>synchronized和volatile</h3><h4 id="简述synchronized的原理"><a href="#简述synchronized的原理" class="headerlink" title="简述synchronized的原理"></a>简述synchronized的原理</h4><p>可见性：表示A修改的值对于B执行时可以看见A修改后的值</p>
<ul>
<li>内部使用<strong>monitorenter</strong>指令，同时只有一个线程可以获取monitor</li>
<li>未获取monitor的线程会被阻塞，等待获取monitor</li>
<li>线程A获取主内存值后加锁，在本地内存更新值（临时区）后，推送到主内存，通过synchronized隐式通知线程B访问主存获取值，在B的把本地内存更新值后推送到主存，重复以上操作。</li>
</ul>
<p>通过Monitor对象来实现方法和代码块的同步，存在monitorEnter和monitorExit指令，插入程序中，在一个线程访问时，通过Monitor进行线程阻塞</p>
<h4 id="synchronized修饰静态方法、⾮静态方法区别"><a href="#synchronized修饰静态方法、⾮静态方法区别" class="headerlink" title="synchronized修饰静态方法、⾮静态方法区别"></a>synchronized修饰静态方法、⾮静态方法区别</h4><p>静态方法：该类的对象，new出来的多个实例对象是被一个锁锁住的，多线程访问需要等待</p>
<p>非静态方法：实例对象</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>修饰成员变量，保证可见性，下一个操作再上一个操作之上。++操作不保证和原子性，</p>
<p>将本地缓存同步到主存中，使其他本地缓存失效，本地缓存通过嗅探检查自己的缓存是否过期。（下一次访问，主存不会主动通知）</p>
<p>volatile无法保证原子性，可以使用乐观锁的重试机制进行优化</p>
<h4 id="synchronized和volatile区别"><a href="#synchronized和volatile区别" class="headerlink" title="synchronized和volatile区别"></a>synchronized和volatile区别</h4><ul>
<li><p>Synchronized 引起线程阻塞，而volatile不会</p>
</li>
<li><p>区别在于，synchronized是隐式通知B去主存获取值，volatile是B主动通过嗅探的方法发现自己的内存过期后去主存做同步</p>
</li>
<li><p>synchronized：先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</p>
</li>
<li><p>都存在可见性，但是volatile不具备原子性，所以不会造成线程阻塞</p>
<p>假设某一时刻i=10，线程A读取10到自己的工作内存，A对该值进行加一操作，但正准备将11赋给i时，由于此时i的值并未改变，B读取了主存的值仍为10到自己的工作内存，并执行了加一操作，正准备将11赋给i时，A将11赋给了i，由于volatile的影响，立即同步到主存，主存中的值为11，并使得B工作内存中的i失效，B执行第三步，虽然此时B工作内存中的i失效了，但是第三步是将11赋给i，对B来说，我只是赋值操作，并没有使用i这个动作，所以这一步并不会去刷新主存，B将11赋值给i，并立即同步到主存，主存中的值仍为11。虽然A/B都执行了加一操作，但主存却为11，这就是最终结果不是10000的原因。</p>
</li>
<li><p>synchronized修饰方法，类，变量，代码块，volatile只能修饰变量</p>
</li>
</ul>
<h4 id="synchronized修饰不同对象的区别"><a href="#synchronized修饰不同对象的区别" class="headerlink" title="synchronized修饰不同对象的区别"></a>synchronized修饰不同对象的区别</h4><ol>
<li>修饰类：作用的对象是这个类的所有对象</li>
<li>方法：作用对象是这个方法的对象</li>
<li>静态方法：作用对象是这个类的对象</li>
<li>代码块：作用对象是这个代码块的对象</li>
</ol>
<h4 id="悲观锁和乐观锁（CAS）"><a href="#悲观锁和乐观锁（CAS）" class="headerlink" title="悲观锁和乐观锁（CAS）"></a>悲观锁和乐观锁（CAS）</h4><p>悲观锁：当前线程获得锁会阻塞其他线程（sychronized）</p>
<p>乐观锁：不会添加锁，会存在三个值内存实际值，内存的旧值，更新的新值，如果内存实际值和旧值相等，则没有线程修改该值，将更新的新值直接赋值给内存，如果不相等，就重新尝试赋值操作（volatile）</p>
<p>CAS的缺点：</p>
<ol>
<li>ABA问题，A-&gt;B-&gt;A，乐观锁认为没有变化，都是A，所以直接赋值</li>
<li>重新赋值的话，会导致时间过长。</li>
</ol>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>CAS+AQS实现，乐观锁</p>
<p>AQS（单链表队列）维护一个等待队列，将获取不到锁的线程放入到队列中进行等待，当当前线程执行结束后，进行出队操作，使用一个volatile的int成员变量（state）来表示同步状态</p>
<p>通过ReentrantLock的Lock方法进行加锁</p>
<p>通过ReentrantLock的unLock方法进行解锁</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="新建线程有几种方式？"><a href="#新建线程有几种方式？" class="headerlink" title="新建线程有几种方式？"></a>新建线程有几种方式？</h4><ol>
<li>new Thread</li>
<li>新建Runnable对象</li>
<li>新建Callable或者Future对象</li>
<li>线程池使用</li>
</ol>
<h4 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h4><p>执行一个异步任务你还只是如下new Thread吗？<br>new Thread的弊端如下：</p>
<ol>
<li>每次new Thread新建对象性能差。</li>
<li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。</li>
<li>缺乏更多功能，如定时执行、定期执行、线程中断。</li>
</ol>
<p>相比new Thread，Java提供的四种线程池的好处在于：</p>
<ol>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳。</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能。</li>
</ol>
<h4 id="线程池-2"><a href="#线程池-2" class="headerlink" title="线程池"></a>线程池</h4><p><a href="#简述线程池">简述线程池</a></p>
<h4 id="线程的5种状态"><a href="#线程的5种状态" class="headerlink" title="线程的5种状态"></a>线程的5种状态</h4><ul>
<li>NEW：创建一个新线程</li>
<li>RUNNABLE：可运行</li>
<li>BLOCKED：阻塞</li>
<li>WAITING：进入等待状态</li>
<li>TIMED_WAITING：等待结束，重新获取锁</li>
<li>TERMINATED：结束</li>
<li>RUNNING：运行中</li>
<li>READY：就绪</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4840092-f85e70e2262b7878.png" alt="img"></p>
<p>一般来说分为五大状态：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/09/716271-20170320112245721-1831918220.jpg" alt="img"></p>
<ol>
<li>新建（New）：<br>创建线程对象，进入新建状态。eg：Thread thread = new Thread();</li>
<li>就绪（Runnable）：<br>调用thread.start()方法，随时可被cpu执行</li>
<li>运行（Runnable）：<br>CPU执行线程</li>
<li>阻塞（Blocked）：<br>出于某些原因，cpu放弃线程执行，线程进入暂停状态<ul>
<li>等待阻塞：调用wait方法，进行阻塞，线程等待某工作完成</li>
<li>同步阻塞：在获取Synchronized同步锁时，进行等待</li>
<li>其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
</li>
<li>死亡（Dead）：<br>堪称执行完毕或者因异常退出，线程死亡，回收</li>
</ol>
<h4 id="start和run的区别？sleep和wait的区别？join-yield，interrupt"><a href="#start和run的区别？sleep和wait的区别？join-yield，interrupt" class="headerlink" title="start和run的区别？sleep和wait的区别？join,yield，interrupt"></a>start和run的区别？sleep和wait的区别？join,yield，interrupt</h4><ul>
<li>start是启动一个线程</li>
<li>run只是Thread的实现方法，主要实现是Runnable的接口回调run方法</li>
<li>sleep不会释放对象锁，只是暂停了线程的运行，当指定时间到了，就恢复运行状态</li>
<li>wait方法放弃对象锁，只有调用了notify()方法，才会重新获取锁，进入运行状态</li>
<li>join方法是规定线程的执行顺序，如果在B线程中调用了A的join方法，那么，直到A执行完毕，才会执行B，按照顺序串行执行。实际内部方法是调用了wait方法，让B处于等待状态，A执行完成后，启动B</li>
</ul>
<blockquote>
<p>注意：wait方法是调用u哦在线程放弃对象锁，所以在B线程调用A的join方法，只是让B等待了。</p>
</blockquote>
<ul>
<li>yield方法，通知cpu该线程任务不紧急，可以被暂停让其他线程运行</li>
<li>interrupt方法，中断通知线程，具体操作由线程执行，根据不同状态，执行不同逻辑</li>
</ul>
<h4 id="线程t1、t2、t3，如何保证他们顺序执行？"><a href="#线程t1、t2、t3，如何保证他们顺序执行？" class="headerlink" title="线程t1、t2、t3，如何保证他们顺序执行？"></a>线程t1、t2、t3，如何保证他们顺序执行？</h4><p>t3开始中调用t2.join()，t2开始中调用t1.join()。</p>
<p>t1执行完毕后，t2中t1.join()方法不阻塞，即t1执行完，执行t2中的方法，后续类似<br>使用CountDownLacth，进行计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//引用t1线程，等待t1线程执行完</span></span><br><span class="line">                   t1.join();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//引用t2线程，等待t2线程执行完</span></span><br><span class="line">                   t2.join();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       t3.start();</span><br><span class="line">       t2.start();</span><br><span class="line">       t1.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>资源竞争互相等待</p>
<p>假设线程A，线程B，资源A，资源B</p>
<p>线程A访问资源A，持有资源A锁，线程B访问资源B，持有资源B锁，而后线程A要访问资源B，但是线程B持有资源B锁，线程A等待，线程B要访问资源A，但是线程A持有资源A锁。所以B等待。</p>
<p>结果就是A、B相互等待对方释放资源，造成死锁。</p>
<h4 id="一个线程崩溃会影响其他线程吗？"><a href="#一个线程崩溃会影响其他线程吗？" class="headerlink" title="一个线程崩溃会影响其他线程吗？"></a>一个线程崩溃会影响其他线程吗？</h4><p>不一定。<br>如果崩溃发生在堆区（线程共享区域），会导致其他线程崩溃。<br>如果崩溃发生在栈区（线程私有区域），不会导致其他线程的崩溃</p>
<h2 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h2><ol>
<li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</li>
<li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</li>
<li>反射也是考虑了线程安全的，放心使用；</li>
<li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li>
<li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</li>
<li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li>
<li>调度反射方法，最终是由jvm执行invoke0()执行；</li>
</ol>
<p>使用反射从jvm中的二进制码文件中读取数据</p>
<h4 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h4><p>.java–&gt;.class–&gt;java.lang.Class对象</p>
<p>编译过程：</p>
<ul>
<li>将.java文件编译成机器可以识别<strong>的二进制文件</strong>.class</li>
<li>.class文件中存储着类文件的各种信息。<br>比如版本号、类的名字、字段的描述和描述符、方法名称和描述、是不是public、类索引、字段表集合，方法集合等等数据</li>
<li>JVM从二进制文件.class中取出并拿到内存解析</li>
<li>类加载器获取类的二进制信息，并在内存中生成java.lang.Class对象</li>
<li>最后开始类的生命周期并初始化（先静态后非静态和构造，先父类在子类）</li>
</ul>
<p>而反射操作的就是内存中的java.lang.Class对象。</p>
<blockquote>
<p>总结来说.class是一种有顺序的结构文件,而Class对象就是对这种文件的一种表示，所以我们能从Class对象中获取关于类的所有信息，这就是反射的原理。</p>
</blockquote>
<h4 id="为什么反射耗时？"><a href="#为什么反射耗时？" class="headerlink" title="为什么反射耗时？"></a>为什么反射耗时？</h4><ol>
<li>校验时间长</li>
<li>基本类型的封箱和拆箱</li>
<li>方法内联</li>
</ol>
<h4 id="什么是内联函数？"><a href="#什么是内联函数？" class="headerlink" title="什么是内联函数？"></a>什么是内联函数？</h4><p>方法调用过多会进行内敛优化，减少方法的嵌套层级，加快执行，缓解栈的空间存储</p>
<h4 id="反射可以修改final类型的成员变量吗？"><a href="#反射可以修改final类型的成员变量吗？" class="headerlink" title="反射可以修改final类型的成员变量吗？"></a>反射可以修改final类型的成员变量吗？</h4><p>已知final修饰后不会被修改，所以获取这个变量的时候就直接帮你在编译阶段就给赋值了</p>
<blockquote>
<p>编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。</p>
</blockquote>
<p>所以上述的getName方法经过JVM编译内联优化后会变成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出来也是Bob</span></span><br><span class="line">System.out.println(user.name)</span><br><span class="line"><span class="comment">//经过内联优化</span></span><br><span class="line">System.out.println(<span class="string">&quot;Bob&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>反射是可以修改final变量的，但是如果是<strong>基本数据类型</strong>或者<strong>String类型</strong>的时候，无法通过对象获取修改后的值，因为JVM对其进行了内联优化。</p>
<h4 id="反射可以修改static值吗？"><a href="#反射可以修改static值吗？" class="headerlink" title="反射可以修改static值吗？"></a>反射可以修改static值吗？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field.get(<span class="keyword">null</span>) 可以获取静态变量。</span><br><span class="line">Field.set(<span class="keyword">null</span>,object) 可以修改静态变量。</span><br></pre></td></tr></table></figure>
<h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><h4 id="简析-1"><a href="#简析-1" class="headerlink" title="简析"></a>简析</h4><p>java中的异常分为2大类，Error和Exception。Error中有StackOverFlowError和OutOfMemoryError。Exception分为IOException和RuntimeException。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTEvMjcvMTM1NDAyMDQxN181MTc2LmpwZw?x-oss-process=image/format,png" alt="异常"></p>
<h4 id="Java中检查型异常和非检查型异常有什么区别？"><a href="#Java中检查型异常和非检查型异常有什么区别？" class="headerlink" title="Java中检查型异常和非检查型异常有什么区别？"></a>Java中检查型异常和非检查型异常有什么区别？</h4><p>检查型异常 extends Exception（编译时异常）：需要使用try catch进行捕获，否则会出错，继承自Exception</p>
<p>非检查型异常 extends RuntimeException（运行时异常）：不需要捕获，在必要时才会报错，</p>
<h4 id="try-catch-finally-return执行顺序？"><a href="#try-catch-finally-return执行顺序？" class="headerlink" title="try-catch-finally-return执行顺序？"></a>try-catch-finally-return执行顺序？</h4><ol>
<li>不管是否有异常产生，finally块中代码都会执行</li>
<li>当try和catch中有return语句时，finally块仍然会执行</li>
<li>finally是在return后面的表达式运算执行的，所以函数返回值在finally执行前确定的，无论finally中的代码怎么样，返回的值都不会改变，仍然是之前return语句中保存的值</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</li>
</ol>
<h4 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h4><p>throw用在方法内部，抛出异常</p>
<p>throws用在方法外部，在方法中抛出异常</p>
<h4 id="栈溢出StackOverFlowError发生的几种情况？"><a href="#栈溢出StackOverFlowError发生的几种情况？" class="headerlink" title="栈溢出StackOverFlowError发生的几种情况？"></a>栈溢出StackOverFlowError发生的几种情况？</h4><p>递归，栈内存存满，函数调用栈太深</p>
<h4 id="Java常见异常有哪些"><a href="#Java常见异常有哪些" class="headerlink" title="Java常见异常有哪些"></a>Java常见异常有哪些</h4><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p>
<p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p>
<p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p>
<p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p>
<p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p>
<p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p>
<p>java.lang.ArithmeticException：算术条</p>
<p>件异常。譬如：整数除零等。</p>
<p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p>
<p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</p>
<p>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p>
<p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p>
<p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p>
<p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p>
<p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p>
<p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</p>
<h2 id="linux进程通信有几种"><a href="#linux进程通信有几种" class="headerlink" title="linux进程通信有几种"></a>linux进程通信有几种</h2><p>Linux中的进程间通信有哪些？解释Binder通信为什么高效？Binder通信有什么限制？</p>
<p>Linux中的进程间通信有如下几种：</p>
<ul>
<li>信号（signal）</li>
<li>消息队列</li>
<li>共享内存（Shared Memory）<br>共享内存允许两个或多个进程进程共享同一块内存(这块内存会映射到各个进程自己独立的地址空间)从而使得这些进程可以相互通信。</li>
<li>管道/命名管道(Pipe)<br>Pipe这个词很形象地描述了通信双方的行为，即进程A与进程B。一根管道同时具有读取端和写入端。比如进程A从write end写入，那么进程B就可以从read end读取数据。</li>
<li>Socket<br>本地和服务端各自维护一个“文件”，在建立连接打开后，向自己的文件中写入数据，供对方读取</li>
</ul>
<p>Binder通信是Android系统特有的IPC机制，Binder的优点有以下几个：</p>
<ol>
<li>性能：Binder的效率高，只需要一次内存拷贝；而Linux中的管道、消息队列、套接字都需要2次；共享内存的方式不需要拷贝数据，但是有多进程同步的问题。</li>
<li>稳定性：Binder的架构是基于C/S结构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</li>
<li>安全性：传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限。从安全角度，Binder的安全性更高。</li>
</ol>
<p>Binder通信的另外一个限制是最多16个线程。最多只能传输1M的数据，否则会有TransactionTooLarge的Exception。</p>
<h2 id="CountDownLatch原理"><a href="#CountDownLatch原理" class="headerlink" title="CountDownLatch原理"></a>CountDownLatch原理</h2><p>存在4个线程，想在4个线程都执行完毕后执行另一个线程，</p>
<p>countDownLatch是采用计数器的原理，存在两个方法:</p>
<p>countDown：计数-1</p>
<p>await：线程挂起，当计数为0时，执行其后的逻辑</p>
<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h4 id="泛型简述"><a href="#泛型简述" class="headerlink" title="泛型简述"></a>泛型简述</h4><p>java中泛型即是“参数化类型”，即该泛型类型是一个参数传入</p>
<blockquote>
<p>只在程序的源代码中存在，在编译后的字节码中已经替换为原生类型，这种方法称为伪泛型。</p>
</blockquote>
<p>java中的泛型只在编译时期有效，正确检验泛型的结果后，会将泛型相关的信息擦出，并在对象进入和离开的方法边界上添加<code>类型检查</code>和<code>类型转化</code>的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">    Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(classStringArrayList==classIntegerArrayList)&#123;   <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;类型相同&quot;</span>);</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure>
<p>泛型有<code>泛型类</code>、<code>泛型方法</code>和<code>泛型接口</code></p>
<p>泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Pear&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span></span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型对方法重载的影响？"><a href="#泛型对方法重载的影响？" class="headerlink" title="泛型对方法重载的影响？"></a>泛型对方法重载的影响？</h4><p>方法不能进行重载，会报错，<code>两种方法都有相同的擦除</code>，在编译期间进行泛型擦除的，会导致擦出后都一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listMethod</span><span class="params">(List&lt;String&gt; list1)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listMethod</span><span class="params">(List&lt;Integer&gt; list2)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h4 id="java类的初始化流程"><a href="#java类的初始化流程" class="headerlink" title="java类的初始化流程"></a>java类的初始化流程</h4><p>父类到子类，静态到（非静态，构造），变量—–&gt;代码块</p>
<p>父类静态变量—-父类静态代码块—-子类静态变量—-子类静态代码块—-父类非静态—-父类构造—-子类非静态—-子类构造</p>
<h4 id="jvm类加载机制的7个流程"><a href="#jvm类加载机制的7个流程" class="headerlink" title="jvm类加载机制的7个流程"></a>jvm类加载机制的7个流程</h4><p>加载—–验证——准备——解析——初始化——-使用——卸载<br>JVM将.java文件加载成二进制文件.class<br>加载：</p>
<ol>
<li>获取二进制流class文件</li>
<li>将静态存储结构转换为方法区中运行时的数据结构，存储到方法区中</li>
<li>在堆中生成一个java对象，作为方法区的引用<blockquote>
<p>获取.class文件并在堆中生成一个class对象，将加载的类结构信息存储在方法区</p>
</blockquote>
</li>
</ol>
<hr>
<p>验证：JVM规范校验，代码逻辑校验</p>
<p>准备：为类变量分配内存并设置类变量的初始化，如果变量被final修饰，会直接放入对应的常量池中，并赋值</p>
<p>解析：常量池符号引用替换为内存的直接引用</p>
<p>（上述三种统称为连接）</p>
<hr>
<p>初始化：执行代码逻辑，对静态变量，静态代码块和类对象进行初始化</p>
<p>使用：使用初始化好的class对象</p>
<p>卸载：销毁创建class对象，负责运行的jvm退出内存</p>
<h5 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h5><ol>
<li>全局变量应用于整个类文件。局部变量只在方法执行期间存在，之后被回收。静态局部变量对本函数体始终可见</li>
<li>全局变量，全局静态变量，局部静态变量都在静态存储空间。局部变量在栈（虚拟机栈）中分配空间</li>
<li>全局变量初始化需要赋值，局部变量不需要赋值</li>
<li>一个<strong>类</strong>中不能声明同名全局变量，一个<strong>方法</strong>中不能声明同名局部变量。若全局变量和局部变量同名，则在方法中全局变量不生效。</li>
</ol>
<h5 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h5><p>当JVM碰到new字节码的时候，会先判断类是否已经初始化，如果没有初始化（有可能类还没有加载，如果是隐式装载，此时应该还没有类加载，就会先进行装载、验证、准备、解析四个阶段），然后进行类初始化。<br>如果已经初始化过了，就直接开始类对象的实例化工作，这时候会调用类对象的<init>方法。</p>
<h5 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h5><ol>
<li>初始化main方法的主类</li>
<li>new 关键字触发，如果类还没有被初始化</li>
<li>访问静态方法和静态字段时，目标对象类没有被初始化，则进行初始化操作</li>
<li>子类初始化过程中，如果发现父类没有初始化，则先初始化父类</li>
<li>通过反射API调用时，如果类没有初始化，则进行初始化操作</li>
<li>第一次调用java.lang.invoke.MethodHandle 实例时，需要初始化 MethodHandle 指向方法所在的类。</li>
</ol>
<h5 id="类的实例化触发时机"><a href="#类的实例化触发时机" class="headerlink" title="类的实例化触发时机"></a>类的实例化触发时机</h5><ol>
<li>new 触发实例化，创建对象</li>
<li>反射，class.newnIstance()和constructor.newnIstance()方法触发创建对象</li>
<li>Clone方法创建对象</li>
<li>使用序列化和反序列化的机制创建对象</li>
</ol>
<h5 id="类的初始化和类的实例化的区别"><a href="#类的初始化和类的实例化的区别" class="headerlink" title="类的初始化和类的实例化的区别"></a>类的初始化和类的实例化的区别</h5><p>类的初始化：为静态成员赋值，执行静态代码块<br>类的实例化：执行非静态方法和构造方法</p>
<ol>
<li>类的初始化只会执行一次，静态代码块只会执行一次</li>
<li>类的实例化会执行多次，每次实例化执行一次</li>
</ol>
<h5 id="在类都没有初始化完毕之前，能直接进行实例化相应的对象吗"><a href="#在类都没有初始化完毕之前，能直接进行实例化相应的对象吗" class="headerlink" title="在类都没有初始化完毕之前，能直接进行实例化相应的对象吗?"></a>在类都没有初始化完毕之前，能直接进行实例化相应的对象吗?</h5><p>正常情况下是先类初始化，再类实例化<br>在非正常情况下，比如在静态变量中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person2 p = <span class="keyword">new</span> Person2();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value4 = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        value1 = <span class="number">101</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        value1 = <span class="number">102</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value1 = <span class="number">103</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行public static Person2 p = new Person2();这样就会直接实例化，然后在执行类的初始化，所以会打印<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23123</span></span><br></pre></td></tr></table></figure></p>
<h5 id="多线程进行类的初始化会出问题吗？"><a href="#多线程进行类的初始化会出问题吗？" class="headerlink" title="多线程进行类的初始化会出问题吗？"></a>多线程进行类的初始化会出问题吗？</h5><p>不会，类初始化<Clinit>方法是阻塞的，多线程访问，只会有一个线程执行，其他阻塞。</p>
<h5 id="一个实例变量在对象初始化的过程中最多可以被赋值几次？"><a href="#一个实例变量在对象初始化的过程中最多可以被赋值几次？" class="headerlink" title="一个实例变量在对象初始化的过程中最多可以被赋值几次？"></a>一个实例变量在对象初始化的过程中最多可以被赋值几次？</h5><p>4次</p>
<ol>
<li>对象被创建时候，分配内存会把实例变量赋予默认值，这是肯定会发生的。</li>
<li>实例变量本身初始化的时候，就给他赋值一次，也就是int value1=100。</li>
<li>初始化代码块的时候，也赋值一次。</li>
<li>构造函数中，在进行赋值一次。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value1 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        value1 = <span class="number">102</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value1 = <span class="number">103</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h4><h5 id="高刷手机，60hz，120hz指的是什么？"><a href="#高刷手机，60hz，120hz指的是什么？" class="headerlink" title="高刷手机，60hz，120hz指的是什么？"></a>高刷手机，60hz，120hz指的是什么？</h5><p>屏幕刷新率，1s内屏幕刷新的次数。这个参数由手机硬件决定<br>一般大于60hz的就是高刷收集，特点在于刷新频率更高，就算存在丢帧、卡顿，也能保持稳定性。</p>
<h5 id="屏幕的刷新过程"><a href="#屏幕的刷新过程" class="headerlink" title="屏幕的刷新过程"></a>屏幕的刷新过程</h5><p>从左到右，从上到下，顺序显示像素点。当整个屏幕刷新完毕，即一个垂直刷新周期后，（1000/60）16ms后再次刷新<br>一般一个图形界面的绘制，需要CPU准备数据，然后GPU进行绘制，绘制完写入缓存区，然后屏幕按照刷新频率来从这个缓存区中取图形显示。</p>
<p>所以整个刷新过程是CPU，GPU，屏幕（Display）三方合作的工作关系。</p>
<h5 id="帧率，VSYNC是什么"><a href="#帧率，VSYNC是什么" class="headerlink" title="帧率，VSYNC是什么"></a>帧率，VSYNC是什么</h5><p>帧率：GPU一秒内渲染绘制的操作的帧数，单位是fps，所以一般帧数和屏幕刷新度保持一致是效果最好的情况，不会导致一方浪费</p>
<p>VSYNC：垂直同步，作用是让帧率和屏幕刷新率保持一致，防止卡顿和跳帧。由于CPU和GPU绘制图像的时间不稳定，所以可能会发生卡顿情况，也就是下一帧的数据还没准备好无法正常显示在屏幕上，设置垂直同步后，要求CPU和GPU在16ms之内将下一帧的数据处理好，那么屏幕刷新的时候就可以直接从缓存中获取下一帧的数据并显示出来</p>
<h5 id="屏幕中单缓存，双缓存，三缓存"><a href="#屏幕中单缓存，双缓存，三缓存" class="headerlink" title="屏幕中单缓存，双缓存，三缓存"></a>屏幕中单缓存，双缓存，三缓存</h5><ol>
<li>单缓存：CPU计算好数据传递给GPU，GPU图像绘制后放到缓存区，display从缓存中获取数据并刷新屏幕<br>缺点：当第二帧的数据还没生成完成时，会导致屏幕中有一部分第一帧的数据，导致一个屏幕同时显示了两帧的数据</li>
<li>双缓存：CPU计算好数据传递到GPU，GPU图像会之后放入缓存区BackBuffer，当到达VSYNC垂直同步时间，将数据同步到缓存区FrameBuffer中，display从缓存区FrameBuffer中获取数据并显示<br>缺点：如果在一个垂直同步的时间内CPU+GPU没有渲染完成（开始绘制的时间在下次垂直同步时间附近，导致只有一小份垂直同步时间在绘制），就会浪费一个VSYNC垂直同步时间，当VSYNC垂直同步时间来临时，GPU正在处理数据，那么不会开启下一帧的处理，当GPU处理结束后，无法触发下一帧的数据处理，就会导致卡顿的情况</li>
<li>三缓存数据：当在一个垂直同步时间内没有完成处理，就会出现第三个缓存区，在第二个垂直同步时间，缓存下一帧的数据，这样两个缓存交替处理，保证FrameBuffer会拿到最新的数据，保证了显示的流畅度</li>
</ol>
<h5 id="代码中修改了UI，屏幕是怎么进行刷新的？"><a href="#代码中修改了UI，屏幕是怎么进行刷新的？" class="headerlink" title="代码中修改了UI，屏幕是怎么进行刷新的？"></a>代码中修改了UI，屏幕是怎么进行刷新的？</h5><p>当调用invalidate/requestLayout中进行重绘工作时，会向VSYNC垂直同步服务请求，等待下一次VSYNC垂直同步时间，执行界面绘制刷新操作，CPU-&gt;GPU-&gt;Display</p>
<h5 id="如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？"><a href="#如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？" class="headerlink" title="如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？"></a>如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？</h5><p>屏幕不会刷新，不会重新绘制，如果屏幕不变，程序就收不到垂直同步时间，自动过滤，不处理屏幕刷新操作，只有当界面改变时，才会请求VSYNC垂直同步服务，触发下一次VSYNC垂直同步刷新屏幕</p>
<h4 id="jvm垃圾回收机制"><a href="#jvm垃圾回收机制" class="headerlink" title="jvm垃圾回收机制"></a>jvm垃圾回收机制</h4><p>首先介绍4个引用</p>
<p>强引用：在使用时不会被回收</p>
<p>软引用：系统内存不足时会被回收</p>
<p>弱引用：下一次gc会被回收</p>
<p>虚引用：任何时候都可能被回收</p>
<h2 id="小知识点-1"><a href="#小知识点-1" class="headerlink" title="小知识点"></a>小知识点</h2><h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><ol>
<li>抽象类中可包含普通方法+实现，接口类中只存在抽象方法，没有具体实现</li>
<li>抽象类中的值可以是任何类型的，接口中的值必须是public static final修饰的</li>
<li>一个类只能继承一个抽象类，一个类可以实现多个接口类</li>
<li>抽象类存在构造函数，接口类没有</li>
<li>抽象类中包含初始化块，接口中没有</li>
</ol>
<h4 id="static和final的区别"><a href="#static和final的区别" class="headerlink" title="static和final的区别"></a>static和final的区别</h4><p>static</p>
<p>是可以直接调用的（类名.方法/变量），</p>
<p>可修饰属性，方法，代码段，内部类</p>
<p>所有对象只有一个值</p>
<p>final</p>
<p>可修饰属性，方法，类，局部变量</p>
<p>final修饰变量不可被更改值，方法不能被重写，类不能被继承</p>
<p>修饰集和的话，其引用不变，集和可以自由变化</p>
<h4 id="java是值传递还是引用传递"><a href="#java是值传递还是引用传递" class="headerlink" title="java是值传递还是引用传递"></a>java是值传递还是引用传递</h4><p>如果是基本类型就是值传递</p>
<p>引用类型就是引用传递</p>
<p>String表现为值传递，但是其实是作为形参后重新创建了对象，引用已经变化，所以是值传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    changeValue(str); </span><br><span class="line">    System.out.println(<span class="string">&quot;str值为: &quot;</span> + str);  <span class="comment">// str未被改变，str = &quot;123&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">changeValue</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="string">&quot;Bobo&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    changeValue1(student);   <span class="comment">// student值未改变，不为null! 输出结果 student值为 name:Bobo、age:15</span></span><br><span class="line">    <span class="comment">// changeValue2(student);  // student值被改变，输出结果 student值为 name:Lily、age:20</span></span><br><span class="line">    System.out.println(<span class="string">&quot;student值为 name: &quot;</span> + student.name + <span class="string">&quot;、age:&quot;</span> + student.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">changeValue1</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">    student = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(Student student)</span>  </span>&#123;    </span><br><span class="line">     student.name = <span class="string">&quot;Lily&quot;</span>;    </span><br><span class="line">     student.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h4><p>String是不可变的，每次赋值都是重新创建对象，对内存和性能都有损耗</p>
<p>StringBuilder是非线程安全的，存储通过一个可变长度的字符数组（char[]）。</p>
<p>append值时，如果所需长度大于分配长度，新建数组长度为（2倍+2），如果所需长度大于(2倍+2)，则使用所需长度大小，否则，使用(2倍+2)长度，默认长度为16，有参构造=16+参数长度</p>
<p>StringBuffer是线程安全的</p>
<p>效率上由快到慢：StringBuilder &gt; StringBuffer &gt; String</p>
<h4 id="String为什么是final（不可变）的？"><a href="#String为什么是final（不可变）的？" class="headerlink" title="String为什么是final（不可变）的？"></a>String为什么是final（不可变）的？</h4><p>final+private保证了其不可修改性</p>
<ol>
<li>不可变性保证了线程安全</li>
<li>不可变后避免了深拷贝，将String值放在字符串常量池（堆内）中，供其他方引用，提高效率，节约内存</li>
</ol>
<h4 id="hashcode、equals和-的区别？"><a href="#hashcode、equals和-的区别？" class="headerlink" title="hashcode、equals和== 的区别？"></a>hashcode、equals和== 的区别？</h4><p>hashcode：</p>
<ol>
<li>基本类型就是改值</li>
<li>引用类型是对象在内存地址的映射</li>
</ol>
<p>equals：</p>
<ol>
<li>在object中equals方法等效于==</li>
<li>在其他方法中，重写了equals方法，会判断值是否相等</li>
</ol>
<p>==：</p>
<ol>
<li>基本类型比对的是值</li>
<li>引用对象比对的是内存地址的映射</li>
</ol>
<p>对于String，Integer对象，他们重写了equals方法，所以其equals方法可以判断值是否相等，而==只能判断引用是否相等</p>
<h4 id="进程，线程，协程的区别？阻塞和非阻塞的区别？"><a href="#进程，线程，协程的区别？阻塞和非阻塞的区别？" class="headerlink" title="进程，线程，协程的区别？阻塞和非阻塞的区别？"></a>进程，线程，协程的区别？阻塞和非阻塞的区别？</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程包含线程<br>进程是CPU分配资源的最小单位</p>
<h5 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h5><p>线程包含协程<br>线程是独立运行和独立调度的基本单位（CPU上真正执行的是线程）<br>线程间共享进程内资源<br>线程的调度切换比进程快</p>
<h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>协程是存在线程之上，通过异步IO处理执行多个协程的操作<br>协程的调度切换比线程快</p>
<h5 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h5><p>阻塞就是线程被cpu挂起，不执行线程逻辑<br>非阻塞就是线程不被cpu挂起，执行线程逻辑</p>
<h5 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h5><p>并发是你执行一下，我执行一下，轮着执行<br>并行是一起执行</p>
<h5 id="协程和线程的比较"><a href="#协程和线程的比较" class="headerlink" title="协程和线程的比较"></a>协程和线程的比较</h5><ol>
<li>协程运行在线程之上</li>
<li>线程执行由内核控制（内核态执行），控制线程切换消耗资源（抢先式），协程由程序执行（也就是在用户态执行）</li>
<li>协程比线程更加轻量</li>
<li>多核处理器的情况下，多个线程是可以并行的，但是运行的协程的函数却只有一个，其他协程都会被suspend（阻塞）。即协程是并发的，但不是并行的。</li>
<li>执行密集型IO操作，性能提高</li>
<li>在协程之间的切换不需要涉及任何系统调用或任何阻塞调用</li>
</ol>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p><img src="https://static.oschina.net/uploads/img/201604/21095604_vhHX.png" alt="img"></p>
<ol>
<li><p>多路复用IO</p>
<p>执行A事件，同时执行B事件，通过状态下发，获取A，B执行状态</p>
</li>
<li><p>信号驱动IO</p>
</li>
<li><p>异步IO</p>
<p>执行A事件，通过异步处理，当A事件处理完成不哦，通知主进程/线程</p>
</li>
<li><p>阻塞IO：</p>
<p>执行完A事件，在执行B事件</p>
</li>
<li><p>非阻塞IO</p>
<p>执行A事件，同时执行B事件，一直监听A，B的执行过程</p>
</li>
</ol>
<h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h4 id="kotlin协程？"><a href="#kotlin协程？" class="headerlink" title="kotlin协程？"></a>kotlin协程？</h4><p>kotlin协程使用<code>Coroutine</code>，通过使用<code>函数挂起</code>(非阻塞挂起)的方式来保证协程的使用，内部使用状态机来管理协程的挂起点</p>
<p>每当遇到<code>suspend</code>修饰的方法，都有可能会挂起当前的协程，通过<code>GlobalScope.launch</code>或者其他方式执行suspend修饰的方法时，进行挂起操作</p>
<h4 id="suspend，runBlocking，launch，withContext，async，doAsync之间的区别"><a href="#suspend，runBlocking，launch，withContext，async，doAsync之间的区别" class="headerlink" title="suspend，runBlocking，launch，withContext，async，doAsync之间的区别"></a>suspend，runBlocking，launch，withContext，async，doAsync之间的区别</h4><p>suspend：挂起函数的标志</p>
<p>runBlocking：阻塞式全局协程</p>
<p>launch：非阻塞全局协程</p>
<p>withContext：任务是串行的</p>
<p>async：任务是并行的</p>
<p>doAsync：封装java的Future类，便于线程切换的，并非协程</p>
<h1 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h1><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h4 id="简述一次完整的Http请求过程"><a href="#简述一次完整的Http请求过程" class="headerlink" title="简述一次完整的Http请求过程"></a>简述一次完整的Http请求过程</h4><p>通过域名请求后————&gt;DNS域名解析为ip地址————&gt;中间路由跳转————&gt;直接访问ip地址进行三次握手————&gt;tcp三次握手成功后进行通信响应———&gt;tcp四次挥手结束通信</p>
<p>客户端：</p>
<ol>
<li>在浏览器输入网址。</li>
<li>浏览器解析网址，并生成http请求消息。</li>
<li>浏览器调用系统解析器，发送消息到DNS服务器查询域名对应的ip。</li>
<li>拿到ip后，和请求消息一起交给操作系统协议栈的TCP模块。</li>
<li>将数据分成一个个数据包，并加上TCP报头形成TCP数据包。</li>
<li>TCP报头包括发送方端口号、接收方端口号、数据包的序号、ACK号。</li>
<li>然后将TCP消息交给IP模块。</li>
<li>IP模块会添加IP头部和MAC头部。</li>
<li>IP头部包括IP地址，为IP模块使用，MAC头部包括MAC地址，为数据链路层使用。</li>
<li>IP模块会把整个消息包交给网络硬件，也就是数据链路层，比如以太网，WIFI等。</li>
<li>然后网卡会将这些包转换成电信号或者在光信号，通过网线或者光纤发送出去，再由路由器等转发设备送达接收方。</li>
</ol>
<p>服务器端：</p>
<ol>
<li>数据包到达服务器的数据链路层，比如以太网，然后会将其转换为数据包（数字信号）交给IP模块。</li>
<li>IP模块会将MAC头部和IP头部后面的内容，也就是TCP数据包发送给TCP模块。</li>
<li>TCP模块会解析TCP头信息，然后和客户端沟通表示收到这个数据包了。</li>
<li>TCP模块在收到消息的所有数据包之后，就会封装好消息，生成相应报文发给应用层，也就是HTTP层。</li>
<li>HTTP层收到消息，比如是HTML数据，就会解析这个HTML数据，最终绘制到浏览器页面上。</li>
</ol>
<h4 id="简述三次握手和四次挥手"><a href="#简述三次握手和四次挥手" class="headerlink" title="简述三次握手和四次挥手"></a>简述三次握手和四次挥手</h4><p><img src="http://img-blog.csdn.net/20180208112533496" alt="img"><br>三次握手：<br>客户端发送一个随机seq=100<br>服务端返回一个随机seq=200，ack=100+1<br>客户端返回一个ack=200+1</p>
<p>四次挥手：<br>客户端发送一个FIN=1，seq=100<br>服务端发送一个ack=100+1<br>服务端发送一个FIN=1，seq=200<br>客户端发送一个ack=200+1</p>
<p>服务端发送两次的原因是需要等待服务器处理当前任务完毕。</p>
<h4 id="为什么需要三次握手而不是2次或者4次？"><a href="#为什么需要三次握手而不是2次或者4次？" class="headerlink" title="为什么需要三次握手而不是2次或者4次？"></a>为什么需要三次握手而不是2次或者4次？</h4><blockquote>
<p>防止已失效的连接请求又传送到服务器端，因而产生错误</p>
</blockquote>
<p>两次的话，服务端是不知道自己的请求是否成功发送到客户端的。但是服务端又会认为连接建立成功了。假设第二次丢失了，客户端认为服务端没有响应，就会重发一次，这样已经失效的连接请求就会传送到服务端。</p>
<p>tcp是可靠的双方通信协议，所以双方都会生成一个初始的序列号供双方确认，如果改成两次，只会确定客户端对于服务端具有可靠性，而服务端对客户端没有可靠性</p>
<p>四次的话，太过繁琐</p>
<h4 id="为什么握手需要三次？挥手却需要四次？"><a href="#为什么握手需要三次？挥手却需要四次？" class="headerlink" title="为什么握手需要三次？挥手却需要四次？"></a>为什么握手需要三次？挥手却需要四次？</h4><p>因为挥手的时候需要等待服务器将本次连接中的所有保文都处理完，在发送关闭状态，说白了，服务器需要等待自身进入可关闭状态</p>
<h4 id="握手可以携带数据信息吗？"><a href="#握手可以携带数据信息吗？" class="headerlink" title="握手可以携带数据信息吗？"></a>握手可以携带数据信息吗？</h4><p>第三次请求可以携带数据信息，客户端认为连接已经建立的，就可以携带参数，但是前两次不能，容易造成对服务器的攻击</p>
<h4 id="为什么TIME-WAIT状态需要等待2MSL才能转换到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要等待2MSL才能转换到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要等待2MSL才能转换到CLOSE状态？"></a>为什么TIME_WAIT状态需要等待2MSL才能转换到CLOSE状态？</h4><ol>
<li>保证最后一次能成功到达服务器。最后一次客户端发送给服务端的确认信息可能丢失，如果丢失，服务端会有重试机制，等待一来一回的时间，也就是2MSL的时间，如果没有接收到服务端的重试请求，就认为服务端接收了，等到了就刷新2MSL时间</li>
<li>等待2MSL的时间也是为了<strong>防止失效连接的请求报文会出现在新连接</strong>中，防止第三次重试请求能被客户端接受，不会干扰其他请求</li>
</ol>
<h4 id="SSL层在传输层还是应用层？"><a href="#SSL层在传输层还是应用层？" class="headerlink" title="SSL层在传输层还是应用层？"></a>SSL层在传输层还是应用层？</h4><p>SSL层在传输层和应用层之间，是一个SSL层</p>
<h4 id="滑动窗口？"><a href="#滑动窗口？" class="headerlink" title="滑动窗口？"></a>滑动窗口？</h4><h4 id="拥塞控制？"><a href="#拥塞控制？" class="headerlink" title="拥塞控制？"></a>拥塞控制？</h4><h4 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h4><p>1、基于连接与无连接；</p>
<p>2、对系统资源的要求（TCP较多，UDP少）；</p>
<p>3、UDP程序结构较简单；</p>
<p>4、流模式与数据报模式 ；</p>
<p>5、TCP保证数据正确性，UDP可能丢包；</p>
<p>6、TCP保证数据顺序，UDP不保证。</p>
<h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><ul>
<li><p>1XX - 临时消息。服务器收到请求，需要请求者继续操作。</p>
</li>
<li><p>2XX - 请求成功。请求成功收到，理解并处理。</p>
</li>
<li><p>3XX - 重定向。需要进一步的操作以完成请求。</p>
</li>
<li><p>4XX - 客户端错误。请求包含语法错误或无法完成请求。</p>
</li>
<li><p>5XX - 服务器错误。服务器在处理请求的过程中发生了错误。</p>
</li>
</ul>
<p>200：客户端请求成功<br>301：资源（网页等）被永久转移到其他URL<br>302：重定向，临时跳转<br>400：客户端请求存在语法错误，不能给被服务器理解（Bad Request）<br>404：请求资源不存在，错误的URL<br>500：服务器内部发生了不可预料的错误<br>502：网关错误（Bad Getway）<br>503：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。（Server Unavailable）</p>
<h4 id="简述TCP和UDP的区别"><a href="#简述TCP和UDP的区别" class="headerlink" title="简述TCP和UDP的区别"></a>简述TCP和UDP的区别</h4><p>TCP：需要数据准确、顺序不能错、要求稳定可靠的场景就需要用到TCP。<br>UDP：数据即时性</p>
<h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>tcp内部是由socket协议填充的</p>
<h4 id="简述https的加密过程"><a href="#简述https的加密过程" class="headerlink" title="简述https的加密过程"></a>简述https的加密过程</h4><p>RSA是非对称加密，AES是对称加密</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/882dee9d98c9455bbb51cc73f22d0487~tplv-k3u1fbpfcp-zoom-1.image" alt="加密过程"></p>
<ol>
<li>客户端请求服务端进行访问</li>
<li>服务端创建RSA，获得私钥和公钥</li>
<li>服务端发送公钥给客户端</li>
<li>客户端经过复杂的证书验证</li>
<li>客户端生成AES密钥</li>
<li>将AES密钥经过RSA公钥加密后发送给服务端</li>
<li>服务端通过RSA私钥解密获取AES密钥</li>
<li>客户端和服务端后续通过AES密钥进行通信</li>
</ol>
<h4 id="为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？"><a href="#为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？" class="headerlink" title="为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？"></a>为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？</h4><p>因为RSA加密有性能上的损耗，加解密过程会比较耗时，不适用于频繁通信过程，而AES加密比较快捷</p>
<h4 id="简述中间人攻击，如何解决？（dns劫持）"><a href="#简述中间人攻击，如何解决？（dns劫持）" class="headerlink" title="简述中间人攻击，如何解决？（dns劫持）"></a>简述中间人攻击，如何解决？（dns劫持）</h4><ol>
<li>客户端访问域名A，向服务端进行请求</li>
<li>中间人劫持dns，使之指向私人ip  B。即客户端同B建立https连接</li>
<li>B在和A建立https连接</li>
<li>服务端创建RSA，获得公钥（S）和私钥（S）</li>
<li>服务端发送公钥（S）给客户端</li>
<li>中间人拦截信息，获得公钥（S）</li>
<li>生成RSA公钥（中）和私钥（中），并将公钥（中）发送给客户端</li>
<li>客户端生成AES密钥</li>
<li>使用公钥（中）加密AES密钥，并发送给服务端</li>
<li>中间人拦截信息，获得加密信息，使用私钥（中）进行解密，获得AES密钥</li>
<li>中间人使用公钥（S）加密AES密钥，并发送给服务端</li>
<li>服务端通过私钥（S）进行解密，获得AES密钥。</li>
</ol>
<p>到此为止，中间人持有客户端和服务端交换的AES密钥，可以进行消息拦截，并解密信息</p>
<p>解决方案：将RSA公钥交给CA机构，CA机构添加上域名，有效期等将其制作成证书，在用CA机构的私钥进行加密后放置在服务器上，当客户端请求时，返回加密后信息，客户端从CA机构获取公钥（一般情况下内置在机器中）进行解密，成功解密后，获取的信息，域名等可以匹配上，则CA验证通过，获得服务器公钥，走下面流程。</p>
<blockquote>
<p>https 无法防止中间人攻击，只有做证书固定ssl-pinning 或者 apk中预置证书做自签名验证可以防中间人攻击</p>
</blockquote>
<blockquote>
<p>证书固定（Certificate Pinning）是指Client端内置Server端真正的公钥证书。在HTTPS请求时，Server端发给客户端的公钥证书必须与Client端内置的公钥证书一致，请求才会成功。</p>
</blockquote>
<h4 id="http分层"><a href="#http分层" class="headerlink" title="http分层"></a>http分层</h4><p><img src="http://bkimg.cdn.bcebos.com/pic/0dd7912397dda144d48ab350bbb7d0a20df48655" alt="img"></p>
<p><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" alt="img"></p>
<p><img src="http://img-blog.csdn.net/20170822222325781" alt="img"></p>
<h4 id="dns污染"><a href="#dns污染" class="headerlink" title="dns污染"></a>dns污染</h4><p>国家或地区防止摸一个网站被访问，是dns发送出错误的ip地址，使之无法访问</p>
<p>使用代理服务器和vpn</p>
<h4 id="http1-0、http1-1和http2-0的区别"><a href="#http1-0、http1-1和http2-0的区别" class="headerlink" title="http1.0、http1.1和http2.0的区别"></a>http1.0、http1.1和http2.0的区别</h4><p>1.0：短暂连接，重复访问，连接无法复用</p>
<p>1.1：支持持久连接，长连接，优化1.0带来的性能问题，可以多路复用（数量限制），串行处理，一条失败，后续全部失败，<strong>同步</strong></p>
<p>2.0：优化多路复用机制，header压缩，并行处理，<strong>异步</strong></p>
<p>3.0：UDP</p>
<h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏)</th>
<th>时间复杂度（最好)</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>复杂性</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>O(n2)O(n2)</td>
<td>O(n2)O(n2)</td>
<td>O(n)O(n)</td>
<td>O(1)O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlog2n)O(nlog2n)</td>
<td>O(n2)O(n2)</td>
<td>O(n)O(n)</td>
<td>O(1)O(1)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>直接选择排序</td>
<td>O(n2)O(n2)</td>
<td>O(n2)O(n2)</td>
<td>O(n2)O(n2)</td>
<td>O(1)O(1)</td>
<td>不稳定</td>
<td>简单</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog2n)O(nlog2n)</td>
<td>O(nlog2n)O(nlog2n)</td>
<td>O(nlog2n)O(nlog2n)</td>
<td>O(1)O(1)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n2)O(n2)</td>
<td>O(n2)O(n2)</td>
<td>O(n)O(n)</td>
<td>O(1)O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog2n)O(nlog2n)</td>
<td>O(n2)O(n2)</td>
<td>O(nlog2n)O(nlog2n)</td>
<td>O(nlog2n)O(nlog2n)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog2n)O(nlog2n)</td>
<td>O(nlog2n)O(nlog2n)</td>
<td>O(nlog2n)O(nlog2n)</td>
<td>O(n)O(n)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+r))O(d(n+r))</td>
<td>O(d(n+r))O(d(n+r))</td>
<td>O(d(n+r))O(d(n+r))</td>
<td>O(n+r)O(n+r)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
</tbody>
</table>
<h4 id="冒泡排序-BubbleSort"><a href="#冒泡排序-BubbleSort" class="headerlink" title="冒泡排序(BubbleSort)"></a>冒泡排序(BubbleSort)</h4><p>依次比较两个相邻的元素，如果顺序错误就交换，直到跑完所有元素，那么最后一个元素就是最大（最小）的值，在接着按照上述操作进行排序。</p>
<p>时间复杂度：O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                   temp = a[j];</span><br><span class="line">                   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                   a[j+<span class="number">1</span>] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>第一趟找出最小的放在第一个，第二趟找出第二小的放在第二个，。。。。。</p>
<p>时间复杂度：O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                    a[i] = a[j];</span><br><span class="line">                    a[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h4><p>分治法：将一大块分解成若干小块，一块一块算</p>
<ul>
<li>设置一边的值为哨兵</li>
<li>将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li>
<li>在对剩下的区间进行排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt;right)&#123;</span><br><span class="line">        <span class="comment">//每一趟排序</span></span><br><span class="line">        <span class="keyword">int</span> base = division(a,left,right);</span><br><span class="line">        <span class="comment">//哨兵两边开始排序</span></span><br><span class="line">        <span class="comment">//左边</span></span><br><span class="line">        quickSort(a,left,base-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右边</span></span><br><span class="line">        quickSort(a,base+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用分治法排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//哨兵</span></span><br><span class="line">    <span class="keyword">int</span> base = a[left];</span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="comment">//哨兵在左边，所以right左移</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; a[right]&gt;=base)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != right) &#123;</span><br><span class="line">            a[left] = a[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//哨兵在右边，所以left右移</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; a[left]&lt;=base)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != right) &#123;</span><br><span class="line">            a[right] = a[left];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = base;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>二分插入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标处的值</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值小，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的中后部部分，所以当前下标取值为mid + 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               lo = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值大，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的前中部部分，所以当前下标取值为mid - 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               hi = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//数组中间处的值与要找的值相等，直接返回数组中部的下标mid</span></span><br><span class="line">               <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>插入排序</p>
<p>从尾部开始遍历，每次–，比他大的值后移一位，直到找到相等或者比它小的，直接赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="扑克牌算法"><a href="#扑克牌算法" class="headerlink" title="扑克牌算法"></a>扑克牌算法</h4><h4 id="根节点到目标节点的路径"><a href="#根节点到目标节点的路径" class="headerlink" title="根节点到目标节点的路径"></a>根节点到目标节点的路径</h4><h4 id="找出最小的k个数"><a href="#找出最小的k个数" class="headerlink" title="找出最小的k个数"></a>找出最小的k个数</h4><ol>
<li>使用快速排序：O(nlogn)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getLeastNumbers1(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    pivotFindMinK(input, output, k, <span class="number">0</span>, input.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pivotFindMinK</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span>[] output, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = start;</span><br><span class="line">    <span class="keyword">int</span> right = end;</span><br><span class="line">    <span class="keyword">int</span> temp = numbers[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (numbers[right] &gt; temp &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[left] = numbers[right];</span><br><span class="line">        <span class="keyword">while</span> (numbers[left] &lt;= temp &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[right] = numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">    numbers[left] = temp;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; k-<span class="number">1</span>) &#123;</span><br><span class="line">        pivotFindMinK(numbers, output, k, start, left - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; k-<span class="number">1</span>) &#123;</span><br><span class="line">        pivotFindMinK(numbers, output, k, right + <span class="number">1</span>, end);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.arraycopy(numbers, <span class="number">0</span>, output, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建一个数组，放入数组前k个数，并由小到大排列好，遍历原数组，如果存在比新数组中的值更小，插入排序，而后得到新数组。</li>
<li>小根堆实现，按顺序放入小根堆—大顶堆（父节点&lt;=子节点），小根堆大小为k，超过大小，删除堆顶元素，相反的话，加入大根堆—小顶堆（父节点&gt;=子节点）</li>
</ol>
<h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用递归的二分查找</span></span><br><span class="line"><span class="comment">	 *title:recursionBinarySearch</span></span><br><span class="line"><span class="comment">	 *<span class="doctag">@param</span> arr 有序数组</span></span><br><span class="line"><span class="comment">	 *<span class="doctag">@param</span> key 待查找关键字</span></span><br><span class="line"><span class="comment">	 *<span class="doctag">@return</span> 找到的位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursionBinarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;				</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;			<span class="comment">//初始中间位置</span></span><br><span class="line">		<span class="keyword">if</span>(arr[middle] &gt; key)&#123;</span><br><span class="line">			<span class="comment">//比关键字大则关键字在左区域</span></span><br><span class="line">			<span class="keyword">return</span> recursionBinarySearch(arr, key, low, middle - <span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; key)&#123;</span><br><span class="line">			<span class="comment">//比关键字小则关键字在右区域</span></span><br><span class="line">			<span class="keyword">return</span> recursionBinarySearch(arr, key, middle + <span class="number">1</span>, high);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> middle;</span><br><span class="line">		&#125;	</span><br></pre></td></tr></table></figure>
<h4 id="一个整形数组里求两个数的和能不能等于一个给定数"><a href="#一个整形数组里求两个数的和能不能等于一个给定数" class="headerlink" title="一个整形数组里求两个数的和能不能等于一个给定数"></a>一个整形数组里求两个数的和能不能等于一个给定数</h4><ol>
<li>如果数组是有序的，两个下标，如果相加大于给定数，左边–，如果小于给定数，右边++，直到数据相等或者右边等于左边</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">56</span>,<span class="number">456</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = a.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] + a[j] &gt;sum)&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i] + a[j] &lt;sum)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(a[i] + <span class="string">&quot;+&quot;</span> + a[j] + <span class="string">&quot;=&quot;</span> + sum);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>如果数组是无序的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                System.out.println(nums[map.get(nums[i])] + <span class="string">&quot;+&quot;</span> + nums[i] + <span class="string">&quot;=&quot;</span> + target);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = target-nums[i];</span><br><span class="line">            map.put(value,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + sum &lt; nums[i])&#123;</span><br><span class="line">            sum = nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum +=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">            max = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">       BinaryTreeNode temp;</span><br><span class="line">       Queue&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;BinaryTreeNode&gt;();</span><br><span class="line">       queue.offer(root);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           temp = queue.poll();</span><br><span class="line">           System.out.print(temp.getData() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != temp.getLeft())</span><br><span class="line">               queue.offer(temp.getLeft());</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != temp.getRight()) &#123;</span><br><span class="line">               queue.offer(temp.getRight());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历递归的方式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">           System.out.print(root.getData() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">           preOrder(root.getLeft());</span><br><span class="line">           preOrder(root.getRight());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">//前序遍历非递归的方式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">       Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">       stack.push(root);</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           BinaryTreeNode node = stack.pop();</span><br><span class="line">           System.out.print(node.getData() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">               stack.push(node.getRight());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">               stack.push(node.getLeft());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中序便利非递归</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       stack.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           TreeNode node = stack.pop();</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.add(node);</span><br><span class="line">               stack.add(node.left);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               list.add(node.val);</span><br><span class="line">               <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   stack.add(node.right);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                       TreeNode node1 = stack.pop();</span><br><span class="line">                       list.add(node1.val);</span><br><span class="line">                       <span class="keyword">if</span>(node1.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                           stack.add(node1.right);</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//后序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       stack.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           TreeNode node = stack.pop();</span><br><span class="line">           list.add(node.val);</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.add(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           result.add(list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//之字形打印</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; listList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> listList;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;count;j++)&#123;</span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                   list.addFirst(node.val);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   list.add(node.val);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           i++;</span><br><span class="line">           <span class="keyword">if</span>(list.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               listList.add(list);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> listList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="两个view第一个公共父view"><a href="#两个view第一个公共父view" class="headerlink" title="两个view第一个公共父view"></a>两个view第一个公共父view</h4><ol>
<li>引入set集和，一个用来存贮a数据，将b放入a数组，当数组重复会返回false，放入另一个set中做返回。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title">getIds</span><span class="params">(Integer[] a, Integer[] b)</span></span>&#123;</span><br><span class="line">	  </span><br><span class="line">	  Set&lt;Integer&gt; same = <span class="keyword">new</span> HashSet&lt;Integer&gt;();  <span class="comment">//用来存放两个数组中相同的元素</span></span><br><span class="line">	  Set&lt;Integer&gt; temp = <span class="keyword">new</span> HashSet&lt;Integer&gt;();  <span class="comment">//用来存放数组a中的元素</span></span><br><span class="line">	  </span><br><span class="line">	  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		  temp.add(a[i]);   <span class="comment">//把数组a中的元素放到Set中，可以去除重复的元素</span></span><br><span class="line">	  &#125;</span><br><span class="line">	  </span><br><span class="line">	  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">	    <span class="comment">//把数组b中的元素添加到temp中</span></span><br><span class="line">	    <span class="comment">//如果temp中已存在相同的元素，则temp.add（b[j]）返回false</span></span><br><span class="line">		<span class="keyword">if</span>(!temp.add(b[j]))</span><br><span class="line">			same.add(b[j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想知道两个数组的索引，使用map存储，key是值，value是数组索引，在进行map.containsKey()对比，找到则使用</p>
<ol start="2">
<li>将a数组放入set中，将b轮询放入set中，返回false，则重复值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getIds</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer integer:a)&#123;</span><br><span class="line">            set1.add(integer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer j:b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set1.add(j))&#123;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>两个链表中第一个根节点</li>
</ol>
<p>两个指针分别跑两条链，短的跑完后，将长的头赋值过去，再开始跑，长的跑完亦然，最终两指针相交地方为两链表的第一个根节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNode</span><span class="params">(Node nodeA, Node nodeB)</span> </span>&#123;</span><br><span class="line">       Node pA = nodeA;</span><br><span class="line">       Node pB = nodeB;</span><br><span class="line">       <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">           <span class="keyword">if</span> (pA.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">               pA = nodeB;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               pA = pA.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (pB.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">               pB = nodeA;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               pB = pB.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.print(pA.value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>二叉树的最近公共祖先<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        dps(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dps</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == p.val)&#123;</span><br><span class="line">            node = p;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == q.val)&#123;</span><br><span class="line">            node = q;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> a = dps(root.left,p,q);</span><br><span class="line">        <span class="keyword">boolean</span> b = dps(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(a &amp;&amp; b)&#123;</span><br><span class="line">            node = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a || b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="判断链表是不是环链，并返回入口"><a href="#判断链表是不是环链，并返回入口" class="headerlink" title="判断链表是不是环链，并返回入口"></a>判断链表是不是环链，并返回入口</h4><p>两个指针，一个一次跑一个，一个一次跑两个，相交的话就是存在环链</p>
<p>将跑的慢的从头开始一个一个跑，跑的快的从相交的点开始跑，一个一个跑，最终相遇的就是入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">isCircle</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node p = node;</span><br><span class="line">        Node q = node;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">            <span class="keyword">if</span>(p == q)&#123;</span><br><span class="line">                <span class="keyword">while</span>(node != p)&#123;</span><br><span class="line">                  node = node.next;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变"><a href="#有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变" class="headerlink" title="有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变"></a>有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变</h4><p>转化成链表，遍历链表将复苏和单独成链后连接到剩下的正数链上</p>
<p>数组两个索引，一个索引记录负数的尾部，一个所以负责遍历，每找到一个负数，将其插入该值，后续值后移一位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a[j]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">int</span> temp = a[j];</span><br><span class="line">               <span class="keyword">int</span> k = j;</span><br><span class="line">               <span class="keyword">while</span>(i&lt;=k-<span class="number">1</span>)&#123;</span><br><span class="line">                   a[k] = a[k-<span class="number">1</span>];</span><br><span class="line">                   k--;</span><br><span class="line">               &#125;</span><br><span class="line">               a[i] = temp;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i:a)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="打印蛇形矩阵"><a href="#打印蛇形矩阵" class="headerlink" title="打印蛇形矩阵"></a>打印蛇形矩阵</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="comment">// left to right.</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="comment">// top to bottom.</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="comment">// right to left.</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="comment">// bottom to top.</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求二叉树的叶子节点数"><a href="#求二叉树的叶子节点数" class="headerlink" title="求二叉树的叶子节点数"></a>求二叉树的叶子节点数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">testTree</span><span class="params">(Tree tree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree.left==<span class="keyword">null</span>&amp;&amp;tree.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;叶子节点：&quot;</span>+tree.val);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> testTree(tree.left)+testTree(tree.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> left = treeDepth(root.left);</span><br><span class="line">        <span class="comment">// 计算右子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> right = treeDepth(root.right);</span><br><span class="line">        <span class="comment">// 树root的深度=路径最长的子树深度 + 1</span></span><br><span class="line">        <span class="keyword">return</span> left &gt;= right ? (left + <span class="number">1</span>) : (right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="数组最大和"><a href="#数组最大和" class="headerlink" title="数组最大和"></a>数组最大和</h4><p>累加值：一个一个累加的值</p>
<p>最大值：记录累加值的最大值</p>
<p>假设数组为最大，每次添加一个值，如果i-1的值&lt;0，那么把i放入累加值，如果&gt;0，那么将i的值加到累加值，如果累加值&gt;最大值，则更新最大值。</p>
<p>如果需要数组的最大和的下标，对最大值的下标进行记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,-<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,-<span class="number">5</span>&#125;;</span><br><span class="line">        Long begintime = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> result =  FindGreatestSumOfSubArray(array);</span><br><span class="line">        Long endtime = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;连续子数组的最大和为：&quot;</span>+result+<span class="string">&quot;,运行时间：&quot;</span>+(endtime - begintime) + <span class="string">&quot;ns&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] currentsum = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        currentsum[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> greatsetsum = array[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;第1步：累加子数组和：&quot;</span>+currentsum[<span class="number">0</span>]+<span class="string">&quot;，最大子数组和：&quot;</span>+greatsetsum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="comment">//下面是动态规划的状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span>(currentsum[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                currentsum[i] = currentsum[i-<span class="number">1</span>] + array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                currentsum[i] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据currentsum的值更新greatsetsum的值</span></span><br><span class="line">            <span class="keyword">if</span>(currentsum[i] &gt; greatsetsum)&#123;</span><br><span class="line">                greatsetsum  = currentsum[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;步：累加子数组和：&quot;</span>+currentsum[i]+<span class="string">&quot;，最大子数组和：&quot;</span>+greatsetsum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> greatsetsum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？"><a href="#有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？" class="headerlink" title="有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？"></a>有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？</h4><h1 id="模式篇"><a href="#模式篇" class="headerlink" title="模式篇"></a>模式篇</h1><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>饿汉：线程安全，类初始化的时候就会触发类的实例化，所以保证只有一个，</p>
<p>缺点：但是会浪费内存，如果不使用单例，就会一直存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在静态初始化器中创建单例实例，这段代码保证了线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//Singleton类只有一个构造方法并且是被private修饰的，所以用户无法通过new方法创建该对象实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>懒汉：synchronized加锁线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//没有加入synchronized关键字的版本是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span>  Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前单例是否已经存在，若存在则返回，不存在则再建立单例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>双重校验锁：双重加锁（线程安全）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>双重判断的原因？<ul>
<li>第一个判断减少锁的使用，提升性能</li>
<li>多个线程同时等待锁，当第一个创建后，就不需要其他线程重复重建</li>
</ul>
</li>
<li>volatile的理解<ul>
<li>禁止重排序导致instance获取失败（3）。</li>
</ul>
</li>
<li>new Singleton()方法执行时可能导致分配了空间，并指向了内存空间，但是没有赋值，这样另一个线程拿到后会导致出错</li>
</ol>
<p>静态内部类：（线程安全）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span></span>&#123;</span><br><span class="line">        <span class="comment">//声明成员变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供接口获取该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>枚举单例：(线程安全)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">调用方法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.INSTANCE.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">直接通过Singleton.INSTANCE.doSomething()的方式调用即可。方便、简洁又安全。</span><br></pre></td></tr></table></figure>
<h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><p>生产者添加数据，消费者自己从中间件中获取信息，通过中间件管理数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kangsx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mode1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Queue&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(list.size()&gt;=maxSize)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(i);</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span> (list.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i = list.remove();</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.box = box;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            box.put(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.box = box;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">int</span> i = box.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box();</span><br><span class="line">        <span class="comment">//5个生产者</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Producer(box).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5个消费者</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Consumer(box).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><p>发布者发送数据到订阅者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kangsx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mode2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IObserver</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> temp)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IObservable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(IObserver iObserver)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(IObserver iObserver)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被观察者（发布者）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> <span class="keyword">implements</span> <span class="title">IObservable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;IObserver&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(IObserver iObserver)</span> </span>&#123;</span><br><span class="line">            list.add(iObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(IObserver iObserver)</span> </span>&#123;</span><br><span class="line">            list.remove(iObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                list.get(i).update(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemp</span><span class="params">(<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.temp = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者1（订阅者）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer1</span> <span class="keyword">implements</span> <span class="title">IObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Observable1更新为 = &quot;</span> + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者2(订阅者)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer2</span> <span class="keyword">implements</span> <span class="title">IObserver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Observable2更新为 = &quot;</span> + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Observable observable = <span class="keyword">new</span> Observable();</span><br><span class="line">        Observer1 observer1 = <span class="keyword">new</span> Observer1();</span><br><span class="line">        Observer2 observer2 = <span class="keyword">new</span> Observer2();</span><br><span class="line">        observable.register(observer1);</span><br><span class="line">        observable.register(observer2);</span><br><span class="line">        observable.setTemp(<span class="number">32131232</span>);</span><br><span class="line">        observable.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>提供复杂参数的对象构造，完全由调用方选择参数配置，反之使用默认。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//显示器</span></span><br><span class="line">    String display;</span><br><span class="line">    <span class="comment">//cpu型号</span></span><br><span class="line">    String cpu;</span><br><span class="line">    <span class="comment">//主板型号</span></span><br><span class="line">    String mainBoard;</span><br><span class="line">    <span class="comment">//显卡型号</span></span><br><span class="line">    String gpu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.display = builder.display;</span><br><span class="line">        <span class="keyword">this</span>.cpu = builder.cpu;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = builder.mainBoard;</span><br><span class="line">        <span class="keyword">this</span>.gpu = builder.gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;显示器是&quot;</span> + display + <span class="string">&quot;\ncpu是&quot;</span> + cpu + <span class="string">&quot;\n主板是&quot;</span> + mainBoard + <span class="string">&quot;\n显卡是&quot;</span> + gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="comment">//显示器</span></span><br><span class="line">        String display;</span><br><span class="line">        <span class="comment">//cpu型号</span></span><br><span class="line">        String cpu;</span><br><span class="line">        <span class="comment">//主板型号</span></span><br><span class="line">        String mainBoard;</span><br><span class="line">        <span class="comment">//显卡型号</span></span><br><span class="line">        String gpu;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.display = <span class="string">&quot;三星曲屏&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.cpu = <span class="string">&quot;i5 8400&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = <span class="string">&quot;华硕Z360-B&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.gpu = <span class="string">&quot;GTX 1050Ti&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setcpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMainBoard</span><span class="params">(String mainBoard)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = mainBoard;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setGpu</span><span class="params">(String gpu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.gpu = gpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Computer(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer.Builder()</span><br><span class="line">                .setcpu(<span class="string">&quot;i9 4700u&quot;</span>)</span><br><span class="line">                .setGpu(<span class="string">&quot;GTX 2060Ti&quot;</span>)</span><br><span class="line">                .setMainBoard(<span class="string">&quot;华硕Z480&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(computer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>对原有功能进行封装，访问对象不能直接访问原有功能，只能访问我们的功能传达，我们就是代理，作为原有功能和访问对象之间的中介</p>
<p>静态代理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>动态代理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">IRetrofit iRetrofit = (IRetrofit) Proxy.newProxyInstance(IRetrofit.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;IRetrofit.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----调用前执行&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----调用前执行Object&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(IRetrofit.class, args);</span><br><span class="line">                &#125;</span><br><span class="line">                IRetrofit iRetrofit1 = <span class="keyword">new</span> IRetrofit() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;------test1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kang</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;------kang1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                Object object = method.invoke(iRetrofit1,args);</span><br><span class="line">                System.out.println(<span class="string">&quot;-------调用后执行&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        iRetrofit.kang();</span><br></pre></td></tr></table></figure><br>打印如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----调用前执行</span><br><span class="line">------kang1</span><br><span class="line">-------调用后执行</span><br></pre></td></tr></table></figure><br>即想调用那个方法都可以，在invoke中做了代理，利用反射执行该类</p>
<h1 id="设计六种原则"><a href="#设计六种原则" class="headerlink" title="设计六种原则"></a>设计六种原则</h1><h4 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h4><p>接口业务单一</p>
<h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><h4 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h4><h4 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h4><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>提高复用性，可拓展性，将业务抽取单一获取</p>
<p>根据业务功能进行划分，功能复杂时考虑分层思想+设计模式，如果业务简单，可以直接套用设计模式进行方案优化，最后业务决定框架选型，细节方面可以面向未来考虑 尽量保证良好的扩展和健壮性</p>
<h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>widget树，skia 2d渲染引擎，</p>
<p>StatelessWidget：不能更新状态的布局，创建一次，永不可修改外观</p>
<p>StatefulWidget：可以更新界面，通过setState方法更新布局，外观</p>
<p>fish-redux</p>
<h2 id="Kotlin-1"><a href="#Kotlin-1" class="headerlink" title="Kotlin"></a>Kotlin</h2><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>完全兼容Java<br>更少的空指针异常<br>更少的代码量，更快的开发速度</p>
<h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><p>action：用户触发程序</p>
<p>reducer：根据action，做不同响应，返回一个新state</p>
<p>store：存储state的集合，数据是不可变的</p>
<h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><h3 id="iot触发日志文件上传"><a href="#iot触发日志文件上传" class="headerlink" title="iot触发日志文件上传"></a>iot触发日志文件上传</h3><p>通过bugly埋点，如果无法解决或者问题不全，或者酒店反馈音箱有问题</p>
<p>存储：监听时间广播，整点会重新存储日志文件，进程设置adb命令存储文件</p>
<p>每次中断或者时间到了都会触发重新开辟文件存储和老文件删除（只存储72个文件，正常情况下对应72个小时的）</p>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>使用leakcanary检测内存泄漏，绑定生命周期，在onDestroy的时候创建弱引用，放置在弱引用队列中，手动gc，如果查到该Activity，就是造成了内存泄漏，会打印出dump栈堆信息</p>
<h3 id="selinux权限配置"><a href="#selinux权限配置" class="headerlink" title="selinux权限配置"></a>selinux权限配置</h3><p>ota中遇到的问题，ota升级失败后，再日志中分析问题，再对应的<code>.te</code>文件中添加权限配置，循环往复，最终关闭这个权限校验。</p>
<p>定义每个用户，进程，应用，文件的访问和转变的权限，使用安全策略组控制这些实体</p>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><h4 id="如何检测？"><a href="#如何检测？" class="headerlink" title="如何检测？"></a>如何检测？</h4><ol>
<li><p>AOP（AspectJ）打点</p>
</li>
<li><p>程序打点</p>
</li>
<li><p>TraceView</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始收集</span></span><br><span class="line">Debug.startMethodTracing(<span class="string">&quot;app_trace&quot;</span>);</span><br><span class="line"><span class="comment">//结束收集</span></span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure>
<p>生成app_trace.trace文件，可以查看方法耗时</p>
</li>
<li><p>函数插桩（ASM）</p>
</li>
</ol>
<h4 id="具体的优化方案"><a href="#具体的优化方案" class="headerlink" title="具体的优化方案"></a>具体的优化方案</h4><ol>
<li>替换主题中theme，保证不会出现闪屏</li>
<li>decroView.post执行延时任务</li>
<li>IdleHandler闲置时间进行任务执行</li>
<li>异步线程池处理</li>
<li>基于dex文件的异步加载，在编译期间对dex按模块进行拆分，把一级页面及配置放置在第一个dex中，二三级页面及配置放置在第二个dex中。</li>
<li>在app启动过程中，不启动odex转化进程，在app启动后，自己启动一个odex进程，将转化后文件放入odex文件</li>
</ol>
<blockquote>
<p>在app启动过程中，android虚拟机会启动一个odex转化进程，将dex转化为odex，避免这个odex进程对前台app的影响很重要</p>
</blockquote>
<h4 id="主旨核心"><a href="#主旨核心" class="headerlink" title="主旨核心"></a>主旨核心</h4><ol>
<li>减法为主：尽量不影响主线程，能较少的启动就减少启动</li>
<li>异步为辅：耗时任务在异步调用</li>
<li>延迟为补：延迟加载增加全面性</li>
</ol>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>在使用Aspect进行时间的监测时，发现Application和Activity中的初始化三方进程耗费了大量时间，在初始化时，我们开启了百度OTA服务，Bugly监测服务，咪咕音乐服务，阿里IOT服务，日志监测服务，Linphone语音服务，Ifly语音服务等，这些串行起来是比较耗时的。<br>所以我们采用开启一个线程池的方案，在子线程启动这些服务，对于OTA，IOT，日志检测，Linphone等服务不需要在第一时间初始化，所以放到线程池中根据执行顺序分别初始化。但是对于咪咕、Ifly和bugly来说，需要第一时间初始化，才能进行后边的逻辑，所以我们将这些服务优先初始化，并联合CountDownLatch，当必须的服务初始化完成后，才进入下面的流程。<br>对于必须要在主线程进行初始化的操作，可能会造成主线程繁忙卡顿，所以使用IdleHandler方法，在主线程空闲时执行，</p>
<p>具体优化了40%，由2.3s压缩到1.4s。</p>
<p>如果由任务A，B，C，D，要求C在A之后执行，D在B之后执行，那么直接将A,C合并为一个任务，放入线程池中运行，B、D合并为一个任务，放入线池程中执行，如需决定AC和BD的顺序，那么可以按照AC、BD的顺序依次放入子线程中。</p>
<p>通过异步线程池进行异步加载处理，使用有向无环图算法控制任务进入线程池的顺序，通过CountDownLatch控制线程的执行顺序，进行异步加载</p>
<h4 id="如何对IDLEHandler进行顺序划分？比如先执行B，在执行A"><a href="#如何对IDLEHandler进行顺序划分？比如先执行B，在执行A" class="headerlink" title="如何对IDLEHandler进行顺序划分？比如先执行B，在执行A"></a>如何对IDLEHandler进行顺序划分？比如先执行B，在执行A</h4><p>规划一个空闲队列，在Handler空闲时进行处理，每次出队优先级最高的，其他等到下次空闲在执行</p>
<h4 id="2-5是怎么计算的？"><a href="#2-5是怎么计算的？" class="headerlink" title="2-5是怎么计算的？"></a>2-5是怎么计算的？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>CPU_COUNT - 1，是因为为了避免后台任务将 CPU 资源完全耗尽， 减掉的这个1 是留给我们 主线程 使用的。</p>
<p>cpu密集型的线程选择：n+1<br>io密集型的线程选择：</p>
<ol>
<li>2n+1</li>
<li>线程数 = CPU核心数/(1-阻塞系数)，一般情况下IO密集型的为0.8，0.9，可适当调整这个数值</li>
</ol>
<p>在改启动器中，我们存在的大都是cpu密集型任务，理论上选择n+1，但是目前在2-5中间进行选择</p>
<p>在最新版本的AsyncTask中的线程池已经设置为了5</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44367006/article/details/106717676">如何选择线程池最优线程数</a></p>
<h4 id="如何看待app-startUp？"><a href="#如何看待app-startUp？" class="headerlink" title="如何看待app startUp？"></a>如何看待app startUp？</h4><p>官方提供的启动优化方案，可以规定初始化模块的运行顺序，配合AndroidManifest+ContentProvider进行初始化。</p>
<p>在Application的生命周期中，application.attachBaseContext()—-&gt;contentProvider.onCreate()—–&gt;application.onCreate()</p>
<p>通过创建一个ContentProvider，在ContentProvider中执行初始化事件，减轻application的负担。</p>
<p>缺点：</p>
<ol>
<li>只支持同步事件，没有线程池做异步处理</li>
<li>需要编写大量的xxInitializer类文件，配置AndroidManifest文</li>
</ol>
<h3 id="设计一个模块："><a href="#设计一个模块：" class="headerlink" title="设计一个模块："></a>设计一个模块：</h3><ol>
<li>接口的易用性，从易用出发</li>
<li>命名规范</li>
<li>尽量不依赖第三方库，避免重复引用</li>
<li>多端使用的一致性，比如都开放同一个端口</li>
<li>sdk包保证小而精</li>
<li>保证老旧版本的兼容性</li>
<li>这类配置项一般就不需要提供 get 方法，防止接口太多</li>
</ol>
<h3 id="组件化构件"><a href="#组件化构件" class="headerlink" title="组件化构件"></a>组件化构件</h3><h3 id="布局优化-1"><a href="#布局优化-1" class="headerlink" title="布局优化"></a>布局优化</h3><h4 id="view的布局"><a href="#view的布局" class="headerlink" title="view的布局"></a>view的布局</h4><h5 id="ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别"><a href="#ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别" class="headerlink" title="ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别"></a>ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别</h5><p>ConstraintLayout：约束布局，完美结合RelativeLayout和LinearLayout的属性，可以拖拽，可以放置在相对布局，也可以按比例设置view，很像flex，都是一层布局</p>
<p>FrameLayout：后一个布局会覆盖前一个布局，可以控制层级</p>
<p>RelativeLayout：相对位置的布局</p>
<p>LinearLayout：线性布局，水平，垂直，比例分配</p>
<h5 id="include，viewstub，merge的区别"><a href="#include，viewstub，merge的区别" class="headerlink" title="include，viewstub，merge的区别"></a>include，viewstub，merge的区别</h5><p>include：复用布局</p>
<p>viewstub：可以显示网络布局，默认显示一次，更加省cpu和内存，只会构建一次，</p>
<p>merge：去除不必要的节点嵌套（比如多个LinearLayout的嵌套）</p>
<p>尽量使用ConstraintLayout，RelativeLayout，使用include，viewstub加载网络异常界面显示，merge去掉不必要的节点</p>
<h4 id="布局优化-2"><a href="#布局优化-2" class="headerlink" title="布局优化"></a>布局优化</h4><ol>
<li>针对复杂布局使用ConstraintLayout，减少层级，实现类Flex布局，后期也可拓展为MotionLayout，添加动画</li>
<li>针对简单布局，使用LinearLayout布局，不增加嵌套层级情况下，性能最优，onMeasure渲染一次</li>
<li>使用include布局对公共布局进行封装，便于统一修改和查看</li>
<li>使用merge标签作为根布局进行include内布局的封装，当其他布局引用时，会直接当作include布局的根布局使用，减少嵌套布局层级</li>
<li>使用viewStub标签，第一次展示时不会进行绘制，他是一个轻量级的view，没有尺寸，当需要使用布局时（调用inflate()方法），才会进行加载</li>
<li>使用开发者选项中的过度绘制进行检查并优化布局</li>
</ol>
<h3 id="apk体积优化"><a href="#apk体积优化" class="headerlink" title="apk体积优化"></a>apk体积优化</h3><p>使用apk Analyzer分析apk，体积主要在lib库，assets库，res库</p>
<p>从150M压缩到50M，</p>
<ol>
<li><p>lib库中存放着三方库，所以需要对三方库进行整理，剔除不需要的库，针对so库，剔除其他架构的so库，只留了armeabi-v7a包。</p>
</li>
<li><p>assets库和res库中主要是一些音频文件，帧动画图片，gif图片等</p>
<ol>
<li>对图片进行压缩，使用<a target="_blank" rel="noopener" href="https://tinypng.com/">tinypng</a>进行图片压缩（支持png和jpg格式）</li>
<li>大部分图片可以使用webp格式替换，减少体积</li>
<li>帧动画和gif尽量换成lottie动画</li>
</ol>
</li>
</ol>
<ol>
<li>使用lint删除无用资源和代码</li>
<li>大图换小图</li>
<li>代码优化整理复用</li>
<li>view整理复用</li>
<li>启动shrinkResources，移除不用的资源</li>
<li>大库换小库，能不用就不用</li>
<li>减小assets，raw的文件目录大小，尽量放置在网络上</li>
<li>调整需求，减少体量</li>
</ol>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Android%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/" class="pre-post btn btn-default" title='Android大厂面试题'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            Android大厂面试题</span>
    </a>
    
    
    <a href="/2021/05/31/%E9%9A%8F%E7%AC%94/%E8%8C%B6%E9%81%93/" class="next-post btn btn-default" title='茶道'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            茶道</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    

<div id="vcomments" class="valine"></div>

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

<script>
new Valine({
    av: AV,
    el: '#vcomments',
    appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
    appKey: 'erIpQac4azoCmgfBB7Dl9maa',
    placeholder: '说点什么吧',
    notify: false,
    verify: true,
    avatar: 'mm',
    meta: 'nick,mail'.split(','),
    pageSize: '10',
    path: window.location.pathname,
    lang: 'zh-CN'.toLowerCase()
})
</script>


</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E7%AF%87"><span class="toc-text">框架篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventBus"><span class="toc-text">EventBus</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0EventBus%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">简述EventBus的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus%E7%9A%84%E4%BA%94%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">EventBus的五种线程模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">EventBus的事件类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AFpublic%EF%BC%9F"><span class="toc-text">为什么必须是public？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8B%E4%BB%B6"><span class="toc-text">简述源码分析事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">索引如何理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MAIN%E5%92%8CMAIN-ORDERED%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">MAIN和MAIN_ORDERED的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus%E5%8F%AF%E5%90%A6%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">EventBus可否跨进程问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BackgroundThread%E5%92%8CAsync%E5%8C%BA%E5%88%AB"><span class="toc-text">BackgroundThread和Async区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">EventBus的优缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-text">EventBus如何做到线程切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%98%E6%80%A7%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">粘性事件的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%B8%BA%E4%B8%BB%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">如何判断当前线程是否为主线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96EventBus"><span class="toc-text">如何优化EventBus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8ConcurrentHashMap%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-text">为什么使用ConcurrentHashMap保存数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Okhttp3"><span class="toc-text">Okhttp3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0OkHttp"><span class="toc-text">简述OkHttp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%87%A0%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-text">有几个拦截器，分别是干什么的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RetryAndFollowUpIntercepter%E4%B8%AD%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%9F"><span class="toc-text">RetryAndFollowUpIntercepter中怎么进行重定向？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9F"><span class="toc-text">什么是连接池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-text">简述连接池的复用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0StreamAllocation"><span class="toc-text">简述StreamAllocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OKIO%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">OKIO的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dispatcher%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Dispatcher的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0OKhttp%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">简述OKhttp的缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E5%81%9Aget%E7%9A%84%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-text">为什么只做get的缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#okhttp%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-text">okhttp的优势？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%88websocket%EF%BC%89%E5%92%8C%E4%B9%85%E8%BF%9E%E6%8E%A5%EF%BC%88keep-alive%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">长连接（websocket）和久连接（keep-alive）的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#websocket%E7%9A%84%E6%8F%A1%E6%89%8B%E5%92%8Chttp%E7%9A%84%E6%8F%A1%E6%89%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">websocket的握手和http的握手有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MQTT%E7%90%86%E8%A7%A3"><span class="toc-text">MQTT理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MQTT%E5%92%8Cwebsocket%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">MQTT和websocket的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Retrofit"><span class="toc-text">Retrofit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-text">简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Retrofit%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">Retrofit中的动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Retrofit%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">Retrofit的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">动态代理和静态代理的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Butterknife%E2%80%94%E2%80%94%E2%80%94view%E7%9A%84%E6%B3%A8%E5%85%A5"><span class="toc-text">Butterknife———view的注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Butterknife"><span class="toc-text">简述Butterknife</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Butterknife%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A7%E4%BB%B6%E4%B8%8D%E8%83%BD%E7%94%A8private%E5%92%8Cstatic"><span class="toc-text">Butterknife为什么初始化控件不能用private和static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ButterKnife%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E5%85%B6%E4%BB%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6%E9%AB%98%EF%BC%9F%E5%AE%83%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-text">继承问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ViewBinding%E6%9C%80%E7%BB%88%E6%9C%80%E5%A5%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">ViewBinding最终最好的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E6%9E%90ViewBinding"><span class="toc-text">简析ViewBinding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ViewBinding%E5%92%8CButterknife%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">ViewBinding和Butterknife的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Viewbinding%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86include%E5%B8%83%E5%B1%80%EF%BC%9F"><span class="toc-text">Viewbinding如何处理include布局？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86"><span class="toc-text">注解原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E6%9E%90"><span class="toc-text">简析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">注解的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%94%A8%E5%A4%84"><span class="toc-text">注解的用处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%99%A8"><span class="toc-text">注解器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">自定义注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Glide%E5%92%8CPicasso"><span class="toc-text">Glide和Picasso</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0LruCache%E5%92%8CDiskLruCache"><span class="toc-text">简述LruCache和DiskLruCache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Glide%E7%9A%84%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B"><span class="toc-text">简述Glide的缓存过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Glide%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%EF%BC%9F"><span class="toc-text">Glide是如何绑定生命周期的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Glide%E4%B8%ADFragment%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%91%E5%AE%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%EF%BC%9F"><span class="toc-text">Glide中Fragment中是怎么绑定生命周期的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Glide%E4%B8%ADinto%E6%8C%87%E5%AE%9Aview%EF%BC%8C%E5%86%8D%E6%AC%A1%E5%88%B7%E6%96%B0view%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Glide中into指定view，再次刷新view会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Glide%E5%92%8CPicasso%E5%AF%B9%E6%AF%94"><span class="toc-text">Glide和Picasso对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Picasso"><span class="toc-text">Picasso</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco%E6%AF%94%E8%BE%83"><span class="toc-text">Fresco比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountingLruMap%EF%BC%8CLru%E7%AE%97%E6%B3%95%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98"><span class="toc-text">CountingLruMap，Lru算法清除缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E4%BD%93%E7%A7%AF"><span class="toc-text">包体积</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeakCanary"><span class="toc-text">LeakCanary</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityLifecycleCallbacks-%E4%B8%8E-FragmentLifeCycleCallbacks"><span class="toc-text">ActivityLifecycleCallbacks 与 FragmentLifeCycleCallbacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B"><span class="toc-text">如何做到内存泄漏检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="toc-text">其他内存泄漏检测工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASM%E5%87%BD%E6%95%B0%E6%8F%92%E6%A1%A9"><span class="toc-text">ASM函数插桩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-1"><span class="toc-text">简述</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">Android基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Application"><span class="toc-text">Application</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Application"><span class="toc-text">简述Application</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Application%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">Application的初始化流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityLifecycleCallbacks%E7%90%86%E8%A7%A3"><span class="toc-text">ActivityLifecycleCallbacks理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity"><span class="toc-text">Activity</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">简述生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Activity%EF%BC%9A"><span class="toc-text">Activity：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">简述启动模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LauncherMode%E5%92%8CstartActivityForResult"><span class="toc-text">LauncherMode和startActivityForResult</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84Activity%E6%A0%88%EF%BC%9F"><span class="toc-text">什么时候会启动一个新的Activity栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6Activity%E7%9A%84%E5%8A%A8%E7%94%BB%E5%88%87%E6%8D%A2"><span class="toc-text">如何控制Activity的动画切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6Fragment%E7%9A%84%E5%8A%A8%E7%94%BB%E5%88%87%E6%8D%A2"><span class="toc-text">如何控制Fragment的动画切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityA%E8%B7%B3%E8%BD%AC%E5%88%B0ActivityB%EF%BC%8C%E5%86%8D%E6%8C%89back%E9%94%AE%E8%BF%94%E5%9B%9EActivityA%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CActivityB%E6%98%AF%E7%AA%97%E5%8F%A3Activity%E5%91%A2%EF%BC%9F"><span class="toc-text">如果ActivityB是窗口Activity呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BC%9A%E5%8F%97Dialog%E5%BD%B1%E5%93%8D%E5%90%97%EF%BC%9F"><span class="toc-text">Activity的生命周期会受Dialog影响吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service"><span class="toc-text">Service</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Service%E6%9C%89%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Service有几种创建方式？有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3IntentService%EF%BC%9F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FHandlerThread-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如何理解IntentService？生命周期是什么？HandlerThread 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JobIntentService"><span class="toc-text">JobIntentService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onStartCommand%E4%B8%AD%E4%B8%89%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">onStartCommand中三个回调分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service%E4%BF%9D%E6%B4%BB"><span class="toc-text">Service保活</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fragment"><span class="toc-text">Fragment</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FragmentPagerAdapter%E5%92%8CFragmentStatePagerAdapter%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">FragmentPagerAdapter和FragmentStatePagerAdapter的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fragment%E7%9A%843%E7%A7%8D%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-text">Fragment的3种切换方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8Fragment%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E4%BC%A0%E5%8F%82%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%A3%E5%8A%BF%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fragment%E7%9A%84%E9%87%8D%E5%BB%BA%E5%9C%A8%E9%82%A3%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%EF%BC%9F"><span class="toc-text">Fragment的重建在那个生命周期中？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BroadCastReceiver"><span class="toc-text">BroadCastReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%B9%BF%E6%92%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">简述广播的启动方式和区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E5%B9%BF%E6%92%AD%E5%92%8C%E6%9C%89%E5%BA%8F%E5%B9%BF%E6%92%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">无序广播和有序广播的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%B9%BF%E6%92%AD%E5%92%8C%E5%85%A8%E5%B1%80%E5%B9%BF%E6%92%AD"><span class="toc-text">本地广播和全局广播</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPC%E6%9C%BA%E5%88%B6"><span class="toc-text">IPC机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0android%E4%B8%AD%E7%9A%84IPC%E6%9C%BA%E5%88%B6"><span class="toc-text">简述android中的IPC机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serializable%E5%92%8Cparcelable%E5%8C%BA%E5%88%AB"><span class="toc-text">Serializable和parcelable区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5Parcelable%EF%BC%9F"><span class="toc-text">Android为什么引入Parcelable？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parcelable%E4%B8%80%E5%AE%9A%E6%AF%94Serializable%E5%BF%AB%E5%90%97%EF%BC%9F"><span class="toc-text">Parcelable一定比Serializable快吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88java%E4%BD%BF%E7%94%A8Serializable%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFjson%E6%88%96%E8%80%85xml%EF%BC%9F"><span class="toc-text">为什么java使用Serializable序列化对象，而不是json或者xml？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E6%9E%90Binder%E6%9C%BA%E5%88%B6"><span class="toc-text">简析Binder机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86"><span class="toc-text">进程空间划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85ServiceManager%EF%BC%9F"><span class="toc-text">如何看待ServiceManager？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binder%E5%8E%9F%E7%90%86"><span class="toc-text">Binder原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">简述通信流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-text">详细的通信过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Binder%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-text">Binder在Android中的应用？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Binder%E6%9C%BA%E5%88%B6%EF%BC%9F%E4%BB%96%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">为什么选择Binder机制？他的优势是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%ADIPC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-text">Android中IPC的几种方式详细分析与优缺点分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler"><span class="toc-text">Handler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%A6%82%E6%8B%ACHandler%EF%BC%8C%E5%B9%B6%E7%AE%80%E8%BF%B0%E5%85%B6%E5%8E%9F%E7%90%86"><span class="toc-text">一句话概括Handler，并简述其原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Looper-loop-%E6%98%AF%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E9%80%A0%E6%88%90%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-text">Looper.loop()是在主线程的死循环，为什么没有造成线程阻塞？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#looper-loop-%E4%B8%AD%E5%BE%AA%E7%8E%AF%EF%BC%8C%E5%88%A4%E7%A9%BA%E9%80%80%E5%87%BA%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">looper.loop()中循环，判空退出怎么理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0UI%EF%BC%9F"><span class="toc-text">为什么不能在子线程更新UI？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%9F%E7%9A%84%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0UI%E5%90%97%EF%BC%9F"><span class="toc-text">真的不能在子线程更新UI吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ViewRootImpl%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%9F"><span class="toc-text">ViewRootImpl是什么时候被创建的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAThread%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%87%A0%E4%B8%AALooper-%E5%87%A0%E4%B8%AAHandler"><span class="toc-text">一个Thread中可以有几个Looper?几个Handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9B%B4%E6%8E%A5new%E4%B8%80%E4%B8%AAHandler%E5%90%97%EF%BC%9F%E9%82%A3%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">可以在子线程直接new一个Handler吗？那该怎么做？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Message%E5%8F%AF%E4%BB%A5%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%EF%BC%9F%E5%93%AA%E7%A7%8D%E6%95%88%E6%9E%9C%E6%9B%B4%E5%A5%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Message可以如何创建？哪种效果更好，为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Hanlder%E7%9A%84postDelay-%E5%90%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-text">使用Hanlder的postDelay()后消息队列会发生什么变化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E3%80%81%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%92%8C%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C%E6%B6%88%E6%81%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">ThreadLocal，谈谈你的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8Handler%EF%BC%8C%E8%80%8CUI%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%EF%BC%9F"><span class="toc-text">为什么子线程中不能使用Handler，而UI线程可以？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handler%E5%A6%82%E4%BD%95%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">Handler如何引起内存泄露？怎么解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MessageQueue-next-%E4%BC%9A%E5%9B%A0%E4%B8%BA%E5%8F%91%E7%8E%B0%E4%BA%86%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%EF%BC%8C%E8%80%8C%E8%BF%9B%E8%A1%8C%E9%98%BB%E5%A1%9E%E3%80%82%E9%82%A3%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%8E%E9%9D%A2%E5%8A%A0%E5%85%A5%E7%9A%84%E9%9D%9E%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E6%B2%A1%E6%9C%89%E8%A2%AB%E9%98%BB%E5%A1%9E%E5%91%A2%EF%BC%9F"><span class="toc-text">MessageQueue.next()会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handler%E5%BB%B6%E6%97%B6%E6%9C%BA%E5%88%B6%E4%BF%9D%E6%97%B6%E5%90%97%EF%BC%9F"><span class="toc-text">Handler延时机制保时吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handler%E7%9A%84%E5%85%A5%E9%98%9F%E6%9C%BA%E5%88%B6%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%88synchronized%EF%BC%89"><span class="toc-text">Handler的入队机制是线程安全的（synchronized）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%B2%BE%E7%A1%AE%E8%AE%A1%E6%97%B6%EF%BC%9F"><span class="toc-text">如何精确计时？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IdleHandler%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%A8%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">IdleHandler是什么？用处是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%9A%84Looper%E4%BD%95%E6%97%B6%E9%80%80%E5%87%BA%EF%BC%9F%E8%83%BD%E5%90%A6%E6%89%8B%E5%8A%A8%E9%80%80%E5%87%BA%EF%BC%9F"><span class="toc-text">主线程的Looper何时退出？能否手动退出？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BAapp"><span class="toc-text">如何退出app</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85sendMessageAtFrontOfQueue"><span class="toc-text">如何看待sendMessageAtFrontOfQueue()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85Handler%E6%9E%84%E9%80%A0%E4%B8%AD%E7%9A%84CallBack%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">如何看待Handler构造中的CallBack方法？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Looper-prepareMain-%E5%92%8CLooper-perpare%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Looper.prepareMain()和Looper.perpare的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncTask"><span class="toc-text">AsyncTask</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3AsyncTask%EF%BC%9F"><span class="toc-text">如何理解AsyncTask？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%B7%E6%AD%8C%E4%B8%BA%E4%BD%95%E5%BC%83%E7%94%A8AsyncTask"><span class="toc-text">谷歌为何弃用AsyncTask</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-1"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">简述线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#android%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">android主要分为几种线程池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B4%A9%E6%BA%83%E5%90%97%EF%BC%9F"><span class="toc-text">线程池中一个线程崩溃会导致线程池崩溃吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-text">如何检测线程池中的崩溃问题呢？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View"><span class="toc-text">View</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92"><span class="toc-text">触摸事件传递</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B"><span class="toc-text">点击事件的传递流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92"><span class="toc-text">简述view的事件传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E5%8F%AA%E6%89%A7%E8%A1%8ConTouch%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%B8%8D%E6%89%A7%E8%A1%8ConClick%E4%BA%8B%E4%BB%B6%EF%BC%9F"><span class="toc-text">如何让只执行onTouch事件，不执行onClick事件？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%AA%E5%8F%96%E4%BA%86%E4%BA%8B%E4%BB%B6%EF%BC%8C%E8%BF%98%E4%BC%9A%E5%BE%80%E4%B8%8B%E4%BC%A0%E5%90%97%EF%BC%9F%E9%82%A3%E4%BC%9A%E8%B5%B0%E5%88%B0%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">如果截取了事件，还会往下传吗？那会走到哪里？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%AA%E5%8F%96%E4%BA%86%E4%BA%8B%E4%BB%B6%E5%B9%B6%E5%A4%84%E7%90%86%E4%BA%86%E4%BA%8B%E4%BB%B6%E8%BF%98%E4%BC%9A%E8%BF%94%E5%9B%9E%E7%88%B6%E7%BA%A7%E5%90%97%EF%BC%9F"><span class="toc-text">如果截取了事件并处理了事件还会返回父级吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#requestDisallowInterceptTouchEvent"><span class="toc-text">requestDisallowInterceptTouchEvent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81"><span class="toc-text">如何解决滑动冲突</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ACTION-CANCEL%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">ACTION_CANCEL怎么理解？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%B0%E5%BA%95%E6%98%AF%E5%85%88%E5%88%B0DecorView%E8%BF%98%E6%98%AF%E5%85%88%E5%88%B0Window%E7%9A%84%EF%BC%9F"><span class="toc-text">事件到底是先到DecorView还是先到Window的？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%8E%A7-%E9%9D%9E%E9%87%8D%E7%82%B9"><span class="toc-text">多点触控(非重点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CViewGroup%E6%98%AF%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E7%9A%84%EF%BC%8CRecyclerView%E6%98%AF%E7%BA%B5%E5%90%91%E6%BB%91%E5%8A%A8%E7%9A%84%EF%BC%8C%E5%BD%93%E8%B0%83%E7%94%A8RecyclerView%E8%BF%9B%E8%A1%8C%E7%BA%B5%E5%90%91%E6%BB%91%E5%8A%A8%E6%97%B6%EF%BC%8C%E5%9C%A8%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-text">如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-text">View的加载流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0View%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-text">简述View的加载流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View%E7%9A%84%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">View的绘制机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">简述View的绘制流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#draw-%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">draw()中的具体流程是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MeasureSpec%E5%88%86%E6%9E%90"><span class="toc-text">MeasureSpec分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RelativeLayout%E3%80%81LinearLayout%E5%92%8CConstraintLayout"><span class="toc-text">RelativeLayout、LinearLayout和ConstraintLayout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setContentView%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">setContentView的执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97view%E7%9A%84%E5%AE%BD%E9%AB%98"><span class="toc-text">什么时候可以获得view的宽高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BC%80%E5%A7%8B%E7%BB%98%E5%88%B6Activity%E7%9A%84view%E7%9A%84%EF%BC%9F"><span class="toc-text">什么时候开始绘制Activity的view的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PhoneWindow%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%9F"><span class="toc-text">PhoneWindow是在什么时候创建的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View%E7%9A%84%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">View的刷新机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#requestLayout%E5%92%8Cinvalidate%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">requestLayout和invalidate区别是什么</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E6%9E%90Activity%E3%80%81Window%E3%80%81DecorView%E4%BB%A5%E5%8F%8AViewRoot%E4%B9%8B%E9%97%B4%E7%9A%84%E9%94%99%E7%BB%BC%E5%85%B3%E7%B3%BB"><span class="toc-text">简析Activity、Window、DecorView以及ViewRoot之间的错综关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setContentView%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-text">setContentView执行的具体过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E8%80%85%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA%EF%BC%9F"><span class="toc-text">四者的创建时机？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dialog%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8application%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="toc-text">dialog为什么不能用application创建？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RecyclerView%E5%92%8CListView"><span class="toc-text">RecyclerView和ListView</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0RecyclerView%E7%9A%84%E5%88%B7%E6%96%B0%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">简述RecyclerView的刷新和缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8C%BA%E5%88%AB"><span class="toc-text">缓存存储结构区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96"><span class="toc-text">数据集发生变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">滑动类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerView%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">RecyclerView的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BE%E5%A4%A7%E7%BC%93%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%BC%93%E5%AD%98%E6%B1%A0%E5%A4%A7%E5%B0%8F"><span class="toc-text">放大缓存大小和缓存池大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96onBindViewHolder-%E8%80%97%E6%97%B6"><span class="toc-text">优化onBindViewHolder()耗时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96"><span class="toc-text">布局优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#measure-%E4%BC%98%E5%8C%96%E5%92%8C%E5%87%8F%E5%B0%91requestLayout-%E8%B0%83%E7%94%A8"><span class="toc-text">measure()优化和减少requestLayout()调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notifyDataSetChanged-%E4%B8%8E-notifyItemRangeChanged-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">notifyDataSetChanged 与 notifyItemRangeChanged 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-notifyDataSetChanged-%E6%97%B6%E9%97%AA%E7%83%81%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">调用 notifyDataSetChanged 时闪烁的原因？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerView%E7%9B%B8%E5%AF%B9%E4%BA%8EListView%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">RecyclerView相对于ListView的优势是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adapter%EF%BC%8CviewHolder%E7%9A%84%E4%BD%9C%E7%94%A8-adapter%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">adapter，viewHolder的作用?adapter中常用方法的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerPool%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8SparseArray%EF%BC%9F"><span class="toc-text">RecyclerPool为何使用SparseArray？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LayoutManager%E6%A0%B7%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FsetLayoutManager%E6%BA%90%E7%A0%81%E9%87%8C%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">LayoutManager样式有哪些？setLayoutManager源码里做了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ItemDecoration%E7%9A%84%E7%94%A8%E9%80%94%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%87%AA%E5%AE%9A%E4%B9%89ItemDecoration%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%EF%BC%9F%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8BaddItemDecoration-%E6%BA%90%E7%A0%81%EF%BC%9F"><span class="toc-text">ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration()源码？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mChangedScrap%E5%92%8CmAttachedScrap%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">mChangedScrap和mAttachedScrap的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onMeasure%E8%BF%87%E7%A8%8B"><span class="toc-text">onMeasure过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Glide%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98"><span class="toc-text">如何解决Glide错乱问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerView%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96"><span class="toc-text">RecyclerView卡顿优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerView%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6"><span class="toc-text">RecyclerView的自适应高度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerView%E5%B5%8C%E5%A5%97RecyclerView%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%EF%BC%8CNestedScrollView%E5%B5%8C%E5%A5%97RecyclerView"><span class="toc-text">RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-text">动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-2"><span class="toc-text">简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E5%92%8C%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">属性动画和补间动画的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%80%BC%E5%99%A8%E5%92%8C%E4%BC%B0%E5%80%BC%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">属性动画中的差值器和估值器是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">android系统启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-text">android系统架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">简述系统启动流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%90%AF%E5%8A%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">第一个启动的进程是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init%E8%BF%9B%E7%A8%8B%E5%AD%B5%E5%8C%96%E5%87%BA%E4%BA%86%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">init进程孵化出了什么进程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Zygote%E8%BF%9B%E7%A8%8B%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Zygote进程做了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BASocket%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%9F"><span class="toc-text">为什么要创建Socket服务端？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#app%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">app启动流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">Activity启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SystemServer%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%BB%96%E5%92%8Czygote%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">SystemServer是什么？有什么作用？他和zygote的关系是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityManagerService%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">ActivityManagerService是什么？什么时候初始化的？有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#App-%E5%92%8C-AMS-SystemServer-%E8%BF%9B%E7%A8%8B-%E8%BF%98%E6%9C%89-zygote-%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">App 和 AMS(SystemServer 进程)还有 zygote 进程是如何通信的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AMS-PMS-WMS%E8%BF%90%E8%A1%8C%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%AD%E8%BF%98%E6%98%AF%E8%BF%9B%E7%A8%8B%E4%B8%AD%EF%BC%9F"><span class="toc-text">AMS&#x2F;PMS&#x2F;WMS运行在一个线程中还是进程中？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B"><span class="toc-text">apk打包流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#aapt%E5%92%8Caapt2%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">aapt和aapt2的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apk%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">apk的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apk%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B"><span class="toc-text">apk安装流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E5%A4%9A%E5%B0%91%E7%A7%8D%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">存在多少种安装方式，分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E8%B7%AF%E5%BE%84"><span class="toc-text">安装过程中的重要路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="toc-text">安装过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-text">Android虚拟机发展史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dalvik%E5%92%8CART%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Dalvik和ART是什么，有啥区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Dalvik"><span class="toc-text">Dalvik</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ART"><span class="toc-text">ART</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-text">区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dex-class-odex%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">.dex .class .odex的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B"><span class="toc-text">简述安装流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86"><span class="toc-text">接口加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E6%8A%80%E5%B7%A7"><span class="toc-text">项目中的接口加密技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84token%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">常规token校验机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">小知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ANR%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-text">ANR条件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ANR%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">ANR原理解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%AF%BC%E8%87%B4oom%EF%BC%9F"><span class="toc-text">什么情况下会导致oom？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%BA%94%E7%94%A8%E8%AE%BE%E7%BD%AE%E4%B8%BALauncher%EF%BC%9F"><span class="toc-text">如何将应用设置为Launcher？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC-MVP-MVVM"><span class="toc-text">MVC,MVP,MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MVC"><span class="toc-text">MVC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MVP"><span class="toc-text">MVP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SharedPreferences-commit-apply%E4%BD%BF%E2%BD%A4%E5%8C%BA%E5%88%AB"><span class="toc-text">SharedPreferences commit apply使⽤区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap%E8%A7%A3%E6%9E%90"><span class="toc-text">Bitmap解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Bitmap%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87%E7%9A%84%EF%BC%9F"><span class="toc-text">Bitmap是怎么存储图片的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bitmap%E5%9B%BE%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F"><span class="toc-text">Bitmap图片的内存是怎么计算的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bitmap%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%9F%E4%B8%8D%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">Bitmap加载优化？不改变图片质量的情况下怎么优化？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bitmap%E5%86%85%E5%AD%98%E5%A4%8D%E7%94%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">Bitmap内存复用怎么实现？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E6%B8%85%E5%A4%A7%E5%9B%BE%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-text">高清大图如何加载？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#intent%E5%8F%AF%E4%BB%A5%E4%BC%A0%E9%80%92bitmap%E5%90%97%EF%BC%9F"><span class="toc-text">intent可以传递bitmap吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bitmap%E5%86%85%E5%AD%98%E5%9C%A8%E5%90%84%E4%B8%AAandroid%E7%89%88%E6%9C%AC%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-text">Bitmap内存在各个android版本的存储？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">创建一个对象的方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E5%8D%A1%E9%A1%BF%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">界面卡顿的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E3%80%81%E6%B8%A9%E5%90%AF%E5%8A%A8%E3%80%81%E7%83%AD%E5%90%AF%E5%8A%A8"><span class="toc-text">冷启动、温启动、热启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">Android类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="toc-text">双亲委派</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="toc-text">为何要使用双亲委派</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%AA%E7%B1%BB%E5%8F%ABjava-lang-System%EF%BC%9F"><span class="toc-text">能不能自己写个类叫java.lang.System？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E5%8C%96"><span class="toc-text">插件化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sqlite%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F"><span class="toc-text">sqlite怎么保证数据可见性和线程安全性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bundle%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88intent%E8%A6%81%E4%BD%BF%E7%94%A8bundle%EF%BC%9F"><span class="toc-text">bundle的数据结构，为什么intent要使用bundle？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%9B%BE%E4%BC%A0%E8%BE%93"><span class="toc-text">大图传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webview"><span class="toc-text">webview</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#android%E8%B0%83%E7%94%A8js%E4%BB%A3%E7%A0%81"><span class="toc-text">android调用js代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#js%E8%B0%83%E7%94%A8android%E4%BB%A3%E7%A0%81"><span class="toc-text">js调用android代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%8F%AF%E4%BB%A5%E6%8B%96%E5%8A%A8%E7%9A%84View%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">要实现可以拖动的View该怎么做？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E6%96%B0%E7%9F%A5%E8%AF%86"><span class="toc-text">Android新知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RxJava"><span class="toc-text">RxJava</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jetpack"><span class="toc-text">Jetpack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AndroidX"><span class="toc-text">AndroidX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVM-1"><span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LiveData-ViewModel%E6%9B%BF%E6%8D%A2EventBus"><span class="toc-text">LiveData+ViewModel替换EventBus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ViewBinding%E6%9B%BF%E6%8D%A2Butterknife"><span class="toc-text">ViewBinding替换Butterknife</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%8C%E6%8F%92%E4%BB%B6%E5%8C%96%EF%BC%8C%E7%83%AD%E4%BF%AE%E5%A4%8D"><span class="toc-text">组件化，插件化，热修复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kotlin%E7%90%86%E8%A7%A3"><span class="toc-text">Kotlin理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConstraintLayout"><span class="toc-text">ConstraintLayout</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">Java基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-text">指令重排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#as-if-serial"><span class="toc-text">as-if-serial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#happens-before"><span class="toc-text">happens-before</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">JVM内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">JVM内存模型的三大特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%AA%E5%9E%83%E5%9C%BE%EF%BC%9F"><span class="toc-text">如何判断对象是个垃圾？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%88%A4%E5%AE%9A%E4%B8%BA%E5%8F%AF%E5%9B%9E%E6%94%B6%E5%8F%98%E9%87%8F"><span class="toc-text">比较常见的将对象判定为可回收变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">垃圾回收算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk7%E5%92%8Cjdk8%E4%B8%8A%E7%9A%84JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-text">jdk7和jdk8上的JVM内存结构的变化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%85%83%E7%A9%BA%E9%97%B4%E6%9B%BF%E4%BB%A3%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%9F"><span class="toc-text">为什么使用元空间替代永久代？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%AD%98%E5%9C%A8%E9%82%A3%EF%BC%9F"><span class="toc-text">字符常量池存在那？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">运行时常量池在哪？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">垃圾收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gc%E7%9A%84%E7%A7%8D%E7%B1%BB%E5%92%8C%E6%96%B9%E5%BC%8F"><span class="toc-text">gc的种类和方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-3"><span class="toc-text">简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87index%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="toc-text">数组下标index的计算过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%85%B7%E4%BD%93%E7%9A%84put%E8%BF%87%E7%A8%8B"><span class="toc-text">描述一下具体的put过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A96%E5%92%8C8-%EF%BC%9F"><span class="toc-text">为什么选择6和8 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-text">为什么不直接使用红黑树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%EF%BC%9A"><span class="toc-text">处理hash冲突的方法有以下几种：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E7%9A%84%E6%80%A7%E8%83%BD%E6%85%A2%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">HashMap的性能慢原因？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88"><span class="toc-text">线程不安全会导致什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E4%B8%AD%E9%BB%98%E8%AE%A4%E5%AE%B9%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%EF%BC%9F"><span class="toc-text">HashMap中默认容量为什么是2的幂？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashcode%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86"><span class="toc-text">hashcode计算原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">hash()算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">HashTable的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SparseArray%E7%90%86%E8%A7%A3"><span class="toc-text">SparseArray理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%83HashMap%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">较HashMap的优点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SparseArray%E4%B8%8EHashMap%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%EF%BC%9F"><span class="toc-text">SparseArray与HashMap的比较，应用场景是？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayMap%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">ArrayMap的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayMap%E5%92%8CSparseArray%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E9%80%89%E5%8F%96%EF%BC%9F"><span class="toc-text">ArrayMap和SparseArray怎么进行选取？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">TreeMap的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">TreeMap和HashMap的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">ThreadLocal的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">ThreadLocalMap的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E4%BD%BF%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">ThreadLocal使用弱引用的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">ThreadLocal的内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap%E6%B8%85%E7%90%86%E8%BF%87%E6%9C%9Fkey%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">ThreadLocalMap清理过期key的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">ConcurrentHashMap和HashMap的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%89hashmap%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8null%E5%80%BC%E5%92%8Cnull%E9%94%AE"><span class="toc-text">为什么只有hashmap可以存储null值和null键</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%81"><span class="toc-text">常见锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">锁的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%E5%B8%B8%E7%94%A8%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">java中常用锁的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8Cvolatile"><span class="toc-text">synchronized和volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0synchronized%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">简述synchronized的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E2%BE%AE%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-text">synchronized修饰静态方法、⾮静态方法区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile"><span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%92%8Cvolatile%E5%8C%BA%E5%88%AB"><span class="toc-text">synchronized和volatile区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E4%BF%AE%E9%A5%B0%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">synchronized修饰不同对象的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88CAS%EF%BC%89"><span class="toc-text">悲观锁和乐观锁（CAS）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-text">ReentrantLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">新建线程有几种方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-Thread%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-text">new Thread的弊端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-2"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">线程的5种状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start%E5%92%8Crun%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9Fsleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9Fjoin-yield%EF%BC%8Cinterrupt"><span class="toc-text">start和run的区别？sleep和wait的区别？join,yield，interrupt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8Bt1%E3%80%81t2%E3%80%81t3%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%96%E4%BB%AC%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-text">线程t1、t2、t3，如何保证他们顺序执行？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="toc-text">什么是死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">一个线程崩溃会影响其他线程吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%8F%8D%E5%B0%84"><span class="toc-text">java反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86"><span class="toc-text">反射原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%8D%E5%B0%84%E8%80%97%E6%97%B6%EF%BC%9F"><span class="toc-text">为什么反射耗时？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">什么是内联函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9final%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F"><span class="toc-text">反射可以修改final类型的成员变量吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9static%E5%80%BC%E5%90%97%EF%BC%9F"><span class="toc-text">反射可以修改static值吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8"><span class="toc-text">Java异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E6%9E%90-1"><span class="toc-text">简析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E6%A3%80%E6%9F%A5%E5%9E%8B%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9D%9E%E6%A3%80%E6%9F%A5%E5%9E%8B%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java中检查型异常和非检查型异常有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-finally-return%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">try-catch-finally-return执行顺序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">throw和throws的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BAStackOverFlowError%E5%8F%91%E7%94%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">栈溢出StackOverFlowError发生的几种情况？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">Java常见异常有哪些</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="toc-text">linux进程通信有几种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch%E5%8E%9F%E7%90%86"><span class="toc-text">CountDownLatch原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%B3%9B%E5%9E%8B"><span class="toc-text">Java泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%80%E8%BF%B0"><span class="toc-text">泛型简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%AF%B9%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">泛型对方法重载的影响？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-text">类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">java类的初始化流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%847%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="toc-text">jvm类加载机制的7个流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">全局变量和局部变量的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="toc-text">大致流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">类初始化的时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="toc-text">类的实例化触发时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">类的初始化和类的实例化的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E9%83%BD%E6%B2%A1%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%89%8D%EF%BC%8C%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9B%B8%E5%BA%94%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%90%97"><span class="toc-text">在类都没有初始化完毕之前，能直接进行实例化相应的对象吗?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E8%A1%8C%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BC%9A%E5%87%BA%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="toc-text">多线程进行类的初始化会出问题吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%9C%A8%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%B5%8B%E5%80%BC%E5%87%A0%E6%AC%A1%EF%BC%9F"><span class="toc-text">一个实例变量在对象初始化的过程中最多可以被赋值几次？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95"><span class="toc-text">屏幕</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E5%88%B7%E6%89%8B%E6%9C%BA%EF%BC%8C60hz%EF%BC%8C120hz%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">高刷手机，60hz，120hz指的是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E7%9A%84%E5%88%B7%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="toc-text">屏幕的刷新过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A7%E7%8E%87%EF%BC%8CVSYNC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">帧率，VSYNC是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E4%B8%AD%E5%8D%95%E7%BC%93%E5%AD%98%EF%BC%8C%E5%8F%8C%E7%BC%93%E5%AD%98%EF%BC%8C%E4%B8%89%E7%BC%93%E5%AD%98"><span class="toc-text">屏幕中单缓存，双缓存，三缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BF%AE%E6%94%B9%E4%BA%86UI%EF%BC%8C%E5%B1%8F%E5%B9%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%88%B7%E6%96%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">代码中修改了UI，屏幕是怎么进行刷新的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%95%8C%E9%9D%A2%E4%BF%9D%E6%8C%81%E9%9D%99%E6%AD%A2%E4%B8%8D%E5%8F%98%EF%BC%8C%E5%B1%8F%E5%B9%95%E4%BC%9A%E5%88%B7%E6%96%B0%E5%90%97%EF%BC%9F%E5%9B%BE%E5%83%8F%E4%BC%9A%E8%A2%AB%E9%87%8D%E6%96%B0%E7%BB%98%E5%88%B6%E5%90%97%EF%BC%9F"><span class="toc-text">如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">jvm垃圾回收机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9-1"><span class="toc-text">小知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E5%92%8Cfinal%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">static和final的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">java是值传递还是引用传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">String、StringBuilder、StringBuffer的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFfinal%EF%BC%88%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%89%E7%9A%84%EF%BC%9F"><span class="toc-text">String为什么是final（不可变）的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashcode%E3%80%81equals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">hashcode、equals和&#x3D;&#x3D; 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">进程，线程，协程的区别？阻塞和非阻塞的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-1"><span class="toc-text">线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-text">协程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-text">并发和并行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">协程和线程的比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kotlin"><span class="toc-text">Kotlin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kotlin%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="toc-text">kotlin协程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#suspend%EF%BC%8CrunBlocking%EF%BC%8Claunch%EF%BC%8CwithContext%EF%BC%8Casync%EF%BC%8CdoAsync%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">suspend，runBlocking，launch，withContext，async，doAsync之间的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%AF%87"><span class="toc-text">网络篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS"><span class="toc-text">HTTP和HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84Http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-text">简述一次完整的Http请求过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">简述三次握手和四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF2%E6%AC%A1%E6%88%96%E8%80%854%E6%AC%A1%EF%BC%9F"><span class="toc-text">为什么需要三次握手而不是2次或者4次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%A1%E6%89%8B%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%EF%BC%9F%E6%8C%A5%E6%89%8B%E5%8D%B4%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-text">为什么握手需要三次？挥手却需要四次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E5%90%97%EF%BC%9F"><span class="toc-text">握手可以携带数据信息吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852MSL%E6%89%8D%E8%83%BD%E8%BD%AC%E6%8D%A2%E5%88%B0CLOSE%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">为什么TIME_WAIT状态需要等待2MSL才能转换到CLOSE状态？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSL%E5%B1%82%E5%9C%A8%E4%BC%A0%E8%BE%93%E5%B1%82%E8%BF%98%E6%98%AF%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%9F"><span class="toc-text">SSL层在传输层还是应用层？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9F"><span class="toc-text">滑动窗口？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">拥塞控制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">TCP和UDP的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">常见状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">简述TCP和UDP的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket"><span class="toc-text">socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0https%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-text">简述https的加密过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8RSA%E5%8A%A0%E5%AF%86%E5%BD%A2%E5%BC%8F%E4%BA%A4%E6%8D%A2AES%E5%AF%86%E9%92%A5%EF%BC%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8RSA%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-text">为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%EF%BC%88dns%E5%8A%AB%E6%8C%81%EF%BC%89"><span class="toc-text">简述中间人攻击，如何解决？（dns劫持）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E5%88%86%E5%B1%82"><span class="toc-text">http分层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dns%E6%B1%A1%E6%9F%93"><span class="toc-text">dns污染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http1-0%E3%80%81http1-1%E5%92%8Chttp2-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">http1.0、http1.1和http2.0的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%AF%87"><span class="toc-text">算法篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-BubbleSort"><span class="toc-text">冒泡排序(BubbleSort)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88QuickSort%EF%BC%89"><span class="toc-text">快速排序（QuickSort）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%91%E5%85%8B%E7%89%8C%E7%AE%97%E6%B3%95"><span class="toc-text">扑克牌算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">根节点到目标节点的路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="toc-text">找出最小的k个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-text">二分查找法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%95%B4%E5%BD%A2%E6%95%B0%E7%BB%84%E9%87%8C%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C%E8%83%BD%E4%B8%8D%E8%83%BD%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E7%BB%99%E5%AE%9A%E6%95%B0"><span class="toc-text">一个整形数组里求两个数的和能不能等于一个给定数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-text">连续子数组的最大和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95"><span class="toc-text">摩尔投票法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAview%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%88%B6view"><span class="toc-text">两个view第一个公共父view</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E4%B8%8D%E6%98%AF%E7%8E%AF%E9%93%BE%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%85%A5%E5%8F%A3"><span class="toc-text">判断链表是不是环链，并返回入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B4%E5%9E%8B%E6%95%B0%E7%BB%84%EF%BC%8C%E5%8C%85%E5%90%AB%E6%AD%A3%E6%95%B0%E5%92%8C%E8%B4%9F%E6%95%B0%EF%BC%8C%E5%B0%86%E8%B4%9F%E6%95%B0%E6%94%BE%E5%9C%A8%E5%B7%A6%E8%BE%B9%EF%BC%8C%E4%B8%94%E4%BF%9D%E8%AF%81%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%BD%AE%E4%BF%9D%E6%8C%81%E4%B8%8D%E5%8F%98"><span class="toc-text">有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E8%9B%87%E5%BD%A2%E7%9F%A9%E9%98%B5"><span class="toc-text">打印蛇形矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0"><span class="toc-text">求二叉树的叶子节点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-text">求二叉树的深度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-text">数组最大和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E9%9D%A2%E5%80%BC%E4%B8%BA1%EF%BC%8C3%EF%BC%8C5%E7%9A%84%E7%A1%AC%E5%B8%81%E8%8B%A5%E5%B9%B2%EF%BC%8C%E9%9C%80%E8%A6%81%E5%87%91%E6%88%9011%E5%85%83%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E7%A1%AC%E5%B8%81%EF%BC%8C%E5%87%91%E6%88%90n%E5%85%83%E6%9C%80%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E7%A1%AC%E5%B8%81%EF%BC%9F"><span class="toc-text">有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%AF%87"><span class="toc-text">模式篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B"><span class="toc-text">单例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">生产者消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85"><span class="toc-text">观察者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">代理模式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%85%AD%E7%A7%8D%E5%8E%9F%E5%88%99"><span class="toc-text">设计六种原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3"><span class="toc-text">单一职责</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE"><span class="toc-text">依赖倒置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB"><span class="toc-text">接口隔离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-text">迪米特法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-text">开闭原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flutter"><span class="toc-text">Flutter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin-1"><span class="toc-text">Kotlin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-text">优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Native"><span class="toc-text">React Native</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redux"><span class="toc-text">redux</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AE%E7%82%B9"><span class="toc-text">亮点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iot%E8%A7%A6%E5%8F%91%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">iot触发日志文件上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-text">内存优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selinux%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE"><span class="toc-text">selinux权限配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96"><span class="toc-text">启动优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%EF%BC%9F"><span class="toc-text">如何检测？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-text">具体的优化方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%97%A8%E6%A0%B8%E5%BF%83"><span class="toc-text">主旨核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-text">优化方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9IDLEHandler%E8%BF%9B%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%88%92%E5%88%86%EF%BC%9F%E6%AF%94%E5%A6%82%E5%85%88%E6%89%A7%E8%A1%8CB%EF%BC%8C%E5%9C%A8%E6%89%A7%E8%A1%8CA"><span class="toc-text">如何对IDLEHandler进行顺序划分？比如先执行B，在执行A</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F"><span class="toc-text">2-5是怎么计算的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85app-startUp%EF%BC%9F"><span class="toc-text">如何看待app startUp？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%9A"><span class="toc-text">设计一个模块：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%84%E4%BB%B6"><span class="toc-text">组件化构件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96-1"><span class="toc-text">布局优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#view%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-text">view的布局</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ConstraintLayout%EF%BC%8CFrameLayout%EF%BC%8CRelativeLayout%E5%92%8CLinearLayout%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#include%EF%BC%8Cviewstub%EF%BC%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">include，viewstub，merge的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96-2"><span class="toc-text">布局优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apk%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96"><span class="toc-text">apk体积优化</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/assets/tagcanvas.min.js?rev=2.9.js"></script>

<script>
var tagOption = {
    textColour: '#444', // 字体颜色
    outlineMethod: 'block', // 选中模式
    outlineColour: '#FFDAB9', // 选中模式的颜色
    interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
    textHeight: 13,
    outlineRadius: 3,
    freezeActive: true || '', // 选中的标签是否继续滚动
    frontSelect: true || '', // 不选标签云后部的标签
    initial: [0.1, -0.1],
    depth: 0.5,
    decel: 0.95,
    maxSpeed: 0.03,
    reverse: true || '', // 是否反向触发
    fadeIn: 500, // 进入动画时间
    wheelZoom: false || '' // 是否启用鼠标滚轮
}
TagCanvas.Start('tag-cloud-3d', '', tagOption);
</script>



<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>