{"meta":{"title":"纳兰寒明的博客","subtitle":null,"description":null,"author":"纳兰寒明","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Kotlin初探","slug":"移动端/Android原生/Kotlin初探","date":"2021-05-31T13:08:21.000Z","updated":"2021-05-31T13:08:42.826Z","comments":true,"path":"2021/05/31/移动端/Android原生/Kotlin初探/","link":"","permalink":"http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Kotlin%E5%88%9D%E6%8E%A2/","excerpt":"","text":"[TOC] 概述以.kt结尾的程序文件 优点： 简洁：大大减少样板代码的数量 安全：避免空指针异常等整个类的错误 互操作性：充分利用JVM、Android和游览器的现有库 工具友好：可用任何Java IDE或者使用命令行构建 创建方法123456789/** * a:入参 b:入参 * 返回：Int */fun sum(a: Int, b: Int): Int &#123; // Int 参数，返回值 Int return a + b&#125;fun sum2(a: Int, b: Int): Int = a + b 可变长参数函数（vararg）1234567891011/** * 多个Int参数 */fun vars(vararg v:Int)&#123; for(vt in v)&#123; print(&quot;----$vt&quot;) &#125;&#125;main : vars(1,2,3,4,5) lambda12val sumLambda:(Int,Int) -&gt; Int = &#123;a,b -&gt;a+b&#125;println(sumLambda(1,2)) // 输出 3 val12//修饰不可变的变量，类似于 final，只可被赋值一次val &lt;标识符&gt; ：&lt;类型&gt; = &lt;初始化值&gt; var12//修饰可变的变量，声明时可不指定类型，由编译器判断var &lt;标识符&gt; ：&lt;类型&gt; = &lt;初始化值&gt; 12345678val a: Int = 1val b = 1 // 系统自动推断变量类型为Intval c: Int // 如果不在声明时初始化则必须提供变量类型c = 1 // 明确赋值var x = 5 // 系统自动推断变量类型为Intx += 1 // 变量可修改 注释1234567891011// kotlin中块注释的级联使用，其实个人觉得块注释的嵌套使用的意义不大，不过从视觉上确实能给人一种层次感/* 第一层块注释 /* 第二层块注释 /* 第三层快注释 这种注释方式在java中是不支持的，但是在kotlin中是支持的。算是一个亮点吧（貌似意义不大）。 */ */ */ 字符串模版$ 表示一个变量名或者变量值$varName 表示变量值${varName.fun()} 表示变量的方法返回值: 1234567var a = 1// 模板中的简单名称：val s1 = &quot;a is $a&quot; a = 2// 模板中的任意表达式：val s2 = &quot;$&#123;s1.replace(&quot;is&quot;, &quot;was&quot;)&#125;, but now is $a&quot; NULL检查机制123456789101112//类型后面加?表示可为空var age: String? = &quot;23&quot; //抛出空指针异常val ages = age!!.toInt()//不做处理返回 nullval ages1 = age?.toInt()//age为空返回-1val ages2 = age?.toInt() ?: -1//当 str 中的字符串内容不是一个整数时, 返回 nullfun parseInt(str: String): Int? &#123; // ...&#125; 类型检测及自动类型转换1234567891011121314fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 做过类型判断以后，obj会被系统自动转换为String类型 return obj.length &#125; //在这里还有一种方法，与Java中instanceof不同，使用!is // if (obj !is String)&#123; // // XXX // &#125; // 这里的obj仍然是Any类型的引用 return null&#125; 区间123456789101112131415161718for (i in 1..4) print(i) // 输出“1234”for (i in 4..1) print(i) // 什么都不输出if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125;// 使用 step 指定步长for (i in 1..4 step 2) print(i) // 输出“13”for (i in 4 downTo 1 step 2) print(i) // 输出“42”// 使用 until 函数排除结束元素for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 println(i)&#125; 基本数据类型 类型 位宽度 Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 十进制：123 长整型以大写的 L 结尾：123L 16 进制以 0x 开头：0x0F 2 进制以 0b 开头：0b00001011 Doubles 默认写法: 123.5, 123.5e10 Floats 使用 f 或者 F 后缀：123.5f 注意：8进制不支持 可以使用下划线使数字常量更易读: 12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 比较两个数字 Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。 三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小 类型转换12345678910val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b.toInt() // OKtoByte(): BytetoShort(): ShorttoInt(): InttoLong(): LongtoFloat(): FloattoDouble(): DoubletoChar(): Char 位操作符1234567shl(bits) – 左移位 (Java’s &lt;&lt;)shr(bits) – 右移位 (Java’s &gt;&gt;)ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)and(bits) – 与or(bits) – 或xor(bits) – 异或inv() – 反向 字符Char：使用单引号&#39;包含起来的 布尔Boolean：true和false 123|| – 短路逻辑或&amp;&amp; – 短路逻辑与! - 逻辑非 数组 注意: 与 Java 不同的是，Kotlin 中数组是不协变的（invariant）。 12345678910fun main(args: Array&lt;String&gt;) &#123; //[1,2,3] val a = arrayOf(1, 2, 3) //[0,2,4] val b = Array(3, &#123; i -&gt; (i * 2) &#125;) //读取数组内容 println(a[0]) // 输出结果：1 println(b[1]) // 输出结果：2&#125; 除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样 字符串和 Java 一样，String 是不可变的 123for (c in str) &#123; println(c)&#125; Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如： 1234567fun main(args: Array&lt;String&gt;) &#123; val text = &quot;&quot;&quot; 多行字符串 多行字符串 &quot;&quot;&quot; println(text) // 输出有一些前置空格&#125; String 可以通过 trimMargin() 方法来删除多余的空白。 12345678910fun main(args: Array&lt;String&gt;) &#123; val text = &quot;&quot;&quot; |多行字符串 |菜鸟教程 |多行字符串 |Runoob &quot;&quot;&quot;.trimMargin() println(text) // 前置空格删除了&#125;//默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(&quot;&gt;&quot;)。 字符串模版表达式123456789101112131415161718fun main(args: Array&lt;String&gt;) &#123; val i = 10 val s = &quot;i = $i&quot; // 求值结果为 &quot;i = 10&quot; println(s)&#125;fun main(args: Array&lt;String&gt;) &#123; val s = &quot;runoob&quot; val str = &quot;$s.length is $&#123;s.length&#125;&quot; // 求值结果为 &quot;runoob.length is 6&quot; println(str)&#125;fun main(args: Array&lt;String&gt;) &#123; val price = &quot;&quot;&quot; $&#123;&#x27;$&#x27;&#125;9.99 &quot;&quot;&quot; println(price) // 求值结果为 $9.99&#125; When表达式类似于其他语言的switch，else类似于default 1234567when (x) &#123; 1 -&gt; print(&quot;x == 1&quot;) 2 -&gt; print(&quot;x == 2&quot;) else -&gt; &#123; // 注意这个块 print(&quot;x 不是 1 ，也不是 2&quot;) &#125;&#125; 类1val site = Runoob() // Kotlin 中没有 new 关键字 主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。 类也可以有二级构造函数，需要加前缀 constructor 类默认是不可变的，即是被final修饰的，使用open后，去除final 内部类使用 inner 关键字来表示。 12345678910111213141516abstract // 抽象类 final // 类不可继承，默认属性enum // 枚举类open // 类可继承，类默认是final的annotation // 注解类private // 仅在同一个文件中可见protected // 同一个文件中或子类可见public // 所有调用的地方都可见internal // 同一个模块中可见模块：一个 IntelliJ IDEA 模块；一个 Maven 项目；一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）；一次 &lt;kotlinc&gt; Ant 任务执行所编译的一套文件。 扩展函数1234567891011class User(var name:String)/**扩展函数**/fun User.Print()&#123; print(&quot;用户名 $name&quot;)&#125;fun main(arg:Array&lt;String&gt;)&#123; var user = User(&quot;Runoob&quot;) user.Print()&#125; 伴生对象关键字整理 lateinit：延迟初始化 ​ 作用：具体来讲，这个关键字告诉编译器，我无法声明的时候就初始化，但是我保证我在使用前一定会初始化，你就别给我检查了。 apply：用于对象配置，类似于构造者模式（Builder），调用某对象的apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象 with：返回是最后一行，然后可以直接调用对象的方法，感觉像是let和apply的结合。 let：默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return also：调用某对象的also函数，则该对象为函数的参数。在函数块内可以通过 it 指代该对象。返回值为该对象自己。 run：run函数和apply函数很像，只不过run函数是使用最后一行的返回，apply返回当前自己的对象。","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"内存优化","slug":"移动端/Android原生/内存优化","date":"2021-05-31T13:02:06.000Z","updated":"2021-05-31T13:02:24.279Z","comments":true,"path":"2021/05/31/移动端/Android原生/内存优化/","link":"","permalink":"http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/","excerpt":"","text":"[TOC] 2895 为什么要做内存优化？Java虚拟机Java内存模型 虚拟机栈（线程私有）：局部变量表、操作数栈、动态链接、方法出口等信息 堆（线程共享）：实例对象 方法区（线程共享）：类信息，常量，即时编译器编译后的代码 程序计数器（线程私有）：字节码行号指示器，记录当前线程执行到多少行 本地方法栈（线程私有）：和虚拟机栈类似，两者的区别就是虚拟机栈是为虚拟机执行java方法服务，本地方法栈为虚拟机执行native方法服务 。 程序计数器线程计数器中如果正在执行java方法，计数器记录的是当前指令的地址，如果是Native方法，计数器记录为空 堆堆内存 = 新生代(1) + 老年代(2) 新生代：复制算法 老年代：标记整理算法 方法区也叫“永久代”，1.8以后将方法区去除了，将方法区移动到直接内存 内存回收主要考虑堆区和方法区的回收，其他部分会根据线程的产生和消亡 个版本区别 1.6：运行常量池在方法区 1.7：运行常量池在堆中 1.8：删除方法区，引入直接内存，元空间概念，方法区中的静态变量被转移到堆中，只有class元数据在元空间。 堆中的老年代和方法区（永久代）是绑定的，无论哪一方满了，都会触发双方的GC回收 问题： 堆和栈的区别： 栈：基本数据类型变量（int、short、long、byte、float、double、boolean、char）以及对象的引用变量 堆：存储java对象 堆中的对象对所有线程可见，栈内存只属于一个线程 堆的内存空间远远大于栈 为什么删除方法区？ 启动大小固定，很难调优，容易发生OOM 元空间在本地内存中分配，本地内存足够就不会溢出 GC垃圾回收判断对象是否存活 引用计数算法（缺点：循环引用，技数永远不为0） 可达性算法（二叉树中向下搜索，不存在引用链则对象不可用） 回收算法 标记清除算法：标记完后对对象进行回收，使用在老年代 缺点： 效率不高，标记和清除效率不高 差生大量碎片空间，导致空间浪费 复制算法：将可用对象复制到新的连续空间，删除之前的空间 缺点： 浪费50%的内存，复制长生存期的对象效率低下，所以该算法使用在新生代 标记整理算法：前期使用标记清除算法，后续使用整理算法，使对象排列称联系空间，使用在老年代 分代收集算法：对数据进行分代，每一代执行不同的回收算法 年轻代分为eden、s0、s1区，分别为8：1：1，年轻代和老年代为1：2 元空间的gc：元空间中的类加载器存活，则元空间中元数据也存活 Minor GC ： 清理年轻代 Major GC ： 清理老年代 Full GC ： 清理整个堆空间，包括年轻代和永久代 四大引用介绍简述 强引用：Strong Reference，通常使用的对象方式，gc不会回收 软引用：SoftReference，当内存不足时进行回收 弱引用：WeakReference，下一次gc时回收 虚引用：PhantomReference，任何时候可回收 在内存泄露问题处理上，使用最多的是弱引用，许多源码、框架都是用eg： ThreadLocalMap中存储以ThreadLocal的弱引用为键，具体内容为value Glide中缓存使用activeResource，存储的是图片的弱引用 解决Handler的内存泄漏使用弱引用 Reference理解所有的引用都是继承自Reference，以下以WeakReference为例：12345678910111213141516171819202122232425public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; &#123; /** * Creates a new weak reference that refers to the given object. The new * reference is not registered with any queue. * * @param referent object the new weak reference will refer to */ public WeakReference(T referent) &#123; super(referent); &#125; /** * Creates a new weak reference that refers to the given object and is * registered with the given queue. * * @param referent object the new weak reference will refer to * @param q the queue with which the reference is to be registered, * or &lt;tt&gt;null&lt;/tt&gt; if registration is not required */ public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125;&#125; 其中存在两种构造方法，区别在于是否传入引用队列，如果不传入引用队列，说明只存在一种引用，不需要引用队列成链存储 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 public abstract class Reference&lt;T&gt; &#123; private static boolean disableIntrinsic = false; private static boolean slowPathEnabled = false; //引用的对象，由垃圾回收器控制其引用 volatile T referent; /* Treated specially by GC */ final ReferenceQueue&lt;? super T&gt; queue; Reference queueNext; Reference&lt;?&gt; pendingNext; public T get() &#123; return getReferent(); &#125; @FastNative private final native T getReferent(); public void clear() &#123; clearReferent(); &#125; @FastNative native void clearReferent(); public boolean isEnqueued() &#123; // Contrary to what the documentation says, this method returns false // after this reference object has been removed from its queue // (b/26647823). ReferenceQueue.isEnqueued preserves this historically // incorrect behavior. return queue != null &amp;&amp; queue.isEnqueued(this); &#125; public boolean enqueue() &#123; return queue != null &amp;&amp; queue.enqueue(this); &#125; /* -- Constructors -- */ Reference(T referent) &#123; this(referent, null); &#125; Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) &#123; this.referent = referent; this.queue = queue; &#125;&#125; 抽象类很简短，可以看出一个关键点，Reference是一个节点，保存next的引用，方法调用都是使用ReferenceQueue方法，直接进入：1234567891011121314151617181920212223242526272829303132 private Reference&lt;? extends T&gt; head = null; private Reference&lt;? extends T&gt; tail = null; boolean enqueue(Reference&lt;? extends T&gt; reference) &#123; synchronized (lock) &#123; if (enqueueLocked(reference)) &#123; lock.notifyAll(); return true; &#125; return false; &#125; &#125; private boolean enqueueLocked(Reference&lt;? extends T&gt; r) &#123; ... if (r instanceof Cleaner) &#123; Cleaner cl = (sun.misc.Cleaner) r; cl.clean(); r.queueNext = sQueueNextUnenqueued; return true; &#125; if (tail == null) &#123; head = r; &#125; else &#123; tail.queueNext = r; &#125; tail = r; tail.queueNext = r; return true; &#125;入队方法中， 使用synchronized添加锁，入队结束后释放锁，在ReferenceQueue中并不是标准的队列，使用的是Reference节点成链，行成单链表，类似于MessageQueue. 如果是Cleaner类，创建一个虚引用节点，即不如队。Cleaner是用来释放非堆内存，所以做特殊处理 SoftReference1234567891011121314151617181920212223242526272829303132public class SoftReference&lt;T&gt; extends Reference&lt;T&gt; &#123; //时间戳，由gc更新 static private long clock; private long timestamp; public SoftReference(T referent) &#123; super(referent); this.timestamp = clock; &#125; /** * Creates a new soft reference that refers to the given object and is * registered with the given queue. * * @param referent object the new soft reference will refer to * @param q the queue with which the reference is to be registered, * or &lt;tt&gt;null&lt;/tt&gt; if registration is not required * */ public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); this.timestamp = clock; &#125; public T get() &#123; T o = super.get(); if (o != null &amp;&amp; this.timestamp != clock) this.timestamp = clock; return o; &#125;&#125;由gc管理时间戳 clock：上一次gc时间 timestamp：访问get时最近一次的gc时间 回收条件为：clock - timestamp &lt;= free_heap * ms_per_mb free_heep为堆空间空闲大小 ms_per_mb是保留软引用时间/MB PhantomReference123456789101112public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public T get() &#123; return null; &#125; public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125;&#125;虚引用的get方法返回null，不做gc保留 虚引用通过构造方法可以查看是持有对象引用的 总结：所有引用都是继承自Reference基类的，该类是一个链表节点，ReferenceQueue通过这点形成单链表，称之为队列，进行引用管理，所有引用都可以通过Reference的isEnqueue方法判断引用是否存在。 FinalizerReference理解java堆中创建对象时，如果java类定义了finalize方法，就会新建一个FinalizerReference类，指向这个新建的对象 内存问题 内存泄漏：内存没有按照预期在gc时回收 内存溢出：内存大小超出指定大小，导致OOM 内存抖动：短时间创建大量内存对象，然后回收，导致内存发生锯齿形抖动，内存空间不连续加上碎片会导致更大的空间，最终OOM 内存优化意义 减少OOM，提高系统稳定性 减少卡顿，提高流畅度 减少内存占用，提高应用存活率 减少异常发生和代码逻辑隐患 Android内存泄漏常见内存泄漏 匿名内部类持有外部类引用，导致外部类内存泄漏（Handler） 单例传入Context导致调用单例方无法被回收。 非静态内部类创建静态实例 注册与反注册 资源对象关闭 集和及时清理 内存泄漏检测 Profiler,Memory Analyzer(MAT) Android studio自带内存、cpu、网络的变化，可以根据内存变化做具体分析 LeakCanary 框架集成，自动检测内存泄漏，生成app，提供内存泄漏栈堆情况 原理：绑定生命周期，对Activity和Fragment来说，在onDestory时将对象放入弱引用队列进行存储，触发gc后，如果还存在，则发生内存泄漏 StrictMode（很少用） 一款比较老的工具，ThreadPolicy可以检测主线程是否网络访问，是否读写。VMPolicy检测内存，Activity，Fragment是否泄漏，资源是否正确关闭 内存优化空间 不必要的自动装箱 自动装箱就是将基础数据类型转化为对应的复杂类型，在HashMap的增删改查中充满了自动装箱问题，所以尽量避免这中问题，如将HashMap替换为SparseArray和ArrayMap 内存复用 资源复用：通用字符串，颜色，布局 视图复用：类似于RecyclerView的优化复用 对象池：创建对象池，不用重复创建对象，类似于线程池，messae享元模式 Bitmap对象复用：使用inBitmap属性可以告知Bitmap解码器尝试使用已经存在的内存区域，新解码的bitmap会尝试使用之前那张bitmap在heap中占据的pixel data内存区域。 在App可用内存过低时主动释放内存在App退到后台内存紧张即将被Kill掉时选择重写Application中 onTrimMemory/onLowMemory 方法去释放掉图片缓存、静态缓存来自保。 其他场景优化 item被回收不可见时释放掉对图片的引用 ListView：因此每次item被回收后再次利用都会重新绑定数据，只需在ImageView onDetachFromWindow的时候释放掉图片引用即可。 RecyclerView：因为被回收不可见时第一选择是放进mCacheView中，这里item被复用并不会只需bindViewHolder来重新绑定数据，只有被回收进mRecyclePool中后拿出来复用才会重新绑定数据，因此重写Recycler.Adapter中的onViewRecycled()方法来使item被回收进RecyclePool的时候去释放图片引用。 如果使用字符串拼接，尽量使用StringBuilder、StringBuffer（内存抖动） 自定义view减少onDraw的耗时和执行次数 尽量使用静态内部类 尽量使用基础数据类型 合适的时候使用软/弱引用 线上监控方案 常规监测 当内存使用超过80%，使用 Debug.dumpHprofData(String fileName)获取dump文件回传至服务器，而后手动分析 LeakCanary集成并带到线上 Probe线上监测工具 LeakInspector ResourceCanary","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"包体优化","slug":"移动端/Android原生/包体优化","date":"2021-05-31T13:01:25.000Z","updated":"2021-06-10T05:46:06.790Z","comments":true,"path":"2021/05/31/移动端/Android原生/包体优化/","link":"","permalink":"http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%8C%85%E4%BD%93%E4%BC%98%E5%8C%96/","excerpt":"","text":"[TOC] 优化好处 包体积减小，易于升级 多市场渠道有体积限制，避免二次处理 apk安装时间减小 运行时内存占用小 磁盘空间占用小，odex二进制文件小。 APK组成及分析APK组成 assets: 开发目录下assets目录 lib：所需要的so库 META-INF：签名文件 okhttp3：okhttp网络相关 org：org相关信息 res：布局信息，对应开发目录res下 AndroidManifest：四大组件配置 classes.dex：代码压缩文件 apk分析 使用常规apktool方法 使用jadx工具 https://github.com/skylot/jadx 直接将apk拖入程序即可查看各种信息 Android Studio中的Analyze apk可以分析apk的组成 优化方案代码优化代码全部存储在dex文件中，所以我们需要先搞懂什么是dex？ dex理解dex文件是专为Dalvik设计的一种压缩格式 .java–&gt;.class–&gt;.dex 在.java–&gt;.class过程中，主要是jvm的操作，在.class–&gt;.dex过程中，需要将.class文件转化为Dalvik识别的.dex文件 dex主要结构如下： 同jar相比，dex文件的大小能够缩减50%左右 ProGuard代码混淆在build.gradle中开启混淆，将类名转化为没有意义的a,b,c等，提高阅读难度，其次通过缩短名称可以有效缩减dex大小，而且会移除在代码中没有使用的代码。 D8与R8的优化 D8：把java字节码转化为dex代码，简单来说就是dex编译器 R8：混淆压缩与优化部分的替代品，但是不能完全替代proguard D8的提出是用来取代DX的，他的优化如下： 编译时间缩短 .dex文件更小 .dex运行性能更好 包含java8语言支持 R8与proguard非常相似，但不能完全替代proguard ProGuard 在将枚举类型简化为原始整数方面会更加强大 ProGuard 中应用的模式匹配算法可以识别和替换短指令序列，从而提高代码效率并为更多优化打开了机会。在优化遍历的顺序中，尤其是数学运算和字符串运算可从中受益 ProGuard 具有独特的能力来优化使用 GSON 库将对象序列化或反序列化为 JSON 的代码 Dex分包优化当apk方法数超过65536时，必须采用分包策略，这样跨dex调用会出现一些重复信息： 多余的 method id：跨 Dex 调用会导致当前dex保留被调用dex中的方法id，这种冗余会导致每一个dex中可以存放的class变少，最终又会导致编译出来的dex数量增多，而dex数据的增加又会进一步加重这个问题。 其它跨dex调用造成的信息冗余：除了需要多记录被调用的method id之外，还需多记录其所属类和当前方法的定义信息，这会造成 string_ids、type_ids、proto_ids 这几部分信息的冗余。 所以使用ReDex进行分包优化，同时，去除dex文件中的debug信息及行号信息 svg的使用使用指定语言，删除不必要的语言使用XZ Utils进行Dex压缩https://tukaani.org/xz/将dex压缩后放在assets目录中，减少包体积，但是会提高安装时间 三方库优化在使用三方库中，小库可以完成目前业务就是用小库，减小三方库的大小，比如Picasso、Glide、Fresco的大小和功能 Lint使用Lint优化代码，移除没有使用的代码 减少enum的使用Android 中的 Enum 到底占多少内存？该如何用？ 资源优化 Lint：使用lint去除冗余资源 shrinkResources：去除无用资源 重复资源优化：多模块使用同一个资源文件，去除重复资源文件，保留第一份资源 图片压缩：AAPT优化图片，选择webp格式的图片 使用针对性图片格式 聊天表情出一套图 =&gt; hdpi。 纯色小 icon 使用 VD =&gt; raw。 背景大图出一套 =&gt; xhdpi。 logo 等权重比较大的图片出两套 =&gt; hdpi，xhdpi。 若某些图在真机中有异常，则用多套图。 若遇到奇葩机型，则针对性补图。 资源路径混淆成单个资源的路径：使用AndroidResGuard，缩短资源路径 将资源文件放置在服务器上，通过网络加载 so库优化 通过abiFilters过滤so库 对于敏感的so库，不同架构全部放置在armeabi中，在程序中判断系统架构，加载不同的so库 Native Library压缩：XZ Utils，SoLoader so库动态下载：https://mp.weixin.qq.com/s/X58fK02imnNkvUMFt23OAg 其他优化 插件化 插件可以热插拔，从服务器下载 转变开发模式 使用混合式开发 梳理业务，简化逻辑和业务","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"布局优化","slug":"移动端/Android原生/布局优化","date":"2021-05-31T13:00:35.000Z","updated":"2021-06-24T09:16:05.588Z","comments":true,"path":"2021/05/31/移动端/Android原生/布局优化/","link":"","permalink":"http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/","excerpt":"","text":"[TOC] 绘画原理Android的绘制主要是借助cpu和gpu结合刷新机制共同完成的 cpu：负责执行measure、layout等方法，计算显示内容 gpu：负责栅格化（将UI元素绘制在屏幕上） 绘制过程使用skia库（2D），硬件本质是采用openGL库进行绘制 16ms内渲染一次，否则会掉帧 布局加载原理Android中的布局加载入口为setContentView()，分析如下：1234567@Override public void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID); &#125; //AppCompatDelegate.java public abstract void setContentView(@LayoutRes int resId);查看抽象接口实现123456789101112@Override public void setContentView(int resId) &#123; ensureSubDecor(); //获取content跟布局 ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); //移除所有布局 contentParent.removeAllViews(); //加载新布局 LayoutInflater.from(mContext).inflate(resId, contentParent); //接口状态通知 mOriginalWindowCallback.onContentChanged(); &#125;进入inflate方法：123456789101112131415161718public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null); &#125; public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); &#125; final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125; &#125;getLayout方法返回一个XmlResourceParser对象：123456789101112131415161718192021public XmlResourceParser getLayout(@LayoutRes int id) throws NotFoundException &#123; return loadXmlResourceParser(id, &quot;layout&quot;);&#125;@NonNullXmlResourceParser loadXmlResourceParser(@AnyRes int id, @NonNull String type) throws NotFoundException &#123; final TypedValue value = obtainTempTypedValue(); try &#123; final ResourcesImpl impl = mResourcesImpl; impl.getValue(id, value, true); if (value.type == TypedValue.TYPE_STRING) &#123; return impl.loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type); &#125; throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id) + &quot; type #0x&quot; + Integer.toHexString(value.type) + &quot; is not valid&quot;); &#125; finally &#123; releaseTempTypedValue(value); &#125;&#125;进入loadXmlResourceParser：12345678910111213141516171819202122232425262728293031323334353637383940414243444546@NonNull XmlResourceParser loadXmlResourceParser(@NonNull String file, @AnyRes int id, int assetCookie, @NonNull String type) throws NotFoundException &#123; if (id != 0) &#123; try &#123; synchronized (mCachedXmlBlocks) &#123; final int[] cachedXmlBlockCookies = mCachedXmlBlockCookies; final String[] cachedXmlBlockFiles = mCachedXmlBlockFiles; final XmlBlock[] cachedXmlBlocks = mCachedXmlBlocks; // First see if this block is in our cache. final int num = cachedXmlBlockFiles.length; for (int i = 0; i &lt; num; i++) &#123; if (cachedXmlBlockCookies[i] == assetCookie &amp;&amp; cachedXmlBlockFiles[i] != null &amp;&amp; cachedXmlBlockFiles[i].equals(file)) &#123; return cachedXmlBlocks[i].newParser(); &#125; &#125; // Not in the cache, create a new block and put it at // the next slot in the cache. final XmlBlock block = mAssets.openXmlBlockAsset(assetCookie, file); if (block != null) &#123; final int pos = (mLastCachedXmlBlockIndex + 1) % num; mLastCachedXmlBlockIndex = pos; final XmlBlock oldBlock = cachedXmlBlocks[pos]; if (oldBlock != null) &#123; oldBlock.close(); &#125; cachedXmlBlockCookies[pos] = assetCookie; cachedXmlBlockFiles[pos] = file; cachedXmlBlocks[pos] = block; return block.newParser(); &#125; &#125; &#125; catch (Exception e) &#123; final NotFoundException rnf = new NotFoundException(&quot;File &quot; + file + &quot; from xml type &quot; + type + &quot; resource ID #0x&quot; + Integer.toHexString(id)); rnf.initCause(e); throw rnf; &#125; &#125; throw new NotFoundException(&quot;File &quot; + file + &quot; from xml type &quot; + type + &quot; resource ID #0x&quot; + Integer.toHexString(id)); &#125;加载指定布局文件的xml，生成XMLBlock：1234567891011121314151617/*package*/ final XmlBlock openXmlBlockAsset(int cookie, String fileName) throws IOException &#123; synchronized (this) &#123; if (!mOpen) &#123; throw new RuntimeException(&quot;Assetmanager has been closed&quot;); &#125; long xmlBlock = openXmlAssetNative(cookie, fileName); if (xmlBlock != 0) &#123; XmlBlock res = new XmlBlock(this, xmlBlock); incRefsLocked(res.hashCode()); return res; &#125; &#125; throw new FileNotFoundException(&quot;Asset XML file: &quot; + fileName); &#125; private native final long openXmlAssetNative(int cookie, String fileName);最终指向了native方法 获取到XMLResourceParser后，进行渲染：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); &#125; final String name = parser.getName(); if (DEBUG) &#123; System.out.println(&quot;**************************&quot;); System.out.println(&quot;Creating root view: &quot; + name); System.out.println(&quot;**************************&quot;); &#125; //如果是merge标签，查看是否是当前布局的父节点，不是的话抛出异常 if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml //获取xml中的根节点 final View temp = createViewFromTag(root, name, inflaterContext, attrs); &#125; ... &#125; &#125; &#125; 使用XmlPull解析布局，如果是merge标签，merge节点不是当前布局的父节点，则抛出异常，进入CreateViewFromTag：1234567891011121314151617181920212223242526272829303132333435363738private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123; return createViewFromTag(parent, name, context, attrs, false); &#125; View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; ...... try &#123; View view; if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf(&#x27;.&#x27;)) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123; view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; ... &#125; &#125;使用mFactory2、mFactory、mPrivateFactory创建view，如果null的情况下，就会调用createView方法，内部采用反射创建节点，过多的反射会造成性能问题，可以进行优化。 获取界面布局耗时 手动埋点，打印时间 AOP打印setContView的时间 重写LayoutInflaterCompat.setFactory2方法，打印每一个控件的耗时时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; // 使用LayoutInflaterCompat.Factory2全局监控Activity界面每一个控件的加载耗时， // 也可以做全局的自定义控件替换处理，比如：将TextView全局替换为自定义的TextView。 LayoutInflaterCompat.setFactory2(getLayoutInflater(), new LayoutInflater.Factory2() &#123; @Override public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; if (TextUtils.equals(name, &quot;TextView&quot;)) &#123; // 生成自定义TextView &#125; long time = System.currentTimeMillis(); // 1 View view = getDelegate().createView(parent, name, context, attrs); LogHelper.i(name + &quot; cost &quot; + (System.currentTimeMillis() - time)); return view; &#125; @Override public View onCreateView(String name, Context context, AttributeSet attrs) &#123; return null; &#125; &#125;); //也可以直接调用这个方法// LayoutInflater.from(this).setFactory2(new LayoutInflater.Factory2() &#123;// @Override// public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;//// if (TextUtils.equals(name, &quot;TextView&quot;)) &#123;// // 生成自定义TextView// &#125;// long time = System.currentTimeMillis();// // 1// View view = getDelegate().createView(parent, name, context, attrs);// AppLog.E(name + &quot; cost &quot; + (System.currentTimeMillis() - time));// return view;// &#125;//// @Override// public View onCreateView(String name, Context context, AttributeSet attrs) &#123;// return null;// &#125;// &#125;); // 2、setFactory2方法需在super.onCreate方法前调用，否则无效 super.onCreate(savedInstanceState); setContentView(getLayoutId()); unBinder = ButterKnife.bind(this); mActivity = this; ActivityCollector.getInstance().addActivity(this); onViewCreated(); initToolbar(); initEventAndData();&#125; 优化工具LintAndroid Studio自带工具，可以进行代码校验，发现代码结构/质量问题 Layout InspectorAndroid Studio推荐布局检测工具，可以查看整个布局的层级，进而优化处理 GPU过度绘制手机中打开开发者选项-开启GPU过度绘制 布局优化的必要性 减少页面卡顿，提高流畅度 减少线上bug产出 总体原则 避免层间嵌套 减少绘制时间，三个方法的执行时间 优化方法 使用include标签重用公共布局 使用merge减少视图层级 当使用的是merge时，连续两个布局相似会合并，减少层级。 使用viewStub延迟加载，减少资源浪费 简单布局使用LinearLayout，复杂布局使用RelativeLayout或者ConstraintLayout减少层级嵌套。 善用控件属性 TextView实现图片+文字显示 使用LinearLayout自带的分割线 使用space控件 尽量少使用wrap_content，增加计算成本，绘制过久 主要布局比较 名称 优点 缺点 RelativeLayout 减少层级嵌套 onDraw执行两次，耗时 LinearLayout 不使用weight，onDraw执行一次 布局时容易层级嵌套 FrameLayout ConstraintLayout 减少层级 + 比例布局 耗时 总结：性能好的布局，FrameLayout和LinearLayout功能复杂，需要层级嵌套使用RelativeLayout或者ConstraintLayout。 优先考虑层级问题，在考虑单个布局性能问题","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"设计模式","slug":"移动端/Android原生/设计模式","date":"2021-05-31T12:59:26.000Z","updated":"2021-05-31T13:13:46.660Z","comments":true,"path":"2021/05/31/移动端/Android原生/设计模式/","link":"","permalink":"http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"[TOC] 单例模式定义确保某个类中只有一个实例，而且子性实例化并向整个系统提供整个实例 例子饿汉：123456789public class Singleton &#123; //在静态初始化器中创建单例实例，这段代码保证了线程安全 private static final Singleton instance = new Singleton(); //Singleton类只有一个构造方法并且是被private修饰的，所以用户无法通过new方法创建该对象实例 private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉：1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; //没有加入synchronized关键字的版本是线程不安全的 public static synchronized Singleton getInstance() &#123; //判断当前单例是否已经存在，若存在则返回，不存在则再建立单例 if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; 双重校验锁（DCL）：1234567891011121314public class Singleton &#123; private static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 双重判断的原因？ 第一个判断减少锁的使用，提升性能 多个线程同时等待锁，当第一个创建后，就不需要其他线程重复重建 volatile的理解 禁止重排序导致instance获取失败。 给Singleton的实例分配内存 调用构造函数，初始化成员 将instance对象指向分配的内存空间 执行顺序有可能是1-2-3，1-3-2 如果是1-3-2，new Singleton()方法执行时可能导致分配了空间，并指向了内存空间，但是没有赋值，这样另一个线程拿到后会导致出错 缺点：部分情况下，这种单例模式会失效 静态内部类：123456789101112public class Singleton &#123; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125; /** * 静态内部类 */ private static class SingletonHolder&#123; private static final Singleton instance = new Singleton(); &#125;&#125; 首次加载Singleton不会初始化instance，当调用getInstance方法时，初始化SingletonHolder类，这样虚拟机加载该类是线程安全的，保证单例对象的唯一性 枚举单例123456public enum SingletonEnum&#123; INSTANCE; public void doSomething()&#123; ...... &#125;&#125; 注意：在反序列化时，会重新创建对象，不符合单例 容器单例123456789101112public class SingletonManager&#123; private static Map&lt;String,Object&gt; objMap = new HashMap&lt;&gt;(); private SingletonManager()&#123;&#125; public static void registerService(String key,Object instance)&#123; if(!objMap.containsKey(key))&#123; objMap.put(key,instance); &#125; &#125; public static Object getValue(String key)&#123; return objMap.get(Key); &#125;&#125; 对单例内容统一管理，放置在map中，但是HashMap线程不安全，所以最好使用ConcurrentHashMap，管理多个单例类 源码应用 LayoutInflater.from(context) 进入main函数 新建ActivityThread，调用attach函数 AMS通信最终调用ahndlelauncherActivity 创建Activity 创建Application 获取Context对象 将context对象attach到activity中 调用Activity的onCreate方法 在虚拟机第一次加载ContextImpl时会注册LayoutInflater Service，将这些服务存储在HashMap中，下次直接从缓存中读取，应用的是容器单例形式。 深入LayoutInflaterLayoutInflater是抽象类，具体实现类是PhoneLayoutInflater inflate方法： 解析xml根标签（父布局） 判断merge，如果是merge直接将子布局添加到根布局 如果是普通标签，调用createViewFromTag对该元素进行解析 解析所有子view，将这些子view都添加到根布局temp下 返回解析到根视图 q：为什么自定义view要使用全包名，而内置view（TextView）就不用? a：因为在布局加载过程中，如果是内置view，直接执行onCreateView方法创建view，并将“android.widget.”加在内置view前（android.widget.TextView），然后执行createView方法。如果是自定义view，从xml中获取全量包名直接执行createView方法即可，默认前缀为null inflate通过深度优先遍历来构造视图树 优缺点优点： 减少内存开支，避免创建和销毁的性能损耗 减少性能开销，永久驻留内存方式初始化复杂对象和依赖 避免对同一资源的多重占用，例如-个写文件操作，只有一个实例可以写，避免对这一个资源文件的同时写操作（避免线程不安全） 设置全局访问点，优化和共享资源访问，便于管理 缺点： 拓展困难，只能修改代码 如果持有context对象，会造成内存泄漏 建造者模式例子将一个复杂对象的构建与他的表示分离，是的同样的构建过程可以创建不同的表示 核心思想是添加建造者构建主类，减少主类功能，建造者只负责构建主类 简单例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Computer &#123; //显示器 String display; //cpu型号 String cpu; //主板型号 String mainBoard; //显卡型号 String gpu; public Computer(Builder builder) &#123; this.display = builder.display; this.cpu = builder.cpu; this.mainBoard = builder.mainBoard; this.gpu = builder.gpu; &#125; @Override public String toString() &#123; return &quot;显示器是&quot; + display + &quot;\\ncpu是&quot; + cpu + &quot;\\n主板是&quot; + mainBoard + &quot;\\n显卡是&quot; + gpu; &#125; static class Builder&#123; //显示器 String display; //cpu型号 String cpu; //主板型号 String mainBoard; //显卡型号 String gpu; public Builder()&#123; this.display = &quot;三星曲屏&quot;; this.cpu = &quot;i5 8400&quot;; this.mainBoard = &quot;华硕Z360-B&quot;; this.gpu = &quot;GTX 1050Ti&quot;; &#125; public Builder setDisplay(String display) &#123; this.display = display; return this; &#125; public Builder setcpu(String cpu) &#123; this.cpu = cpu; return this; &#125; public Builder setMainBoard(String mainBoard) &#123; this.mainBoard = mainBoard; return this; &#125; public Builder setGpu(String gpu) &#123; this.gpu = gpu; return this; &#125; public Computer build()&#123; return new Computer(this); &#125; &#125; public static void main(String args[])&#123; Computer computer = new Computer.Builder() .setcpu(&quot;i9 4700u&quot;) .setGpu(&quot;GTX 2060Ti&quot;) .setMainBoard(&quot;华硕Z480&quot;) .build(); System.out.println(computer.toString()); &#125;&#125; 源码应用 AlertDialog内部调用Buidler模式构建，最终通过WindowManager显示在手机屏幕上。 WindowManager源码分析所有需要显示到屏幕上的内容都是通过WindowManager来操作的，WM的一个非常重要的子系统为WMS（WindowManagerService）在android.app.SystemServiceRegistry中： 123456registerService(Context.WINDOW_SERVICE, WindowManager.class, new CachedServiceFetcher&lt;WindowManager&gt;() &#123; @Override public WindowManager createService(ContextImpl ctx) &#123; return new WindowManagerImpl(ctx); &#125;&#125;); WMS也是初始化的众多服务的一种，所以在ContentImpl中初始化,并将初始化的服务注册到一个map中，需要时通过键获取调用，属于单例模式的容器单例。 以PopupWindow为例，我们获取到popupWindow的初始化：1mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);通过以上方法获取WM，显示时使用showAtLocation()方法，1234567891011public void showAtLocation(IBinder token, int gravity, int x, int y) &#123; ...... invokePopup(p);&#125; private void invokePopup(WindowManager.LayoutParams p) &#123; ...... mWindowManager.addView(decorView, p); ......&#125; 通过一系列的调用，最终使用WM的addView方法添加布局，回溯之前的分析WM的实例是WindowManagerImpl，进入addView方法12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125;而在WMImpl方法中调用WMGlobal.addView方法，进入：1234567891011121314151617181920212223242526272829303132public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ...... ViewRootImpl root; View panelParentView = null; ...... //构建ViewRootImpl root = new ViewRootImpl(view.getContext(), display); //view设置参数 view.setLayoutParams(wparams); //将view添加到列表 mViews.add(view); //将ViewRootImpl添加到列表 mRoots.add(root); //将参数添加在列表 mParams.add(wparams); // do this last because it fires off messages to start doingthings try &#123; //调用viewRootImpl的setView方法添加布局 root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125; 构建ViewRootImpl 将布局参数设置给view 存储ViewRootImpl、View、LayoutParam到列表 调用ViewRootImpl.setView将view显示在窗口 进一步查看ViewRootImpl是什么？123456789public ViewRootImpl(Context context, Display display) &#123; mContext = context; //获取WindowSession，也就是和WMS建立连接 mWindowSession = WindowManagerGlobal.getWindowSession(); ...... //创建线程为当前线程，因为主界面在UI线程，所以在子线程更新UI会抛出异常，但并不是只用UI线程才能更新UI mThread = Thread.currentThread(); ...... &#125; 进入WMGlobal.getWindowSession方法：1234567891011121314151617181920212223public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; InputMethodManager imm = InputMethodManager.getInstance(); //获取WMS IWindowManager windowManager = getWindowManagerService(); //建立一个WindowSession sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125;&#125;进入getWindowManagerService，1234567891011121314151617public static IWindowManager getWindowManagerService() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowManagerService == null) &#123; sWindowManagerService = IWindowManager.Stub.asInterface( ServiceManager.getService(&quot;window&quot;)); try &#123; if (sWindowManagerService != null) &#123; ValueAnimator.setDurationScale( sWindowManagerService.getCurrentAnimatorScale()); &#125; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowManagerService; &#125;&#125;通过ServiceManager.getService()获取WMS，12345678910111213public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return Binder.allowBlocking(getIServiceManager().getService(name)); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, &quot;error in getService&quot;, e); &#125; return null;&#125;通过sCache获取到一个IBinder对象，所以FrameWork与WMS之间也是通过Binder机制进行通信的，回溯到之前，会调用IWindowManager.Stub.asInterface()，将IBinder对象转化为WM对象，然后通过openSession与WMS建立通信绘画，之后通过这个session进行交换信息，但是到现在还是没有显示view，所以继续走ViewRootImpl.setView方法，12345678910111213141516public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; ...... //请求布局 requestLayout(); ...... try &#123; //通过Windowsession和WMS通信，请求显示 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; &#125;&#125; requestlayout：请求布局 向WMS请求显示布局 12345678910111213141516171819202122232425@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; //线程校验 checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125;void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; //开启屏障消息，优先处理 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //通过handler回调执行MTraversalRunnable mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 通过handler回调执行MTraversalRunnable，123456789101112131415161718192021222324final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(&quot;ViewAncestor&quot;); &#125; //view的具体操作 performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125; 最终进入performTraversals进行具体操作 获取Surface对象，用于图形绘制 performMeasure函数，测量整个视图树各个view的大小 performLayout,布局整个view performDraw，绘制整个view 优缺点优点： 良好的封装性，使客户端不知道产品内部组成细节 独立，容易拓展 缺点： 产生多余Builder对象和Director对象，消耗内存 原型模式定义用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象 简单例子深拷贝和浅拷贝原型模式实际上是浅拷贝，也称为影子拷贝。拷贝实际不是将所有字段重新构造一份，而是拷贝文档的字段引用原始文档的字段而已，所以会导致修改副本的字段，原始字段也会跟着修改，因为最终修改的是同一个内存单元，所以在原型模式中，要尽量使用深拷贝。 深拷贝：复制引用对象的值 浅拷贝：复制引用 源码分析 ArrayList的clone方法实现 12345678910111213public Object clone() &#123; try &#123; //克隆自身 ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); //克隆数组对象 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&#x27;t happen, since we are Cloneable throw new InternalError(e); &#125;&#125; 克隆自身后，在克隆数组对象，并没有对size进行克隆是因为size是值类型，并不是引用类型。 Intent的clone方法分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic Object clone() &#123; return new Intent(this);&#125;public Intent(Intent o) &#123; this(o, COPY_MODE_ALL);&#125;private Intent(Intent o, @CopyMode int copyMode) &#123; this.mAction = o.mAction; this.mData = o.mData; this.mType = o.mType; this.mPackage = o.mPackage; this.mComponent = o.mComponent; if (o.mCategories != null) &#123; this.mCategories = new ArraySet&lt;&gt;(o.mCategories); &#125; if (copyMode != COPY_MODE_FILTER) &#123; this.mFlags = o.mFlags; this.mContentUserHint = o.mContentUserHint; this.mLaunchToken = o.mLaunchToken; if (o.mSourceBounds != null) &#123; this.mSourceBounds = new Rect(o.mSourceBounds); &#125; if (o.mSelector != null) &#123; this.mSelector = new Intent(o.mSelector); &#125; if (copyMode != COPY_MODE_HISTORY) &#123; if (o.mExtras != null) &#123; this.mExtras = new Bundle(o.mExtras); &#125; if (o.mClipData != null) &#123; this.mClipData = new ClipData(o.mClipData); &#125; &#125; else &#123; if (o.mExtras != null &amp;&amp; !o.mExtras.maybeIsEmpty()) &#123; this.mExtras = Bundle.STRIPPED; &#125; // Also set &quot;stripped&quot; clip data when we ever log mClipData in the (broadcast) // history. &#125; &#125;&#125; 在Intent的clone方法中直接使用new方法构建了新intent 所以延伸出一个问题，new和clone怎么选择？ 如果对象的构造成本太高或者构造比较麻烦，那么使用clone函数效率高，否则使用new intent的查找和匹配 intent是怎么查找对应的组件然后跳转的呢？ 在ContextImpl初始化的SystemServiceRegistry中初始化各种服务（WMS,AMS等），其中，初始化了PMS（PackageManagerService） 在ContextImpl中执行getPackageManager方法：1234567891011121314@Overridepublic PackageManager getPackageManager() &#123; if (mPackageManager != null) &#123; return mPackageManager; &#125; IPackageManager pm = ActivityThread.getPackageManager(); if (pm != null) &#123; // Doesn&#x27;t matter if we make more than one instance. return (mPackageManager = new ApplicationPackageManager(this, pm)); &#125; return null;&#125;进入ActivityThread.getPackageManager()123456789101112public static IPackageManager getPackageManager() &#123; if (sPackageManager != null) &#123; //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager); return sPackageManager; &#125; //获取PackageManagerService IBinder b = ServiceManager.getService(&quot;package&quot;); //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b); sPackageManager = IPackageManager.Stub.asInterface(b); //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager); return sPackageManager;&#125; 获取到PackageManagerService服务，这个服务是在系统初始化时通过SystemServer启动的，现在只是获取，查看PackageManagerService类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139//PMS为IPackageManager.Stub的具体实现类public class PackageManagerService extends IPackageManager.Stub implements PackageSender &#123; public PackageManagerService(Context context, Installer installer,boolean factoryTest, boolean onlyCore) &#123; // Collect privileged system packages. // 扫描特殊系统包 final File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;); scanDirTracedLI(privilegedAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_AS_SYSTEM | SCAN_AS_PRIVILEGED, 0); // Collect ordinary system packages. // 扫描普通系统包 final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;); scanDirTracedLI(systemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_AS_SYSTEM, 0); // Collect privileged vendor packages. // 扫描特殊vendor下包 File privilegedVendorAppDir = new File(Environment.getVendorDirectory(), &quot;priv-app&quot;); try &#123; privilegedVendorAppDir = privilegedVendorAppDir.getCanonicalFile(); &#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one &#125; scanDirTracedLI(privilegedVendorAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_AS_SYSTEM | SCAN_AS_VENDOR | SCAN_AS_PRIVILEGED, 0); // Collect ordinary vendor packages. // 扫描普通vendor下包 File vendorAppDir = new File(Environment.getVendorDirectory(), &quot;app&quot;); try &#123; vendorAppDir = vendorAppDir.getCanonicalFile(); &#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one &#125; scanDirTracedLI(vendorAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_AS_SYSTEM | SCAN_AS_VENDOR, 0); // Collect privileged odm packages. /odm is another vendor partition // other than /vendor. // 扫描特殊odm下包/odm时vendor的一部分 File privilegedOdmAppDir = new File(Environment.getOdmDirectory(), &quot;priv-app&quot;); try &#123; privilegedOdmAppDir = privilegedOdmAppDir.getCanonicalFile(); &#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one &#125; scanDirTracedLI(privilegedOdmAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_AS_SYSTEM | SCAN_AS_VENDOR | SCAN_AS_PRIVILEGED, 0); // Collect ordinary odm packages. /odm is another vendor partition // other than /vendor. // 扫描普通odm下包/odm时vendor的一部分 File odmAppDir = new File(Environment.getOdmDirectory(), &quot;app&quot;); try &#123; odmAppDir = odmAppDir.getCanonicalFile(); &#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one &#125; scanDirTracedLI(odmAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_AS_SYSTEM | SCAN_AS_VENDOR, 0); // Collect all OEM packages. // 扫描所有OEM包 final File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;); scanDirTracedLI(oemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_AS_SYSTEM | SCAN_AS_OEM, 0); // Collected privileged product packages. // 扫描特殊product包 File privilegedProductAppDir = new File(Environment.getProductDirectory(), &quot;priv-app&quot;); try &#123; privilegedProductAppDir = privilegedProductAppDir.getCanonicalFile(); &#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one &#125; scanDirTracedLI(privilegedProductAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_AS_SYSTEM | SCAN_AS_PRODUCT | SCAN_AS_PRIVILEGED, 0); // Collect ordinary product packages. // 扫描普通product包 File productAppDir = new File(Environment.getProductDirectory(), &quot;app&quot;); try &#123; productAppDir = productAppDir.getCanonicalFile(); &#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one &#125; scanDirTracedLI(productAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_AS_SYSTEM | SCAN_AS_PRODUCT, 0); &#125;&#125;PMS会加载一系列，在不同目录下的包执行scanDirTracedLI方法：12345678910111213141516171819202122232425262728293031 private void scanDirTracedLI(File dir, final int parseFlags, int scanFlags, long currentTime) &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;scanDir [&quot; + dir.getAbsolutePath() + &quot;]&quot;); try &#123; scanDirLI(dir, parseFlags, scanFlags, currentTime); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125;private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) &#123; //获取目录下所有文件 final File[] files = dir.listFiles(); ...... for (File file : files) &#123; final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) &#123; // Ignore entries which are not packages continue; &#125; parallelPackageParser.submit(file, parseFlags); fileCount++; &#125; ...... for (; fileCount &gt; 0; fileCount--) &#123; scanPackageLI(parseResult.pkg, parseResult.scanFile, parseFlags, scanFlags, currentTime, null); &#125; ...... &#125;&#125;扫描目录下的子目录，对apk文件进行解析 12345678910111213141516171819202122232425262728293031323334353637public void submit(File scanFile, int parseFlags) &#123; mService.submit(() -&gt; &#123; ParseResult pr = new ParseResult(); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;parallel parsePackage [&quot; + scanFile + &quot;]&quot;); try &#123; //创建一个包解析器 PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setOnlyCoreApps(mOnlyCore); pp.setDisplayMetrics(mMetrics); pp.setCacheDir(mCacheDir); pp.setCallback(mPackageParserCallback); pr.scanFile = scanFile; //执行apk包解析 pr.pkg = parsePackage(pp, scanFile, parseFlags); &#125; catch (Throwable e) &#123; pr.throwable = e; &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; try &#123; mQueue.put(pr); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); // Propagate result to callers of take(). // This is helpful to prevent main thread from getting stuck waiting on // ParallelPackageParser to finish in case of interruption mInterruptedInThread = Thread.currentThread().getName(); &#125; &#125;); &#125; @VisibleForTesting protected PackageParser.Package parsePackage(PackageParser packageParser, File scanFile, int parseFlags) throws PackageParser.PackageParserException &#123; return packageParser.parsePackage(scanFile, parseFlags, true /* useCaches */); &#125; 创建一个PackageParser，调用parsePackage函数解析apk 123456789101112131415161718public Package parsePackage(File packageFile, int flags, boolean useCaches) throws PackageParserException &#123; Package parsed = useCaches ? getCachedResult(packageFile, flags) : null; if (parsed != null) &#123; return parsed; &#125; //如果是文件夹类型 if (packageFile.isDirectory()) &#123; parsed = parseClusterPackage(packageFile, flags); &#125; else &#123; //解析单个apk parsed = parseMonolithicPackage(packageFile, flags); &#125; cacheResult(packageFile, flags, parsed); return parsed;&#125; 如果是文件夹类型，加载多个apk文件，如果是单个apk，只加载一个apk123456789101112131415161718192021@Deprecated public Package parseMonolithicPackage(File apkFile, int flags) throws PackageParserException &#123; final AssetManager assets = newConfiguredAssetManager(); final PackageLite lite = parseMonolithicPackageLite(apkFile, flags); if (mOnlyCoreApps) &#123; if (!lite.coreApp) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED, &quot;Not a coreApp: &quot; + apkFile); &#125; &#125; try &#123; //执行具体解析 final Package pkg = parseBaseApk(apkFile, assets, flags); pkg.setCodePath(apkFile.getAbsolutePath()); pkg.setUse32bitAbi(lite.use32bitAbi); return pkg; &#125; finally &#123; IoUtils.closeQuietly(assets); &#125; &#125;进入parseBaseApk:1234567891011121314151617181920212223242526272829303132333435363738394041private Package parseBaseApk(File apkFile, AssetManager assets, int flags) throws PackageParserException &#123; //获取apk路径 final String apkPath = apkFile.getAbsolutePath(); String volumeUuid = null; if (apkPath.startsWith(MNT_EXPAND)) &#123; final int end = apkPath.indexOf(&#x27;/&#x27;, MNT_EXPAND.length()); volumeUuid = apkPath.substring(MNT_EXPAND.length(), end); &#125; mParseError = PackageManager.INSTALL_SUCCEEDED; mArchiveSourcePath = apkFile.getAbsolutePath(); if (DEBUG_JAR) Slog.d(TAG, &quot;Scanning base APK: &quot; + apkPath); final int cookie = loadApkIntoAssetManager(assets, apkPath, flags); Resources res = null; XmlResourceParser parser = null; try &#123; //获取apk资源文件 res = new Resources(assets, mMetrics, null); //解析AndroidManifest parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME); final String[] outError = new String[1]; final Package pkg = parseBaseApk(apkPath, res, parser, flags, outError); if (pkg == null) &#123; throw new PackageParserException(mParseError, apkPath + &quot; (at &quot; + parser.getPositionDescription() + &quot;): &quot; + outError[0]); &#125; pkg.setVolumeUuid(volumeUuid); pkg.setApplicationVolumeUuid(volumeUuid); pkg.setBaseCodePath(apkPath); pkg.setSignatures(null); return pkg; ...... &#125; 获取apk路径，解析apk资源文件及AndroidManifest12345678910111213141516171819202122232425262728private boolean parseBaseApkChild(Package parentPkg, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; //创建package对象，将版本信息存储进来 // Go ahead and parse the child Package childPkg = new Package(childPackageName); // Child package inherits parent version code/name/target SDK childPkg.mVersionCode = parentPkg.mVersionCode; childPkg.baseRevisionCode = parentPkg.baseRevisionCode; childPkg.mVersionName = parentPkg.mVersionName; childPkg.applicationInfo.targetSdkVersion = parentPkg.applicationInfo.targetSdkVersion; childPkg.applicationInfo.minSdkVersion = parentPkg.applicationInfo.minSdkVersion; childPkg = parseBaseApkCommon(childPkg, CHILD_PACKAGE_TAGS, res, parser, flags, outError); if (childPkg == null) &#123; // If we got null then error was set during child parsing return false; &#125; // Set the parent-child relation if (parentPkg.childPackages == null) &#123; parentPkg.childPackages = new ArrayList&lt;&gt;(); &#125; parentPkg.childPackages.add(childPkg); childPkg.parentPackage = parentPkg; return true;&#125; 创建package对象，将版本信息存储进来 1234567891011121314151617181920212223private Package parseBaseApkCommon(Package pkg, Set&lt;String&gt; acceptedTags, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; ....... //解析AndroidManifest的深度 int outerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; ...... if (tagName.equals(TAG_APPLICATION)) &#123; ...... //解析Application标签 if (!parseBaseApplication(pkg, res, parser, flags, outError)) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_PERMISSION)) &#123; //解析权限标签 if (!parsePermission(pkg, res, parser, outError)) &#123; return null; &#125; &#125; return pkg;&#125; 获取AndroidManifest的深度，然后深度遍历获取所有的标签并依次处理，这里以Application为例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private boolean parseBaseApplication(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; //获取应用信息 final ApplicationInfo ai = owner.applicationInfo; //获取包名 final String pkgName = owner.applicationInfo.packageName; //获取Application的TypedArray TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestApplication); ...... //获取应用名 String manageSpaceActivity = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity, Configuration.NATIVE_CONFIG_VERSION); ...... //获取Application的allowBackUp boolean allowBackup = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_allowBackup, true); //获取主题 ai.theme = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestApplication_theme, 0); //获取描述 ai.descriptionRes = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestApplication_description, 0); //获取taskAffinity ai.taskAffinity = buildTaskAffinityName(ai.packageName, ai.packageName, str, outError); final int innerDepth = parser.getDepth(); int type; //迭代Application元素下的所有子元素 while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; //获取标签名 String tagName = parser.getName(); //如果是Activity if (tagName.equals(&quot;activity&quot;)) &#123; Activity a = parseActivity(owner, res, parser, flags, outError, false, owner.baseHardwareAccelerated); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.activities.add(a); //如果是receiver &#125; else if (tagName.equals(&quot;receiver&quot;)) &#123; Activity a = parseActivity(owner, res, parser, flags, outError, true, false); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.receivers.add(a); &#125; &#125; return true;&#125;解析Application的其他属性及其子标签,而后返回方法直到scanDirLI方法，执行scanPackageLI函数 scanPackageLI—&gt;scanPackageInternalLI—&gt;scanPackageLI—&gt;scanPackageDirtyLI—&gt;commitPackageSettings123456789101112131415161718192021222324private void commitPackageSettings(PackageParser.Package pkg, PackageSetting pkgSetting, UserHandle user, int scanFlags, boolean chatty) throws PackageManagerException &#123; ...... //获取activities的大小 N = pkg.activities.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.activities.get(i); a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName); //将activity添加到mActivies mActivities.addActivity(a, &quot;activity&quot;); if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(&#x27; &#x27;); &#125; r.append(a.info.name); &#125; &#125; //其他标签忽略 ...... &#125;将解析的标签，例activity记载到PMS的缓存中。至此，apk的所有信息就被存储在系统中，当使用intent跳转时会在该信息表中进行查找，然后跳转。 我们使用intent时，一般是这样：12Intent intent = new Intent(this,MainActivity.class);this.startActivity(intent);跟踪源码，最终跳转到startActivityForResult：12345678910111213141516171819202122232425262728293031public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); //启动Activity Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; //发送启动请求 mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; &#125;通过instrumentation启动Activity，并向主线程发送启动请求12345678910111213141516171819202122public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ...... try &#123; //将Intent中的数据迁移到粘贴板 intent.migrateExtraStreamToClipData(); //准备离开当前进程 intent.prepareToLeaveProcess(who); //通过AMS启动Activity int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target, requestCode, 0, null, options); //检测结果，并且回调给调用端 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null; &#125;进入AMS方法，调用 startActivityAsUser—&gt;ActivityStarter.startActivityMayWait—&gt;ActivityStackSupervisor.resolveIntent—&gt;AMS.getPackageManagerInternalLocked—&gt;PMS.resolveIntent—&gt;PMS.resolveIntentInternal—&gt;PMS.queryIntentActivitiesInternal123456789101112131415161718192021222324252627282930313233343536373839404142434445private @NonNull List&lt;ResolveInfo&gt; queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId, boolean resolveForStart) &#123; ...... //获取包名 final String pkgName = intent.getPackage(); //获取component对象 ComponentName comp = intent.getComponent(); //如果component不为null if (comp != null) &#123; final List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1); //直接getActivityInfo获取ActivityInfo对象 final ActivityInfo ai = getActivityInfo(comp, flags, userId); ...... &#125; ...... //如果是隐式intent synchronized (mPackages) &#123; //如果包名为null if (pkgName == null) &#123; List&lt;CrossProfileIntentFilter&gt; matchingFilters = getMatchingCrossProfileIntentFilters(intent, resolvedType, userId); // Check for results that need to skip the current profile. //获取resolveInfo对象 ResolveInfo xpResolveInfo = querySkipCurrentProfileIntents(matchingFilters, intent, resolvedType, flags, userId); if (xpResolveInfo != null) &#123; List&lt;ResolveInfo&gt; xpResult = new ArrayList&lt;ResolveInfo&gt;(1); xpResult.add(xpResolveInfo); return applyPostResolutionFilter( filterIfNotSystemUser(xpResult, userId), instantAppPkgName); &#125; &#125; else &#123; //通过包名获取Package对象 final PackageParser.Package pkg = mPackages.get(pkgName); result = null; if (pkg != null) &#123; //通过package获取ActivityInfo result = filterIfNotSystemUser( mActivities.queryIntentForPackage( intent, resolvedType, flags, pkg.activities, userId), userId); &#125; ......&#125; 如果intent指明了Component（即MainActivity），直接获取到ActivityInfo并且数量只有一个，直接返回。如果Component为空，会检测发起方所在的包名，如果有包名，通过包名获取ActivityInfo，反之，根据其他信息比如外部拉起，action，Category等判断。 总结：在系统启动时，PMS启动分析所有apk的信息，创建一个信息表，当用胡使用Intent跳转时，会根据intent中包含的信息到PMS的信息表查找，最后跳转到目标组件 优缺点优点： 内存中二进制流的拷贝，其比直接new一个对象性能会好很多缺点： 直接在内存中拷贝，不会执行构造函数，使用过程中对比new和clone方法的区别 原型模式就是要实现深拷贝 工厂模式定义用于创建对象的接口，让子类决定实例化那个类，解决对象之间的解耦 例子简单工厂12345678910111213141516171819202122232425262728293031323334353637383940public abstract class Product &#123; /** * 子类具体实现方法 */ public abstract void method();&#125;public class ProductA extends Product &#123; @Override public void method() &#123; System.out.println(&quot;制造ProductA&quot;); &#125;&#125;public class ProductB extends Product &#123; @Override public void method() &#123; System.out.println(&quot;制造ProductB&quot;); &#125;&#125;public class Factory &#123; public Product create(String type)&#123; if(&quot;A&quot;.equals(type))&#123; return new ProductA(); &#125;else if(&quot;B&quot;.equals(type))&#123; return new ProductB(); &#125;else&#123; return null; &#125; &#125;&#125;public static void main(String args[]) &#123; Factory factory = new Factory(); Product a = factory.create(&quot;A&quot;); a.method(); Product b = factory.create(&quot;B&quot;); b.method();&#125; 运行后： 制造ProductA 制造ProductB 工厂方法抽象产品类不变，工厂变为抽象类12345678910111213141516171819202122232425262728public abstract class Factory &#123; /** * 工厂具体实现方法 * @return */ public abstract Product create();&#125;public class FactoryA extends Factory &#123; @Override public Product create() &#123; return new ProductA(); &#125;&#125;public class FactoryB extends Factory &#123; @Override public Product create() &#123; return new ProductB(); &#125;&#125;public static void main(String args[]) &#123; FactoryA factoryA = new FactoryA(); FactoryB factoryB = new FactoryB(); factoryA.create().method(); factoryB.create().method();&#125; 运行后： 制造ProductA 制造ProductB 抽象工厂需要多个产品最终组成为一个产品123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public abstract class Cpu &#123; /** * cpu子类的具体执行 */ public abstract void method();&#125;public class CpuA extends Cpu &#123; @Override public void method() &#123; System.out.println(&quot;A型号CPU&quot;); &#125;&#125;public class CpuB extends Cpu &#123; @Override public void method() &#123; System.out.println(&quot;B型号CPU&quot;); &#125;&#125;public abstract class Display &#123; /** * 显示屏的子类执行方法 */ public abstract void method();&#125;public class DisplayA extends Display &#123; @Override public void method() &#123; System.out.println(&quot;A型号显示屏&quot;); &#125;&#125;public class DisplayB extends Display &#123; @Override public void method() &#123; System.out.println(&quot;B型号显示屏&quot;); &#125;&#125;public abstract class Factory &#123; /** * 创建Cpu * @return */ public abstract Cpu createCpu(); /** * 创建显示屏 * @return */ public abstract Display createDisplay();&#125;public class FactoryA extends Factory &#123; @Override public Cpu createCpu() &#123; return new CpuA(); &#125; @Override public Display createDisplay() &#123; return new DisplayA(); &#125;&#125;public class FactoryB extends Factory &#123; @Override public Cpu createCpu() &#123; return new CpuB(); &#125; @Override public Display createDisplay() &#123; return new DisplayB(); &#125;&#125; public static void main(String args[]) &#123; FactoryA factoryA = new FactoryA(); FactoryB factoryB = new FactoryB(); factoryA.createCpu().method(); factoryA.createDisplay().method(); factoryB.createCpu().method(); factoryB.createDisplay().method(); &#125;执行结果如下： A型号CPU A型号显示屏 B型号CPU B型号显示屏 抽象工厂的核心是复杂的工厂模式。存在多个工厂，多种产品类型，就会使用抽象工厂，在android源码中使用较少，并没有那么多产品种类，大部分使用简单工厂或者工厂方法就可以解决。 源码分析 ArrayList和HashSet都继承自Collection接口，collection接口继承自Iterator接口。 xxxActivity都继承自Activity，其onCreate方法就是工厂方法，两个Activity构建不同的view，可以将view看成product，Activity为Factory。 xxService都继承自Service，其onBind方法也可以看作是一个工厂方法4. 优缺点优点： 功能逻辑解耦 缺点： 拓展新功能需要添加新类，复杂类结构 抽象工厂的优点: 分离接口与实现,使用方不知道具体的实现是什么,同时使抽象该工厂方法模式在切换产品类时更加灵活,容易 抽象工厂的缺点: 类文件结构复杂 不容易拓展新类 策略模式定义定义一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，策略模式让算法独立于使用他们的客户而独立存在，解决if-else滥用的问题 例子12345678910111213141516171819202122232425262728293031323334353637383940public class CalculatePrice &#123; public enum TransPortType &#123; BUS, SUBWAY &#125; /** * 计算公交车车费 */ private void calculateBus(int km) &#123; System.out.println(&quot;公交车&quot; + km + &quot;公里的车票&quot;); &#125; /** * 计算地铁车费 */ private void calculateSubWay(int km) &#123; System.out.println(&quot;地铁&quot; + km + &quot;公里的车票&quot;); &#125; private void calculate(int km, TransPortType transPortType) &#123; switch (transPortType) &#123; case BUS: calculateBus(km); break; case SUBWAY: calculateSubWay(km); break; default: break; &#125; &#125; public static void main(String args[])&#123; CalculatePrice calculatePrice = new CalculatePrice(); calculatePrice.calculate(16,TransPortType.BUS); calculatePrice.calculate(15,TransPortType.SUBWAY); &#125;&#125; 结果：公交车16公里的车票 地铁15公里的车票 当需要拓展时，比如多了一个出租车，需要这样做12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class CalculatePrice &#123; public enum TransPortType &#123; BUS, SUBWAY, TAXI &#125; /** * 计算公交车车费 */ private void calculateBus(int km) &#123; System.out.println(&quot;公交车&quot; + km + &quot;公里的车票&quot;); &#125; /** * 计算地铁车费 */ private void calculateSubWay(int km) &#123; System.out.println(&quot;地铁&quot; + km + &quot;公里的车票&quot;); &#125; /** * 计算出租车车费 */ private void calculateTaxi(int km) &#123; System.out.println(&quot;出租车&quot; + km + &quot;公里的车票&quot;); &#125; private void calculate(int km, TransPortType transPortType) &#123; switch (transPortType) &#123; case BUS: calculateBus(km); break; case SUBWAY: calculateSubWay(km); break; case TAXI: calculateTaxi(km); break; default: break; &#125; &#125; public static void main(String args[])&#123; CalculatePrice calculatePrice = new CalculatePrice(); calculatePrice.calculate(16,TransPortType.BUS); calculatePrice.calculate(15,TransPortType.SUBWAY); calculatePrice.calculate(17,TransPortType.TAXI); &#125;&#125;结果： 公交车16公里的车票 地铁15公里的车票 出租车17公里的车票 改动还是比较大的，对源代码的基础上做了更改，并且添加了if-else判断taxi类型。如果把他改成策略模式，试试效果123456789101112131415161718192021222324252627public abstract class CalculateStrategy &#123; /** * 子类具体执行车票计算 */ public abstract void getPrice(int km);&#125;public class BusCalculateStrategy extends CalculateStrategy &#123; @Override public void getPrice(int km) &#123; System.out.println(&quot;公交车&quot; + km + &quot;公里的车票&quot;); &#125;&#125;public class SubWayCalculateStrategy extends CalculateStrategy &#123; @Override public void getPrice(int km) &#123; System.out.println(&quot;地铁&quot; + km + &quot;公里的车票&quot;); &#125;&#125; public static void main(String args[])&#123; CalculateStrategy calculateStrategy = new BusCalculateStrategy(); calculateStrategy.getPrice(16); CalculateStrategy calculateStrategy1 = new SubWayCalculateStrategy(); calculateStrategy1.getPrice(15); &#125;结果： 公交车16公里的车票 地铁15公里的车票 当需要拓展出租车时1234567891011public class TaxiCalculateStrategy extends CalculateStrategy &#123; @Override public void getPrice(int km) &#123; System.out.println(&quot;出租车&quot; + km + &quot;公里的车票&quot;); &#125;&#125; public static void main(String args[])&#123; CalculateStrategy calculateStrategy2 = new TaxiCalculateStrategy(); calculateStrategy2.getPrice(17); &#125;只需要添加Taxi类继承自策略类，执行具体车费计算方法，在main中调用即可，这样对代码的侵入性最小，不用修改原有逻辑代码，在咋付逻辑出引用效果优秀 状态模式定义当一个对象的内在行为改变时，允许改变其行为，整个对象看起来像是改变了其类 源码解析 wifi状态管理责任链模式定义使多个对象都有机会处理请求，这些对象形成一条链，依次执行，直到结束。源码解析 view的事件传递 观察者模式定义定义对象间一种一对多的一栏关系，使得每当一个对象改变状态，则所有依赖与他的对象都会得到通知并被自动更新 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Mode2 &#123; static public interface IObserver &#123; void update(int temp); &#125; static public interface IObservable &#123; void register(IObserver iObserver); void unregister(IObserver iObserver); void notifyObserver(); &#125; //被观察者（发布者） static class Observable implements IObservable &#123; private ArrayList&lt;IObserver&gt; list = new ArrayList&lt;&gt;(); private int temp; @Override public void register(IObserver iObserver) &#123; list.add(iObserver); &#125; @Override public void unregister(IObserver iObserver) &#123; list.remove(iObserver); &#125; @Override public void notifyObserver() &#123; for (int i = 0; i &lt; list.size(); i++) &#123; list.get(i).update(temp); &#125; &#125; public void setTemp(int temp) &#123; this.temp = temp; &#125; &#125; //观察者1（订阅者） static class Observer1 implements IObserver &#123; @Override public void update(int temp) &#123; System.out.println(&quot;Observable1更新为 = &quot; + temp); &#125; &#125; //观察者2(订阅者) static class Observer2 implements IObserver &#123; @Override public void update(int temp) &#123; System.out.println(&quot;Observable2更新为 = &quot; + temp); &#125; &#125; public static void main(String args[])&#123; Observable observable = new Observable(); Observer1 observer1 = new Observer1(); Observer2 observer2 = new Observer2(); observable.register(observer1); observable.register(observer2); observable.setTemp(32131232); observable.notifyObserver(); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"启动优化","slug":"移动端/Android原生/启动优化","date":"2021-05-31T12:58:13.000Z","updated":"2021-06-01T05:55:34.883Z","comments":true,"path":"2021/05/31/移动端/Android原生/启动优化/","link":"","permalink":"http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/","excerpt":"","text":"app启动过程 点击图标启动 LauncherApp通知AMS进行启动，LauncherActivity onPause AMS新建app进程，创建ActivityThread，创建ApplicationThread 通过ApplicationThread向AMS注册Binder 执行Application的onCreate方法 新建进入的Activity 执行Activity的onCreate方法，进行UI绘制等操作 启动分类 冷启动：从点击应用图标到UI界面完全显示且用户可操作的全部过程。 Click Event -&gt; IPC -&gt; Process.start -&gt; ActivityThread -&gt; bindApplication -&gt; LifeCycle -&gt; ViewRootImpl 热启动：直接从后台切换到前台。 优化方向可优化Application、Activity的创建以及回调过程 提前展示一个window（欢迎页），给用户友好的提示 避免启动做繁重密集的初始化操作 过度绘制，网络，io等优化 优化检测 adb命令检测12// 其中的AppstartActivity全路径可以省略前面的packageNameadb shell am start -W [packageName]/[AppstartActivity全路径] ThisTime：最后一个Activity的启动耗时 TotalTime：所有Activity的启动耗时 WaitTime：表示AMS启动Activity的总耗时。 一般读取WaitTime，为Application和Activity的初始化过程耗时。（冷启动耗时） 优缺点： 线下使用方便，不能带到线上 非精确时间 自定义打点查看耗时 应用生命周期节点 启动的初始化方法节点 其他耗时业务，算法节点 优缺点： 精确，可上线 修改成本高 3.AOP打点加入aspectjx库，打印出Application，Activity的耗时时间，进行针对优化 根路径build.gradle中添加1classpath &#x27;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.0&#x27;app中build.gradle中添加123apply plugin: &#x27;android-aspectjx&#x27;...implementation &#x27;org.aspectj:aspectjrt:1.8.+&#x27;使用如下：12345678910111213141516@Aspectpublic class LauncherAop &#123; @Around(&quot;call(* com.jw.myapplication.MainActivity.**(..))&quot;) public void getTime(ProceedingJoinPoint joinPoint) throws Exception&#123; Signature signature = joinPoint.getSignature(); String name = signature.toShortString(); long time = System.currentTimeMillis(); try &#123; joinPoint.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; Log.d(&quot;kangkang = &quot;,&quot;kangaop = &quot; +name+ &quot; cost &quot; + (System.currentTimeMillis() - time)); &#125;&#125; 4.TraceView 代码中开启123Debug.startMethodTracing();method();Debug.stopMethodTracing(); 生成.trace文件，导入Android Studio，使用profile中的cpu查看文件生成的火炬图 优化方案 主题切换 设置自定义主题设置背景图，执行到onCreate方法后替换为Activiy的真实布局 初始化分化 MultiDex以及Tinker的初始化操作 Application中的第三方组件的初始化 异步初始化组件，不阻塞主线程，设置异步线程为THREAD_PRIORITY_BACKGROUND 延迟初始化操作，再线程空闲时加载， EventBus、ota、bugly、migu、Linphone、Butterknife、地图、IOT 设置线程池初始化任务 仿照AsyncTask新建线程池，核心线程数为2-4个 任务使用该线程池加载，如有顺序，使用CountDownLatch进行处理 部分任务可以延迟加载，使用IdleHandler，在主线程空闲时加载 Multidex预加载优化 优化方案在使用Aspect进行时间的监测时，发现Application和Activity中的初始化三方进程耗费了大量时间，在初始化时，我们开启了百度OTA服务，Bugly监测服务，咪咕音乐服务，阿里IOT服务，日志监测服务，Linphone语音服务，Ifly语音服务等，这些串行起来是比较耗时的。所以我们采用开启一个线程池的方案，在子线程启动这些服务，对于OTA，IOT，日志检测，Linphone等服务不需要在第一时间初始化，所以放到线程池中根据执行顺序分别初始化。但是对于咪咕、Ifly和bugly来说，需要第一时间初始化，才能进行后边的逻辑，所以我们将这些服务优先初始化，并联合CountDownLatch，当必须的服务初始化完成后，才进入下面的流程。对于必须要在主线程进行初始化的操作，可能会造成主线程繁忙卡顿，所以使用IdleHandler方法，在主线程空闲时执行， 具体优化了40%，由2.3s压缩到1.4s。 如果由任务A，B，C，D，要求C在A之后执行，D在B之后执行，那么直接将A,C合并为一个任务，放入线程池中运行，B、D合并为一个任务，放入线池程中执行，如需决定AC和BD的顺序，那么可以按照AC、BD的顺序依次放入子线程中。 如何对IDLEHandler进行顺序划分？比如先执行B，在执行A规划一个空闲队列，在Handler空闲时进行处理，每次出队优先级最高的，其他等到下次空闲在执行 2-4是怎么计算的？核心线程数位2-4，计算方式是cpu核数-1，如果比2小，就选择2，比4大就选择4，中间就选它自己，之所以 减掉这个1，是因为为了避免后台任务将 CPU 资源完全耗尽， 减掉的这个1 是留给我们 主线程 使用的。","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"注解原理","slug":"移动端/Android原生/注解原理","date":"2021-05-31T12:56:54.000Z","updated":"2021-05-31T13:05:16.422Z","comments":true,"path":"2021/05/31/移动端/Android原生/注解原理/","link":"","permalink":"http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/","excerpt":"","text":"[TOC] 注解简析元注解：修饰注解的注解， @Target：注解的作用目标（修饰方法，类还是字段） @Retention：注解的生命周期 SOURCE：仅存在java源文件中，经过编译器后就丢弃，适用于一些检查行的操作，比如@Override CLASS：编译class文件时生效，适用于在编译时女性一些预处理操作，比如Butterknife的@BindView，在编译时，通过注解器生成一些辅助代码，完成完整的功能 RUNTIME：保留在运行时VM中可以通过反射获取注解。适用于一些需要运行时动态获取注解信息，类似反射获取注解等，比如EventBus的@Subscribe @Documented：注解是否应当被包含在JavaDoc文档中 @Inherited：是否允许子类继承该注解 AnnotationInvocationHandler：专门处理注解的Handler 代码的生命周期包含：编码(SOURCE)—-&gt;编译(CLASS)—-&gt;运行(RUNTIME) 默认时注解在编译阶段，即CLASS阶段 本质：一个继承了Annotation接口的接口 运行时处理：使用反射获取当前的所需要的东西 编译时处理：APT技术，即编译期扫描java文件的注解，并传递到注解处理器，注解处理器可根据注解生成新的java文件 注解器注解器通常是以Java代码（或者编译过的字节码）作为输入，生成.java文件作为输出 使用google的AutoService（@AutoService）可以自动生成resources/META-INF.services中的注册目录 包含注解处理器，注解声明库，实际使用APT的Android/Java项目 为什么把注解处理器独立抽成一个库呢？对于Android项目默认是不包含 APT相关类的。所以要使用APT技术，那么就必须创建一个Java Library。对于Java项目，独立抽成一个库，更容易维护与扩展。 为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？这样可以不用将注解处理器的相关代码大报道使用者的项目中去 注解器声明其方法包含四个主要重写方法 init() ：初始化调用 process()：实际处理方法 getSupportedAnnotationTypes()：返回当前注解器处理注解的类型 getSupportedSourceVersion()：指定你使用的java版本 在注解处理过程中，会扫描所有的java源文件，查询注解，在java源代码中，每一部分都代表一个特定类型的Element，比如：12345678910package com.jennifer.andy.aptdemo.domain;//PackageElementclass Person &#123;//TypeElement private String where;//VariableElement public void doSomething() &#123; &#125;//ExecutableElement public void run() &#123;//ExecutableElement int runTime;//VariableElement &#125;&#125; 注解处理器是运行在它自己的虚拟机JVM中，javac启动一个完整Java虚拟机来运行注解处理器。 最终是通过自定义注解器在编译时期生成加载注解后的类，在process方法中具体做了执行，编译了程序模版信息进行添加。 自定义注解如果是单一属性，可以使用value字段 1234567891011@interface MyAnno1 &#123; //格式：类型名 属性名（） String value();&#125;@MyAnno1(&quot;kang&quot;)@interface MyAnno2 &#123; //格式：类型名 属性名（） String name();&#125;@MyAnno2(name = &quot;kang&quot;) 如果不是value字段的话，需要（指定属性 = 值） 注解中只允许八中基本数据类型、字符串、类类型，注解类型，枚举类型及其一维数组","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"LiveData和ViewModel源码分析","slug":"移动端/Android原生/LiveData和ViewModel源码分析","date":"2021-05-31T12:55:45.000Z","updated":"2021-06-01T05:58:30.948Z","comments":true,"path":"2021/05/31/移动端/Android原生/LiveData和ViewModel源码分析/","link":"","permalink":"http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/LiveData%E5%92%8CViewModel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"[TOC] ViewModelViewModel的定义ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。 历史方式的缺点： 对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。 需要处理异步调用，内存泄漏等问题 使界面控制器类越发膨胀 ViewModel将数据存储和界面控制进行分离，独立出来ViewModel 存在的时间范围是从您首次请求 ViewModel 直到 Activity 完成并销毁。 ViewModel生命周期 ViewModel在onCreate中初始化，在finish()后会调用onCleared()方法， 所以ViewModel生命周期长于Activity,ViewModel不持有UI的引用，通过观察者通知界面更新 ViewModel在Fragment之间共享数据为什么能在Fragment中共享数据？因为在Fragment中初始化ViewModel时传入的宿主Activity，ViewModelStore中取出当前Activity对应的ViewModel对象，返回给Fragment，这样他们获取的是同一个ViewModel实例，数据当然也会共享 ViewModel源码分析构造函数我们通常使用这种方式初始化ViewModel1234567ProgressViewModel processViewModel = new ViewModelProvider(this).get(ProcessViewModel.class);public ViewModelProvider(@NonNull ViewModelStoreOwner owner) &#123; this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory() : NewInstanceFactory.getInstance()); &#125;从ViewModelStoreOwer中获取ViewModelStore，ViewModelStore是从AppCompatActivity-&gt;FragmentActivity-&gt;ComponentActivity中获取，本质还是new ViewModelStore()。Factory在AppCompatActivity和Fragment中的是HasDefaultViewModelProviderFactory，具体实现是SavedStateViewModelFactory 1234public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) &#123; mFactory = factory; mViewModelStore = store;&#125; 将ViewModelStore和Factory进行赋值 get方法进入get方法： 12345678910111213141516171819202122232425262728293031323334353637383940@NonNull@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; //返回该类的规范名称，如果它是本地或匿名类或其组件类型没有规范名称的数组，则返回null。 String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;); &#125; //key = DEFAULT_KEY + &quot;:&quot; + canonicalName return get(DEFAULT_KEY + &quot;:&quot; + canonicalName, modelClass);&#125;@NonNull@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; //从ViewModelStore中获取ViewModel，首次进入获取为空 ViewModel viewModel = mViewModelStore.get(key); //等效于instanceOf，判断是否是所需viewModel if (modelClass.isInstance(viewModel)) &#123; if (mFactory instanceof OnRequeryFactory) &#123; ((OnRequeryFactory) mFactory).onRequery(viewModel); &#125; return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; if (mFactory instanceof KeyedFactory) &#123; viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass); &#125; else &#123; viewModel = (mFactory).create(modelClass); &#125; mViewModelStore.put(key, viewModel); return (T) viewModel;&#125; 我们可知Factory放入具体实现是SavedStateViewModelFactory，SavedStateViewModelFactory又继承于KeyedFactory，我们看下create方法，值得一提的是，这里的mFactory是AndroidViewModelFactory 12345678910111213141516171819202122232425262728293031323334353637@NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; //是否为AndroidViewModel类，或者其子类 boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass); Constructor&lt;T&gt; constructor; if (isAndroidViewModel) &#123; constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE); &#125; else &#123; constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE); &#125; // doesn&#x27;t need SavedStateHandle //如果constructor为null，create内部什么也不处理 if (constructor == null) &#123; return mFactory.create(modelClass); &#125; SavedStateHandleController controller = SavedStateHandleController.create( mSavedStateRegistry, mLifecycle, key, mDefaultArgs); try &#123; T viewmodel; if (isAndroidViewModel) &#123; viewmodel = constructor.newInstance(mApplication, controller.getHandle()); &#125; else &#123; viewmodel = constructor.newInstance(controller.getHandle()); &#125; viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller); return viewmodel; &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(&quot;Failed to access &quot; + modelClass, e); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(&quot;A &quot; + modelClass + &quot; cannot be instantiated.&quot;, e); &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException(&quot;An exception happened in constructor of &quot; + modelClass, e.getCause()); &#125; &#125; 判断ViewModel类型，获取不同的构造方法，通过反射实现ViewModel的初始化，然后使用mViewModelStore.put(key, viewModel); 将viewModel以key的形式存入ViewModelStore进入ViewModelStore：123456789101112131415161718192021222324252627282930 public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; Set&lt;String&gt; keys() &#123; return new HashSet&lt;&gt;(mMap.keySet()); &#125; /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.clear(); &#125; mMap.clear(); &#125;&#125;内部实现就是一个HashMap，Key为String，value为ViewModel，put后新放入的ViewModel覆盖新的ViewModel，这里的key强调一下，统一格式为androidx.lifecycle.ViewModelProvider.DefaultKey:com.zz.chatright.ChatViewModel SavedState在源码分析中我们看到构造函数中都包含了一个SavedStateHandleController类，这里保存了数据类，使其不受生命周期影响，例如发生屏幕旋转等。 SaveStateHandle：内部存储数据格式为Map&lt;String, Object&gt;，亦存在Map&lt;String, SavingStateLiveData&lt;?&gt;&gt;完成值的通知 SaveStateHandleController：将SaveStateHandle同Lifecycle生命周期进行绑定 SavedStateRegistry：管理 SavedStateProvider 列表的组件，此注册表绑定了其所有者的生命周期（即 activity 或 fragment） SavedStateProvider：保存状态的组件，此状态将在以后恢复并使用 activity 的状态保存分为 view 状态和成员状态 继承关系 如何保证viewModel的唯一性？通过反射进行初始化操作，带入的是Application的Context对象，这样就保证不会持有Activity或者Fragment的引用。然后会将创建出来的实例对象存储在ViewModelStore（内部HashMap）中，每次使用都会去ViewModelStore中查看是否存在，如果存在，则直接使用，不需要实例化key就是DEFAULT_KEY + “:” + canonicalName（viewmModel类名路径，eg：com.zz.test.MyViewModel） 为什么viewModel能管理生命周期，并且不受重建情况的影响2.0以前：创建了一个无view的HolderFragment同步Activity的生命周期，并关联ViewModelStore，而且设置setRetainInstance(true)时，会保证屏幕切换时生命周期不会改变，让fragment在Activity重建时存活下来 2.0以后：运用了androidx新库，用到了AppCompatActivity的父类ComponentActivity，重写onRetainNonConfigurationInstance()方法保存了ViewModelStore，Activity通过onRetainNonConfigurationInstance()方法获取ViewModelStore实例，保证了ViewModel不会随着Activity的重建而重建。不论是Activity还是Fragment都实现了LifecycleOwner，所以生命周期通过Lifecycles组件感知每个页面的生命周期 onRetainNonConfigurationInstance()和onSaveInstanceState的调用时机是一样的，但是onRetainNonConfigurationInstance()的Bundle数据不限制大小，所以更倾向这个 当Activity因为配置需要重建时，系统会调用onRetainNonConfigurationInstance()方法，将ViewModelStore存储在NonConfigurationInstances中，最终交给ActivityClientRecord类，因为ActivityClientRecord不受Activity重建的影响，所以NoConfigurationInstances也不受Activity重建的影响 ViewModel同onSaveInstanceState()的区别使用场景在Activity变得“容易”销毁时，就会触发onSaveInstanceState() 当按下HOME键后，系统就会触发调用 当长按HOME键，选择运行其他程序时 按电源键息屏的时候 从Activity A中启动一个新的Activity 横竖屏切换时 而使用ViewModel恢复数据 则 只有在 因配置更改界面销毁重建 的情况。 存储方式ViewModel存储在内存中，onSaveInstanceState()是序列化到磁盘中存储的 存储大小ViewModel存储大小限制时app的可用内存onSaveInstanceState()因为使用了序列化和反序列化，那么通过Bundle存储大小限制为1M LiveDataLiveData的定义 当在onStart后，onResume,onPause都是STARTED/RESUMED的，即为活跃的（onActive），当在onStop后，则为非活跃状态（onInActive）LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。 如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。LiveData 只会将更新通知给活跃的观察者。为观察 LiveData 对象而注册的非活跃观察者不会收到更改通知。 您可以注册与实现 LifecycleOwner 接口的对象配对的观察者。有了这种关系，当相应的 Lifecycle 对象的状态变为 DESTROYED 时，便可移除此观察者。这对于 Activity 和 Fragment 特别有用，因为它们可以放心地观察 LiveData 对象，而不必担心泄露（当 Activity 和 Fragment 的生命周期被销毁时，系统会立即退订它们）。 LiveData的优势 及时更新界面数据 不会发生内存泄漏，当其关联的生命周期被摧毁，则回收自己 不会因为Activity停止而崩溃，准确判断生命周期，决定是否通知 不需要自己手动处理生命周期 在再次活跃时会接收到最新的数据，保持数据最新状态 如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。 共享资源。您可以使用单例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。 LiveData源码分析建立号viewModel后，我们在Activity中这样使用：123processViewModel.isBigScreen.observe(appCompatActivity, it -&gt; &#123; ...&#125;); 进入observe方法进行查看：123456789101112131415161718192021@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread(&quot;observe&quot;); //如果该生命周期为onDestory之后，则return，不做处理 if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); //将观察者注册到mObservers中，如果存在，则返回wrapper，否则，返回null ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); &#125; if (existing != null) &#123; return; &#125; //添加到LifeCycle中 owner.getLifecycle().addObserver(wrapper);&#125;通常我们使用setValue和postValue的方法进行数据更新进入setValue下查看：1234567@MainThreadprotected void setValue(T value) &#123; assertMainThread(&quot;setValue&quot;); mVersion++; mData = value; dispatchingValue(null);&#125; 进入dispatchingValue()12345678910111213141516171819202122232425void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; //便利订阅者集合 for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false;&#125; 便利订阅者集合，进行分发：123456789101112131415161718192021222324private void considerNotify(ObserverWrapper observer) &#123; //如果改订阅者不活跃，直接过滤 if (!observer.mActive) &#123; return; &#125; // Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we&#x27;ve not received that event, we better not // notify for a more predictable notification order. //如果不是onResume状态 if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; //通过version判断是否是最新数据 if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; observer.mLastVersion = mVersion; //noinspection unchecked //执行分发逻辑 observer.mObserver.onChanged((T) mData);&#125; 在active的生命周期下，如果是onResume状态且是最新数据，则进行数据分发，否则，进入activeStateChanged方法：1234567891011121314151617181920void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; return; &#125; // immediately set active state, so we&#x27;d never dispatch anything to inactive // owner mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; if (wasInactive &amp;&amp; mActive) &#123; onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; onInactive(); &#125; if (mActive) &#123; //调用具体分发逻辑 dispatchingValue(this); &#125; &#125; 当不是active状态下，则不会进行分发处理，当页面从后台回到前台时，也会触发该方法，那么会取最新的mData并分发给该页面。 如果是post请求，会通过handler传递到主线程，调用setvalue方法，所有的回掉，observer方法都是在主线程中的","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android大厂面试题","slug":"移动端/Android原生/Android大厂面试题","date":"2021-05-31T12:53:14.000Z","updated":"2021-05-31T12:54:06.971Z","comments":true,"path":"2021/05/31/移动端/Android原生/Android大厂面试题/","link":"","permalink":"http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Android%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"京1: butterknife原理，R2文件？ Handler异步消息，同步屏障？同步消息？looper.perpare()何时创建？message.obtain()? Vsync，垂直同步信号？ UI滑动渲染优化？ 内存泄漏？leakcarray原理？ oom的条件？ 开辟多个线程导致oom？ bitmap的存储形式在系统中的存储？存储在哪？ 布局优化？LinearLayout draw几次？ IPC机制，binder机制的理解？为什么使用线程池？（一个服务端对多个客户端） flutter渲染机制？flutter的树？ 京2: 移动端自动化开发 EventBus原理？优点？缺点？切换线程的方式 ViewModel+LiveData 音箱和手机的差异化？android版本，厂商room，客户群体不同 apk瘦身？ 启动优化的时间检测？启动器优化方式 组件化？如何设计一个组件 小米1： Activity的生命周期？activityA在下拉框的时候的生命周期？（不变化）onDestory有立即执行吗？ activity启动后在最后一帧绘制在哪？ android启动打点？AOP？启动优化？开启一个线程？AMS，反射？如何对函数进行插桩？ ASM对.class文件修改，生成.dex文件前搞定，在.class和.dex文件转化中间作修改 leakcanary原理？自己如何做内存泄漏器？各个函数之间的耗时情况？ 亮点？有向无环图？contentprovider的初始化？ Handler内存泄漏的原因？怎么处理？handler持有Activity强引用，messageQueue持有handler的强引用 view的绘制？dispatchDraw()和onDraw()的执行顺序？ 如果绘制一个圆，保证这个圆的中间不被绘制？cavas进行裁剪，画布上就缺一块，则子view绘制不上 view的事件分发？如果dispatch返回true，会拦截到onInterrcept和onTouch bitmap的优化？bitmap的大小的计算？2x的大小图片放大1x的图片中，bitmap会变大 线程池？阻塞的处理？exectue和submit的区别，如何捕获线程池错误（ThreadFactory） 生产者消费者通知？ 线程同步？加锁，Sychronized，ReentrantLock Hashmap，hash值计算？为什么这么计算？arraymap和hashmap？ 数组和链表的区别？ https加密形式 小米2面： 启动优化？bitmap预加载？如何更快加载图片？还有别的什么优化？ Glide的into方法是怎么执行的，如何显示到imageView中的？ Glide的加载流程？fragment如何绑定？imageView正在加载，再次加载另一个图片，具体会执行什么？ Android启动流程？Activity启动流程？ ViewModel？LiveData的理解 ？mvvm的理解？ 网络请求异步框架？线程池？ 链表反转（逆置） Yy1: okhttp io的方式？okio，java中io的方式？责任链模式？连接池复用？ Glide的缓存结构？为什么要用activieResource？ EventBus的简述？字节码=.class文件，注解方式？ RecyclerView缓存形式？ MotionLayout的内部原理 Mvvm需要注意什么？内存泄漏？持有view的引用 leakCanary原理，gc间隔=5s，在idleHandler中使用延迟5s的操作，大概是主线程闲置后在等待5s中进行验证后执行gc？Fragment怎么监听内存泄漏的？fragmentManager.registerFragmentLifecycleCallbacks中检测 apk瘦身？so库合并 先把所有要打包的库编译生成静态库，然后使用如下命令把它们合并成一个*.so: 1gcc -shared -o c.so -Wl,--whole-archive a.a b.a -Wl,--no-whole-archive 启动优化？其他的优化框架， 线程，进程，协程？时间分片？协程是怎么做的？那个io？ handler机制？子线程中如何使用handler？handler中的Looper.prepareMain和Looper.prepare的区别？主线程永不退出，死循环？同步屏障？ Yy2: 音频协议？ 协程，进程，线程的区别？ mvvm？组件化？ websocket协议和http协议的区别？ butterknife原理？注解的三种形式？ 动态代理的方式？2中？动态代理的关联？ 类型擦出？范性？ 类加载过程？类什么时候初始化？静态类的初始化过程？ 编译器优化？ GCroot？栈溢出？（递归） java异常有几种？可以捕获oom异常吗？可以，在bitmap中如果触发oom可以进行try catch 动画？差值器，估值器？ 二叉树之字形打印 581: 组件化ARouter框架原理？ 编译时注解生成类文件，存储全局路由管理，通过反射创建对象。 如果是Activity，通过Intent进行跳转传参，Fragment，BroadCastReceiver，Service等都是通过反射创建对象的 LiveData，viewModel机制，如何绑定生命周期，viewModel中持久化是怎么做的，LiveData中的粘性事件 粘性事件是通过版本号控制的，当进入active状态后，会比对version版本，进行订阅者的通知 Activity的启动过程 RecyclerView机制 Handler机制 java中锁的机制，volatile的可见性怎么理解？Synchronized怎么理解？自旋锁怎么理解？ReentrantLock怎么理解？ kotlin中的协程？ kotlin中协程通过挂起函数来实现协程的处理，使用CPS变换，suspend 每个挂起函数都会被编译为Continuation ，将函数体编译为状态机 ASM flutter理解？fish-redux的分层？数据流向？ view—–&gt;action—-&gt;effect—–&gt;reducer—–&gt;store—–&gt;view 58 2: 项目相关。。。 36012: Fragment切换，add和replace，复用的问题？ Fragment可见性准确保证？ Fragment构造传参的劣势？ 在Activity异常退出重建Fragment的时候，会执行Fragment的无参构造方法，如果通过setArguments进行传递参数，Activity在构造Fragment时会通过反射午餐构造实力 内联优化？ aapt1和aapt2的区别 aapt1进行全量编译 aapt2进行差量编译 垃圾加载的GC root LRU算法怎么实现的 java中的容器有哪些？线程安全的有哪些？ Vector 与ArrayList几乎相同，但是线程安全 Stack 继承自Vector CopyOnWriteArrayList 写实拷贝 ConcurrentLinkedQueue 基础链表同步队列 LinkedBlockingQueue HashTable ConcurrentHashMap 58 3: 对排序？ http请求过程，https的过程 数组和链表的区别 栈中调用方法的过程 LRU算法的实现 美团 1: 携程 1: 快手 1: 知乎 1: Activity的生命后期 onConfigurationChanged？其他回掉时机？onSaveInstanceState回调？分屏？ ARouter？ Fragment的生命周期？onCreateView可以返回null吗？ fragment怎么初始化？fragment为什么不推荐携带参数？androidx中提供fragment传参？Fragment重建？ viewModel持久化？viewmodel重建？可以存储Bundle？ java内存模型？volatile原理？可见性，非原子性，禁止指令重排 组件化开发？ 二叉树镜像？ 知乎 2: mvvm的理解 离开公司的原因 未来的方向，2c方向，架构方向 架构师主要负责，技术选型 为什么选择知乎？ 知乎界面的分析+选型+排期 你的优势，为什么给你发offer？ android启动器？线程池选型？ 大文件查找方案？ 整数的逆置，头和尾是0的情况排除","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"面试指南","slug":"移动端/Android原生/面试指南","date":"2021-05-31T12:47:57.000Z","updated":"2021-06-01T06:22:55.816Z","comments":true,"path":"2021/05/31/移动端/Android原生/面试指南/","link":"","permalink":"http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/","excerpt":"","text":"[TOC] 框架篇EventBus简述EventBus的理解EventBus作为通信事件传递的总线，你无需控制值的传递，也无需通过广播等低效实现，通过EventBus在你需要发送的地方post信息，在你需要接收的地方接收信息处理即可，（前提是register过） EventBus的五种线程模式 POSTING：默认，发布和订阅在同一个线程，同发布者一个线程（主—&gt;主 , 子—&gt;子），最小的开销，因为不用切换线程，避免了线程的完全切换，使用此模式的事件处理程序必须快速返回，以避免阻塞可能是主线程的发布线程。 MAIN：事件处理函数的线程在主线程（UI）线程。不能进行耗时操作，订阅者需快速返回以免阻塞主线程 MAIN_ORDERED:事件处理函数的线程在主线程（UI）线程。不会阻塞线程 BACKGROUND：处理函数在后台线程，不能进行UI操作。发布在主线程，订阅会开启一个新的后台线程。发布在后台线程，事件处理函数也在该后台线程 ASYNC：无论事件发布的线程是哪一个，都会重新开辟一个新的子线程运行，不能进行UI操作 EventBus的事件类型接收事件必须是public修饰符修饰，不能用static关键字修饰，不能是抽象的（abstract） 普通事件：先订阅在发布，发布到订阅者后进行处理 粘性事件：支持先发布在订阅，当订阅者订阅后会自动发送到订阅者进行处理，发送粘性事件EventBus.postSticky()，接收粘性事件sticky = true 为什么必须是public？因为源码定义 优先级优先级高的订阅者优先接收到任务 简述源码分析事件 register：通过注解初始化订阅方法后，在register后，在缓存中获取所有该订阅者的方法，循环遍历订阅，新建newSubscription方法，根据priority优先级将newSubscription方法放入subscriptions中，判断如果是粘性事件，则执行其对应的订阅方法。 unregister：从typesBySubscriber获取订阅事件类型，根据订阅事件类型从subscriptionsByEventType获取订阅者信息，将subscription的active置为false，并移除该subscription 索引如何理解？EventBus 3.0以后，采用Subscribe注解配置事件订阅方法，采用反射的方式来查找订阅事件的方法，我们都知道反射对性能是有影响的，所以提出了索引的概念。 在项目编译时，通过配置，生成一个辅助类用来存储订阅信息，原理是HashMap，存储注册类的class类型和事件订阅方法的信息，提高速度3-4倍 MAIN和MAIN_ORDERED的区别？ 在MAIN模式下，如果事件发布者post事件也是在主线程的话，会阻塞post事件所在的线程，意思是连续post多个事件，如果接收事件方法执行完，才能post下一个事件 **post(1) ——&gt; onReceiveMsg(1) ——&gt;post(2)——&gt;onReceiveMsg(2)——&gt;post(3)——&gt;onReceiveMsg(3)** 如果事件发布者post事件不在主线程，连续post多个事件，同时在主线程是接收事件是耗时操作的话，执行的流程是非阻塞的 **post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(3)** 或 **post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(2)——&gt;onReceiveMsg(3)** MAIN_ORDERED模式下，无论什么场景都是非阻塞的 EventBus可否跨进程问题？不能，单进程间通信 HermesEventBus——&gt;饿了吗开发框架，可应用于单进程和多进程。 使用IPC机制，首先选择一个主进程，其他则为子进程，每一个event会经过4步： 使用Hermes库将event传递给主进程。 主进程使用EventBus在主进程内部发送event。 主进程使用Hermes库将event传递给所有的子进程。 每个子进程使用EventBus在子进程内部发送event。 BackgroundThread和Async区别BackgroundThread：发布在主线程，新开辟子线程中执行。发布在子线程，则在子线程中执行，这个子线程是阻塞式的,按顺序交付所有事件，所以也不适合做耗时任务，因为多个事件共用这一个后台线程 Async：无论发布在哪一个线程，都会在重新开辟一个子线程执行 EventBus的优缺点：优点:EventBus是greenrobot公司出的另一款开源框架，这个框架是针对Android优化的发布/订阅事件总线，使用EventBus可以极大的减少我们程序的耦合度。调度灵活。不依赖于 Context，使用时无需像广播一样关注 Context 的注入与传递。使用简单。快速且轻量。完全解耦了请求链之间的关系，避免了请求者被长持有，比广播更轻量可以定义在调用线程、主线程、后台线程、异步。 粘性事件 优先级概念 为了避免频繁的向主线程 sendMessage()(Handler机制)，EventBus 的做法是在一个消息里尽可能多的处理更多的消息事件，所以使用了 while 循环，持续从消息队列 queue 中获取消息。 同时为了避免长期占有主线程，间隔 10ms （maxMillisInsideHandleMessage = 10ms）会重新发送 sendMessage()，用于让出主线程的执行权，避免造成 UI 卡顿和 ANR。 缺点:各种Event的定义工作量大。每次传的内容不一样,就需要重新定义一个JavaBean 单向传播 需要显性注册 EventBus如何做到线程切换EventBus发送的消息，如何做到线程切换？ 12345678910111213141516171819202122232425262728293031323334private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case MAIN_ORDERED: if (mainThreadPoster != null) &#123; mainThreadPoster.enqueue(subscription, event); &#125; else &#123; // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125; &#125; 主要分为主线程执行和子线程执行，当为主线程时：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class HandlerPoster extends Handler implements Poster &#123; private final PendingPostQueue queue; private final int maxMillisInsideHandleMessage; private final EventBus eventBus; private boolean handlerActive; protected HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) &#123; super(looper); this.eventBus = eventBus; this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; &#125; &#125; &#125; @Override public void handleMessage(Message msg) &#123; boolean rescheduled = false; try &#123; long started = SystemClock.uptimeMillis(); //循环处理消息事件，避免重复sendMessage() while (true) &#123; PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; //避免长期占用主线程，间隔10ms重新sendMassage() if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; rescheduled = true; return; &#125; &#125; &#125; finally &#123; handlerActive = rescheduled; &#125; &#125;&#125;使用HandlerPoster将任务通过sendMessage方法发送到主线程执行，通过消息队列存储该handler的任务，通过10ms发送一次任务，防止主线程卡顿，MAIN情况下，如果在主线程，直接执行。MAIN_ORDER的情况下，全部交给handler异步执行，所以区别于MAIN不是同步的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677final class BackgroundPoster implements Runnable, Poster &#123; private final PendingPostQueue queue; private final EventBus eventBus; private volatile boolean executorRunning; BackgroundPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; queue.enqueue(pendingPost); if (!executorRunning) &#123; executorRunning = true; eventBus.getExecutorService().execute(this); &#125; &#125; &#125; @Override public void run() &#123; try &#123; try &#123; while (true) &#123; PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); &#125; &#125; catch (InterruptedException e) &#123; eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + &quot; was interruppted&quot;, e); &#125; &#125; finally &#123; executorRunning = false; &#125; &#125;&#125;class AsyncPoster implements Runnable, Poster &#123; private final PendingPostQueue queue; private final EventBus eventBus; AsyncPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); queue.enqueue(pendingPost); eventBus.getExecutorService().execute(this); &#125; @Override public void run() &#123; PendingPost pendingPost = queue.poll(); if(pendingPost == null) &#123; throw new IllegalStateException(&quot;No pending post available&quot;); &#125; eventBus.invokeSubscriber(pendingPost); &#125;&#125; 子线程执行是通过线程池进行管理，内部也存在一个消息队列，按顺序执行任务，对于BACKGROUND情况下，同时只会使用线程池中的一个线程，而Async直接放入线程池，让线程池去规划线程。当线程池中等待任务过多时，会触发oom（线程池是newCachedThreadPool()，则线程为非核心线程MAX） 粘性事件的原理普通事件是先注册后发布，而粘性事件可以先发布后注册，实现方式上是这样的： 发送时会将粘性事件的事件类型和对应事件保存起来，在执行post方法，在注册后，如果是粘性事件，会多走一步类似于post的方法，触发进行分发 如何判断当前线程是否为主线程？在发布事件的地方判断发送线程和主线程的Looper对象是否相等1return Looper.getMainLooper() == Looper.myLooper(); 如何优化EventBus 尽量使用索引功能，避免不必要的反射，提升性能 增加EventBus的进程间通信 为什么使用ConcurrentHashMap保存数据ConcurrentHashMap和HashMap的区别 因为EventBus是单进程、多线程间通信，可能涉及到线程安全问题，使用ConcurrentHashMap可以有效解决线程安全和效率。 Okhttp3 简述OkHttp是基于Socket的封装，主要有三个类：Response、Request、Call 同步使用client.excute(); 异步使用client.enqueue(); OkHttp的高效在于内部有一个Dispatcher，是okhttp维护的一个线程池，对最大连接数（并发），host最大访问量做了定义，维护了3个队列（同步正在执行，准备执行，异步正在执行）和一个线程池（0~max） 内部还维护了连接池，实现了复用机制，减少重复握手 提供缓存机制。 有几个拦截器，分别是干什么的？client.intercepters()：应用拦截器 RetryAndFollowUpIntercepter：重试和重定向机制，最大重试次数为20，构造StreamAllocation，创建缓存池，复用 BridgeIntercepter：将用户构造的请求转化为服务器识别的请求，将服务器返回的响应转化为用户识别的响应，添加keep-alive，供连接池复用 CacheIntercepter：缓存读取和更新 ConnectIntercepter：dns解析与服务器建立连接(握手结束)，它利用 Okio 对 Socket 的读写操作进行封装，它对 java.io 和 java.nio 进行了封装，让我们更便捷高效的进行 IO 操作 client.networkIntercepter：网络拦截器 CallServerIntercepter：最后一个拦截器，负责向服务器发送请求和接收服务器的响应 采用责任链模式，将请求和发送分别处理，并且可以动态添加中间的处理方实现对请求的处理、短路等操作。 addNetworkInterceptor() （网络拦截器）和addInterceptor() （应用拦截器） 区别就是一个靠前一个靠后，其中经过的拦截器会导致不一样的结果 自定义拦截器区别 RetryAndFollowUpIntercepter中怎么进行重定向？最大重试次数为20次123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051case HTTP_PERM_REDIRECT://307case HTTP_TEMP_REDIRECT://308 // &quot;If the 307 or 308 status code is received in response to a request other than GET // or HEAD, the user agent MUST NOT automatically redirect the request&quot; if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) &#123; return null; &#125; // fall-throughcase HTTP_MULT_CHOICE://300case HTTP_MOVED_PERM://301case HTTP_MOVED_TEMP://302case HTTP_SEE_OTHER://303 // Does the client allow redirects? if (!client.followRedirects()) return null; String location = userResponse.header(&quot;Location&quot;); if (location == null) return null; HttpUrl url = userResponse.request().url().resolve(location); // Don&#x27;t follow redirects to unsupported protocols. if (url == null) return null; // If configured, don&#x27;t follow redirects between SSL and non-SSL. boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme()); if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null; // Most redirects don&#x27;t include a request body. Request.Builder requestBuilder = userResponse.request().newBuilder(); if (HttpMethod.permitsRequestBody(method)) &#123; final boolean maintainBody = HttpMethod.redirectsWithBody(method); if (HttpMethod.redirectsToGet(method)) &#123; requestBuilder.method(&quot;GET&quot;, null); &#125; else &#123; RequestBody requestBody = maintainBody ? userResponse.request().body() : null; requestBuilder.method(method, requestBody); &#125; if (!maintainBody) &#123; requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); requestBuilder.removeHeader(&quot;Content-Type&quot;); &#125; &#125; // When redirecting across hosts, drop all authentication headers. This // is potentially annoying to the application layer since they have no // way to retain them. if (!sameConnection(userResponse, url)) &#123; requestBuilder.removeHeader(&quot;Authorization&quot;); &#125; return requestBuilder.url(url).build();如果返回响应code是307和308，则只对get和head类型的请求进行重定向。如果返回请求为PROPFIND，则重新发送的请求都为保持原状，如果不是propFind，则重新请求的都会被设置为get请求，且请求信息为空 RetryAndFollowUpInterceptor的intercept中先是创建了StreamAllocation对象，然后开启while(true)无限循环。接着在这个循环中先调用下层拦截器去网络请求，若请求期间发生异常，判断能否重试，能就continue进行下一轮循环，否则抛异常退出循环结束方法。如果下层拦截器请求完成返回response，通过response的状态码判断是否需要重定向，若需要重定向，修改request后进行下一轮循环，否则返回response结束方法。 什么是连接池？OkHttp的底层是通过Java的Socket发送HTTP请求与接受响应的(这也好理解，HTTP就是基于TCP协议的)，但是OkHttp实现了连接池的概念， 即对于同一主机的多个请求，其实可以公用一个Socket连接，而不是每次发送完HTTP请求就关闭底层的Socket，这样就实现了连接池的概念。 简述连接池的复用？okhttp中所有的请求都被抽象为RealConnection，而ConnectionPool就是管理这些connection的，共享一个Address的链接可以复用 ConnectionPool，默认大小是5，每个链接存储5分钟，使用keep-alive，达到久连接，所以默认keep-alive是5分钟，也可以自定义 excutor：线程池，监测时间并释放连接的后台线程 connections：缓存池。是一个双端列表，这里用作栈 routeDatabase：记录连接失败router（路由） 使用put方法将连接放入缓存池，并清除闲置的线程，对缓存池进行排序（对比最大闲置时间），使用StreamAllocation复用请求 StreamAllocation的初始化在RetryAndFllowUpIntercepter。 在StreamAllocation调用newStream进行初始化，其中使用get方法在缓存池中查找相同的请求，如果找到就复用这条请求，没找到就新建连接并put到缓存池 连接池的工作就这么多，并不负责，主要就是管理双端队列Deque，可以用的连接就直接用，然后定期清理连接，同时通过对StreamAllocation的引用计数实现自动回收。 简述StreamAllocationStreamAllocation是用来协调connections，stream和Call(请求)的。 HTTP通信执行网络请求Call需要在连接Connection上建立一个新的流Stream，我们将StreamAllocation称之流 的桥梁，它负责为一次请求寻找连接并建立流，从而完成远程通信。 其初始化在RetryAndFllowUpIntercepter，再次使用在CallServerInterceptor，复用机制使用该方法调用，减少一个三次握手的时间（不需要握手） OKIO的优势 更加轻便，速度更快，使用更快 实现缓存结构，对cpu和内存进行优化，避免频繁gc（Segment链表实现） 功能强大，支持阻塞和非阻塞IO 支持多种类型，想比较于java.io和java.nio，不需要庞大的装饰类 Dispatcher的理解内部维护了三个队列，分别为： runningAsyncCalls：正在请求的异步队列 readyAsyncCalls：准备请求的异步队列\\等待请求的异步队列 runningSyncCalls：正在请求的同步队列 maxRequest：默认64。这是okhttp允许的最大请求数量。maxRequestsPerHost ：默认5。这是okhttp对同一主机允许的最大请求数量。 同步执行源码：1234567891011121314151617@Override public Response execute() throws IOException &#123; synchronized (this) &#123; //此处除去一些其他代码 //... try &#123; //通知Dispatcher这个Call正在被执行,同时将此Call交给Dispatcher //Dispatcher可以对此Call进行管理 client.dispatcher().executed(this); //请求的过程，注意这行代码是阻塞的，直到返回result！ Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; finally &#123; //此时这个请求已经执行完毕了，通知Dispatcher，不要再维护这个Call了 client.dispatcher().finished(this); &#125;&#125; try 中的return执行完成后，执行finally语句，所以不论请求成功或者失败，都会关闭这个请求 异步执行源码：1234567891011@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; //判断是否已经执行过了 if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; //捕获调用栈的信息，用来分析连接泄露 captureCallStackTrace(); //封装一个AsyncCall交给Dispatcher调度 client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 1234567891011synchronized void enqueue(AsyncCall call) &#123; //判断正在执行的异步请求数没有达到阈值，并且每一个Host的请求数也没有达到阈值 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; //加入到正在执行队列，并立即执行 runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; //加入到等待队列 readyAsyncCalls.add(call); &#125;&#125; 简述OKhttp的缓存机制okhttp有具备网络缓存机制，短时间内重复请求会复用缓存的数据，这样节省流量，应用也会很流畅。但是okhttp本身默认是不打开缓存机制的，需要配置后才能启动。 okhttp的缓存机制是以DiskLruCache（最近最少使用算法（Least recently used））为基础的，仅支持文件存储。 MD5(url)作为key，value是存储的服务端响应数据 默认不开启缓存机制 文件存储 DiskLruCache写入是依赖于okio的，内部实现类似于LinkedHashMap，键值对获取。 使用DiskLruCache，仅支持get请求的缓存 如果服务器支持缓存，即response携带Cache-control属性，则当你打开okhttp缓存即开始缓存，通过属性控制类型 如果服务器不支持缓存或者okhttp不想按照服务器缓存策略来存储，通过自定义拦截器重写response的头部即可 客户端不支持缓存，则可以不缓存，不理会服务器的cache-control属性 可以直接使用CacheControl类，包含 CacheControl.FORCE_NETWORK，即强制使用网络请求 CacheControl.FORCE_CACHE，即强制使用本地缓存，如果无可用缓存则返回一个code为504的响应 123max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。no-cache：不做缓存。max-age：这个参数告诉浏览器将页面缓存多长时间，超过这个时间后才再次向服务器发起请求检查页面是否有更新。对于静态的页面，比如图片、CSS、Javascript，一般都不大变更，因此通常我们将存储这些内容的时间设置为较长的时间，这样浏览器是不会向服务器反复发起请求，也不会去检查是否更新了。 添加自定义网络拦截器，在其中改变Response的响应头，添加Cache-control，后续回到CacheIntercepter中时，就会执行缓存策略。 CacheControl.Builder 12345678- noCache();//不使用缓存，用网络请求- noStore();//不使用缓存，也不存储缓存- onlyIfCached();//只使用缓存- noTransform();//禁止转码- maxAge(10, TimeUnit.MILLISECONDS);//设置超时时间为10ms。- maxStale(10, TimeUnit.SECONDS);//超时之外的超时时间为10s- minFresh(10, TimeUnit.SECONDS);//超时时间为当前时间加上10秒钟。 CacheStrategy：缓存策略类，通过响应头信息与服务器端信息进行对比，最后返回是否使用新的网络请求还是直接使用缓存。其中存储的是Request请求体和Response响应体的具体内容 1234567/** 如果不使用网络，则 networkRequest为 null *///客户端请求public final @Nullable Request networkRequest;/** 如果不使用缓存，则 cacheResponse为 null *///服务端返回public final @Nullable Response cacheResponse; 根据输出的networkRequest和cacheResponse的值是否为null给出不同的策略，如下： networkRequest cacheResponse result 结果 null(不使用网络) null（不使用缓存） only-if-cached (表明不进行网络请求，且缓存不存在或者过期，一定会返回503错误) null non-null 不进行网络请求，直接返回缓存，不请求网络 non-null null 需要进行网络请求，而且缓存不存在或者过去，直接访问网络 non-null non-null Header中包含ETag/Last-Modified标签，需要在满足条件下请求，还是需要访问网络（根据情况使用） 如果网络不为null，则使用网络请求，如果网络为null，当缓存不为null，则使用缓存，当缓存为null时，返回503错误 为什么只做get的缓存？其他响应成本大，效率低 线程池okhttp其中有一个dispatcher对最大连接数（并发），host最大访问量做了定义，维护了3个队列（同步正在执行，准备执行，异步正在执行）和一个线程池（0~max） 该线程池类似于CachedThreadPool，没有核心线程，全是非核心线程，超时时间是60s，即60s后回收该线程，其队列为空，没有容量，是一种特殊的队列，适用于执行短时的大量任务。 okhttp的优势？最大特点是，intercepter拦截器，连接池复用，okio io处理，线程池处理（全是非核心线程），支持http1.0，1.1，2.0 okio内部封装链表数据存储，比较之前的数组存储，更加节省空间，还可以复用 长连接（websocket）和久连接（keep-alive）的区别调用的是equeue异步方法，将长连接放入线程池中不会被释放掉 1.1推出keep-alive机制，服务器不会主动发送请求，一个request返回一个response。 减少了握手的次数而已 久连接是同步串行处理的，当某一个请求因为网络，服务器等原因阻塞时，那么后面的请求都得不到处理 http头部太大，传输耗时 实时性得不到保证 http是单向的，websocket属于应用层协议，使用http1.1的101码进行握手状态判断 websocket建立连接是使用https连接，三次握手，在通信过程中 以ws开头 握手成功后，复用连接发送请求和接收 不需要发送header信息 服务端客户端平等，可以相互建立连接，http久连接是基于http的，符合http协议。 最开始使用get请求进行握手，携带Upgrade: websocket ，告知服务器上升为websocket协议，成功后，使用web socket数据流（帧）进行通信，设置超时时间为永不超时，客户端设置循环，一直从服务端取消息。 使用http的get请求进行3次握手协议，使用http1.1版本的101状态码返回成功后，就不需要http交互了，后续采用web socket流进行通信，减少包体 使用标准的HTTP协议无法实现WebSocket，只有支持那些协议的专门浏览器才能正常工作。 websocket的握手和http的握手有什么区别？使用http的get请求进行握手，基本一致，额外传输了header的信息标记为websocket。 MQTT理解发布订阅者模式，低带宽，低开销的即时通信协议，基于tcp/ip协议，成为IOT通讯标准 消息体如下：固定头部+可变头部+消息体，整个消息体比较轻便，便于交互及时 固定报头（fixed header） 可变报头（variable header） 荷载（payload） 所有报文都包含，数据包类型及数据包的分组类标识 部分报文包含，数据包类型决定了可变头是否存在及其具体内容 部分报文包含，表示客户端收到的具体内容 基于二进制实现，MQTT运行于http上，所以明文传输，如果位于https中，则可以使用TLS加密传输 发布者，订阅者模式：客户端是发布者和订阅者，服务端是代理服务器 MQTT和websocket的区别？MQTT面向原生设备，基于二进制实现，提供一对多的通信方式，采用发布/订阅模式传输 websocket面向web设备，是全双工通信 Retrofit简述基于Okhttp的RESTFUL Api请求工具，Retrofit可以让你简单到调用一个Java方法的方式去请求一个api，这样App中的代码就会很简洁方便阅读 Retrofit通过java接口及注解来描述网络请求，并用动态代理的方式生成网络请求的Request，通过调用相应的网络框架（默认Okhttp）去发起网络请求，并将返回的Response通过converterFactory转化成相应的model，最后通过CallAdapter转换成其他的数据方式（Rxjava Observable） Retrofit.create()方法是Retrofit的核心，其中，使用Proxy.newProxyInstance()方法创建ServiceMethod，具体实现是在InvocationHandler类中的invoke方法，实现了动态代理的形式，而这个InvocationHandler对象就是代理对象，这个对象是在运行时动态生成的。 Retrofit中的动态代理123456789101112public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; ... return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; ... ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 通过动态代理生成InvocationHandler类，在内部，创建一个ServiceMethod，存储接口的请求信息，构建一个OKhttpCall对象，初始化网络请求 Retrofit的优势Retrofit是对okhttp的二次封装，解决okhttp中接口请求、数据结果返回和接口调用的短板。 规划了interface接口类，整合所有接口调用的详细内容，便于调用，降低耦合性。 配合RxJava，okhttp，职责明确。RxJava负责异步处理，Retrofit负责请求的数据和结果的展示，okhttp负责接口请求和返回的具体过程 Retrofit主要负责应用层面的封装，就是说主要面向开发者，方便使用，比如请求参数，响应数据的处理，错误处理等等。 OkHttp主要负责socket部分的优化，比如多路复用，buffer缓存，数据压缩等等。 相对于okhttp来说，使用动态代理生成Request对象，不用每次调用自己实现 网络结果线程切换库（RxJava，普通），网络结果格式化库（Gson，xml）等可以做到随意替换和支持 动态代理和静态代理的区别静态代理：由程序员创建或工具生成的代理类，在运行前就存在代理类的字节码文件，代理类和委托类的关系已经确定 动态代理：在程序运行过程中，通过反射实现对代理类的动态创建，可以代理多个方法。（InvocationHandler、CGLib） Butterknife———view的注入简述Butterknife初始化控件会写大量的findViewById()，setOnClickListener()方法，很繁琐，该框架使用注解的方式实现辅助代码的生成，简化这些代码。 该框架是基于java注解机制实现的，也就是在编译期间就初始化好了一个viewBinding类（view和点击事件的处理），生成findViewById来绑定布局，不用开发者每次去初始化 Butterknife为什么初始化控件不能用private和static因为在编译期间构建view的绑定事件会报错，无法访问private变量，否则，要加入反射，导致性能问题 static可能会导致内存泄漏，而且外部可以访问。 ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么解析注解处理器， 对比Butterknife，Dagger2，DBFlow。 没有反射机制，使用自定义注解框架 继承问题butterknife继承后，子类可以使用父类控件，但是必须在setContView之后进行绑定。如果在子view进行绑定控件，但是父类找不到子类的控件，因为生成的是子view_ViewBinding类，父类获取不到 缺点 每个Activity会生成一个类，增大包体积 butterknife可以称之为view的注入，对findviewById包装更加简单，功能单一 ViewBinding最终最好的解决方案简析ViewBinding在build.gradle中开启ViewBinding1234android &#123; //... viewBinding.enabled = true&#125; android studio会将xml文件中所有文件在编译过程中生成xxxBinding类，这个类有三种初始化方法1binding = LayoutSecondBinding.inflate(getLayoutInflater());在Activity或Fragment中调用inflate方法进行初始化123inflate(LayoutInflater inflater)inflate(LayoutInflater inflater,ViewGroup parent,boolean attachToParent)bind(View rootView)最终三个方法都会走到bind方法中，在这个方法中，对View进行findViewById操作 ViewBinding和Butterknife的区别ViewBinding会处理空安全，类型安全，还可以兼容java和kotlin。最新版本Gradle中设置对R文件的修改，R文件中的id不再是final的，(Fragment中R文件不是final的时候，Butterknife使用生成R2文件的做法围魏救赵)这样就会影响注解的使用，butterknife就被迫下台Viewbinding根正苗红，官方支持就是最大优势 Viewbinding如何处理include布局？xml布局中存在include布局的，需要给include布局添加id，生成一个includexxxBinding文件，在xxxBinding类中做映射体现。 内部view由final修饰，保证view不能被重新创建的view替换（引用不可修改），但是其内部的值可以修改 注解原理简析元注解：修饰注解的注解， @Target：注解的作用目标（修饰方法，类还是字段） @Retention：注解的生命周期 SOURCE：仅存在java源文件中，经过编译器后就丢弃，适用于一些检查行的操作，比如@Override CLASS：编译class文件时生效，适用于在编译时做一些预处理操作，比如Butterknife的@BindView，在编译时，通过注解器生成一些辅助代码，完成完整的功能 RUNTIME：保留在运行时VM中可以通过反射获取注解。适用于一些需要运行时动态获取注解信息，类似反射获取注解等，比如EventBus的@Subscribe @Documented：注解是否应当被包含在JavaDoc文档中 @Inherited：是否允许子类继承该注解 AnnotationInvocationHandler：专门处理注解的Handler 代码的生命周期包含：编码(SOURCE)—-&gt;编译(CLASS)—-&gt;运行(RUNTIME) 默认时注解在编译阶段，即CLASS阶段 本质：一个继承了Annotation接口的接口 运行时处理：使用反射获取当前的所需要的东西 编译时处理：APT技术，即编译期扫描java文件的注解，并传递到注解处理器，注解处理器可根据注解生成新的java文件 APT(Annotation Processing Tool)编译期解析注解 注解的种类 JDK提供的注解（源码注解） 自定义注解 元注解 注解的用处 降低项目的耦合 自动完成一些规律性代码 自动生成java代码，减少开发工作量 注解器注解器通常是以Java代码（或者编译过的字节码）作为输入，生成.java文件作为输出 AbstractProcessor 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 源于javax.annotation.processing;public abstract class AbstractProcessor implements Processor &#123; // 集合中指定支持的注解类型的名称（这里必须时完整的包名+类名) public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; SupportedAnnotationTypes sat = this.getClass().getAnnotation(SupportedAnnotationTypes.class); if (sat == null) &#123; if (isInitialized()) processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, &quot;No SupportedAnnotationTypes annotation &quot; + &quot;found on &quot; + this.getClass().getName() + &quot;, returning an empty set.&quot;); return Collections.emptySet(); &#125; else return arrayToSet(sat.value()); &#125; // 指定当前正在使用的Java版本 public SourceVersion getSupportedSourceVersion() &#123; SupportedSourceVersion ssv = this.getClass().getAnnotation(SupportedSourceVersion.class); SourceVersion sv = null; if (ssv == null) &#123; sv = SourceVersion.RELEASE_6; if (isInitialized()) processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, &quot;No SupportedSourceVersion annotation &quot; + &quot;found on &quot; + this.getClass().getName() + &quot;, returning &quot; + sv + &quot;.&quot;); &#125; else sv = ssv.value(); return sv; &#125; // 初始化处理器 public synchronized void init(ProcessingEnvironment processingEnv) &#123; if (initialized) throw new IllegalStateException(&quot;Cannot call init more than once.&quot;); Objects.requireNonNull(processingEnv, &quot;Tool provided null ProcessingEnvironment&quot;); this.processingEnv = processingEnv; initialized = true; &#125; /** * 这些注解是否由此 Processor 处理，该方法返回ture表示该注解已经被处理, 后续不会再有其他处理器处理; 返回false表示仍可被其他处理器处理 */ public abstract boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv);&#125; 自定义注解如果是单一属性，可以使用value字段 1234567891011@interface MyAnno1 &#123; //格式：类型名 属性名（） String value();&#125;@MyAnno1(&quot;kang&quot;)@interface MyAnno2 &#123; //格式：类型名 属性名（） String name();&#125;@MyAnno2(name = &quot;kang&quot;) 如果不是value字段的话，需要（指定属性 = 值） 注解中只允许八种基本数据类型、字符串、类类型，注解类型，枚举类型及其一维数组 Glide和Picasso简述LruCache和DiskLruCache内部都实现了LRU算法，即：优先淘汰那些最近最少使用的缓存对象 LruCache： 内部采用LinkedHashMap，是线程安全的（get、put、remove方法都是用synchronized），双向链表（保持LinkedList规定顺序+HashMap便于查找）将最近使用的节点放置在链表尾部，当超过大小时，删除第一个头节点。 存储了前一个元素和后一个元素的引用，get方法后，就查出值删除，然后放置在头部，如果超过Lru算法的大小，直接遍历删除尾节点，直到大小在范围内 简述Glide的缓存过程默认打开缓存，内存缓存使用LruCache+弱引用实现，磁盘缓存使用DiskLruCache实现 使用内存缓存+磁盘缓存的策略，生成key时，图片只要发生变化，就算长宽发生变化也会导致缓存不同的key。Glide将内存缓存划分为两个区域： LruResourceCache：使用LruCache算法，LinkedHashMap（不在使用的） activeResources：添加弱引用机制，HashMap（正在使用的图片） 磁盘缓存之存在DiskLruCache，因为Glide可以压缩图片（尺寸压缩），所以磁盘缓存中可以设置缓存原始图片还是压缩后的图片，压缩图片可以有效避免大图和超大图带来的OOM，Glide没有使用google提供的DiskLruCache，而是使用自己开发的，不过原理都一样 在首次访问时，将正在使用的图片信息会存储在activeResources的弱引用中，当引用次数为0时（调用release方法），会将其放入LruResourceCache中，执行Lru算法，移除后会存入DiskLruCache中。 所以，先去activeResources中寻找，找到后，将引用对象索引+1（active.aquire();）（计算引用次数）。然后去LruResourceCache中寻找了，若找到了，在LruResourceCache中移除，并将其放入activeResources中。然后去DiskLruCache中寻找，若找到了，在DiskLruCache中删除，并将其放入activeResources中。 Glide 缓存的是imageView的所需图片的大小，若大小不同，重新缓存 Picasse 缓存图片原图大小 Glide是如何绑定生命周期的？ Application参数:如果传入的是Application对象,那么这里就会调用带有Context参数的get()方法重载，调用getApplicationManager()方法来获取一个RequestManager对象。其实这是最简单的一种情况，因为Application对象的生命周期即应用程序的生命周期，因此Glide并不需要做什么特殊的处理，它自动就是和应用程序的生命周期是同步的，如果应用程序关闭的话，Glide的加载也会同时终止。 非Application参数:不管传入的是Activity、FragmentActivity、v4包下的Fragment、还是app包下的Fragment，最终的流程都是一样的，那就是会向当前的Activity当中添加一个隐藏的Fragment。因为Glide需要知道加载的生命周期。很简单的一个道理，如果你在某个Activity上正在加载着一张图片，结果图片还没加载出来，Activity就被用户关掉了，那么图片还应该继续加载吗？当然不应该。可是Glide并没有办法知道Activity的生命周期，于是Glide就使用了添加隐藏Fragment的这种小技巧，因为Fragment的生命周期和Activity是同步的，如果Activity被销毁了，Fragment是可以监听到的，这样Glide就可以捕获这个事件并停止图片加载了。 如果我们是在非主线程当中使用的Glide，那么不管你是传入的Activity还是Fragment，都会被强制当成Application来处理。 RequestManagerFragment：实现一个无UI的fragment。 ActivityFragmentLifecycle：无UI的fragment通过它，去调用RequestManager RequestManager：实现关键的几个方法，去调用glide 的操作 RequestManagerRetriever：作为一个桥梁，将RequestManagerFragment和RequestManager给联系起来 空RequestManagerFragment 的生命周期调用 ActivityFragmentLifecycle，然后ActivityFragmentLifecycle 调用 RequestManager ，RequestManager 再去调用RequestTracker 的glide操作，最终实现gilde的操作，能够根据页面的生命周期做相应的处理。 Glide中Fragment中是怎么绑定生命周期的？Glide中into指定view，再次刷新view会发生什么？ Glide内部通过HttpUrlConnection进行通信，也可切换为okhttp/volley 根据ScaleType进行相应的设置 根据传入的类型对Glide加载进行配置，asBitmap，asGif，asDrawable 根据target（View）创建Request请求，根据生命周期管控Request的暂停和下载 target就是view，先判断target是之前已经绑定了请求，如果旧请求和新请求一样且处于请求完成或者正在请求状态就直接复用旧请求。如果不复用,就RequestManager先移除和旧请求绑定的target对象，Target再重新和Request对象进行一个绑定，调用requestManager.track(target, request)再加入请求队列，开启请求，最后返回经过处理的traget对象。 Glide和Picasso对比 Glide较Picasso庞大的多 Glide绑定生命周期，onPause时暂停加载，onResume时再启动，Picasso只存在context Glide会缓存imageView图片大小，尺寸不同，key不同，会缓存两份，Picasso是缓存完整大小，使用时会重新设置大小 Glide首次加载快于Picasso，而后每次加载慢于Picasso，因为Glide需要改变图片的大小再缓存到内存，时间会慢。picasso拿到缓存后需要对图片重新设置大小，耗时较长。 Glide支持gif Glide加载的图片质量略差，因为bitmap的格式内存开销小，但是很难察觉 Glide可以配置图片显示的动画，而picasso只有默认的一种动画 Glide缓存方式更优，减少OOM的发生 Glide：RGB565Picasso：ARGB8888 Picasso缓存机制：LruCache，DiskLruCache 内存缓存占用一个app的15%内存 网络请求使用的okhttp，内部缓存也使用okhttp，一般大小不超过50M 网络机制：network Fresco比较缓存机制： BitmapMemoryCache缓存，已解码的内存缓存 EncodedMemoryCache缓存， CountingLruMap，Lru算法清除缓存 分层处理，producer层层处理，每层处理结果通过Consumer向上传递，Producer-consumer链 从已编码缓存中获取bitmap缓存 从未编码缓存中获取EncodedImage类型 从磁盘中获取 从网络中获取 DraweeView： 动图播放，多级图层，渐进显示，画面剪裁 解码器优化，避免频繁解码导致内存抖动，使用pool内存池复用 适合各个android版本的解码器 优点： 内存管理，LRU算法，缓存和磁盘管理 加载大图和高清图时可以先加载低清晰度图和缩略图 加载gif 图片渐进式处理：，渐进式图片格式先呈现大致的图片轮廓，然后随着图片下载的继续，呈现逐渐清晰的图片 包体积Fresco&gt;Glide&gt;Picasso LeakCanary检测内存泄漏 ActivityLifecycleCallbacks 与 FragmentLifeCycleCallbacks通过application.registerActivityLifecyleCallbacks获取Activity的生命周期 通过fragmentManager.registerFragmentLifecyleCallbacks获取Fragment的生命周期 注册接口，拿到Activity和Fragment的各种生命周期回调信息 如何做到内存泄漏检测Activity在onDestory后会将Activity生成一个唯一的key后存储在弱引用队列中，在主线程空闲时（IdleHandler）触发gc机制，垃圾回收，整理弱引用队列，查看弱引用队列中没有被回收的对象，即是内存泄漏的对象，打印出栈堆信息以供分析dump 缺陷只能监听Activity和Fragment的内存泄漏检测，无法检测Service 其他内存泄漏检测工具Profiler：android studio自带，可以查看内存的整体过程，分析是否发生内存泄漏 ASM函数插桩简述简析为字节码插桩，可以直接修改已经存在的class文件或者生成class文件，相比较于AspectJ，ASM更加偏向于底层，他是直接操作字节码的，在设计中更小，更快 class文件本质是16进制数据 ClassVisitor MethodVistor Android基础篇Application简述Application作用：做初始化工作，提供上下文。继承自ContextWarpper，获取的是ContextWrapper中的context对象 一个应用中有且只有一个 其生命周期和应用程序一样长 Application的onCreate方法才是整个应用程序的入口 只会实例化一次，所以天生就是一个单例 生命周期： onCreate：创建时执行 onTerminate：终止时执行 onLowMemory：低内存时执行 Application的初始化流程通过AMS协调，ActivityThread优先建立后，会新建一个ApplicationThread，用作和AMS通过Binder通信，之后AMS通知ActivityThread去bindApplication，将消息返送到messageQueue，进行初始化Application的任务，然后调用attachBaseContext将Context绑定到Application，最后调用Application.onCreate()方法进行后续Activity的初始化 AMS 来通知 zygote 进程来 fork 一个新进程，来开启我们的目标 App 的 ActivityLifecycleCallbacks理解ActivityLifecycleCallback是Application中的一个接口，可以监听应用中所有Activity的生命周期，可以通过该方法完成一些特殊的需求，比如监测当前App显示的Activity是那个？App是否存在前台 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyApplication extends Application &#123; private ActivityLifecycleCallbacks activityLifecycleCallbacks = new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(@NonNull Activity activity, @Nullable Bundle savedInstanceState) &#123; &#125; @Override public void onActivityStarted(@NonNull Activity activity) &#123; &#125; @Override public void onActivityResumed(@NonNull Activity activity) &#123; &#125; @Override public void onActivityPaused(@NonNull Activity activity) &#123; &#125; @Override public void onActivityStopped(@NonNull Activity activity) &#123; &#125; @Override public void onActivitySaveInstanceState(@NonNull Activity activity, @NonNull Bundle outState) &#123; &#125; @Override public void onActivityDestroyed(@NonNull Activity activity) &#123; &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); // 注册Callback registerActivityLifecycleCallbacks(callbacks); &#125;&#125; Activity简述生命周期 Activity： onCreate() 正在被创建 onRestart() 不可见到可见 onStart() Activity正在启动，已经可见了 onResume() Acitivty已经可见，并在前台显示 onPause() Acitivty正在停止，之后会不可见 onStop() Activity即将停止 onDestory() Activity被销毁 onStart和onResume都为可见，onStart不在前台显示，onResume在前台显示 onPause后已经不可见，会进入onResume或者另一个onResume，所以不能做耗时操作，会影响界面显示 onPause和onStop中不能太耗时 如果新的Activity采用了透明主题，那么当前Activity不会回调onStop onStart和onStop对应Activity是否可见 onResume和onPause对应Activity是否在前台显示 异常情况下会执行onSaveInstance方法进行数据保存 简述启动模式 standard：标准模式，来一个添加一个 singleTop：栈顶复用，如果在栈顶，就复用这个Activity，onNewIntent会被执行，替代onCreate() singleTask：栈内复用，如果在栈内，就复用这个Activity，该Activity之上的全部出栈，onNewIntent会被执行 singleInstance：单实例模式。加强版singleTask，会为自己新建一个栈，在该栈中栈内复用 LauncherMode和startActivityForResult 在5.0之前，当启动一个Activity时，系统将首先检查Activity的launchMode，如果为A页面设置为SingleInstance或者B页面设置为singleTask或者singleInstance,则会在LaunchFlags中加入FLAG_ACTIVITY_NEW_TASK标志，而如果含有FLAG_ACTIVITY_NEW_TASK标志的话，onActivityResult将会立即接收到一个cancle的信息，而5.0之后这个方法做了修改，修改之后即便启动的页面设置launchMode为singleTask或singleInstance，onActivityResult依旧可以正常工作，也就是说无论设置哪种启动方式，StartActivityForResult和onActivityResult()这一组合都是有效的 什么时候会启动一个新的Activity栈？ allowTaskReparenting： singleInstance单独使用，会新建一个栈 singleTask配合taskAffinity使用 taskAffinity配合Intent.FLAG_ACTIVITY_NEW_TASK修饰Activity（AMS先处理LauncherMode，在处理FLAG_ACTIVITY_NEW_TASK） taskAffinity配合allowTaskReparenting属性，使Activity从启动栈移动到正在使用的栈中并显示出来 如何控制Activity的动画切换 通过overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_left)方法控制再startActivity方法后或者finish方法之后调用即可生效 使用style定义切换动画 如何控制Fragment的动画切换123456FragmentTransaction fragmentTransaction = mFragmentManager .beginTransaction();fragmentTransaction.setCustomAnimations( R.anim.in_from_right, R.anim.out_to_left); 使用FragmentTransaction开启Fragment动画，设置自定义动画切换，进入动画和推出动画 ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？ActivityA跳转到ActivityB：onPauseA()—–&gt;onCreateB()—–&gt;onStartB()—–&gt;onResumeB()—–&gt;onStopA() ActivityB按back键返回ActivityA： onPauseB()—–&gt;onRestartA()—–&gt;onStartA()—–&gt;onResumeA()—–&gt;onStopB()—–&gt;onDestoryB() 如果ActivityB是窗口Activity呢？ActivityA跳转到ActivityB：onPauseA()—–&gt;onCreateB()—–&gt;onStartB()—–&gt;onResumeB() ActivityB按back键返回ActivityA：onPauseB()—–&gt;onResumeA()—–&gt;onStopB()—–&gt;onDestoryB() Activity的生命周期会受Dialog影响吗？不会，Activity生命周期不会随Dialog的显示而变化 Activity的生命周期受AMS调用，而dialog不是Activity，所以不受AMS控制，所以不会触发Activity的生命周期 ServiceService有几种创建方式？有什么区别？ startService()，在不需要的时候stopService() bindService()，与生命周期相绑定，在销毁的时候进行回收unbind() 如何理解IntentService？生命周期是什么？HandlerThread 是什么？intentService继承自Service，持有Service的功能，同时，他是一个处理异步操作的类，当异步执行结束后会自动关闭intentService，多次执行startService()，只是执行onStartCommand方法，将消息加入到消息队列中。 其本质就是启动了一个类似于主线程Handler的机制去维护异步操作。 生命周期：onStartCommand()中执行onStart()方法，在onstart()方法中添加handler.sendMessage()方法 HandlerThread：就是将Handler+looper进行封装，允许直接在子线程中使用handler的一套逻辑。 IntentService更像是一个后台线程，但是他又是一个服务，不容易被回收，这是他的优点 JobIntentService是IntentService的子类，在android 8.0（26）以上，IntentService的所有后台执行任务都会受到限制约束，所以要使用JobIntentService。 service不能使用后台服务，需要使用ContextCompat.startForegroundService启动前台服务，这样就会启动一个notification，对用户来说体验不是很好，所以就要使用JobIntentService启动一个后台服务 在使用JobIntentService的时候不需要startService，stopService，在需要的时候调用1DownLoadJobIntentService.enqueueWork(MainActivity.this,DownLoadJobIntentService.class,jobId(8),intent);而后会执行onHandleWork方法中的逻辑，执行完毕后自动销毁 onStartCommand中三个回调分别是什么？ START_NOT_STICKY：Service被回收后不做处理 START_STICKY：Service在被回收后，重新创建Service，但是不保存intent START_REDELIVER_INTENT：Service在被回收后，重新创建Service，保存intent START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但不保证服务被kill后一定能重启。 Service保活 设置成前台服务，绑定Notification， startForeground(1, getNotification()); 单独设置为服务进程 onStartCommand返回START_STICKY，START_REDELIVER_INTENT，保证服务被干掉后重启 在onDestory发送一个广播，广播接收器接收广播后拉起服务 添加系统广播拉起 提升服务的优先级 Fragment生命周期 FragmentPagerAdapter和FragmentStatePagerAdapter的区别？FragmentPagerAdapter：切换页面只是将Fragment分离，适合Fragment较少的情况不影响内存 FragmentStatePagerAdapter：切换页面将Fragment回收，适合Fragment较多的情况，这样不会消耗太多内存资源 Fragment的3种切换方式 add方法：只是重新回到fragment replace方法：每次都会重新构建fragment 为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？Fragment在异常崩溃后重建时，默认会调用Fragment无参构造，这样会导致Fragment中的有参构造的值不会被执行，这样数据就会异常 Fragment中调用setArguments来传递参数，在Activity构造Fragment时会通过反射午餐构造实例化一个新的Fragment，并且给mArguments初始化为原先的值 Fragment的重建在那个生命周期中？在FragmentActivity的onSaveInstanceState中做存储，将Framgent通过序列化Parcelable进行存储，在Activity的onCreate中进行恢复 当配置发生变化时，Activity进入销毁过程，FragmentManager先销毁队列中Fragment的视图，然后检查每个Fragment的retainInstance属性。如果retainInstance为false，FragmentManager会销毁该Fragment实例；如果retainInstance为true，则不会销毁该Fragment实例，Activity重建后，新的FragmentManager会找到保留的Fragment并为其创建视图。 BroadCastReceiver简述广播的启动方式和区别 静态注册：在AndroidManifest中注册，常驻型广播 动态注册：使用intentFilter过滤广播，registerReceiver注册广播，跟随生命周期 Android8.0以上部分广播不允许静态注册 无序广播和有序广播的区别 无序广播：所有广播接收器都可以获得，不可以拦截，不可以修改 有序广播：按照优先级向下传递，可拦截广播，修改广播 本地广播和全局广播本地广播接收器只接收本地广播，减少应用外广播干扰，高效androidx中1.1.0-alpha01中弃用本地广播，官方推荐该用LiveData或响应式流 IPC机制简述android中的IPC机制进程间通信 架构：Client/Server架构，Binder机制，之间通过代理接口通信 client，server，serverManager AndroidManifest中指定Android:process属性 包名:remote为应用私有进程，其他应用不可访问 包名.remote为全局进程，其他应好通过ShareUID可以和他跑在同一个进程 多进程带来的问题：四大组件共享数据失败，每个进程会单独开辟内存空间存储信息 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPreferences可靠性下降，不支持多进程 Application会多次创建 Serializable和parcelable区别serializable:java自带，反射后产生大量临时变量，容易引起gc，主要用于持久化存储和网络传输的序列化 parcelable:android专用，性能强，将完整对象分解为部分对象，每一部分进行intent传输，可用于ipc，内部实现Bundle，主要用于内存的序列化 Android为什么引入Parcelable？ serializable通过反射，性能不好， serializable反射产生大量临时变量，容易gc，导致内存抖动 serializable使用了大量的IO操作，也影响了耗时 parcelable使用复杂，但高效，适用于内存序列化 Parcelable一定比Serializable快吗？单论内存中的传输速度，Parcelable一定快于Serializable，但是Parcelable没有缓存的概念Serializable存在缓存，会将解析过的内容放置在HandleTable，下次解析到同一类型的对象时就可以直接复用 为什么java使用Serializable序列化对象，而不是json或者xml？因为历史遗留问题，在json和xml出来之前，java已经设计了Serializable，对于Java的庞大体系，并不容易修改这个问题。java官方文档也推荐使用json库，因为他简单、易读、高效 简析Binder机制 在Android通信中并不是所有的进程通信都使用Binder，当fork()进程时，使用的是Socket()通信，因为fork不允许多线程，Binder是多线程模式，所以不被允许 进程空间划分一个进程空间分为用户空间和内核空间 用户空间：数据独享，其他进程无法访问 内核空间：数据共享，其他进程可以访问 所有的进程共用1个内核空间 如何看待ServiceManager？ServiceManager管理系统中所有的服务，服务需要使用时都要在ServiceManager中进行注册，他的存在类似于DNS，提供client访问某一个服务的查询。 Binder原理binder驱动属于进程中的内核空间，即共享空间，在client发起请求时，需要将数据从用户空间拷贝到内核空间，binder通过传输内核空间中数据存储的引用映射给服务端，供服务端调用，服务端处理后，将返回值放在内核空间，通过binder传递引用映射给客户端进行处理 简述通信流程总体通信流程就是： 客户端通过代理对象向服务器发送请求。 代理对象通过Binder驱动发送到服务器进程 服务器进程处理请求，并通过Binder驱动返回处理结果给代理对象 代理对象将结果返回给客户端。 详细的通信过程 服务端跨进程的类都要继承Binder类，所以也就是服务端对应的Binder实体。这个类并不是实际真实的远程Binder对象，而是一个Binder引用(即服务端的类引用)，会在Binder驱动里还要做一次映射。 客户端要调用远程对象函数时，只需把数据写入到Parcel，在调用所持有的Binder引用的transact()函数 transact函数执行过程中会把参数、标识符（标记远程对象及其函数）等数据放入到Client的共享内存，Binder驱动从Client的共享内存中读取数据，根据这些数据找到对应的远程进程的共享内存。 然后把数据拷贝到远程进程的共享内存中，并通知远程进程执行onTransact()函数，这个函数也是属于Binder类。 远程进程Binder对象执行完成后，将得到的写入自己的共享内存中，Binder驱动再将远程进程的共享内存数据拷贝到客户端的共享内存，并唤醒客户端线程。 通过Binder将客户端，服务端的共享内存中的数据进行读写，放入对方的共享内存中，并通知。 Binder在Android中的应用？ 系统服务及四大组件的启动调用工作：系统服务是通过getSystemService获取的服务，内部也就是通过ServiceManager。例如四大组件的启动调度等工作，就是通过Binder机制传递给ActivityManagerService，再反馈给Zygote。而我们自己平时应用中获取服务也是通过getSystemService(getApplication().WINDOW_SERVICE)代码获取。 AIDL（Android Interface definition language）。例如我们定义一个IServer.aidl文件，aidl工具会自动生成一个IServer.java的java接口类（包含Stub，Proxy等内部类）。 前台进程通过bindService绑定后台服务进程时，onServiceConnected(ComponentName name, IBinder service)传回IBinder对象，并且可以通过IServer.Stub.asInterface(service)获取IServer的内部类Proxy的对象，其实现了IServer接口。 为什么选择Binder机制？他的优势是什么？ 性能高，效率高：传统的IPC（socket，管道，消息队列）需要拷贝两次内存，Binder只需要拷贝一次内存、共享内存不需要拷贝数据，只需要传递引用 安全性好：C/S通信添加UID/PID，方便验证，安全机制完善。 利用C/S架构，通过多线程控制一个服务端多个客户端的情况 Android中IPC的几种方式详细分析与优缺点分析 Bundle 文件共享 Messenger：内部实现AIDL机制，c/s架构，通过handler接收message对象 AIDL ContentProvider Binder连接池 HandlerAndroid Handler机制之总目录 Android面试题：Handler 其实并不是每一次添加消息时，都会唤醒线程。当该消息插入到队列头时，会唤醒该线程；如果有延迟消息，插入到头部，也会唤醒线程后在休眠 一句话概括Handler，并简述其原理android中用于主线程和子线程之间通信的工具 主要包含Handler,Looper,MessageQueue,ThreadLocal. Handler：封装了消息的发送和接收looper分发过来的Message Looper：协调Handler和MessageQueue之间的桥梁，Looper的作用是循环从MessageQueue中取出message，并分发 给相应的Handler，Handler则存储在Message中的target中 message：单节点，存储handler传输的数据 MessageQueue：内部结构为单链表，由Looper创建，具体代码为Looper.prepare()；先进先出原则(队列)，根据 Message.when进行插入队列（队列中是按时间执行顺序排序） ThreadLocal：负责存储和获取本线程的Looper handler.sendMessage(message)将message发送到MessageQueue，MessageQueue执行enqueueMessage()方法入队，Looper执行looper.loop()方法从MessageQueue中取出message，执行message.target.dispatchMessage(message)方法将消息发送到Handler中，在handleMessage()方法中拿到回调 Looper.loop()是在主线程的死循环，为什么没有造成线程阻塞？真正的ANR是在生命周期的回调中等待的时间过长导致的，深层次的讲，就是Looper.loop()没有及时取出消息进行分发导致的。一旦没有消息，Linux的epoll机制则会通过管道写文件描述符的方式来对主线程进行唤醒与沉睡，Android里调用了linux层的代码实现在适当时会睡眠主线程。 MessageQueue包含jni调用，无消息时，通知epoll休眠，来消息时，线程启动 looper.loop()中循环，判空退出怎么理解？12345678public static void loop() &#123; .... for (;;) &#123; Message msg = queue.next(); // might block（可能会阻塞） if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; 在queue.next中，会通过jni调用，通过Linux的epoll机制则会通过管道写文件描述符的方式来对主线程进行唤醒与沉睡，只有当应用程序退出时，才会执行if语句退出循环。 为什么不能在子线程更新UI？因为如果要在子线程中更新UI，势必要考虑线程安全，加锁机制，这样很耗时，不加锁又很容易发生错误，这些错误是致命的，所以在设计时只允许UI线程更新UI，避免这些错误。 真的不能在子线程更新UI吗？ViewRootImpl中会进行通过checkThread()进行线程检测 12345678910111213public ViewRootImpl(Context context, Display display) &#123; ...... mThread = Thread.currentThread(); ......&#125;......void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); &#125; &#125; 由此得出：viewRootImpl在那个线程被初始化，就会在那个线程更新UI，大部分情况下，ViewRootImpl都是在UI线程中初始化的，所以只能在UI线程更新UI，部分情况下可以在子线程更新UI（比如Dialog是在addView中初始化ViewRootImpl） SurfaceView可以在子线程中更新 ViewRootImpl是什么时候被创建的？在Acitivty中，ViewRootImpl是在onResume中创建的，所以在onCreate中进行子线程更新是可以绕过checkThread()检测的。 一个Thread中可以有几个Looper?几个Handler一个Thread中只有一个Looper，可以存在无数个Handler，但是使用MessageQueue都是同一个，也就是一个Looper 可以在子线程直接new一个Handler吗？那该怎么做？123456789101112thread= new Thread()&#123; @Override public void run() &#123; super.run(); //创建Looper，Looper再创建MessageQueue Looper.prepare(); //新建Handler handler=new Handler(); //循环取出消息并执行 Looper.loop(); &#125; &#125;.start(); 需要创建Looper，Looper会创建MessageQueue，循环从MessageQueue中取消息。 Message可以如何创建？哪种效果更好，为什么？享元模式 数据重复利用 Message msg = new Message(); Message msg2 = Message.obtain(); Message msg1 = handler1.obtainMessage(); 2，3从整个Messge池中返回一个新的Message实例，通过obtainMessage能避免重复Message创建对象。 所以2，3都可以避免重复创建Message对象，所以建议用第二种或者第三种任何一个创建Message对象。 messge就是一个节点，存在就是一条链表，链表中存储的都是可以复用的message，在handleMessage和callback 方法执行完成后执行message.recycle()方法，进行信息重置后加入闲置链表头部中，每次调用obtain方法会从闲置链表中取出头节点，如果闲置链表为空，则新建message。 Message缓存池大小为50 使用Hanlder的postDelay()后消息队列会发生什么变化？postDelay()内部调用sendMessageDelayed() 1234567public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; 时间：SystemClock.uptimeMillis() + delayMillis SystemClock.uptimeMills()是从开机到现在的时间，不使用currentMills，因为其是可变的，uptimeMills()期间不包括休眠的时间，是一个相对时间 Handler.postDelayed(Runnable r, long delayMillis) Handler.sendMessageDelayed(getPostMessage(r), delayMillis) Handler.sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis) Handler.enqueueMessage(queue, msg, uptimeMillis) MessageQueue.enqueueMessage(msg, uptimeMillis) 消息入队的时候会根据when判断时间，最终按照时间大小排序，时间短的在链表头，时间长的在链表尾部。 案例如下： postDelay()一个10秒钟的Runnable A、消息进队，MessageQueue调用nativePollOnce()阻塞，Looper阻塞； 紧接着post()一个Runnable B、消息进队，判断现在A时间还没到、正在阻塞，把B插入消息队列的头部（A的前面），然后调用nativeWake()方法唤醒线程； MessageQueue.next()方法被唤醒后，重新开始读取消息链表，第一个消息B无延时，直接返回给Looper； Looper处理完这个消息再次调用next()方法，MessageQueue继续读取消息链表，第二个消息A还没到时间，计算一下剩余时间（假如还剩9秒）继续调用nativePollOnce()阻塞； 直到阻塞时间到或者下一次有Message进队； 同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？同步消息：handler默认无参构造的形式是同步消息 异步消息：async传入true，则为异步消息 屏障消息：msg.target == null，使用postSyncBarrier()方法打开同步屏障，导致同步消息不执行，优先执行异步消息，规则同同步消息一样，当执行完毕后关闭同步屏障。 应用场景：在view的更新过程中，draw，requestLayout、invalidate中都用到这个方法，系统会优先处理这些异步消息，等处理结束后再处理同步消息。这样可以优先处理我们指定的系统消息。 postSyncBarrier()该方法为私有方法，所以api不允许我们在开发中调用，我们只要知道原理就好了 调用该方法，会直接发送一个屏障消息进入messageQueue，则队列头部为屏障消息 ThreadLocal，谈谈你的理解跟HashMap功能类似，为什么不直接用HashMap呢？原因： HashMap太大了，太臃肿了。ThreadLocal的key值只有Thread，value为looper，而HashMap的key值则可以是string、int等数据类型，我们可以不用考虑这些数据类型; 线程隔离：我们的线程是系统中唯一的，用ThreadLocal来管理这些唯一的线程和其对应的value值会非常方便， ThreadLocal参照了HashMap,简化了HashMap,便于我们使用。 HashMap线程不安全 ThreadLocal的理解 为什么子线程中不能使用Handler，而UI线程可以？UI线程就是ActivityThread，他在初始化的时候创建了Looper,MessageQueue，所以可以直接使用Handler，而新创建的子线程没有创建Looper，所以创建了就可以使用了 Handler的构造方法中使用Looper.myLooper()获取了looper，但是在子线程中并没有looper Handler如何引起内存泄露？怎么解决？非静态内部类或匿名内部类默认持有外部类的引用，当外部类被回收时，因为内部类持有外部类的引用，导致外部类不能被回收，造成内存泄露。 Activity销毁时及时清理消息队列； 自定义静态Handler类+弱引用。 MessageQueue.next()会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？首先非延时消息会入队，并且插入链表头，这时唤醒线程，进行循环取出message，非延时消息出队，到延迟消息后，如果事件未到，触发next的阻塞机制，如果时间到了，取出message，执行消息 Handler延时机制保时吗？不保时 12345678910111213141516chatIflyHandler.post(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); chatIflyHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; Log.e(&quot;handler&quot;,&quot;执行延时1s操作&quot;); &#125; &#125;,1000); 首先一个非延时消息入队，紧接着一个延时消息入队，执行第一个非延时消息，用时3s后执行延时消息，对比when，然后直接执行，测试总共耗时3420ms Handler的入队机制是线程安全的（synchronized）12345messageQueue.equeue()&#123; synchronized(this)&#123; ...... &#125;&#125; 如何精确计时？ 使用timer（子线程处理TimerThread） 误差补偿算法(TextClock控件方法) 12345678910private final Runnable mTicker = new Runnable() &#123; public void run() &#123; onTimeChanged(); long now = SystemClock.uptimeMillis(); long next = now + (1000 - now % 1000); getHandler().postAtTime(mTicker, next); &#125; &#125;; 整秒数执行，当上次执行累积到1200，在下次执行时，通过next的计算后保证下次执行的时间不被累加到2200，而是同样在2000 IdleHandler是什么？用处是什么？messageQueue中有一个addIdleHandler()方法，添加IdleHandler接口 添加时messageQueue不为空，则在线程休眠（没有消息，延时消息）时回掉方法 添加时messageQueue为空，则当时不会触发回掉，当线程被唤醒时才会执行 就是在启用IdleHandler的时候，如果线程处于休眠状态，要等到下次休眠状态才会生效。如果不是休眠状态，则下一次休眠立即生效。 启用IdleHandler后，主线程下次休眠时会通知123456789Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123; @Override public boolean queueIdle() &#123; //do something return false; &#125; &#125;); 如果return true，则表示这个IdleHandler可多次使用如果return false，则表示这个IdleHandler只能使用一次 主线程的Looper何时退出？能否手动退出？在app退出或者异常终止时，会退出Looper。在正常退出时，ActivityThread主线程中的mH（Handler）会接收到回调信息，调用quit()方法，强制退出1234567//ActivityThread.javacase EXIT_APPLICATION: if (mInitialApplication != null) &#123; mInitialApplication.onTerminate(); &#125; Looper.myLooper().quit(); break; Looper.quit():调用后直接终止Looper，不在处理任何Message，所有尝试把Message放进消息队列的操作都会失败，比如Handler.sendMessage()会返回 false，但是存在不安全性，因为有可能有Message还在消息队列中没来的及处理就终止Looper了。 Looper.quitSafely():调用后会在所有消息都处理后再终止Looper，所有尝试把Message放进消息队列的操作也都会失败。 当尝试在主线程手动退出looper时，会报错：12345678910111213141516171819Caused by: java.lang.IllegalStateException: Main thread not allowed to quit. at android.os.MessageQueue.quit(MessageQueue.java:428) at android.os.Looper.quit(Looper.java:354) at com.jackie.testdialog.Test2Activity.onCreate(Test2Activity.java:29) at android.app.Activity.performCreate(Activity.java:7802) at android.app.Activity.performCreate(Activity.java:7791) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1299) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3245) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3409) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:83) at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2016) at android.os.Handler.dispatchMessage(Handler.java:107) at android.os.Looper.loop(Looper.java:214) at android.app.ActivityThread.main(ActivityThread.java:7356) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) 因为主线程退出意味着app的关闭，这种操作不和规范，需要使用正式的退出操作 如何退出app 记录Activity任务栈，全部finish System.exit(0);//正常退出System.exit(1);//非正常退出 android.os.Process.killProcess(android.os.Process.myPid()); 关闭进程，如果系统发现进程未正常关闭，会重新启动进程 在Intent中直接加入标识Intent.FLAG_ACTIVITY_CLEAR_TOP，这样开启B时，会清除该进程空间的所有Activity。 2.2版本之前使用ActivityManager关闭 12ActivityManager am = (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE);am.restartPackage(getPackageName()); 2.2版本以后 123ActivityManager am = (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE);am.killBackgroundProcesses(getPackageName());System.exit(0); 该方法只是结束后台进程的方法，不能结束当前应用移除所有的 Activity。如果需要退出应用，需要添加System.exit(0)方法一起使用，并且只限栈内只有一个Activity，如果有多个Activity时，正如上面 方法 2 所说，就不起作用了。 将MainActivity设置为singleTask，返回MainActivity后会清空所有的Activity，这样直接在MainActivity执行finish()方法即可 如何看待sendMessageAtFrontOfQueue()12345678910public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0);&#125; 传入的延迟时间为0，头插入消息队列，即消息队列下一次立即执行的消息， 如何看待Handler构造中的CallBack方法？1234567891011121314151617181920212223 @UnsupportedAppUsage public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; &#125;public void dispatchMessage(Message msg) &#123; //这里的 callback 是 Runnable if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; //如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 由源码可以看出构造函数中传入Callback参数，调用dispatch方法时，会优先调用callback方法，在调用handleMessage方法，即 Callback接口可以在handleMessage前收到消息，如果返回true，则不会调用handleMessage方法 我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！ Looper.prepareMain()和Looper.perpare的区别？区别是一个boolean值，主线程的looper永不退出，除非调用 AsyncTask如何理解AsyncTask？ 必须创建在主线程 AscncTask内部封装了Handler+线程池 包含两个线程池，一个是用来排队的 ，一个才是真正的执行，通过Handler将状态回掉到主线程 核心线程数，最少两个，最多四个 最大线程数= cpu核心数*2+1 核心线程无超时限制，非核心线程在闲置时的超时时间为1s 任务队列容量为128 execute方法执行，加入排队线程池排队，等待任务执行后通过handler通知主线程，调用状态回调方法，内部实现因为排队线程池阻塞，导致任务是串行的，即同时只有一个任务会进入线程池执行 executeOnExecutor执行调用异步操作 谷歌为何弃用AsyncTask 使用多线程更加复杂，使bug难以定位 太过复杂 滥用继承，effic java推荐“使用组合而不是继承”，使类多，且低效 默认的THREAD_POOL_EXECUTOR线程池配置不太合适 线程池线程 简述线程池android中线程池主要实现是ThreadPoolExecutor 参数： 核心线程数：如果指定ThreadPoolExecutor的allowCoreThreadTimeOut这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间，就会被销毁掉 最大线程数： = 核心线程数 + 非核心线程数 超时时间：非核心线程的闲置超时时间 超时时间单位：非核心线程的闲置超时时间单位 线程等待队列：当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务 线程创建工厂：线程池的拒绝策略，可以出错，也可以顾虑 allowCoreThreadTimeOut设置为true，非核心线程超时时间同样用于核心线程，如果为false，核心线程永远不会终止 SynchronousQueue（空集合）：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大 LinkedBlockingQueue（大小无限）：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize ArrayBlockingQueue（大小可以设置）：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误 DelayQueue（延迟出队，大小可以设置）：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务 规则： 未达到核心线程数，新建核心线程 达到或者大于核心线程数，任务被插入任务队列等待执行 步骤2中无法插入队列（队列满了），线程数量小于线程池最大值，启动一个非核心线程执行任务 步骤3 中线程数量达到最大值，则拒绝执行此任务 android主要分为几种线程池？四种 FixedThreadPool：全是核心线程，没有超时机制，任务队列没有大小限制 CachedThreadPool：全是非核心线程，最大为Integer.MAX_VALUE，空闲线程60s超时（60s内可以复用，60s后回收），适用于执行短时的大量任务，空闲时也不占用cpu资源 ScheduledThreadPool：核心线程固定，非核心线程为Interger.MAX_VALUE，非核心线程无超时机制（执行完就被回收），适用执行定时任务和固定周期任务 SingleThreadExecutor：只有一个核心线程，无超时机制，保证只在一个线程中执行任务 线程池中一个线程崩溃会导致线程池崩溃吗？不会，线程池存在两种方式去执行线程任务，submit和execute方式。 当发生线程崩溃时，execute下会将线程关闭，开辟新的线程，submit会返回异常，但不会关闭线程。 submit： 继承自ExecutorService 不会抛出栈堆异常，通过Future.get方法获取异常信息 submit通过构造一个RunnableFuture后，执行execute方法，RunnableFuture内部使用状态管理，通过死循环判断任务执行状态，在执行完或者cancle后返回， get()方法是一个阻塞方法，在调用时需要注意 execute： 继承自Executor 会抛出堆栈异常信息，关闭该线程并创建新的线程 如何检测线程池中的崩溃问题呢？submit的get()方法可以获取崩溃，但是该方法是阻塞的，可用性不高，于是我们使用另一种方法 execute+ThreadFactory.UncaughtExceptionHandler在submit下UncaughtExceptionHandler失效，因为FutureTask会捕获异常并保存不会放入UncaughtExceptionHandler中 在run方法中自行捕获 重写ThreadLocalExecutor.afterExecute方法 submit+get方法 View触摸事件传递 DecorView为最顶层的view，DecorView、TitleView和ContentView都为FrameLayout 如果一个view处理了down事件，那么后续的move，up都会交给他处理 点击事件的传递流程onTouchListener(onTouch)&gt;onTouchEvent()&gt;onClickListener(onClick) onTouchListener的onTouch返回为false，则onTouchEvent被调用 简述view的事件传递事件传递从父类向子类传递，其中包含3个方法，在一个类中顺序执行， dispatchEvent：事件的分发，true—-&gt;分发给自己 onIntercepterEvent：事件拦截，true—-&gt;拦截后交给自己的onTouchEvent处理，false —-&gt;传递给子View onTouchEvent：事件的执行。 如果View没有对ACTION_DOWN进行消费，之后的事件也不会传递过来。 事件的传递是从Activity开始的，Activity –&gt;PhoneWindow–&gt;DectorView–&gt;ViewGroup–&gt;View；主要操作在ViewGroup和View中； ViewGroup类主要调用：dispatchTouchEvent()–&gt;onInterceptTouchEnent()–&gt;dispatchTransformedTouchEvent()；ViewGroup不直接调用onTouchEvent()方法； 类 相关子类 方法 Activity类 Activity…… dispatchTouchEvent(); onTouchEvent(); View容器（ViewGroup的子类） FrameLayout、LinearLayout、ListView、ScrollVIew…… dispatchTouchEvent(); onInterceptTouchEvent(); onTouchEvent(); View控件（非ViewGroup子类） Button、TextView、EditText…… dispatchTouchEvent(); onTouchEvent(); onIntercepterTouchEvent()方法之只存在ViewGroup中，Activity为最顶层，不需要拦截，直接分发，view为最底层，不需要拦截，直接分发 以ACTION_DOWN为开始，UP或者CANCEL为结束 如果dispatch不处理ACTION_DOWN事件，那么就不会继续接收到后续的ACTION_xxxx事件 如何让只执行onTouch事件，不执行onClick事件？将onTouch方法的返回值改为true，就会只执行onTouch事件，不执行onClick事件。 如果截取了事件，还会往下传吗？那会走到哪里？如果截取了事件就不会往下传递了，只会执行本Viewgroup的onTouchEvent。 如果截取了事件并处理了事件还会返回父级吗？会返回父类，因为父类需要确认子级是否已经处理了事件 requestDisallowInterceptTouchEvent子view让其父view不做事件拦截，在子view的onTouchEvent方法中调用parent.requestDisallowInterceptTouchEvent(true)方法， 如果父view拦截事件，是怎么通知到子view的onInterceptTouchEvent中调用disallowIntercepter？ 在ScrollView中进行源码分析：在onIntercepterTouchEvent中返回true，则进行拦截，在按下滑动一小部分距离后设置为false（ACTION_MOVE），可以进行事件传递，当然就可以调用disallowIntercepter方法进行处理，后续的值触发父view的机制，直接过滤掉了onIntercepterTouchEvent 所以在ScrollView中默认的onClickListener是不生效的 onIntercepterTouchEvent不执行，直接返回false，然后向下dispatch到子类 该方法生效的前提是父view不拦截ACTION_DOWN事件，第一次的ACTION_DOWN事件可以传递到子view中，则后续的ACTION事件父view无法拦截 如何解决滑动冲突 外部拦截法： 重写父view的onIntercepterTouchEvent，在其中对触摸的坐标进行控制，在父view要拦截的时候拦截，在子view想要调用的时候不进行拦截 12345678910111213141516171819202122232425262728public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; intercepted = false; break; &#125; case MotionEvent.ACTION_MOVE: &#123; if (满足父容器的拦截要求) &#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; break; &#125; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted; &#125; 内部拦截法： 在子view的dispatchTouchEvent中在ACTION_DOWN事件下调用parent.requestDisallowInterceptTouchEvent(true);，设置不允许父view的拦截 12345678910111213141516171819202122232425262728public boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; parent.requestDisallowInterceptTouchEvent(true); break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; if (父容器需要此类点击事件) &#123; parent.requestDisallowInterceptTouchEvent(false); &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event); &#125; 该条件需要在父view的ACTION_DOWN事件可以传递到子view中才可以实现，所以需要在父view的onInterceptTouchEvent中不拦截父View的ACTION_DOWN事件 123456789public boolean onInterceptTouchEvent(MotionEvent event) &#123; int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; return false; &#125; else &#123; return true; &#125; &#125; ACTION_CANCEL怎么理解？ 在划出子view的布局后，onIntercepterTouchEvent进行拦截ACTION_MOVE事件，并将其转化为ACTION_CANCEL交给子view的处理，表示手指划出view所在区域 在父view进行拦截的时候，子view有可能接收到ACTION_CANCEL事件 触摸事件的结束有两种状态，一种时ACTION_UP事件，另一种就是ACTION_CANCEL事件，正常在view的事件传递中，抬起手指的ACTION_UP事件会被监听，当父view认为不需要将后续的ACTION_MOVE事件传递给子View的时候，就会将ACTION_MOVE事件转化为ACTION_CANCEL事件，子View就会认为事件结束 主要是父view在拦截中做了处理影响子view的触摸，不需要触摸就直接传ACTION_CANCEL。 使用TouchTarget（具体实现时mFirstTouchTarget）单链表存储触摸事件的，当置为CANCLE时，将触摸view在mFirstTouchEvent删除 事件到底是先到DecorView还是先到Window的？ViewRootImpl——&gt;DecorView——&gt;Activity——&gt;PhoneWindow——&gt;DecorView——&gt;ViewGroup 为什么绕来绕去的呢，光DecorView就走了两遍。 ViewRootImpl并不知道有Activity这种东西存在，它只是持有了DecorView。所以先传给了DecorView，而DecorView知道有Activity，所以传给了Activity。 Activity也不知道有DecorView，它只是持有PhoneWindow，所以这么一段调用链就形成了。 多点触控(非重点)使用TouchTarge（mFirstTouchTarget）管理 12345678910private static final class TouchTarget &#123; // The touched child view. public View child; // The combined bit mask of pointer ids for all pointers captured by the target. public int pointerIdBits; // The next target in the target list. public TouchTarget next;&#125; view：触摸目标view pointerIdBits：位运算（与、或） next：链表指针 第一个触摸目标，在ACTION_DOWN、ACTION_POINTER_DOWN时会触发寻找触摸目标过程（事件分发），所以DOWN事件会重置mFirstTouchTarget。 单点触控，mFirstTouchEvent为单个对象 多点触控，在一个view上，也是单个对象 多点触控，在多个view上，会成为一个链表 传入的view消耗了事件，则构建一个TouchTarget，并发至在mFirstTouchTarget的头部。多个view目标会头插在链表中。 即便是多指触控，也都是使用ACTION_MOVE，不做区分，可以使用index获取 如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？当使用纵向滑动，默认事件传递是viewPager到RecyclerView，即后续的所有事件都由RecyclerView进行处理，那么RecycleView没有横向事件，所以不会做处理，所以不会出现横向的滑动。 View的加载流程简述View的加载流程 通过Activity的setContentView方法间接调用Phonewindow的setContentView（），在PhoneWindow中通过getLayoutInflate（）得到LayoutInflate对象 通过LayoutInflate对象去加载View，主要步骤是 （1）通过xml的Pull方式去解析xml布局文件，获取xml信息，并保存缓存信息，因为这些数据是静态不变的 （2）根据xml的tag标签通过反射创建View逐层构建View （3）递归构建其中的子View，并将子View添加到父ViewGroup中 加载结束后就开始绘制view了 View的绘制机制 DecorView为最顶层的view，DecorView、TitleView和ContentView都为FrameLayout， 当Activity对象被创建完毕后，会将DecorView添加到PhoneWindow中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，view的绘制过程是由ViewRootImpl完成的。 所有的view都是依附在window上的，比如PopupWindow、菜单。 Window是个概念性的东西，你看不到他，如果你能感知它的存在，那么就是通过View，所以View是Window的存在形式，有了View，你才感知到View外层有一个皇帝的新衣——window 有视图的地方就有window 简述View的绘制流程深度便利主要分为3个方法，顺序执行： measure()：测量视图的大小，根据MeasureSpec进行计算大小 layout()：确定view的位置 draw()：绘制view。创建Canvas对象。六个步骤：①、绘制视图的背景；②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用；⑤、还原图层（Layer）；⑥、绘制滚动条。 draw()中的具体流程是什么？ 绘制背景：drawBackground(canvas) 绘制自己的内容：onDraw(canvas) 绘制Children：dispatchDraw(canvas) 绘制装饰：onDrawForeground(canvas) MeasureSpec分析MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求，子view依据该值进行大小的绘制 MeasureSpec是个大小和模式的组合值。是一个32位的整型，将size（大小）和mode（模式）打包成一个int，其中高两位是mode，其余30位存储size（大小）12345678// 获取测量模式int specMode = MeasureSpec.getMode(measureSpec)// 获取测量大小int specSize = MeasureSpec.getSize(measureSpec)// 通过Mode 和 Size 生成新的SpecModeint measureSpec=MeasureSpec.makeMeasureSpec(size, mode);测量模式有三种： EXACTLY: 相等于MATCH_CONTENT AT_MOST: 相等于WRAP_CONTENT UNSPECIFIED: 相等于具体的值 RelativeLayout、LinearLayout和ConstraintLayoutLinearLayout： weight设置导致二次测量，首先测量一遍大小onMeasure（非weight），然后根据weight在次测量，调整大小 RelativeLayout： onMeasure执行两遍，对横向和纵向分别测量，所以是2遍 ConstraintLayout： 可以不使用嵌套，提供相对布局，并且支持权重布局，尽可能减少层级，提高性能，类似于flex布局 对比 同层级的布局，LinearLayout&lt;RelatvieLayout=ConstraintLayout，因为LinearLayout执行onMeasure一遍，RelativeLayout执行两遍 LinearLayout会增加层级深度，RelativeLayout减少层级，所以通常下使用RelativeLayout，如果层级简单则使用LinearLayout RelativeLayout的子View如果高度和RelativeLayout不同，会引发效率问题 setContentView的执行过程 初始化windows 绑定ui布局 什么时候可以获得view的宽高因为onMeasure和生命周期不同步，所以不能在onCreate，onStart，onResume中进行获取操作， 在view.post方法中进行获取，内部实现是handler机制，回调的时候已经执行完了 在onWindowFocusChanged获取焦点后，view的绘制完成，可以在这里拿到view的宽高 使用ViewTreeObserver的回调也可以解决这个问题。12345678910111213ViewTreeObserver observer = tv1.getViewTreeObserver(); observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; tv1.getViewTreeObserver().removeOnGlobalLayoutListener(this); &#125; int width = tv1.getMeasuredWidth(); int height = tv1.getMeasuredHeight(); Log.d(&quot;tv1Width&quot;, String.valueOf(width)); Log.d(&quot;tv1Height&quot;, String.valueOf(height)); &#125; &#125;); 手动调用measure方法后，获取宽高 什么时候开始绘制Activity的view的？在DecorView添加(addView)到phoneWindows中时，触发measure，layout，draw方法 PhoneWindow是在什么时候创建的？在Activity的attch方法时，创建了PhoneWindow View的刷新机制requestLayout和invalidate区别是什么requestLayout：触发onMeasure,onLayout方法，大小和位置变化，不一定触发onDraw invalidate：触发performTraversals机制，导致view重绘，调用onDraw方法，主要是内容发生变化 postInvalidate：异步调用invalidate方法 invalidate如果是个view，那就只有自己本身会draw，如果是ViewGroup就是对子view进行重绘 简析Activity、Window、DecorView以及ViewRoot之间的错综关系 Activity是控制器 windows装载DecorView，并将DecorView交给ViewRoot进行绘制和交互，其唯一实现子类就是PhoneWindow，在attach中创建，是Activity和View交互的中间层，帮助Activity管理View。 DecorView是FrameLayout的子类，是视图的顶级view viewRoot负责view的绘制和交互，实际的viewRoot就是ViewRootImpl类，是连接WMS和DecorView的纽带 setContentView执行的具体过程 Activity实例化，执行attach方法，在attach中创建PhoneWindow 执行onCreate方法，执行setContentView，先调用phoneWindow.setContentView(),然后开始根据不同的主题创建DecorView的结构，传入我们的xml文件，生成一个多结构的View Activity调用onResume方法，调用WindowManager.addView()方法，随后在addView()方法中创建ViewRootImpl 接着调用ViewRootImpl的setView方法，最终触发meaure，layout，draw方法进行渲染绘制，其中和WMS通过Binder交互，最终显示在界面上 四者的创建时机？ Activity：startActivity后，performLaunchActivity方法中创建 PhoneWindow：Activity的attach方法 DecorView：setConentView中创建 ViewRootImpl：onResume中调用WM.addView方法创建 dialog为什么不能用application创建？Android-Window机制原理之Token验证(为什么Application的Context不能show dialog) token是WMS唯一用来标识系统中的一个窗口 Dialog有一个PhoneWindow实例，属于应用窗口。Dialog最终也是通过系统的WindowManager把自己的Window添加到WMS上。Dialog是一个子Window，需要依附一个父window。 Dialog创建PhoneWindow时，token是null。只有传入Activity中的Context对象，Activity才会将自己的token给Dialog，这样，才会被WMS所识别，如果使用的不是Activit的token，就会报错BadTokenException 在application的情况下，将Dialog的window升级为系统window即可显示 RecyclerView和ListViewAndroid—RecyclerView进阶(4)—复用机制及性能优化 RecyclerView问题汇总 老大爷都能看懂的RecyclerView动画原理 RecyclerView性能优化及高级使用 简述RecyclerView的刷新和缓存机制 recyclerView中有三个重要方： Adapter：负责与数据集交互 LayoutManager：负责ItemView的布局，接管Measure，Layout，Draw过程 Recycler：负责管理ViewHolder ViewHolder：视图的创建和显示在Recycler中有多个缓存池， mAttachedScrap被称为一级缓存，在重新layout时使用，主要是数据集发生变化的场景 1234567891011121314//屏幕内缓存scrap// mAttachedScrap在重新layout时使用，表示未与RecyclerView分离的ViewHolderfinal ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;();// mChangedScrap用于数据变化等ArrayList&lt;ViewHolder&gt; mChangedScrap = null;//屏幕外缓存cache// mCachedViews和RecycledViewPool用于滑动时的缓存final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();// 用户自定义缓存，一般不用private ViewCacheExtension mViewCacheExtension;//屏幕外缓存pool，数据会被重置，虚之行onBindViewHolderRecycledViewPool mRecyclerPool; mAttachedScrap：mAttachedScrap用于屏幕中可见表项的回收和复用，没有大小限制mAttachedScrap生命周期起始于RecyclerView布局开始，终止于RecyclerView布局结束，无论mAttachedScrap中是否存在数据，都会清空，存储到mCacheView或者mRecyclerPool 插入或是删除itemView时，先把屏幕内的ViewHolder保存至AttachedScrap中 mAttachView和mCacheView都是通过比对position或者id（setStableIds（true）+getItemId复写）来确定是否复用的 缓存存储结构区别 mAttachedScrap：ArrayList mCachedView：ArrayList mRecyclerPool：SparseArray，ScrapData中包含ArrayList和其他标记位。数据集发生变化当数据集发生变化后，我们会调用notifyDataSetChanged()方法进行刷新布局操作，这时LayouManager通过调用detachAndScrapAttachedViews方法，将布局中正在显示的ItemView缓存到mAttachScrap中，重新构建ItemView时，LayoutManager会首先到mAttachScrap中进行查找如图所示，如果只是删除Data1数据，执行NotifyDataSetChanged()方法时，layoutManager将Data0到Data4缓存到mAttachScrap中，重新渲染布局时，会直接复用mAttachScrap中的四个布局，而得不到复用的布局会被放置在mRecyclerPool中。 通过比较Position确定mAttachScrap中ItemView的复用，因为2的位置从2变为1，位置发生变化，但是还是通过比对position进行复用，那是因为在recyclerView重新渲染时，执行dispatchLayoutStep1()对position进行了校正。 滑动类型在滑出可视区域后，会将ViewHolder存储在mCachedView中，当超出大小（默认大小为2+预加载item）后会将最先放进来的放在RecyclerViewPool中，根据viewType进行缓存，每个viewType缓存最多5个，从RecyclerViewPool中取出的数据，最终会调用onBindViewHolder()方法重新绑定 当发现有新的构建时，会去缓存找，找不到就去mRecyclerPool中寻找，如果有viewType相同的就取出来绑定并复用。 RecyclerView滑动时，刚开始的时候回收了Position0和Position1，它们被添加到了mCachedViews中。随后回收Position2时，达到数量上限，最先进入mCachedViews的Position0被放进了mRecyclerPool中。再看下方进入可视区域的3个Item，最初的Position6和Position7找不到对应的缓存，只能新建ViewHolder并绑定。当Position8滑入可视区域时，发现mRecyclerPool中有一个ViewType相等的缓存，则将其取出并绑定数据进行复用。 当有数据进行变动时，数据的position会发生变化。 stableId mChangedScrap—–&gt;mAttachedScrap—–&gt;mCachedViews—–&gt;ViewCacheExtension—–&gt;RecycledViewPool——–&gt;onCreatViewHolder 如果是单个viewType的RecyclerView，在滑动过程中，RecyclerPool最多可能存在一个数据 假设一屏幕显示7个，向上滑动10个，总共bindView10个，又下滑10个（滑回去），总共8个（cacheView复用两个），一共18个 在RecyclerView的v25版本中，引入预取机制，在初始化时，初始化8个，提前缓存一个数据 RecyclerView的优化放大缓存大小和缓存池大小 再滑动过程中，不论上滑还是下滑都会从mCachedViews中查找缓存，如果滑动频繁，可以通过RecyclerView.setItemViewCacheSize(...)方法增大mCachedViews的大小，减少onBindViewHolder()和onCreateViewHolder()调用 放大RecyclerViewPool的默认大小，现在是每个viewType中默认大小为5，如果显示数据过多，可放大默认大小12//设置viewType类型的默认存储大小为10recyclerview.getRecycledViewPool().setMaxRecycledViews(viewType,10); 如果多个RecyclerView中存在相同ViewType的ItemView，那么这些RecyclerView可以公用一个mRecyclerPool。 优化onBindViewHolder()耗时尽量少的在onBindViewHolder中执行操作，减少新建对象对内消耗 布局优化多使用include,merage，viewStub,LinearLayout,FrameLayout measure()优化和减少requestLayout()调用当RecyclerView宽高的测量模式都是EXACTLY（精确数据）时，onMeasure()方法不需要执行dispatchLayoutStep1()等方法来进行测量。而当RecyclerView的宽高不确定并且至少一个child的宽高不确定时，要measure两遍。因此将RecyclerView的宽高模式都设置为EXACTLY有助于优化性能。 如果RecyclerView的宽高都不会变，大小不变,方法RecyclerView.setHasFixedSize(true)可以避免数据改变时重新计算RecyclerView的大小，优化性能 notifyDataSetChanged 与 notifyItemRangeChanged 的区别？当notifyItemRangeChanged的区间在mRecyclerpool的大小的间隔内，则会通过mRecyclerpool复用viewholder，响应快速。 notifyItemInsert()和notifyItemRemove()方法，会通过RecyclerView的预加载流程，会将ViewHolder缓存到mAttachView中，避免重新create和bind。 notifyItemChanged(int)方法更新固定item notifyDataSetChanged 会将所有viewholder放置在pool中，但是只能放置5个，其他就回收了，再构建时，需要重新绘制测量，界面会导致闪烁等 如果使用SetHasStableIds（true）,会将数据缓存到scrap中，复用时直接使用 调用 notifyDataSetChanged 时闪烁的原因？itemView重新测量和布局导致的(bindViewHolder)，并非createViewHolder。数据存储在RecyclerViewPool中，拿出需要重新BindView，itemView重新进行测量和布局，导致出现UI线程耗时，出现闪烁 如果使用SetHasStableIds（true）,会将数据缓存到scrap中，复用时直接使用 如果你的列表能够容纳很多行，而且使用 notifyDataSetChanged 方法比较频繁，那么你应该考虑设置一下容量大小。 RecyclerView相对于ListView的优势是什么？ 屏幕外缓存可以直接在mCacheView()中复用，不需要重新BindView recyclerPool可以提供给多个RecyclerView使用，在特定场景下，如viewpaper+多个列表页下有优势. ListView缓存View，RecyclerView缓存ViewHolder adapter，viewHolder的作用?adapter中常用方法的作用是什么？ Adapter：负责与数据集交互 ViewHolder：视图的创建和显示，持有所有的用于绑定数据或者需要操作的View 123456789//创建Item视图，并返回相应的ViewHolderpublic VH onCreateViewHolder(ViewGroup parent, int viewType)//绑定数据到正确的Item视图上。public void onBindViewHolder(VH holder, int position)//返回该Adapter所持有的Item数量public int getItemCount()//用来获取当前项Item(position参数)是哪种类型的布局public int getItemViewType(int position) RecyclerPool为何使用SparseArray？在RecyclerView中，第四级缓存，mRecyclerPool中存储是通过SparseArray存储ViewHolder，根据不同的ViewType的int值为键，ScrapData为值，ScrapData也是ArrayList及其标志位组成的，在进行put和get方法时，都是通过ViewType值获取。不使用HashMap的原因是： 我们定义了viewType为int值，则不用HashMap中较为繁重的类型，减少装箱问题耗时 量级较小，不需要HashMap的大量级处理 节省内存 使用SparseArray存储空间id和空间对象关系。 HashMap更加复杂，SparseArray减少开销 LayoutManager样式有哪些？setLayoutManager源码里做了什么？ LinearLayoutManager 水平或者垂直的Item视图。 GridLayoutManager 网格Item视图。 StaggeredGridLayoutManager 交错的网格Item视图。 当之前设置过 LayoutManager 时，移除之前的视图，并缓存视图在 Recycler 中，将新的 mLayout 对象与 RecyclerView 绑定，更新缓存 View 的数量。最后去调用 requestLayout ，重新请求 measure、layout、draw。 ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration()源码？用途：来改变Item之间的偏移量或者对Item进行装饰 123456//装饰的绘制在Item条目绘制之前调用，所以这有可能被Item的内容所遮挡public void onDraw(Canvas c, RecyclerView parent)//装饰的绘制在Item条目绘制之后调用，因此装饰将浮于Item之上public void onDrawOver(Canvas c, RecyclerView parent)//与padding或margin类似，LayoutManager在测量阶段会调用该方法，计算出每一个Item的正确尺寸并设置偏移量。public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) 当通过这个方法添加分割线后，会指定添加分割线在集合中的索引，然后再重新请求 View 的测量、布局、(绘制) mChangedScrap和mAttachedScrap的区别是什么？因为mChangedScrap表示item变化了，有可能是数据变化，有可能是类型变化，所以它的viewHolder无法重用，只能去RecycledViewPool中重新取对应的，然后再重新绑定。 mChangedScrap与mAttachedScrap，作用差不多。 mChangedScrap更多的用于pre-layout的动画处理。 然后一点需要注意：mChangedScrap只能在pre-layout中使用，mAttachedScrap可以在pre-layout与post-layout中使用。 mChangedScrap：ViewHolder.isUpdated() == true mAttachedScrap：1.被同时标记为remove和invalid；2.完全没有改变的ViewHolder 在notifyItemRangeChanged，将数据变化的放置在mChangedScrap，没有变化的存储在mAttachScrap中，然后再取出来，mChangedScrap的数据会被移动到RecyclerPool中，进行重新绑定后再放回mChangedScrap中 mAttachScrap中得不到复用的会放置在recyclerpool中 onMeasure过程过程中包含mAttachedScrap的使用 dispatchLayoutStep1：预布局 dispatchLayoutStep2：实际布局 dispatchLayoutStep3：执行动画信息 如何解决Glide错乱问题因为存在复用机制，8可能会复用1，在网络不好或者图片过大的情况下，8的图片加载缓慢，会先显示1的图片，加载后才会刷新掉。 方案：imageView设置tag，判断是否复用，如果是复用，就清除该控件上Glide的缓存 RecyclerView卡顿优化通过BlockCanary进行主线程卡顿检测，打印出任务耗时，在卡顿时，打印出栈堆信息 原理是在looper.loop()死循环中，执行任务都是dispatchMessage方法，如果该方法超过一个任务的常规耗时，就会导致主线程卡顿 解决方法： 放大mCacheView和RecyclerPool的大小，提高复用率，减少渲染 图片在滑动结束后再进行加载，避免在滑动的时候向主线程做更新 12345678910mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; if (newState == RecyclerView.SCROLL_STATE_IDLE) &#123; Glide.with(mContext).resumeRequests(); &#125;else &#123; Glide.with(mContext).pauseRequests(); &#125; &#125;&#125;); 在滑动过程中停止加载，在滑动结束后恢复加载 使用DiffUtil进行局部刷新优化 123456//DiffUtil会自动计算新老数据的差异，自动调用notifyxxx方法，将无脑的notifyDataSetChanged()进行优化//并且伴随动画adapter.notifyItemRangeInserted(position, count);adapter.notifyItemRangeRemoved(position, count);adapter.notifyItemMoved(fromPosition, toPosition);adapter.notifyItemRangeChanged(position, count, payload); 12345678//文艺青年新宠//利用DiffUtil.calculateDiff()方法，传入一个规则DiffUtil.Callback对象，和是否检测移动item的 boolean变量，得到DiffUtil.DiffResult 的对象DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffCallBack(mDatas, newDatas), true);//利用DiffUtil.DiffResult对象的dispatchUpdatesTo（）方法，传入RecyclerView的Adapter，轻松成为文艺青年diffResult.dispatchUpdatesTo(mAdapter);//别忘了将新数据给AdaptermDatas = newDatas;mAdapter.setDatas(mDatas); 减少布局的嵌套和层级，减少过度绘制，尽量自定义view 如果Item高度固定，调用RecyclerView.setHasFixedSize(true);来避免requestLayout浪费资源 可以关闭动画，减少RecyclerView的渲染次数 RecyclerView的自适应高度 使用瀑布流布局StaggeredGridLayoutManager 重写LinearLayoutManager，onMeasure中重新测量子布局的大小 RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView 同方向的情况下会造成滑动冲突，默认外层的RecyclerView可滑动一般有两种处理方案：内部拦截法和外部拦截法这里推荐内部拦截法，通过设置requestDisallowInterceptTouchEvent(true)时，不让父RecyclerView拦截子类的事件 ScrollView嵌套RecyclerView同样可以使用这个方法解决。也可以使用NestedScrollView，该类就是为了解决滑动冲突问题，可以保证两View类都可以滑动，但是需要设置RecyclerView.setNestedScrollingEnabled(false)，取消RecyclerView本身的滑动效果。解决滑动的卡顿感 动画简述帧动画：一连串的图片进行连贯的播放，形成动画。 补间动画：通过xml文件实现，实现 alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转），通过不断的绘制view，看起来移动了效果，实际上view没有变化，还在原地 属性动画：对于对象属性的动画，也可以使用xml配置，但是推荐代码配置，比xml更加方便。通过不断改变自己view的属性值，真正的改变view 所有的补间动画都可以用属性动画实现 属性动画和补间动画的区别 补间动画虽然移动了，但是点击的还是原来的位置，点击事件允许触发。而属性动画不是，所以我们可以确认，属性动画才是真正实现了View的移动，补间动画的view其实只是在其他地方绘制了一个影子 Activity退出时，没有关闭动画，属性动画会导致Activity无法释放的内存泄漏，而补间动画不会发生这样的情况 xml的补间动画复用率极高，在页面切换过程中都有很好的效果 帧动画避免大图，否则会带来oom 属性动画中的差值器和估值器是什么？差值器：定义动画随时间流逝的变化规律。通俗点就是动画的执行速度的变化，可以是由缓即快，由快即缓，也可以是匀速，也可以是弹性动画效果 ，LinearInterpolator（匀速差值器） 估值器：定义从初始值过渡到结束值的规则定义，TypeEvaluator，可以通俗的理解为位置的移动 android系统启动流程android系统架构简述系统启动流程从系统层看： linux 系统层 Android系统服务层 Zygote 从开机启动到Home Launcher： 启动bootloader （小程序；初始化硬件） 加载系统内核 （先进入实模式代码在进入保护模式代码） 启动init进程（用户级进程 ，进程号为1） 启动Zygote进程（初始化Dalvik VM等） 启动Runtime进程 启动本地服务（system service） 启动 HomeLauncher 第一个启动的进程是什么？init进程，其他进程都是fork这个进程的 init进程孵化出了什么进程？ 守护进程 Zygote进程，负责孵化应用进程 MediaServer进程 Zygote进程做了什么？ 创建Socket服务端 加载虚拟机 SystemServer进程 fork第一个应用进程—Launcher 为什么要创建Socket服务端？ ServiceManager不能保证在孵化Zygote进程时就初始化好了，所以无法使用Binder Binder属于多线程操作，fork不允许多线程操作，容易发生死锁，所以使用Socketapp启动流程 用户点击 icon 系统开始加载和启动应用 应用启动：开启空白(黑色)窗口 创建应用进程 初始化Application 启动 UI 线程 创建第一个 Activity 解析(Inflater)和加载内容视图 布局(Layout) 绘制(Draw) 源码分析 LauncherActivity.startActivitySafely(intent)：使用intent启动 Activity.startActivity(intent)： Activity.startActivityForResult(intent)：获取ApplicationThread成员变量，是一个Binder对象 Instrumentation.execStartActivity：ActivityManagerService的远程接口 ActivityManagerProxy.startActivity：通过Binder进入AMS ActivityManagerService.startActivity ActivityStack.startActivityMayWait：解析MainActivity的信息 ActivityStack.startActivityLocked：创建即将要启动的Activity的相关信息 ActivityStack.startActivityUncheckedLocked：获取intent标志位，新建Task栈，添加到AMS中 Activity.resumeTopActivityLocked：查看LauncherActivity状态，新建Activity的状态 ActivityStack.startPausingLocked：停止LauncherActivity，onPause ApplicationThreadProxy.schedulePauseActivity ApplicationThread.schedulePauseActivity ActivityThread.queueOrSendMessage：在主线程通过Handler发送消息 H.handleMessage：Handler的回调 ActivityThread.handlePauseActivity：pause LauncherActivity ActivityManagerProxy.activityPaused：进入AMS中的onPause事件 ActivityManagerService.activityPaused ActivityStack.activityPaused ActivityStack.completePauseLocked ActivityStack.resumeTopActivityLokced：LauncherActivity已经onPause了 ActivityStack.startSpecificActivityLocked ActivityManagerService.startProcessLocked：创建新进程 ActivityThread.main：app入口，添加looper循环 ActivityManagerProxy.attachApplication：通过Binder进入AMS中 ActivityManagerService.attachApplication ActivityManagerService.attachApplicationLocked ActivityStack.realStartActivityLocked ApplicationThreadProxy.scheduleLaunchActivity：进入ApplicationThread ApplicationThread.scheduleLaunchActivity ActivityThread.queueOrSendMessage H.handleMessage ActivityThread.handleLaunchActivity ActivityThread.performLaunchActivity：进入onCreat方法 MainActivity.onCreate 总结： 1～11：Launcher通过Binder进程通知ActivityManagerService，他要启动一个Activity 12～16：ActivityManagerService通过Binder进程通知Launcher进入Pause阶段 17～24：Launcher告知我已进入pause阶段，ActivityManagerService创建新进程，用来启动ActivityThread。 25～27：ActivityThread通过Binder进程将ApplicationThread的Binder传递给ActivityManagerService，以便AMS可以直接用这个Binder通信 28～35：AMS通过Binder通知ActivityThread，你可以启动 这里以启动微信为例子说明 Launcher通知AMS 要启动微信了，并且告诉AMS要启动的是哪个页面也就是首页是哪个页面 AMS收到消息告诉Launcher知道了，并且把要启动的页面记下来 Launcher进入Paused状态，告诉AMS，你去找微信吧 上述就是Launcher和AMS的交互过程 AMS检查微信是否已经启动了也就是是否在后台运行，如果是在后台运行就直接启动，如果不是，AMS会在新的进程中创建一个ActivityThread对象，并启动其中的main函数。 微信启动后告诉AMS，启动好了 AMS通过之前的记录找出微信的首页，告诉微信应该启动哪个页面 微信按照AMS通知的页面去启动就启动成功了。 Activity启动流程参照app的启动流程 ApplicationThread：ActivityThread的内部类，负责和AMS进行Binder通信 ActivityManagerService：服务端对象，负责管理系统中所有的Activity Activity 启动过程是由 ActivityMangerService（AMS) 来启动的，底层 原理是 Binder实现的 最终交给 ActivityThread 的 performActivity 方法来启动她 ActivityThread大概可以分为以下五个步骤 通过ActivityClientRecord对象获取Activity的组件信息 通过Instrument的newActivity使用类加载器创建Activity对象 检验Application是否存在，不存在的话，创建一个，保证 只有一个Application 通过ContextImpl和Activity的attach方法来完成一些初始化操作 调用oncreat方法 Android开启新进程的方式是通过复制第一个zygote（受精卵）进程实现，所以像受精卵一样快速分裂 SystemServer是什么？有什么作用？他和zygote的关系是什么？SystemServer也是一个进程，并且复制于zygote，系统中重要的服务都是在这个进程中开启的，如：AMS，PMS，WMS等 ActivityManagerService是什么？什么时候初始化的？有什么作用？简称AMS，负责系统中所有Activity的生命周期，控制其开启、关闭、暂停等是在SystemServer进程开启时进行初始化的 App 和 AMS(SystemServer 进程)还有 zygote 进程是如何通信的？App 与 AMS 通过 Binder 进行 IPC 通信，AMS(SystemServer 进程)与 zygote 通过 Socket 进行 IPC 通信。 AMS/PMS/WMS运行在一个线程中还是进程中？运行在System_server进程中的线程中 apk打包流程 aapt阶段，打包res目录，生成R.java AIDL阶段，生成java文件 java编译器。将java文件通过javac编译生成.class文件 dex阶段，生成.dex文件 apk打包阶段，将文件打包成为apk文件 签名阶段，对apk进行签名 整理apk文件 aapt和aapt2的区别？aapt是全量编译，打包res目录，生成R文件 aapt2是差量编译，将变化的res目录进行重新打包，修改R文件 aapt2中存在两部分，编译和链接 编译：将资源文件编译为二进制文件 链接：将编译后二进制文件进行合并，生成独立的文件 在需要差量的时候，只需要重新编译二进制文件，再将这些二进制文件生成新的文件即可 apk的组成 AndroidManifest.xml assets（项目中assets目录） classes.dex lib库 META-INF（校验文件） res（资源文件） resources.arsc（资源文件映射，索引文件） apk安装流程存在多少种安装方式，分别是什么？四种 系统应用安装——————开机时完成安装，没有安装界面 网络下载安装——————通过市场应用完成，没有安装界面 adb命令安装——————没有安装界面 第三方应用安装——————sdk卡导入apk，点击安装，存在安装界面 安装过程中的重要路径应用安装涉及到如下几个目录： system/app —————系统自带的应用程序，获得adb root权限才能删除 data/app —————用户程序安装的目录。安装时把 apk文件复制到此目录 data/data —————存放应用程序的数据 data/dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一) 安装过程 将apk文件复制到/data/app目录 解析apk信息 dexopt操作（将dex文件优化为odex文件） 更新权限信息 发送安装完成广播 Android虚拟机发展史 android初期，Dalvik负责加载dex/odex文件 2.2版本，JIT（即时编译）初次加入，每次启动的时候编译，耗时，耗电 4.4版本引入ART（Android RunTime）和AOT（Ahead-of-time）（运行前编译成机器码），与Dalvik共存 5.0版本全部采用ART编译器，不耗时，不耗电，在安装期间比较慢而已，而且会占用额外的控件存储机器码 7.0版本JIT回归，再用JIT/AOT并用，即初次启动使用JIT，在手机空闲时，使用AOT生成机器码（只编译热点函数信息，用户操作次数越多，性能越高），这样保证了安装迅速，启动迅速，耗电少 Dalvik和ART是什么，有啥区别？DalvikDalvik是Google公司自己设计用于Android平台的虚拟机。支持已转换为.dex格式的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。2014年6月25日，Android L 正式亮相于召开的谷歌I/O大会，Android L 改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART。 ART即Android RuntimeART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。 区别Dalvik是基于寄存器的，而JVM是基于栈的。Dalvik运行dex文件，而JVM运行java字节码自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）。优化后的Dalvik较其他标准虚拟机存在一些不同特性:1.占用更少空间2.为简化翻译，常量池只使用32位索引3.标准Java字节码实行8位堆栈指令,Dalvik使用16位指令集直接作用于局部变量。局部变量通常来自4位的“虚拟寄存器”区。这样减少了Dalvik的指令计数，提高了翻译速度。当Android启动时，Dalvik VM 监视所有的程序（APK），并且创建依存关系树，为每个程序优化代码并存储在Dalvik缓存中。Dalvik第一次加载后会生成Cache文件，以提供下次快速加载，所以第一次会很慢。Dalvik解释器采用预先算好的Goto地址，每个指令对内存的访问都在64字节边界上对齐。这样可以节省一个指令后进行查表的时间。为了强化功能, Dalvik还提供了快速翻译器（Fast Interpreter）。 对比ART有什么优缺点呢？ 优点：1、系统性能的显著提升。2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。3、更长的电池续航能力。4、支持更低的硬件。缺点：1.机器码占用的存储空间更大，字节码变为机器码之后，可能会增加10%-20%2.应用的安装时间会变长 .dex .class .odex的区别.dex是谷歌对.class文件进行了优化后得到的文件格式 .dex去除了.class中冗余的信息，更加轻量 .class内存占用大，不适合移动端，堆栈的加栈模式，加载速度慢，文件IO操作多，类查找慢 .dex文件在虚拟机进行加载时，会预加载成.odex文件，.odex文件对.dex文件进行了优化，避免了重复验证和优化处理，启动时，可直接接在odex文件，提升app启动的速度 简述安装流程 使用installPackageAsUser判断安装来源 校验后（权限，存储空间，安全）将apk文件copy至data/app目录 解析apk信息，覆盖安装或者安装新应用 Dalvik中将dex优化为odex文件 ART将dex翻译为oat文件（机器码）预编译过程 创建/data/data/包名 存放应用数据，发送广播结束安装 接口加密项目中的接口加密技巧在版本中写死一个密钥，首个接口请求后返回该app的密钥。 对上传的get，post请求的参数以ASCII码进行排序+密钥后生成md5值，添加到header中，传递给服务器 服务器端根据获取到的参数依据同样的规则生成md5后进行比较，如果相同，比较时间戳是否在5秒内，通过则成功 不使用token机制的原因是本产品不存在账号密码等机制，应用可能一直保持在线状态，不会下线，需要协调token的时效性，所以不使用该方案。 缺点：token机制一台机子只允许一个token进行访问，而上述方案没有该限制 常规token校验机制 适用于存在账户名密码的应用 小知识点ANR条件？Service执行的操作最多是20s，BroadcastReceiver是10s，Activity是5s，超过时间发生ANR ANR原理解析Application Not Responding 主线程频繁进行IO操作，比如读写文件或者数据库； 硬件操作如进行调用照相机或者录音等操作； 多线程操作的死锁，导致主线程等待超时； 主线程操作调用join()方法、sleep()方法或者wait()方法； 耗时动画/耗资源行为导致CPU负载过重 system server中发生WatchDog ANR； service binder的数量达到上限 在应用程序运行过程中，通过send一个延迟的handler，延迟时间为设置的anr时间，如果到时间，没有执行完任务/没有移除handler任务，就会调用appNotResponding方法，触发anr 主要在AMS和WMS中进行控制，通过获取/data/anr/trace.txt进行分析 什么情况下会导致oom？ 大图片存储导致oom，内存溢出 使用软弱引用，当内存不足时，删除Bitmap缓存 调用Bitmap.recycle()快速回收，但是慎用，容易报错 除了程序计数器之外的内存模型都会发生oom1java.lang.StackOverflowError:死循环/递归调用产生的 关闭流文件、数据库cursor等对象关闭 创建很多线程会导致oom，因为开辟线程需要对虚拟机栈，本地方法栈，程序计数器，开辟内存，线程数量过多，会导致OOM 如何将应用设置为Launcher？设置HOME，DEFAULT。 MVC,MVP,MVVM浅谈MVP in Android MVC View：对应于布局文件 Model：业务逻辑和实体模型 Controller：对应于Activity 缺点： Controller（Activity）中处理的逻辑过于繁重，原因是在Activity有太多操作View的代码，View和Controller绑定太过紧密 android中算不上mvc模式，Activity可以叫View层，也可以叫Controller层，所有代码基本都在Activity中 MVP View 对应于Activity，负责View的绘制以及与用户交互 Model 依然是业务逻辑和实体模型 Presenter 负责完成View于Model间的交互 因为Activity任务过于繁重，所以在Activity中提炼出一个Presenter层，该层主要通过接口和View层交互，同时获得View层的反馈 优点 大大减轻了Activity的逻辑，将View和Presenter做分离，让项目更加简单明确 缺点 每个功能需要添加一个Presenter类，添加各种借口，增加开发量 Presenter层持有Activity层的引用，需要注意内存泄漏或空指针的问题 MVVM View：View层 ViewModel层：JetPack中的ViewModel组件，配合LiveData+DataBinding，保证View和ViewModel之间的交互，双向绑定，数据的更新可以实时绑定到界面中。 Model层：数据层 ViewModel层中代替了Presenter的作用，里边做具体的逻辑，ViewModel与Activity的绑定通过反射构建，通过LiveData达到响应式，在Activity中调用ViewModel的逻辑，并实时更新到界面。 优点 ViewModel+LiveData同Activity的生命周期绑定，当Avtivity不存在后，会销毁ViewModel，减少内存泄漏 提供Activity中多个Fragment的数据共享和逻辑调用 提供响应式编程，提供解决问题新方向 优秀的架构思想+官方支持=强大 代码量少，双向绑定减少UI的更新代码 缺点 降低了View的复用性，因为添加了很多DataBinding的代码，绑定到Activity中 难以定位bug，流程许多地方都是自动化更新，执行，无法确定当中哪一个环节出现问题（数据逻辑问题还是界面显示问题） SharedPreferences commit apply使⽤区别 commit具有回调 apply将信息推送到主存，异步提交到文件，commit同步提交到文件 Bitmap解析Bitmap是怎么存储图片的？Bitmap是图片在内存中的表达形式，存储的是有限个像素点，每个像素点存储着ARGB值，代表每个像素所代表的颜色（RGB）和透明度（A） Bitmap图片的内存是怎么计算的？图片内存 = 宽 高 每个像素所占字节每个像素所占字节和Bitmap.Config有关： ARGB_8888：常用类型，总共32位，4个字节，分别表示透明度和RGB通道。 ARGB_4444：2个字节 RGB_565：16位，2个字节，只能描述RGB通道。 ALPHA_8：1个字节 Bitmap加载优化？不改变图片质量的情况下怎么优化？ 修改Bitmap.Config，降低bitmap每个像素所占用的字节大小，替换格式为RGB_565，这样，内存直接缩小1倍 修改inSampleSize采样率，降低图片的大小，不影响图片的质量，控制每隔inSampleSize个像素进行一次采集 inSampleSize为1时，为原图大小。大于1时，比如2时，宽高就会缩小为原来的1/2 inSampleSize进行2的幂取整操作，1，2，4，8等 Bitmap内存复用怎么实现？如果在一个imageView中加载多种不同的Bitmap图片，如果频繁的去创建bitmap，获取内存，释放内存，从而导致大量GC，内存抖动。在使用Bitmap时，使用inBitmap配合inMutable参数，复用Bitmap内存。在4.4之前，只能复用内存大小相同的Bitmap，4.4之后，新Bitmap内存大小小于或等于复用Bitmap空间的，可以复用 高清大图如何加载？使用BitmapRegionDecoder属性进行部分加载，根据界面滑动，不断更新部分图片的位置 intent可以传递bitmap吗？可以，bitmap是parcelable序列化过的，也可以转化成byte[]进行传递 大小受限1M，因为binder的大小是1M，binder的线程数不大于16 Bitmap内存在各个android版本的存储？Android Bitmap变迁与原理解析（4.x-8.x） 2.3版本之前：存储在本地内存中，不及时回收（recycler()方法），会触发OOM 2.3版本到7.0版本：像素数据和对象数据都存储在堆中 8.0以后：将对象存储在本地内存中（非java内存），通过NativeAllocationRegistry对bitmap进行回收 Fresco 对这个有详细的描述 深拷贝和浅拷贝深拷贝：拷贝堆区中值浅拷贝：拷贝堆区中的引用地址 创建一个对象的方式？ 使用new关键字创建 Class.newInstance反射创建 Constructor.newInstance反射创建 利用clone方法实现（浅拷贝） 通过反序列化实现（深拷贝） 界面卡顿的原因 UI线程存在耗时操作 视图渲染时间过长，导致卡顿 频繁gc，内存抖动 冷启动、温启动、热启动冷启动：app首次启动，或者上次正常关闭后的启动，需要创建app的进程 启动系统进程。加载启动app进程，创建app进程 启动app进程任务。渲染屏幕，加载布局等 温启动：系统进程存在，app非正常关闭，只需要执行第二步，需要创建Activity或者重新布局等 热启动：热启动就是App进程存在，并且Activity对象仍然存在内存中没有被回收。所以热启动的开销最少，这个过程只会把Activity从后台展示到前台，无需初始化，布局绘制等工作 冷启动可以认为是android标准启动流程 Android类加载器Android从ClassLoader中派生出两个类加载器：PathClassLoader和DexClassLoader DexClassLoader：是一个可以从包含classes.dex实体的.jar或.apk文件中加载classes的类加载器。可以用于实现dex的动态加载、代码热更新等等。 PathClassLoader：可以操作在本地文件系统的文件列表或目录中的classes DexClassLoader：能够加载未安装的jar/apk/dexPathClassLoader：只能加载系统中已经安装过的apk 双亲委派当一个类需要被初始化加载时，总会先把加载请求传递给父加载器，最终会传递到最高层加载器进行加载。父类加载器会检查是否加载过该类，如果没有加载过，则加载，若无法加载，会传递给子类加载器加载。 为何要使用双亲委派 首先明确，jvm认为不同加载器加载的类为两个不同的对象，所以为了系统安全性，需要保证相同的类要被同一个类加载器加载 避免了重复加载，如果父类加载过，直接使用父类加载过的类。 能不能自己写个类叫java.lang.System？不可以，通过双亲委派该类名被加载为系统类，不会加载自己写的类。如果非要实现这个效果，需要绕过双亲委派机制，实现自己的类加载器进行加载 插件化 PathClassLoader:只能加载已经安装到Android系统中的apk文件（/data/app目录），是Android默认使用的类加载器。 DexClassLoader:可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现热修复的重点。 阿里系：DeXposed、andfix：从底层二进制入手（c语言）。阿里andFix hook 方法在native的具体字段。art虚拟机上是一个叫ArtMethod的结构体。通过修改该结构体上有bug的字段来达到修复bug方法的目的，但这个artMethod是根据安卓原生的结构写死的，国内很多第三方厂家会改写ArtMethod结构，导致替换失效。腾讯系：tinker：从java加载机制入手。qq的dex插装就类似上面分析的那种。通过将修复的dex文件插入到app的dexFileList的前面，达到更新bug的效果，但是不能及时生效，需要重启。但虚拟机在安装期间会为类打上CLASS_ISPREVERIFIED标志，是为了提高性能的，我们强制防止类被打上标志是否会有些影响性能美团robust：是在编译器为每个方法插入了一段逻辑代码，并为每个类创建了一个ChangeQuickRedirect静态成员变量，当它不为空会转入新的代码逻辑达到修复bug的目的。优点是兼容性高,但是会增加应用体积 startActivity 的时候最终会走到 AMS 的 startActivity 方法 系统会检查一堆的信息验证这个 Activity 是否合法。 然后会回调 ActivityThread 的 Handler 里的 handleLaunchActivity 在这里走到了 performLaunchActivity 方法去创建 Activity 并回调一系列生命周期的方法 创建 Activity 的时候会创建一个 LoaderApk对象，然后使用这个对象的 getClassLoader 来创建 Activity 我们查看 getClassLoader() 方法发现返回的是 PathClassLoader，然后他继承自 BaseDexClassLoader 然后我们查看 BaseDexClassLoader 发现他创建时创建了一个 DexPathList 类型的 pathList对象，然后在 findClass 时调用了 pathList.findClass 的方法 然后我们查看 DexPathList类 中的 findClass 发现他内部维护了一个 Element[] dexElements的dex 数组，findClass 时是从数组中遍历查找的 sqlite怎么保证数据可见性和线程安全性？sqlite不支持多个数据库连接进行写操作，但是使用同一个SQLiteHelper连接，可以进行多线程读和写，同一个连接下，sqlite内部有锁机制，不会出现异常，由于有锁的机制，所以是阻塞的，并不是真正的并发 延伸：SharedPreference是线程安全的，内部使用sychronized的 bundle的数据结构，为什么intent要使用bundle？内部存储ArrayMap，key是int数组，value是object数组，使用Bundle传递对象和对象数组的时候会默认使用序列化，不用我们做处理。 key是hash值，value[]是存储的数据key值，和value值，采用二分法排序，使用二分法查找 优势：省内存，小数据上占优势。 大图传输 文件描述符是一个简单的整数，用以标明每一个被进程所打开的文件和socket。第一个打开的文件是0，第二个是1，依此类推。socket：如果是网络中，会使用ip号+port号方式为套接字地址，但是如果同一台主机上两个进程间通信用套接字,还需要指定ip地址,有点过于繁琐. 这个时候就需要用到UNIX Domain Socket, 简称UDS,UDS不需要IP和Port, 而是通过一个文件名来表示（int, (AF_UNIX,文件路径)） 直接传输Bitmap，Bitmap实现Parcelable序列化，所以可以直接在内存中传输，所以可以直接通过Bundle传输过去，但是限制大小为1M。 可以存储在文件中，传输一个文件路径过去 使用Bundle的putBinder方法，通过Binder发送，其实putBinder传输过去的只是一个文件描述符fd，获取到fd后，从共享内存中获取到Bitmap 而用Intent/bundle直接传输的时候，会禁用文件描述符fd，只能在parcel的缓存区中分配空间来保存数据，所以无法突破1M的大小限制 webviewandroid调用js代码 通过loadUrl的方法直接调用js方法，会刷新页面，没有返回值 evaluateJavascript()方法，android4.4以后使用，不会刷新页面，有返回值 js调用android代码 addJavascriptInterface()方法进行对象映射，存在漏洞 4.2以下 创建一个类，使用@JavascriptInterface注解标识方法，使用addJavascriptInterface()为js创建对象 漏洞： 通过反射获取到这个类的所有方法和系统类，进行获取信息泄漏 4.2后添加注解避免漏洞攻击 webViewClient.shouldOverrideUrlLoading()拦截url 不存在漏洞 在js中传入url，携带参数，拼接到url中，在shouldOverrideUrlLoading获取 触发js弹窗向android发消息。之后再回调中通过2方式的url传输消息 内存泄漏：加弱引用即可 要实现可以拖动的View该怎么做？使用windowManager的updateViewLayout方法吗，实时传入手指的坐标就可以移动window1234567891011121314btn.setOnTouchListener &#123; v, event -&gt; val index = event.findPointerIndex(0) when (event.action) &#123; ACTION_MOVE -&gt; &#123; windowParams.x = event.getRawX(index).toInt() windowParams.y = event.getRawY(index).toInt() windowManager.updateViewLayout(btn, windowParams) &#125; else -&gt; &#123; &#125; &#125; false&#125; Android新知识RxJava响应式编程：根据响应去触发动作 使用观察者模式调用，使用于逻辑复杂的操作可以使用Rxjava做异步处理 按钮短300ms内不允许重复点击 123456RxView.clicks(button).debounce(300, TimeUnit.MILLISECONDS).subscribe(new Action1&lt;Void&gt;() &#123; @Override public void call(Void aVoid) &#123; Log.i(&quot;test&quot;, &quot;clicked&quot;); &#125; &#125;); 轮询，定时执行 1234567//每隔两秒执行一次 Observable.interval(2, 2, TimeUnit.SECONDS).subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; //TODO WHAT YOU WANT &#125; &#125;); 消息传递，可取代EventBus 12345678910111213//发布消息RxBus.getInstance().post(&quot;SomeChange&quot;);//接收消息并处理Subscription mSubscription = RxBus.getInstance().toObserverable(String.class).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; handleRxMsg(s); &#125;&#125;);//取消订阅mSubscription.unsubscribe(); Jetpack一系列辅助android开发者的使用工具，统称Jetpack 提供新组件，比如导航组件，分页组件，切片组件等，例如mvvm中的LiveData，viewmodel都属于Jetpack组件 paging,room,livedata,viewmodel,lifecycler,compose,databinding,viewbinding Jetpack在androidx中进行发布，androidx也属于Jetpack AndroidXandroidx空间中包含Jetpack库， 之前使用android-support-v4(最低支持1.6) 和 android-support-v7（最低支持2.1）库做支持，androidx提出后，对support-v4 和 support-v7库不再做维护 MVVM LiveData使用观察者模式观察生命周期，在onStart和onResume时回调onChanged，确保liveData对象内存泄漏。 DataBind 双向绑定，将view和model进行绑定，一方变化会导致另一方变化。 缺点： 难以排查bug，不知道是view的bug还是model的bug，bug会转移 不能复用view，因为绑定不同的model LiveData+ViewModel替换EventBusViewBinding替换Butterknife组件化，插件化，热修复Kotlin理解ConstraintLayoutJava基础篇指令重排as-if-serial不管指令怎么重排序，在单线程下执行结果不能改变 happens-before一个操作的执行结果需要对另一个操作可见，则两个操作之间必须存在happens-before关系，主要强调在多线程情况中 123456789101112131415public class ControlDep&#123; int a = 0; boolean flag = true; public void init()&#123; a = 1; //1 flag = true; //2 &#125; public void use()&#123; if(flag)&#123; //3 int i = a * a; //4 &#125; &#125;&#125; 存在两个线程A，B，当A执行init发生了重排序，即先执行2，在执行1，当执行2时，B执行了use方法，但是B拿到的a还是0，所以i = 0，而正确的答案应该是i = 1 解决上面问题有两种方案： 内存屏障（volatile），禁止关于a的指令重排 synchronized锁，锁住该对象或者该类 JVM内存模型 本地方法栈，程序计数器，虚拟机栈都是线程私有的，不存在线程安全方法区和堆区，所有线程共享的，需要加锁保证线程安全 程序计数器：占用内存小，线程私有，生命周期与线程相同，大致为字节码行号指示器 虚拟机栈：java方法执行的内存模型，包含局部变量表，操作栈，动态链接，方法出口等信息，用于管理java方法的调用，使用连续的内存空间 本地方法栈：本地方法栈用于管理本地方法的调用 堆区：与jvm生命周期相同，存储所有的对象实例（包括数组） 方法区：存储已被加载的类信息，常量池，静态变量，即使编译器编译后的代码 静态变量创建在方法区，程序结束后回收，与堆无关 stack的大小默认为1M，如果是递归调用，大概只支持800多次 JVM内存模型的三大特性原子性：多线程情况下，一旦一个线程开始执行，就不能被其他线程干扰 可见行：当一个线程修改了变量后及时更新到主存 有序性：处理器在执行运算的时候，会对程序代码进行乱序执行优化，也叫做重排序优化 垃圾回收机制 如何判断对象是个垃圾？ 引用计数法要操作对象必须使用引用，所以通过引用计数来判断对象是否需要被回收。因为无法解决循环引用的问题，所以JAVA中并没有采用这种方式（python中采用） 可达性分析法为了解决循环引用的问题，使用可达性分析。通过一系列的”GC ROOT”对象作为起点进行搜索，如果在”GC ROOT”和对象之间没有可达路径，那么该对象为不可达对象，并标记一次，标记两次后就会被回收。“GC ROOT”： 虚拟机栈中引用的对象（栈帧中的本地变量表）； 方法区中的常量引用的对象； 方法区中的类静态属性引用的对象； 本地方法栈中JNI（Native方法）的引用对象。 活跃线程对象 垃圾回收机制是针对堆区的回收 比较常见的将对象判定为可回收变量 某个引用对象为null12Object obj = new Object();obj = null; 已经指向某个对象的引用指向新的对象123Object obj1 = new Object();Object obj2 = new Object();obj1 = obj2; 局部引用所指向的对象12345678void fun() &#123; ..... for(int i=0;i&lt;10;i++) &#123; Object obj = new Object(); System.out.println(obj.getClass()); &#125; &#125; 循环每执行完一次，生成的Object对象都会成为可回收的对象。 只有弱引用修饰的1WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(new String(&quot;world&quot;)); 垃圾回收算法 标记清除算法将可回收对象标记后指定删除对象缺点：产生大量内存碎片 复制算法为了解决内存碎片的问题，提出复制算法。把内存按容量分成两份，当一份用完了，将还存活的对象复制在另一块对象中，把已使用的内存空间一次性清理掉缺点：空间上的两倍消耗，可使用内存空间减半 标记整理算法为了充分利用内存空间，在标记回收对象后，将存活对象向一端移动，然后清理掉端边界以外的内存 分代回收算法将内存分为新生代，老年代和永久代。新生代：使用复制算法，回收大量对象，但不是按照1:1分配内存空间，将内存空间分为3份，较大的Eden和两块较小的Survivor空间，每次使用Eden和一块Survivor，当进行回收时，会将Eden和一块Survivor中存活的对象复制到另一个Survivor中。（比例为8:1:1）老年代：使用标记整理算法（和标记清除算法—-垃圾收集器种说），回收少量对象永久代：存在于方法区，不属于堆区，用来存储class类，常量，方法描述等，对永久代的回收主要包含两种：废弃常量和无用的类 注意: 在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。 新生代 = 1/3的堆空间大小，老年代 = 2/3的对空间大小 新创建的对象都是在Eden区，大对象因为在新生代复制会影响性能，则直接创建在老年代 在Survivor中复制一次，就年龄计数+1，当年龄大大于15岁时，会移动到老年区 jdk7和jdk8上的JVM内存结构的变化？jdk7: 在物理存储上，堆区和方法区是连续的，但是在逻辑上是分离的，因为物理存储上是存在一起的，所以在Full GC时，会触发堆永久代的回收 jdk8: 取消永久代，将类的结构等信息放入Native内存区，常量池和静态变量/全局变量存储在堆区 方法区存在元空间中，Native内存区就是元空间区 Native Memory（本地内存），空间不足，不会触发gc 为什么使用元空间替代永久代？避免永久代的OOM发生，因为需要加载的类的总数，方法总数难以确定，分配的空间也难以确定，为了避免OOM，使用元空间，理论上可以获得本地内存中所有可用的空间 字符常量池存在那？1.6：存储在方法区1.7：对象存储在堆区中，引用存在字符串常量池，都在堆中1.8：存储在堆区中 运行时常量池在哪？1.8的时候移动到元空间中，之前都在方法区中 垃圾收集器java种使用的是HotSpot虚拟机，HotSpot一共7种垃圾收集器，大致分为3类：新生代收集器：Serial，ParNew，Parllel Scavenge老年代收集器：Serial Old，CMS，Parllel Old回收整个堆的G1收集器 Serial（复制）：新生代单线程收集器，在标记和清理都是单线程，优点是效率高，缺点是停留时间长。 ParNew（复制）：新生代并行收集器，Serial的多线程版本，在多核cpu环境下比Serial表现更好（只有他能和CMS配合） Parllel Scavenge（复制）：新生代并行收集器，追求高吞吐量，高效利用CPU。尽快完成程序的运算任务，适合后台应用等对交互场景要求不高的场景。吞吐量 = 用户线程时间/（用户线程时间+GC线程时间），缩短工作线程的等待时间 Serial Old（标记-整理）：老年代的单线程收集器，老年版的单线程 Parllel Old（标记-整理）：老年代的并行收集器，老年版的Parllel Scavenge CMS（Concurrent Mark Sweep）（标记-清除）：老年代并行收集器，以获取最短回收停顿时间为目标，具有高并发，低停顿的特点。追求最短GC回收停顿时间，就是GC的时间更短缺点： 对CPU资源异常敏感，应用程序变慢，吞吐率下降 无法处理浮动垃圾。因为在标记和清除的时候，工作线程是运行的，所以期间会产生新的垃圾，但是本次无法回收。 产生大量内存碎片，会提前触发Full GC G1（Garbage First）(标记-整理)：java并行收集器，G1的回收范围包含新生代和老年代。他用来作为下一代的收集器，保存新生代和老年代的概念，但是内部将Java堆划分为多个大小相等Region独立区域优点： 并行和并发。使用多个CPU缩短回收停顿时间，与用户线程并发执行 分带收集。独立去管理整个堆区间，能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果 使用标记-整理算法。无内存碎片产生。 可预测的停顿。可以使开发者制定一个时间长度，在该时间长度内，需要完成垃圾回收。 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合 gc的种类和方式 Minor GC：新生代GC 当Eden（[‘id(ə)n]）区放满的时候，触发Minor GC Major GC：老年代GC Full GC：全局GC（青年+老年） System.gc()方法有可能触发Full GC 老年代存储满了 永久代存储满了，触发Full GC，针对常量池的回收和类型的卸载 Minor GC后放入老年代大小&gt;老年代可用内存，即老年代放不下 Minor GC后，放入一个1区中时，放不下，溢出来部分放入老年区，老年区放不下就会触发Full GC GC会触发“stop-the-world”，即工作线程全部关闭，进行gc回收，当gc回收结束后，才会执行任务 HashMap（1）美团面试题：Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析 简述影响性能的两个参数： 初始容量：2的幂，默认是16 加载因子：什么时候扩容的标志，默认0.75，即16*0.75=12的时候开始hashmap扩容（容量为原来的2倍） 最大容量：2的30次方，如果大于，则使用2的30次方的大小 可以存储key == null，value == null，key == null则存储在table[0]位置 删除元素的本质是“删除单向链表的节点” Entry是单向链表 计算key的hash值，并将hash值添加到对应的链表中，若key存在，则更新vlaue值 1234567static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //计算出来的hash值 final K key; //key V value; //value Node&lt;K,V&gt; next; //链表next引用 ...... &#125; 和修改 因为是非synchronized的，非线程安全，所以比较快 HashMap可以接受null键和null值 数组下标index的计算过程12//数组长度-1 &amp; hash值(n - 1) &amp; hash 同等于hash值对数组长度的求余 描述一下具体的put过程 对key求hash值，然后计算数组下标 如果数组下标没有碰撞，将Node放置在数组中 如果碰撞，将Node以链表的形式连接在后面 如果链表长度超过阈值（8），将链表转化为红黑树，链表长度低于6，则将红黑树转回链表 如果节点存在，则替换旧值 如果数组快满了（最大容量16*加载因子0.75），就需要resize（扩容两倍） 为什么选择6和8 ？因为中间7的位置放置频繁的数据结构切换后，影响性能 get方法 计算key的hash，在计算index值 在数组中查找index值，在比对key值，取出value，复杂度最好是O(1)，最坏为O(n) 为什么不直接使用红黑树？空间和时间的选择，链短的时候空间上占用小，时间还好，转化为红黑树后，便于查找，但是耗费空间。 处理hash冲突的方法有以下几种： 开放地址法（线性探测再散列（碰撞后，位置后挪，数组长度+x）x可为正数，二次探测再散列（数组长度+x的平方）x可为正负数，平方后均为正数） 再哈希法（多种计算哈希的方法，相同则替换方法，直到算出不重复的哈希值） 链地址法（链表） 建立公共溢出区（建立一个溢出表，存放冲突的数据） HashMap的性能慢原因？ 数据类型自动装箱问题 resize扩容重新计算index值和hashcode，重新赋值（1.7）1.8后，扩容位置 = hash值 &amp; 数组长度，如果为0，则不动，反之则反 线程不安全会导致什么环状链表，resize（扩容）时头插法导致环形链表（1.7版本） 都存在数据丢失的问题数据丢失，1.8版本修复环形链表（尾插） HashMap中默认容量为什么是2的幂？因为如果不是2的幂，可能会造成更多的hash碰撞（index 下标碰撞）假设n为17，n-1的二进制为10000，01001和01101算出的index值均为0假设n为16，n-1的二进制为01111，01001和01101算出的index值不同 hashcode计算原理对于int类型，hashcode为它本身，eg：int i = 1; hashcode = 1;对于对象来说，hashcode是内部地址和对象值的一个映射 hash()算法原理1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 拿到key的hashCode()，在将该值与该值的高16位（h无符号右移16位）进行亦或运算（相同为0，不同为1） HashTable的理解put和get方法是用了synchronized修饰，锁住了整个map，同一时刻只有一个线程可以操作 不可以存储null值和null健 SparseArray理解原理装箱，int数据类型—-&gt;Integer对象，拆箱，Integer对象—-&gt;int数据类型 默认容量是10 key是int值（避免装箱问题），使用二分查找寻找key，同样也是用二分插入，从小到大排列好的 两个数组，一组存放key（int []），一组存放value(object []) 12mKeys[i] = key;mValues[i] = value; 如果冲突，直接替换value的值 二分插入： 1234567891011121314151617181920212223while (lo &lt;= hi) &#123; //二分法一分而二，数组中间下标 final int mid = (lo + hi) &gt;&gt;&gt; 1; //二分法一分而二，数组中间下标处的值 final int midVal = array[mid]; if (midVal &lt; value) &#123; /** 如果数组中间处的值比要找的值小，代表要找的值 在数组的中后部部分，所以当前下标取值为mid + 1 */ lo = mid + 1; &#125; else if (midVal &gt; value) &#123; /** 如果数组中间处的值比要找的值大，代表要找的值 在数组的前中部部分，所以当前下标取值为mid - 1 */ hi = mid - 1; &#125; else &#123; //数组中间处的值与要找的值相等，直接返回数组中部的下标mid return mid; // value found &#125; &#125; 第一个值放到最中间位置 第二个值如果大于中间的值放置在左边的中间位置 …………. put方法中，容量充足，计算key值所需存放的index，如果key相同，就直接替换value，如果不同，就insert数组，后续index元素后移，新key放置在index上 较HashMap的优点 节省内存 性能更好，避免装箱问题 数据量不达到千级，key为int值，可以用SparseArray替换HashMap SparseArray与HashMap的比较，应用场景是？ SparseArray采用的不是哈希算法，HashMap采用的是哈希算法 SparseArray采用的是两个一维数组分别用于存储键和值，HashMap采用的是一维数组+单向链表/红黑树 SparseArray key只能是int类型，而HashMap可以任何类型 SparseArray key是有序存储（升序），而HashMap不是 SparseArray 默认容量是10，而HashMap默认容量是16 SparseArray 内存使用要优于HashMap，因为： SparseArray key是int类型，而HashMap是Object SparseArray value的存储被不像HashMap一样需要额外的需要一个实体类（Node）进行包装 SparseArray查找元素总体而言比HashMap要逊色，因为SparseArray查找是需要经过二分法的过程，而HashMap不存在冲突的情况其技术处的hash对应的下标直接就可以取到值 针对上面与HashMap的比较，采用SparseArray还是HashMap，建议根据如下需求选取： 如果对内存要求比较高，而对查询效率没什么大的要求，可以是使用SparseArray 数量在百级别的SparseArray比HashMap有更好的优势 要求key是int类型的，因为HashMap会对int自定装箱变成Integer类型 要求key是有序的且是升序 ArrayMap的理解内部也使用二分算法进行存储和查找，设计上更多考虑了内存中的优化 int []存储hash值，array[index]存储key，array[index+1]存储value 数据量最好在千级以内 ArrayMap和SparseArray怎么进行选取？ 如果key为int，那么选取SparseArray进行存储， 不存在封/拆箱问题 如果key不为int，则使用ArrayMap TreeMap的理解TreeMap是一个二叉树的结构，红黑树 不允许重复的key TreeMap没有调优选项，因为其红黑树总保持在平衡状态 TreeMap和HashMap的区别？ TreeMap由红黑树构成，HashMap由数组+链表/红黑树构成 HashMap元素没有顺序，TreeMap元素会根据可以进行升序排序 HashMap进行插入，查找，删除最好，TreeMap进行自然顺序便利或者自定义顺序便利比较好 ThreadLocal的理解面试官：小伙子，听说你看过ThreadLocal源码？（万字图文深度解析ThreadLocal） 线程隔离，数据不交叉 ThreadLocalMap，每个thread都存在一个变量ThreadLocalMap threadLocals threadLocalMap中存在Entry，同ThreadLocal之间为弱引用关系 ThreadLocalMap中key为ThreadLocal的弱引用，value为Entry，内部为一个object对象 table默认大小为16，存在初始容量（16）和阈值（16*2/3） 在ThreadLocal中使用get()和set()方法初始化threadLocals get、set、remove方法将key==null的数据清除 table是环形数组 线性探测法避免哈希冲突，增量查找没有被占用的地方 通过hashcode计算索引位置，如果key值相同，则替换，不同就nextIndex，继续判断，直到插入数据 ThreadLocal就是管理每个线程中的ThreadLocalMap，所以线程隔离了。 ThreadLocalMap的理解新建ThreadLcoal的时候，创建一个ThreadLocalMap对象，计算hash的时候使用0x61c88647这个值，他是黄金分割数，导致计算出来的hash值比较均匀，这样回大大减少hash冲突，内部在采用线性探测法解决冲突set： 根据key计算出数组索引值 遍历该索引值的链表，如果为空，直接将value赋值，如果key相等，直接更新value，如果key不相等，使用线性探测法再次检测。 ThreadLocal使用弱引用的原因key使用了弱引用，如果key使用强引用，那么当ThreadLocal的对象被回收了，但ThreadLocalMap还持有ThreadLocal的强引用，回导致ThreadLocal不会被回收，导致内存泄漏 ThreadLocal的内存泄漏 避免使用static修饰ThreadLocal：延长生命周期，可能造成内存泄漏 ThreadLocal弱引用被gc回收后，则key为null，object对象没有被回收，只有当再次调用set，get，remove方法的时候才会清楚key为null的对象 ThreadLocalMap清理过期key的方式 探测式清理本该放在4的位置上的值，放到了7的位置上，当5过时后，将7的数据挪到5的位置上 启发式清理遍历数组，清理数据 ConcurrentHashMap和HashMap的区别jdk 1.7 ReentrantLock+segments + hashEntry(不可变) 线程安全，分段线程锁，hashtable是整段锁，所以性能有所提高 默认分配16个锁，比Hashtable效率高16倍 hashEnty是final的，不能被修改，只要被修改，该节点之前的链就要重新创建，采用头插插入，所以顺序反转 获取size，因为是多线程访问，所以size会获取三遍，如果前后两个相等就返回，假设不相等，就将Segment加锁后计算。 jdk 1.8 ： synchronized +node+volatile+红黑树 put： 根据key的hash值算出Node数组的相应位置 如果该Node不为空，且当前该节点不处于移动状态，则对节点加synchronized锁，进行遍历节点插入操作 如果是红黑树节点，向红黑树插入操作 如果大于8个，拓展为红黑树 get： 计算hash值，定位到该table索引位置，如果是首节点符合就返回 如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，通知在新表中查找该节点，匹配就返回 以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null 1.7和1.8的区别： 1.7：ReentrantLock+segments + hashEntry(不可变) 1.8：synchronized +node+volatile+红黑树 1.8的锁的粒度更低，锁的是一个链表（table[i]），而1.7锁的是一个小的hashmap（segement） ReentrantLock性能比synchronized差 扩容： 1.7下进行小HashMap（segement）扩容操作 1.8下使用synchrozied节点加锁，所以可以通过多个线程扩容处理。一个线程创建新的ConcurrentHashMap，并设置大小，多个线程将旧的内容添加到新的map中，如果添加过的内容就会设置标记，其他线程就不会处理 为什么只有hashmap可以存储null值和null键因为hashmap是线程不安全的，而在其他中都是线程安全的，在多线程访问时，无法判断key为null是没有找到，还是key为null 锁常见锁锁的分类 公平锁/非公平锁 公平锁：多个线程按照申请锁的顺序获取锁。 非公平锁：多个线程申请锁并不是按照顺序获取锁，有可能先申请后获取锁。（Synchronized） ReentrantLock默认是非公平锁，通过构造传参可设置为公平锁。非公平锁的优点在于吞吐量比公平锁大 可重入锁：又名递归锁，指在外层方法获取锁以后，在进入内层方法也会自动获取锁。12345678synchronized void setA() throws Exception()&#123; Thread.sleep(1000); setB();&#125;synchronized void setB() throws Exception()&#123; Thread.sleep(1000);&#125; 如果不是可重入锁，那么setB方法不会被当前线程执行，容易造成死锁 synchronized是可重入锁 独享锁/共享锁 独享锁：一个锁一次只能被一个线程所持有（ReentrantLock，synchronized） 共享锁：一个锁被多个线程所持有。（ReadWriteLock） 互斥锁/读写锁上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在Java中的具体实现就是ReentrantLock读写锁在Java中的具体实现就是ReadWriteLock 乐观锁/悲观锁 悲观锁：对同一数据的并发操作，一定会发生修改的。（利用各种锁实现） 乐观锁：对同一数据的并发操作，一定不会发生修改的。（无锁编程，CAS算法，自旋实现原子操作的更新） 分段锁是一种锁的设计，并不是具体的锁，在1.7版本的ConcurrentHashMap中，使用分段锁设计，该分段锁又称为Segment，map中每一个链表由ReentrantLock修饰 偏向锁/轻量级锁/重量级锁这三种锁是描述synchronized的三种状态。 偏向锁：一段同步代码一直被一个线程访问，那么会自动获取锁，降低获取锁的代价 轻量级锁：当锁是偏向锁的时候，被另一个线程访问，偏向锁会升级为轻量级锁，其他线程通过自旋的方式获取锁，不会阻塞，提高性能 重量级锁：在轻量级锁的基础上，自旋达到上限就会阻塞，升级为重量级锁，会让其他线程进入阻塞，影响性能。 锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后无法降为偏向锁，这种升级无法降级的策略目的就是为了提高获得锁和释放锁的效率。 自旋锁获取锁的过程中，不会立即阻塞，会采用循环的方式获取锁，减少线程切换上下文的消耗，缺点是循环会消耗cpu java中常用锁的类型 synchronized：非公平，悲观，独享，互斥，可重入，重量级锁 ReentrantLock：默认非公平（可公平），悲观，独享，互斥，可重入，重量级锁 CAS，全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM 只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。 synchronized和volatile简述synchronized的原理可见性：表示A修改的值对于B执行时可以看见A修改后的值 内部使用monitorenter指令，同时只有一个线程可以获取monitor 未获取monitor的线程会被阻塞，等待获取monitor 线程A获取主内存值后加锁，在本地内存更新值（临时区）后，推送到主内存，通过synchronized隐式通知线程B访问主存获取值，在B的把本地内存更新值后推送到主存，重复以上操作。 通过Monitor对象来实现方法和代码块的同步，存在monitorEnter和monitorExit指令，插入程序中，在一个线程访问时，通过Monitor进行线程阻塞 synchronized修饰静态方法、⾮静态方法区别静态方法：该类的对象，new出来的多个实例对象是被一个锁锁住的，多线程访问需要等待 非静态方法：实例对象 volatile修饰成员变量，保证可见性，下一个操作再上一个操作之上。++操作不保证和原子性， 将本地缓存同步到主存中，使其他本地缓存失效，本地缓存通过嗅探检查自己的缓存是否过期。（下一次访问，主存不会主动通知） volatile无法保证原子性，可以使用乐观锁的重试机制进行优化 synchronized和volatile区别 Synchronized 引起线程阻塞，而volatile不会 区别在于，synchronized是隐式通知B去主存获取值，volatile是B主动通过嗅探的方法发现自己的内存过期后去主存做同步 synchronized：先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。 都存在可见性，但是volatile不具备原子性，所以不会造成线程阻塞 假设某一时刻i=10，线程A读取10到自己的工作内存，A对该值进行加一操作，但正准备将11赋给i时，由于此时i的值并未改变，B读取了主存的值仍为10到自己的工作内存，并执行了加一操作，正准备将11赋给i时，A将11赋给了i，由于volatile的影响，立即同步到主存，主存中的值为11，并使得B工作内存中的i失效，B执行第三步，虽然此时B工作内存中的i失效了，但是第三步是将11赋给i，对B来说，我只是赋值操作，并没有使用i这个动作，所以这一步并不会去刷新主存，B将11赋值给i，并立即同步到主存，主存中的值仍为11。虽然A/B都执行了加一操作，但主存却为11，这就是最终结果不是10000的原因。 synchronized修饰方法，类，变量，代码块，volatile只能修饰变量 synchronized修饰不同对象的区别 修饰类：作用的对象是这个类的所有对象 方法：作用对象是这个方法的对象 静态方法：作用对象是这个类的对象 代码块：作用对象是这个代码块的对象 悲观锁和乐观锁（CAS）悲观锁：当前线程获得锁会阻塞其他线程（sychronized） 乐观锁：不会添加锁，会存在三个值内存实际值，内存的旧值，更新的新值，如果内存实际值和旧值相等，则没有线程修改该值，将更新的新值直接赋值给内存，如果不相等，就重新尝试赋值操作（volatile） CAS的缺点： ABA问题，A-&gt;B-&gt;A，乐观锁认为没有变化，都是A，所以直接赋值 重新赋值的话，会导致时间过长。 ReentrantLockCAS+AQS实现，乐观锁 AQS（单链表队列）维护一个等待队列，将获取不到锁的线程放入到队列中进行等待，当当前线程执行结束后，进行出队操作，使用一个volatile的int成员变量（state）来表示同步状态 通过ReentrantLock的Lock方法进行加锁 通过ReentrantLock的unLock方法进行解锁 线程新建线程有几种方式？ new Thread 新建Runnable对象 新建Callable或者Future对象 线程池使用 new Thread的弊端执行一个异步任务你还只是如下new Thread吗？new Thread的弊端如下： 每次new Thread新建对象性能差。 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 缺乏更多功能，如定时执行、定期执行、线程中断。 相比new Thread，Java提供的四种线程池的好处在于： 重用存在的线程，减少对象创建、消亡的开销，性能佳。 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 提供定时执行、定期执行、单线程、并发数控制等功能。 线程池简述线程池 线程的5种状态 NEW：创建一个新线程 RUNNABLE：可运行 BLOCKED：阻塞 WAITING：进入等待状态 TIMED_WAITING：等待结束，重新获取锁 TERMINATED：结束 RUNNING：运行中 READY：就绪 一般来说分为五大状态： 新建（New）：创建线程对象，进入新建状态。eg：Thread thread = new Thread(); 就绪（Runnable）：调用thread.start()方法，随时可被cpu执行 运行（Runnable）：CPU执行线程 阻塞（Blocked）：出于某些原因，cpu放弃线程执行，线程进入暂停状态 等待阻塞：调用wait方法，进行阻塞，线程等待某工作完成 同步阻塞：在获取Synchronized同步锁时，进行等待 其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡（Dead）：堪称执行完毕或者因异常退出，线程死亡，回收 start和run的区别？sleep和wait的区别？join,yield，interrupt start是启动一个线程 run只是Thread的实现方法，主要实现是Runnable的接口回调run方法 sleep不会释放对象锁，只是暂停了线程的运行，当指定时间到了，就恢复运行状态 wait方法放弃对象锁，只有调用了notify()方法，才会重新获取锁，进入运行状态 join方法是规定线程的执行顺序，如果在B线程中调用了A的join方法，那么，直到A执行完毕，才会执行B，按照顺序串行执行。实际内部方法是调用了wait方法，让B处于等待状态，A执行完成后，启动B 注意：wait方法是调用u哦在线程放弃对象锁，所以在B线程调用A的join方法，只是让B等待了。 yield方法，通知cpu该线程任务不紧急，可以被暂停让其他线程运行 interrupt方法，中断通知线程，具体操作由线程执行，根据不同状态，执行不同逻辑 线程t1、t2、t3，如何保证他们顺序执行？t3开始中调用t2.join()，t2开始中调用t1.join()。 t1执行完毕后，t2中t1.join()方法不阻塞，即t1执行完，执行t2中的方法，后续类似使用CountDownLacth，进行计数 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; final Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;t1&quot;); &#125; &#125;); final Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //引用t1线程，等待t1线程执行完 t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;t2&quot;); &#125; &#125;); Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //引用t2线程，等待t2线程执行完 t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;t3&quot;); &#125; &#125;); t3.start(); t2.start(); t1.start(); &#125; 什么是死锁资源竞争互相等待 假设线程A，线程B，资源A，资源B 线程A访问资源A，持有资源A锁，线程B访问资源B，持有资源B锁，而后线程A要访问资源B，但是线程B持有资源B锁，线程A等待，线程B要访问资源A，但是线程A持有资源A锁。所以B等待。 结果就是A、B相互等待对方释放资源，造成死锁。 一个线程崩溃会影响其他线程吗？不一定。如果崩溃发生在堆区（线程共享区域），会导致其他线程崩溃。如果崩溃发生在栈区（线程私有区域），不会导致其他线程的崩溃 java反射 反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化； 每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上； 反射也是考虑了线程安全的，放心使用； 反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销； 反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器； 当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离； 调度反射方法，最终是由jvm执行invoke0()执行； 使用反射从jvm中的二进制码文件中读取数据 反射原理.java–&gt;.class–&gt;java.lang.Class对象 编译过程： 将.java文件编译成机器可以识别的二进制文件.class .class文件中存储着类文件的各种信息。比如版本号、类的名字、字段的描述和描述符、方法名称和描述、是不是public、类索引、字段表集合，方法集合等等数据 JVM从二进制文件.class中取出并拿到内存解析 类加载器获取类的二进制信息，并在内存中生成java.lang.Class对象 最后开始类的生命周期并初始化（先静态后非静态和构造，先父类在子类） 而反射操作的就是内存中的java.lang.Class对象。 总结来说.class是一种有顺序的结构文件,而Class对象就是对这种文件的一种表示，所以我们能从Class对象中获取关于类的所有信息，这就是反射的原理。 为什么反射耗时？ 校验时间长 基本类型的封箱和拆箱 方法内联 什么是内联函数？方法调用过多会进行内敛优化，减少方法的嵌套层级，加快执行，缓解栈的空间存储 反射可以修改final类型的成员变量吗？已知final修饰后不会被修改，所以获取这个变量的时候就直接帮你在编译阶段就给赋值了 编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。 所以上述的getName方法经过JVM编译内联优化后会变成：12345678public String getName() &#123; return &quot;Bob&quot;;&#125;//打印出来也是BobSystem.out.println(user.name)//经过内联优化System.out.println(&quot;Bob&quot;) 反射是可以修改final变量的，但是如果是基本数据类型或者String类型的时候，无法通过对象获取修改后的值，因为JVM对其进行了内联优化。 反射可以修改static值吗？12Field.get(null) 可以获取静态变量。Field.set(null,object) 可以修改静态变量。 Java异常简析java中的异常分为2大类，Error和Exception。Error中有StackOverFlowError和OutOfMemoryError。Exception分为IOException和RuntimeException。 Java中检查型异常和非检查型异常有什么区别？检查型异常 extends Exception（编译时异常）：需要使用try catch进行捕获，否则会出错，继承自Exception 非检查型异常 extends RuntimeException（运行时异常）：不需要捕获，在必要时才会报错， try-catch-finally-return执行顺序？ 不管是否有异常产生，finally块中代码都会执行 当try和catch中有return语句时，finally块仍然会执行 finally是在return后面的表达式运算执行的，所以函数返回值在finally执行前确定的，无论finally中的代码怎么样，返回的值都不会改变，仍然是之前return语句中保存的值 finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值 throw和throws的区别throw用在方法内部，抛出异常 throws用在方法外部，在方法中抛出异常 栈溢出StackOverFlowError发生的几种情况？递归，栈内存存满，函数调用栈太深 Java常见异常有哪些java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。 java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常. java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。 java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。 java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 java.lang.ArithmeticException：算术条 件异常。譬如：整数除零等。 java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。 java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。 java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。 java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。 linux进程通信有几种Linux中的进程间通信有哪些？解释Binder通信为什么高效？Binder通信有什么限制？ Linux中的进程间通信有如下几种： 信号（signal） 消息队列 共享内存（Shared Memory）共享内存允许两个或多个进程进程共享同一块内存(这块内存会映射到各个进程自己独立的地址空间)从而使得这些进程可以相互通信。 管道/命名管道(Pipe)Pipe这个词很形象地描述了通信双方的行为，即进程A与进程B。一根管道同时具有读取端和写入端。比如进程A从write end写入，那么进程B就可以从read end读取数据。 Socket本地和服务端各自维护一个“文件”，在建立连接打开后，向自己的文件中写入数据，供对方读取 Binder通信是Android系统特有的IPC机制，Binder的优点有以下几个： 性能：Binder的效率高，只需要一次内存拷贝；而Linux中的管道、消息队列、套接字都需要2次；共享内存的方式不需要拷贝数据，但是有多进程同步的问题。 稳定性：Binder的架构是基于C/S结构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。 安全性：传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限。从安全角度，Binder的安全性更高。 Binder通信的另外一个限制是最多16个线程。最多只能传输1M的数据，否则会有TransactionTooLarge的Exception。 CountDownLatch原理存在4个线程，想在4个线程都执行完毕后执行另一个线程， countDownLatch是采用计数器的原理，存在两个方法: countDown：计数-1 await：线程挂起，当计数为0时，执行其后的逻辑 Java泛型泛型简述java中泛型即是“参数化类型”，即该泛型类型是一个参数传入 只在程序的源代码中存在，在编译后的字节码中已经替换为原生类型，这种方法称为伪泛型。 java中的泛型只在编译时期有效，正确检验泛型的结果后，会将泛型相关的信息擦出，并在对象进入和离开的方法边界上添加类型检查和类型转化的方法。 123456789List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;(); Class classStringArrayList = stringArrayList.getClass(); Class classIntegerArrayList = integerArrayList.getClass(); if(classStringArrayList==classIntegerArrayList)&#123; //返回true System.out.println(&quot;类型相同&quot;); &#125; 泛型有泛型类、泛型方法和泛型接口 泛型类： 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 泛型接口： 1234567891011121314151617181920212223242526272829303132//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125;/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125;/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125; 泛型方法： 1234567891011121314/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)&#123; T instance = tClass.newInstance(); return instance;&#125; 泛型对方法重载的影响？方法不能进行重载，会报错，两种方法都有相同的擦除，在编译期间进行泛型擦除的，会导致擦出后都一样 1234public class MyMethod &#123; public void listMethod(List&lt;String&gt; list1)&#123;&#125; public void listMethod(List&lt;Integer&gt; list2)&#123;&#125;&#125; 类加载java类的初始化流程父类到子类，静态到（非静态，构造），变量—–&gt;代码块 父类静态变量—-父类静态代码块—-子类静态变量—-子类静态代码块—-父类非静态—-父类构造—-子类非静态—-子类构造 jvm类加载机制的7个流程加载—–验证——准备——解析——初始化——-使用——卸载JVM将.java文件加载成二进制文件.class加载： 获取二进制流class文件 将静态存储结构转换为方法区中运行时的数据结构，存储到方法区中 在堆中生成一个java对象，作为方法区的引用 获取.class文件并在堆中生成一个class对象，将加载的类结构信息存储在方法区 验证：JVM规范校验，代码逻辑校验 准备：为类变量分配内存并设置类变量的初始化，如果变量被final修饰，会直接放入对应的常量池中，并赋值 解析：常量池符号引用替换为内存的直接引用 （上述三种统称为连接） 初始化：执行代码逻辑，对静态变量，静态代码块和类对象进行初始化 使用：使用初始化好的class对象 卸载：销毁创建class对象，负责运行的jvm退出内存 全局变量和局部变量的区别 全局变量应用于整个类文件。局部变量只在方法执行期间存在，之后被回收。静态局部变量对本函数体始终可见 全局变量，全局静态变量，局部静态变量都在静态存储空间。局部变量在栈（虚拟机栈）中分配空间 全局变量初始化需要赋值，局部变量不需要赋值 一个类中不能声明同名全局变量，一个方法中不能声明同名局部变量。若全局变量和局部变量同名，则在方法中全局变量不生效。 大致流程当JVM碰到new字节码的时候，会先判断类是否已经初始化，如果没有初始化（有可能类还没有加载，如果是隐式装载，此时应该还没有类加载，就会先进行装载、验证、准备、解析四个阶段），然后进行类初始化。如果已经初始化过了，就直接开始类对象的实例化工作，这时候会调用类对象的方法。 类初始化的时机 初始化main方法的主类 new 关键字触发，如果类还没有被初始化 访问静态方法和静态字段时，目标对象类没有被初始化，则进行初始化操作 子类初始化过程中，如果发现父类没有初始化，则先初始化父类 通过反射API调用时，如果类没有初始化，则进行初始化操作 第一次调用java.lang.invoke.MethodHandle 实例时，需要初始化 MethodHandle 指向方法所在的类。 类的实例化触发时机 new 触发实例化，创建对象 反射，class.newnIstance()和constructor.newnIstance()方法触发创建对象 Clone方法创建对象 使用序列化和反序列化的机制创建对象 类的初始化和类的实例化的区别类的初始化：为静态成员赋值，执行静态代码块类的实例化：执行非静态方法和构造方法 类的初始化只会执行一次，静态代码块只会执行一次 类的实例化会执行多次，每次实例化执行一次 在类都没有初始化完毕之前，能直接进行实例化相应的对象吗?正常情况下是先类初始化，再类实例化在非正常情况下，比如在静态变量中12345678910111213141516171819202122232425262728public class Run &#123; public static void main(String[] args) &#123; new Person2(); &#125;&#125;public class Person2 &#123; public static int value1 = 100; public static final int value2 = 200; public static Person2 p = new Person2(); public int value4 = 400; static&#123; value1 = 101; System.out.println(&quot;1&quot;); &#125; &#123; value1 = 102; System.out.println(&quot;2&quot;); &#125; public Person2()&#123; value1 = 103; System.out.println(&quot;3&quot;); &#125;&#125; 执行public static Person2 p = new Person2();这样就会直接实例化，然后在执行类的初始化，所以会打印123123 多线程进行类的初始化会出问题吗？不会，类初始化方法是阻塞的，多线程访问，只会有一个线程执行，其他阻塞。 一个实例变量在对象初始化的过程中最多可以被赋值几次？4次 对象被创建时候，分配内存会把实例变量赋予默认值，这是肯定会发生的。 实例变量本身初始化的时候，就给他赋值一次，也就是int value1=100。 初始化代码块的时候，也赋值一次。 构造函数中，在进行赋值一次。12345678910111213public class Person3 &#123; public int value1 = 100; &#123; value1 = 102; System.out.println(&quot;2&quot;); &#125; public Person3()&#123; value1 = 103; System.out.println(&quot;3&quot;); &#125;&#125; 屏幕高刷手机，60hz，120hz指的是什么？屏幕刷新率，1s内屏幕刷新的次数。这个参数由手机硬件决定一般大于60hz的就是高刷收集，特点在于刷新频率更高，就算存在丢帧、卡顿，也能保持稳定性。 屏幕的刷新过程从左到右，从上到下，顺序显示像素点。当整个屏幕刷新完毕，即一个垂直刷新周期后，（1000/60）16ms后再次刷新一般一个图形界面的绘制，需要CPU准备数据，然后GPU进行绘制，绘制完写入缓存区，然后屏幕按照刷新频率来从这个缓存区中取图形显示。 所以整个刷新过程是CPU，GPU，屏幕（Display）三方合作的工作关系。 帧率，VSYNC是什么帧率：GPU一秒内渲染绘制的操作的帧数，单位是fps，所以一般帧数和屏幕刷新度保持一致是效果最好的情况，不会导致一方浪费 VSYNC：垂直同步，作用是让帧率和屏幕刷新率保持一致，防止卡顿和跳帧。由于CPU和GPU绘制图像的时间不稳定，所以可能会发生卡顿情况，也就是下一帧的数据还没准备好无法正常显示在屏幕上，设置垂直同步后，要求CPU和GPU在16ms之内将下一帧的数据处理好，那么屏幕刷新的时候就可以直接从缓存中获取下一帧的数据并显示出来 屏幕中单缓存，双缓存，三缓存 单缓存：CPU计算好数据传递给GPU，GPU图像绘制后放到缓存区，display从缓存中获取数据并刷新屏幕缺点：当第二帧的数据还没生成完成时，会导致屏幕中有一部分第一帧的数据，导致一个屏幕同时显示了两帧的数据 双缓存：CPU计算好数据传递到GPU，GPU图像会之后放入缓存区BackBuffer，当到达VSYNC垂直同步时间，将数据同步到缓存区FrameBuffer中，display从缓存区FrameBuffer中获取数据并显示缺点：如果在一个垂直同步的时间内CPU+GPU没有渲染完成（开始绘制的时间在下次垂直同步时间附近，导致只有一小份垂直同步时间在绘制），就会浪费一个VSYNC垂直同步时间，当VSYNC垂直同步时间来临时，GPU正在处理数据，那么不会开启下一帧的处理，当GPU处理结束后，无法触发下一帧的数据处理，就会导致卡顿的情况 三缓存数据：当在一个垂直同步时间内没有完成处理，就会出现第三个缓存区，在第二个垂直同步时间，缓存下一帧的数据，这样两个缓存交替处理，保证FrameBuffer会拿到最新的数据，保证了显示的流畅度 代码中修改了UI，屏幕是怎么进行刷新的？当调用invalidate/requestLayout中进行重绘工作时，会向VSYNC垂直同步服务请求，等待下一次VSYNC垂直同步时间，执行界面绘制刷新操作，CPU-&gt;GPU-&gt;Display 如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？屏幕不会刷新，不会重新绘制，如果屏幕不变，程序就收不到垂直同步时间，自动过滤，不处理屏幕刷新操作，只有当界面改变时，才会请求VSYNC垂直同步服务，触发下一次VSYNC垂直同步刷新屏幕 jvm垃圾回收机制首先介绍4个引用 强引用：在使用时不会被回收 软引用：系统内存不足时会被回收 弱引用：下一次gc会被回收 虚引用：任何时候都可能被回收 小知识点抽象类和接口的区别 抽象类中可包含普通方法+实现，接口类中只存在抽象方法，没有具体实现 抽象类中的值可以是任何类型的，接口中的值必须是public static final修饰的 一个类只能继承一个抽象类，一个类可以实现多个接口类 抽象类存在构造函数，接口类没有 抽象类中包含初始化块，接口中没有 static和final的区别static 是可以直接调用的（类名.方法/变量）， 可修饰属性，方法，代码段，内部类 所有对象只有一个值 final 可修饰属性，方法，类，局部变量 final修饰变量不可被更改值，方法不能被重写，类不能被继承 修饰集和的话，其引用不变，集和可以自由变化 java是值传递还是引用传递如果是基本类型就是值传递 引用类型就是引用传递 String表现为值传递，但是其实是作为形参后重新创建了对象，引用已经变化，所以是值传递 123456789public void test() &#123; String str = &quot;123&quot;; changeValue(str); System.out.println(&quot;str值为: &quot; + str); // str未被改变，str = &quot;123&quot;&#125;public changeValue(String str) &#123; str = &quot;abc&quot;;&#125; 123456789101112131415public void test() &#123; Student student = new Student(&quot;Bobo&quot;, 15); changeValue1(student); // student值未改变，不为null! 输出结果 student值为 name:Bobo、age:15 // changeValue2(student); // student值被改变，输出结果 student值为 name:Lily、age:20 System.out.println(&quot;student值为 name: &quot; + student.name + &quot;、age:&quot; + student.age);&#125;public changeValue1(Student student) &#123; student = null;&#125;public static void changeValue2(Student student) &#123; student.name = &quot;Lily&quot;; student.age = 20;&#125; String、StringBuilder、StringBuffer的区别String是不可变的，每次赋值都是重新创建对象，对内存和性能都有损耗 StringBuilder是非线程安全的，存储通过一个可变长度的字符数组（char[]）。 append值时，如果所需长度大于分配长度，新建数组长度为（2倍+2），如果所需长度大于(2倍+2)，则使用所需长度大小，否则，使用(2倍+2)长度，默认长度为16，有参构造=16+参数长度 StringBuffer是线程安全的 效率上由快到慢：StringBuilder &gt; StringBuffer &gt; String String为什么是final（不可变）的？final+private保证了其不可修改性 不可变性保证了线程安全 不可变后避免了深拷贝，将String值放在字符串常量池（堆内）中，供其他方引用，提高效率，节约内存 hashcode、equals和== 的区别？hashcode： 基本类型就是改值 引用类型是对象在内存地址的映射 equals： 在object中equals方法等效于== 在其他方法中，重写了equals方法，会判断值是否相等 ==： 基本类型比对的是值 引用对象比对的是内存地址的映射 对于String，Integer对象，他们重写了equals方法，所以其equals方法可以判断值是否相等，而==只能判断引用是否相等 进程，线程，协程的区别？阻塞和非阻塞的区别？进程进程包含线程进程是CPU分配资源的最小单位 线程线程包含协程线程是独立运行和独立调度的基本单位（CPU上真正执行的是线程）线程间共享进程内资源线程的调度切换比进程快 协程协程是存在线程之上，通过异步IO处理执行多个协程的操作协程的调度切换比线程快 阻塞与非阻塞阻塞就是线程被cpu挂起，不执行线程逻辑非阻塞就是线程不被cpu挂起，执行线程逻辑 并发和并行并发是你执行一下，我执行一下，轮着执行并行是一起执行 协程和线程的比较 协程运行在线程之上 线程执行由内核控制（内核态执行），控制线程切换消耗资源（抢先式），协程由程序执行（也就是在用户态执行） 协程比线程更加轻量 多核处理器的情况下，多个线程是可以并行的，但是运行的协程的函数却只有一个，其他协程都会被suspend（阻塞）。即协程是并发的，但不是并行的。 执行密集型IO操作，性能提高 在协程之间的切换不需要涉及任何系统调用或任何阻塞调用 IO 多路复用IO 执行A事件，同时执行B事件，通过状态下发，获取A，B执行状态 信号驱动IO 异步IO 执行A事件，通过异步处理，当A事件处理完成不哦，通知主进程/线程 阻塞IO： 执行完A事件，在执行B事件 非阻塞IO 执行A事件，同时执行B事件，一直监听A，B的执行过程 Kotlinkotlin协程？kotlin协程使用Coroutine，通过使用函数挂起(非阻塞挂起)的方式来保证协程的使用，内部使用状态机来管理协程的挂起点 每当遇到suspend修饰的方法，都有可能会挂起当前的协程，通过GlobalScope.launch或者其他方式执行suspend修饰的方法时，进行挂起操作 suspend，runBlocking，launch，withContext，async，doAsync之间的区别suspend：挂起函数的标志 runBlocking：阻塞式全局协程 launch：非阻塞全局协程 withContext：任务是串行的 async：任务是并行的 doAsync：封装java的Future类，便于线程切换的，并非协程 网络篇HTTP和HTTPS简述一次完整的Http请求过程通过域名请求后————&gt;DNS域名解析为ip地址————&gt;中间路由跳转————&gt;直接访问ip地址进行三次握手————&gt;tcp三次握手成功后进行通信响应———&gt;tcp四次挥手结束通信 客户端： 在浏览器输入网址。 浏览器解析网址，并生成http请求消息。 浏览器调用系统解析器，发送消息到DNS服务器查询域名对应的ip。 拿到ip后，和请求消息一起交给操作系统协议栈的TCP模块。 将数据分成一个个数据包，并加上TCP报头形成TCP数据包。 TCP报头包括发送方端口号、接收方端口号、数据包的序号、ACK号。 然后将TCP消息交给IP模块。 IP模块会添加IP头部和MAC头部。 IP头部包括IP地址，为IP模块使用，MAC头部包括MAC地址，为数据链路层使用。 IP模块会把整个消息包交给网络硬件，也就是数据链路层，比如以太网，WIFI等。 然后网卡会将这些包转换成电信号或者在光信号，通过网线或者光纤发送出去，再由路由器等转发设备送达接收方。 服务器端： 数据包到达服务器的数据链路层，比如以太网，然后会将其转换为数据包（数字信号）交给IP模块。 IP模块会将MAC头部和IP头部后面的内容，也就是TCP数据包发送给TCP模块。 TCP模块会解析TCP头信息，然后和客户端沟通表示收到这个数据包了。 TCP模块在收到消息的所有数据包之后，就会封装好消息，生成相应报文发给应用层，也就是HTTP层。 HTTP层收到消息，比如是HTML数据，就会解析这个HTML数据，最终绘制到浏览器页面上。 简述三次握手和四次挥手三次握手：客户端发送一个随机seq=100服务端返回一个随机seq=200，ack=100+1客户端返回一个ack=200+1 四次挥手：客户端发送一个FIN=1，seq=100服务端发送一个ack=100+1服务端发送一个FIN=1，seq=200客户端发送一个ack=200+1 服务端发送两次的原因是需要等待服务器处理当前任务完毕。 为什么需要三次握手而不是2次或者4次？ 防止已失效的连接请求又传送到服务器端，因而产生错误 两次的话，服务端是不知道自己的请求是否成功发送到客户端的。但是服务端又会认为连接建立成功了。假设第二次丢失了，客户端认为服务端没有响应，就会重发一次，这样已经失效的连接请求就会传送到服务端。 tcp是可靠的双方通信协议，所以双方都会生成一个初始的序列号供双方确认，如果改成两次，只会确定客户端对于服务端具有可靠性，而服务端对客户端没有可靠性 四次的话，太过繁琐 为什么握手需要三次？挥手却需要四次？因为挥手的时候需要等待服务器将本次连接中的所有保文都处理完，在发送关闭状态，说白了，服务器需要等待自身进入可关闭状态 握手可以携带数据信息吗？第三次请求可以携带数据信息，客户端认为连接已经建立的，就可以携带参数，但是前两次不能，容易造成对服务器的攻击 为什么TIME_WAIT状态需要等待2MSL才能转换到CLOSE状态？ 保证最后一次能成功到达服务器。最后一次客户端发送给服务端的确认信息可能丢失，如果丢失，服务端会有重试机制，等待一来一回的时间，也就是2MSL的时间，如果没有接收到服务端的重试请求，就认为服务端接收了，等到了就刷新2MSL时间 等待2MSL的时间也是为了防止失效连接的请求报文会出现在新连接中，防止第三次重试请求能被客户端接受，不会干扰其他请求 SSL层在传输层还是应用层？SSL层在传输层和应用层之间，是一个SSL层 滑动窗口？拥塞控制？TCP和UDP的区别？1、基于连接与无连接； 2、对系统资源的要求（TCP较多，UDP少）； 3、UDP程序结构较简单； 4、流模式与数据报模式 ； 5、TCP保证数据正确性，UDP可能丢包； 6、TCP保证数据顺序，UDP不保证。 常见状态码 1XX - 临时消息。服务器收到请求，需要请求者继续操作。 2XX - 请求成功。请求成功收到，理解并处理。 3XX - 重定向。需要进一步的操作以完成请求。 4XX - 客户端错误。请求包含语法错误或无法完成请求。 5XX - 服务器错误。服务器在处理请求的过程中发生了错误。 200：客户端请求成功301：资源（网页等）被永久转移到其他URL302：重定向，临时跳转400：客户端请求存在语法错误，不能给被服务器理解（Bad Request）404：请求资源不存在，错误的URL500：服务器内部发生了不可预料的错误502：网关错误（Bad Getway）503：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。（Server Unavailable） 简述TCP和UDP的区别TCP：需要数据准确、顺序不能错、要求稳定可靠的场景就需要用到TCP。UDP：数据即时性 sockettcp内部是由socket协议填充的 简述https的加密过程RSA是非对称加密，AES是对称加密 客户端请求服务端进行访问 服务端创建RSA，获得私钥和公钥 服务端发送公钥给客户端 客户端经过复杂的证书验证 客户端生成AES密钥 将AES密钥经过RSA公钥加密后发送给服务端 服务端通过RSA私钥解密获取AES密钥 客户端和服务端后续通过AES密钥进行通信 为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？因为RSA加密有性能上的损耗，加解密过程会比较耗时，不适用于频繁通信过程，而AES加密比较快捷 简述中间人攻击，如何解决？（dns劫持） 客户端访问域名A，向服务端进行请求 中间人劫持dns，使之指向私人ip B。即客户端同B建立https连接 B在和A建立https连接 服务端创建RSA，获得公钥（S）和私钥（S） 服务端发送公钥（S）给客户端 中间人拦截信息，获得公钥（S） 生成RSA公钥（中）和私钥（中），并将公钥（中）发送给客户端 客户端生成AES密钥 使用公钥（中）加密AES密钥，并发送给服务端 中间人拦截信息，获得加密信息，使用私钥（中）进行解密，获得AES密钥 中间人使用公钥（S）加密AES密钥，并发送给服务端 服务端通过私钥（S）进行解密，获得AES密钥。 到此为止，中间人持有客户端和服务端交换的AES密钥，可以进行消息拦截，并解密信息 解决方案：将RSA公钥交给CA机构，CA机构添加上域名，有效期等将其制作成证书，在用CA机构的私钥进行加密后放置在服务器上，当客户端请求时，返回加密后信息，客户端从CA机构获取公钥（一般情况下内置在机器中）进行解密，成功解密后，获取的信息，域名等可以匹配上，则CA验证通过，获得服务器公钥，走下面流程。 https 无法防止中间人攻击，只有做证书固定ssl-pinning 或者 apk中预置证书做自签名验证可以防中间人攻击 证书固定（Certificate Pinning）是指Client端内置Server端真正的公钥证书。在HTTPS请求时，Server端发给客户端的公钥证书必须与Client端内置的公钥证书一致，请求才会成功。 http分层 dns污染国家或地区防止摸一个网站被访问，是dns发送出错误的ip地址，使之无法访问 使用代理服务器和vpn http1.0、http1.1和http2.0的区别1.0：短暂连接，重复访问，连接无法复用 1.1：支持持久连接，长连接，优化1.0带来的性能问题，可以多路复用（数量限制），串行处理，一条失败，后续全部失败，同步 2.0：优化多路复用机制，header压缩，并行处理，异步 3.0：UDP 算法篇 排序方法 时间复杂度（平均） 时间复杂度（最坏) 时间复杂度（最好) 空间复杂度 稳定性 复杂性 直接插入排序 O(n2)O(n2) O(n2)O(n2) O(n)O(n) O(1)O(1) 稳定 简单 希尔排序 O(nlog2n)O(nlog2n) O(n2)O(n2) O(n)O(n) O(1)O(1) 不稳定 较复杂 直接选择排序 O(n2)O(n2) O(n2)O(n2) O(n2)O(n2) O(1)O(1) 不稳定 简单 堆排序 O(nlog2n)O(nlog2n) O(nlog2n)O(nlog2n) O(nlog2n)O(nlog2n) O(1)O(1) 不稳定 较复杂 冒泡排序 O(n2)O(n2) O(n2)O(n2) O(n)O(n) O(1)O(1) 稳定 简单 快速排序 O(nlog2n)O(nlog2n) O(n2)O(n2) O(nlog2n)O(nlog2n) O(nlog2n)O(nlog2n) 不稳定 较复杂 归并排序 O(nlog2n)O(nlog2n) O(nlog2n)O(nlog2n) O(nlog2n)O(nlog2n) O(n)O(n) 稳定 较复杂 基数排序 O(d(n+r))O(d(n+r)) O(d(n+r))O(d(n+r)) O(d(n+r))O(d(n+r)) O(n+r)O(n+r) 稳定 较复杂 冒泡排序(BubbleSort)依次比较两个相邻的元素，如果顺序错误就交换，直到跑完所有元素，那么最后一个元素就是最大（最小）的值，在接着按照上述操作进行排序。 时间复杂度：O(n^2) 12345678910111213private void bubbleSort(int a[])&#123; int temp; for(int i = 0;i&lt;a.length-1;i++)&#123; for(int j = 0;j&lt;a.length-1-i;j++)&#123; if(a[j]&gt;a[j+1])&#123; temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125; &#125; 选择排序第一趟找出最小的放在第一个，第二趟找出第二小的放在第二个，。。。。。 时间复杂度：O(n^2) 1234567891011public static void selectSort(int a[])&#123; for(int i = 0;i&lt;a.length;i++)&#123; for(int j = i+1;j&lt;a.length;j++)&#123; if(a[i]&gt;a[j])&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; &#125; &#125; 快速排序（QuickSort）分治法：将一大块分解成若干小块，一块一块算 设置一边的值为哨兵 将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 在对剩下的区间进行排序 123456789101112131415161718192021222324252627282930313233343536private void quickSort(int a[],int left,int right)&#123; //结束条件 if(left &lt;right)&#123; //每一趟排序 int base = division(a,left,right); //哨兵两边开始排序 //左边 quickSort(a,left,base-1); //右边 quickSort(a,base+1,right); &#125;&#125;//使用分治法排序private int division(int a[],int left,int right)&#123; //哨兵 int base = a[left]; while (left&lt;right)&#123; //哨兵在左边，所以right左移 while(left&lt;right &amp;&amp; a[right]&gt;=base)&#123; right--; &#125; if(left != right) &#123; a[left] = a[right]; &#125; //哨兵在右边，所以left右移 while(left&lt;right &amp;&amp; a[left]&lt;=base)&#123; left++; &#125; if(left != right) &#123; a[right] = a[left]; &#125; &#125; a[left] = base; return left;&#125; 二分插入： 1234567891011121314151617181920212223while (lo &lt;= hi) &#123; //二分法一分而二，数组中间下标 final int mid = (lo + hi) &gt;&gt;&gt; 1; //二分法一分而二，数组中间下标处的值 final int midVal = array[mid]; if (midVal &lt; value) &#123; /** 如果数组中间处的值比要找的值小，代表要找的值 在数组的中后部部分，所以当前下标取值为mid + 1 */ lo = mid + 1; &#125; else if (midVal &gt; value) &#123; /** 如果数组中间处的值比要找的值大，代表要找的值 在数组的前中部部分，所以当前下标取值为mid - 1 */ hi = mid - 1; &#125; else &#123; //数组中间处的值与要找的值相等，直接返回数组中部的下标mid return mid; // value found &#125; &#125; 插入排序 从尾部开始遍历，每次–，比他大的值后移一位，直到找到相等或者比它小的，直接赋值 1 扑克牌算法根节点到目标节点的路径找出最小的k个数 使用快速排序：O(nlogn) 1234567891011121314151617181920212223242526272829303132333435 public static int[] getLeastNumbers1(int[] input, int k) &#123; if (input == null || input.length &lt; k) &#123; return null; &#125; int[] output = new int[k]; pivotFindMinK(input, output, k, 0, input.length - 1); return output;&#125;private static void pivotFindMinK(int[] numbers, int[] output, int k, int start, int end) &#123; if (numbers == null || numbers.length == 0) &#123; return; &#125; int left = start; int right = end; int temp = numbers[left]; while (left &lt; right) &#123; while (numbers[right] &gt; temp &amp;&amp; left &lt; right) &#123; right--; &#125; numbers[left] = numbers[right]; while (numbers[left] &lt;= temp &amp;&amp; left &lt; right) &#123; left++; &#125; numbers[right] = numbers[left]; &#125; numbers[left] = temp; if (left &gt; k-1) &#123; pivotFindMinK(numbers, output, k, start, left - 1); &#125; else if (left &lt; k-1) &#123; pivotFindMinK(numbers, output, k, right + 1, end); &#125; else &#123; System.arraycopy(numbers, 0, output, 0, k); &#125;&#125; 新建一个数组，放入数组前k个数，并由小到大排列好，遍历原数组，如果存在比新数组中的值更小，插入排序，而后得到新数组。 小根堆实现，按顺序放入小根堆—大顶堆（父节点&lt;=子节点），小根堆大小为k，超过大小，删除堆顶元素，相反的话，加入大根堆—小顶堆（父节点&gt;=子节点） 二分查找法1234567891011121314151617181920212223/** * 使用递归的二分查找 *title:recursionBinarySearch *@param arr 有序数组 *@param key 待查找关键字 *@return 找到的位置 */ public static int recursionBinarySearch(int[] arr,int key,int low,int high)&#123; if(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123; return -1; &#125; int middle = (low + high) / 2; //初始中间位置 if(arr[middle] &gt; key)&#123; //比关键字大则关键字在左区域 return recursionBinarySearch(arr, key, low, middle - 1); &#125;else if(arr[middle] &lt; key)&#123; //比关键字小则关键字在右区域 return recursionBinarySearch(arr, key, middle + 1, high); &#125;else &#123; return middle; &#125; 一个整形数组里求两个数的和能不能等于一个给定数 如果数组是有序的，两个下标，如果相加大于给定数，左边–，如果小于给定数，右边++，直到数据相等或者右边等于左边 1234567891011121314int[] a = &#123;1,4,5,7,9,12,56,456&#125;;int i = 0;int j = a.length-1;int sum = 65;while(i&lt;j)&#123; if(a[i] + a[j] &gt;sum)&#123; j--; &#125;else if(a[i] + a[j] &lt;sum)&#123; i++; &#125;else&#123; System.out.println(a[i] + &quot;+&quot; + a[j] + &quot;=&quot; + sum); break; &#125;&#125; 如果数组是无序的 123456789101112public static void twoSum(int[] nums,int target)&#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0;i&lt;nums.length;i++)&#123; System.out.println(&quot;--------&quot;); if(map.containsKey(nums[i]))&#123; System.out.println(nums[map.get(nums[i])] + &quot;+&quot; + nums[i] + &quot;=&quot; + target); break; &#125; int value = target-nums[i]; map.put(value,i); &#125; &#125; 连续子数组的最大和123456789101112131415public int maxSubArray(int[] nums) &#123; int max = nums[0]; int sum = nums[0]; for(int i = 1;i&lt;nums.length;i++)&#123; if(nums[i] + sum &lt; nums[i])&#123; sum = nums[i]; &#125;else&#123; sum +=nums[i]; &#125; if(sum &gt; max)&#123; max = sum; &#125; &#125; return max;&#125; 摩尔投票法12345678910class Solution &#123; public int majorityElement(int[] nums) &#123; int x = 0, votes = 0; for(int num : nums)&#123; if(votes == 0) x = num; votes += num == x ? 1 : -1; &#125; return x; &#125;&#125; 二叉树二叉树遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//层序遍历 public void levelOrder(BinaryTreeNode root) &#123; BinaryTreeNode temp; Queue&lt;BinaryTreeNode&gt; queue = new LinkedList&lt;BinaryTreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; temp = queue.poll(); System.out.print(temp.getData() + &quot;\\t&quot;); if (null != temp.getLeft()) queue.offer(temp.getLeft()); if (null != temp.getRight()) &#123; queue.offer(temp.getRight()); &#125; &#125; &#125;//前序遍历递归的方式 public void preOrder(BinaryTreeNode root) &#123; if (null != root) &#123; System.out.print(root.getData() + &quot;\\t&quot;); preOrder(root.getLeft()); preOrder(root.getRight()); &#125; &#125; //前序遍历非递归的方式 public void preOrderNonRecursive(BinaryTreeNode root) &#123; Stack&lt;BinaryTreeNode&gt; stack = new Stack&lt;BinaryTreeNode&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; BinaryTreeNode node = stack.pop(); System.out.print(node.getData() + &quot;\\t&quot;); if (node.getRight() != null) &#123; stack.push(node.getRight()); &#125; if (node.getLeft() != null) &#123; stack.push(node.getLeft()); &#125; &#125; &#125; //中序便利非递归 public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null)&#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); if(node.left != null)&#123; stack.add(node); stack.add(node.left); &#125;else&#123; list.add(node.val); if(node.right != null)&#123; stack.add(node.right); &#125;else&#123; while(!stack.isEmpty())&#123; TreeNode node1 = stack.pop(); list.add(node1.val); if(node1.right != null)&#123; stack.add(node1.right); break; &#125; &#125; &#125; &#125; &#125; return list; &#125; //后序遍历 public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if(root == null)&#123; return new ArrayList&lt;&gt;(); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); list.add(node.val); if(node.left != null)&#123; stack.add(node.left); &#125; if(node.right != null)&#123; stack.add(node.right); &#125; &#125; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i = list.size()-1;i&gt;=0;i--)&#123; result.add(list.get(i)); &#125; return result; &#125; //之字形打印 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; listList = new ArrayList&lt;&gt;(); if(root == null)&#123; return listList; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int i = 1; while(!queue.isEmpty())&#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); int count = queue.size(); for(int j = 0;j&lt;count;j++)&#123; TreeNode node = queue.poll(); if(i%2 == 0)&#123; list.addFirst(node.val); &#125;else&#123; list.add(node.val); &#125; if(node.left != null)&#123; queue.add(node.left); &#125; if(node.right != null)&#123; queue.add(node.right); &#125; &#125; i++; if(list.size()&gt;0)&#123; listList.add(list); &#125; &#125; return listList; &#125; 两个view第一个公共父view 引入set集和，一个用来存贮a数据，将b放入a数组，当数组重复会返回false，放入另一个set中做返回。 12345678910111213141516public static Set&lt;Integer&gt; getIds(Integer[] a, Integer[] b)&#123; Set&lt;Integer&gt; same = new HashSet&lt;Integer&gt;(); //用来存放两个数组中相同的元素 Set&lt;Integer&gt; temp = new HashSet&lt;Integer&gt;(); //用来存放数组a中的元素 for (int i = 0; i &lt; a.length; i++) &#123; temp.add(a[i]); //把数组a中的元素放到Set中，可以去除重复的元素 &#125; for (int j = 0; j &lt; b.length; j++) &#123; //把数组b中的元素添加到temp中 //如果temp中已存在相同的元素，则temp.add（b[j]）返回false if(!temp.add(b[j])) same.add(b[j]); &#125;&#125; 如果想知道两个数组的索引，使用map存储，key是值，value是数组索引，在进行map.containsKey()对比，找到则使用 将a数组放入set中，将b轮询放入set中，返回false，则重复值 12345678910111213public static void getIds(int a[], int b[]) &#123; Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(); for(Integer integer:a)&#123; set1.add(integer); &#125; for(Integer j:b)&#123; if(!set1.add(j))&#123; System.out.println(j); break; &#125; &#125; &#125; 两个链表中第一个根节点 两个指针分别跑两条链，短的跑完后，将长的头赋值过去，再开始跑，长的跑完亦然，最终两指针相交地方为两链表的第一个根节点 1234567891011121314151617public static void getNode(Node nodeA, Node nodeB) &#123; Node pA = nodeA; Node pB = nodeB; while (pA != pB) &#123; if (pA.next == null) &#123; pA = nodeB; &#125; else &#123; pA = pA.next; &#125; if (pB.next == null) &#123; pB = nodeA; &#125; else &#123; pB = pB.next; &#125; &#125; System.out.print(pA.value); &#125; 二叉树的最近公共祖先123456789101112131415161718192021222324252627282930class Solution &#123; TreeNode node; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; dps(root,p,q); return node; &#125; public boolean dps(TreeNode root, TreeNode p, TreeNode q)&#123; if(root == null)&#123; return false; &#125; if(root.val == p.val)&#123; node = p; return true; &#125; if(root.val == q.val)&#123; node = q; return true; &#125; boolean a = dps(root.left,p,q); boolean b = dps(root.right,p,q); if(a &amp;&amp; b)&#123; node = root; &#125; if(a || b)&#123; return true; &#125; return false; &#125;&#125; 判断链表是不是环链，并返回入口两个指针，一个一次跑一个，一个一次跑两个，相交的话就是存在环链 将跑的慢的从头开始一个一个跑，跑的快的从相交的点开始跑，一个一个跑，最终相遇的就是入口 12345678910111213141516public static Node isCircle(Node node) &#123; Node p = node; Node q = node; while (p != null &amp;&amp; q != null) &#123; p = p.next.next; q = q.next; if(p == q)&#123; while(node != p)&#123; node = node.next; p = p.next; &#125; return node; &#125; &#125; return p; &#125; 有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变转化成链表，遍历链表将复苏和单独成链后连接到剩下的正数链上 数组两个索引，一个索引记录负数的尾部，一个所以负责遍历，每找到一个负数，将其插入该值，后续值后移一位。 1234567891011121314151617public static void get(int a[])&#123; for(int i = 0,j = 0;j&lt;a.length;j++)&#123; if(a[j]&lt;0)&#123; int temp = a[j]; int k = j; while(i&lt;=k-1)&#123; a[k] = a[k-1]; k--; &#125; a[i] = temp; i++; &#125; &#125; for(int i:a)&#123; System.out.println(i); &#125; &#125; 打印蛇形矩阵123456789101112131415161718class Solution &#123; public int[] spiralOrder(int[][] matrix) &#123; if(matrix.length == 0) return new int[0]; int l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1, x = 0; int[] res = new int[(r + 1) * (b + 1)]; while(true) &#123; for(int i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; // left to right. if(++t &gt; b) break; for(int i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; // top to bottom. if(l &gt; --r) break; for(int i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; // right to left. if(t &gt; --b) break; for(int i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; // bottom to top. if(++l &gt; r) break; &#125; return res; &#125;&#125; 求二叉树的叶子节点数12345678910public int testTree(Tree tree)&#123; if(tree==null)&#123; return 0; &#125; if(tree.left==null&amp;&amp;tree.right==null)&#123; System.out.println(&quot;叶子节点：&quot;+tree.val); return 1; &#125; return testTree(tree.left)+testTree(tree.right); &#125; 求二叉树的深度1234567891011public static int treeDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; // 计算左子树的深度 int left = treeDepth(root.left); // 计算右子树的深度 int right = treeDepth(root.right); // 树root的深度=路径最长的子树深度 + 1 return left &gt;= right ? (left + 1) : (right + 1); &#125; 动态规划数组最大和累加值：一个一个累加的值 最大值：记录累加值的最大值 假设数组为最大，每次添加一个值，如果i-1的值&lt;0，那么把i放入累加值，如果&gt;0，那么将i的值加到累加值，如果累加值&gt;最大值，则更新最大值。 如果需要数组的最大和的下标，对最大值的下标进行记录 1234567891011121314151617181920212223242526272829303132333435 public static void main(String[] args) &#123; int[] array = &#123;1,-2,3,10,-4,7,2,-5&#125;; Long begintime = System.nanoTime(); int result = FindGreatestSumOfSubArray(array); Long endtime = System.nanoTime(); System.out.println(&quot;连续子数组的最大和为：&quot;+result+&quot;,运行时间：&quot;+(endtime - begintime) + &quot;ns&quot;); &#125; public static int FindGreatestSumOfSubArray(int[] array) &#123; int len = array.length; if (len == 0)&#123; return 0; &#125; int[] currentsum = new int[len]; currentsum[0] = array[0]; int greatsetsum = array[0]; System.out.println(&quot;第1步：累加子数组和：&quot;+currentsum[0]+&quot;，最大子数组和：&quot;+greatsetsum); for(int i=1;i&lt;array.length;i++)&#123; //下面是动态规划的状态转移方程 if(currentsum[i-1]&gt;0)&#123; currentsum[i] = currentsum[i-1] + array[i]; &#125;else&#123; currentsum[i] = array[i]; &#125; //根据currentsum的值更新greatsetsum的值 if(currentsum[i] &gt; greatsetsum)&#123; greatsetsum = currentsum[i]; &#125; System.out.println(&quot;第&quot;+(i+1)+&quot;步：累加子数组和：&quot;+currentsum[i]+&quot;，最大子数组和：&quot;+greatsetsum); &#125; return greatsetsum; &#125;&#125; 有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？模式篇单例饿汉：线程安全，类初始化的时候就会触发类的实例化，所以保证只有一个， 缺点：但是会浪费内存，如果不使用单例，就会一直存在 123456789public class Singleton &#123; //在静态初始化器中创建单例实例，这段代码保证了线程安全 private static final Singleton instance = new Singleton(); //Singleton类只有一个构造方法并且是被private修饰的，所以用户无法通过new方法创建该对象实例 private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉：synchronized加锁线程安全 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; //没有加入synchronized关键字的版本是线程不安全的 public static synchronized Singleton getInstance() &#123; //判断当前单例是否已经存在，若存在则返回，不存在则再建立单例 if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; 双重校验锁：双重加锁（线程安全） 1234567891011121314public class Singleton &#123; private static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 双重判断的原因？ 第一个判断减少锁的使用，提升性能 多个线程同时等待锁，当第一个创建后，就不需要其他线程重复重建 volatile的理解 禁止重排序导致instance获取失败（3）。 new Singleton()方法执行时可能导致分配了空间，并指向了内存空间，但是没有赋值，这样另一个线程拿到后会导致出错 静态内部类：（线程安全）123456789101112131415public class Singleton &#123; //私有构造方法 private Singleton ()&#123; &#125; private static class SingletonHelper&#123; //声明成员变量 private static final Singleton instance = new Singleton(); &#125; //对外提供接口获取该实例 public static Singleton getSingleton()&#123; return SingletonHelper.instance; &#125;&#125; 枚举单例：(线程安全) 1234567891011121314151617181920public enum Singleton &#123; INSTANCE; public void doSomething() &#123; System.out.println(&quot;doSomething&quot;); &#125;&#125;调用方法：public class Main &#123; public static void main(String[] args) &#123; Singleton.INSTANCE.doSomething(); &#125;&#125;直接通过Singleton.INSTANCE.doSomething()的方式调用即可。方便、简洁又安全。 生产者消费者生产者添加数据，消费者自己从中间件中获取信息，通过中间件管理数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;import java.util.concurrent.ConcurrentHashMap;/** * @author kangsx * @description * @date 2020/5/13 */public class Mode1 &#123; static class Box&#123; private Queue&lt;Integer&gt; list = new LinkedList&lt;&gt;(); int maxSize = 50; private void put(int i)&#123; synchronized (this)&#123; while(list.size()&gt;=maxSize)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; list.add(i); notifyAll(); &#125; &#125; private int get()&#123; int i = 0; synchronized (this)&#123; while (list.size()&lt;=0)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; i = list.remove(); notifyAll(); &#125; return i; &#125; &#125; static class Producer extends Thread&#123; private Box box; public Producer(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; super.run(); box.put(5); &#125; &#125; static class Consumer extends Thread&#123; private Box box; public Consumer(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; super.run(); int i = box.get(); System.out.println(&quot;i = &quot; + i); &#125; &#125; public static void main(String args[])&#123; Box box = new Box(); //5个生产者 for(int i = 0;i&lt;5;i++) &#123; new Producer(box).start(); &#125; //5个消费者 for(int i = 0;i&lt;5;i++)&#123; new Consumer(box).start(); &#125; &#125;&#125; 观察者发布者发送数据到订阅者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.ArrayList;/** * @author kangsx * @description * @date 2020/5/13 */public class Mode2 &#123; static public interface IObserver &#123; void update(int temp); &#125; static public interface IObservable &#123; void register(IObserver iObserver); void unregister(IObserver iObserver); void notifyObserver(); &#125; //被观察者（发布者） static class Observable implements IObservable &#123; private ArrayList&lt;IObserver&gt; list = new ArrayList&lt;&gt;(); private int temp; @Override public void register(IObserver iObserver) &#123; list.add(iObserver); &#125; @Override public void unregister(IObserver iObserver) &#123; list.remove(iObserver); &#125; @Override public void notifyObserver() &#123; for (int i = 0; i &lt; list.size(); i++) &#123; list.get(i).update(temp); &#125; &#125; public void setTemp(int temp) &#123; this.temp = temp; &#125; &#125; //观察者1（订阅者） static class Observer1 implements IObserver &#123; @Override public void update(int temp) &#123; System.out.println(&quot;Observable1更新为 = &quot; + temp); &#125; &#125; //观察者2(订阅者) static class Observer2 implements IObserver &#123; @Override public void update(int temp) &#123; System.out.println(&quot;Observable2更新为 = &quot; + temp); &#125; &#125; public static void main(String args[])&#123; Observable observable = new Observable(); Observer1 observer1 = new Observer1(); Observer2 observer2 = new Observer2(); observable.register(observer1); observable.register(observer2); observable.setTemp(32131232); observable.notifyObserver(); &#125;&#125; 建造者模式提供复杂参数的对象构造，完全由调用方选择参数配置，反之使用默认。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class Computer &#123; //显示器 String display; //cpu型号 String cpu; //主板型号 String mainBoard; //显卡型号 String gpu; public Computer(Builder builder) &#123; this.display = builder.display; this.cpu = builder.cpu; this.mainBoard = builder.mainBoard; this.gpu = builder.gpu; &#125; @Override public String toString() &#123; return &quot;显示器是&quot; + display + &quot;\\ncpu是&quot; + cpu + &quot;\\n主板是&quot; + mainBoard + &quot;\\n显卡是&quot; + gpu; &#125; static class Builder&#123; //显示器 String display; //cpu型号 String cpu; //主板型号 String mainBoard; //显卡型号 String gpu; public Builder()&#123; this.display = &quot;三星曲屏&quot;; this.cpu = &quot;i5 8400&quot;; this.mainBoard = &quot;华硕Z360-B&quot;; this.gpu = &quot;GTX 1050Ti&quot;; &#125; public Builder setDisplay(String display) &#123; this.display = display; return this; &#125; public Builder setcpu(String cpu) &#123; this.cpu = cpu; return this; &#125; public Builder setMainBoard(String mainBoard) &#123; this.mainBoard = mainBoard; return this; &#125; public Builder setGpu(String gpu) &#123; this.gpu = gpu; return this; &#125; public Computer build()&#123; return new Computer(this); &#125; &#125; public static void main(String args[])&#123; Computer computer = new Computer.Builder() .setcpu(&quot;i9 4700u&quot;) .setGpu(&quot;GTX 2060Ti&quot;) .setMainBoard(&quot;华硕Z480&quot;) .build(); System.out.println(computer.toString()); &#125;&#125; 工厂模式代理模式对原有功能进行封装，访问对象不能直接访问原有功能，只能访问我们的功能传达，我们就是代理，作为原有功能和访问对象之间的中介 静态代理：123456789101112131415161718192021222324252627282930313233343536373839404142package proxy;public class ProxyTest &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); proxy.Request(); &#125;&#125;//抽象主题interface Subject &#123; void Request();&#125;//真实主题class RealSubject implements Subject &#123; public void Request() &#123; System.out.println(&quot;访问真实主题方法...&quot;); &#125;&#125;//代理class Proxy implements Subject &#123; private RealSubject realSubject; public void Request() &#123; if (realSubject == null) &#123; realSubject = new RealSubject(); &#125; preRequest(); realSubject.Request(); postRequest(); &#125; public void preRequest() &#123; System.out.println(&quot;访问真实主题之前的预处理。&quot;); &#125; public void postRequest() &#123; System.out.println(&quot;访问真实主题之后的后续处理。&quot;); &#125;&#125;动态代理：12345678910111213141516171819202122232425IRetrofit iRetrofit = (IRetrofit) Proxy.newProxyInstance(IRetrofit.class.getClassLoader(), new Class&lt;?&gt;[]&#123;IRetrofit.class&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;-----调用前执行&quot;); if(method.getDeclaringClass() == Object.class) &#123; System.out.println(&quot;-----调用前执行Object&quot;); return method.invoke(IRetrofit.class, args); &#125; IRetrofit iRetrofit1 = new IRetrofit() &#123; @Override public void test() &#123; System.out.println(&quot;------test1&quot;); &#125; @Override public void kang() &#123; System.out.println(&quot;------kang1&quot;); &#125; &#125;; Object object = method.invoke(iRetrofit1,args); System.out.println(&quot;-------调用后执行&quot;); return null; &#125; &#125;); iRetrofit.kang();打印如下：123-----调用前执行------kang1-------调用后执行即想调用那个方法都可以，在invoke中做了代理，利用反射执行该类 设计六种原则单一职责接口业务单一 里氏替换原则依赖倒置接口隔离迪米特法则开闭原则提高复用性，可拓展性，将业务抽取单一获取 根据业务功能进行划分，功能复杂时考虑分层思想+设计模式，如果业务简单，可以直接套用设计模式进行方案优化，最后业务决定框架选型，细节方面可以面向未来考虑 尽量保证良好的扩展和健壮性 Flutterwidget树，skia 2d渲染引擎， StatelessWidget：不能更新状态的布局，创建一次，永不可修改外观 StatefulWidget：可以更新界面，通过setState方法更新布局，外观 fish-redux Kotlin优势完全兼容Java更少的空指针异常更少的代码量，更快的开发速度 React Nativereduxaction：用户触发程序 reducer：根据action，做不同响应，返回一个新state store：存储state的集合，数据是不可变的 亮点iot触发日志文件上传通过bugly埋点，如果无法解决或者问题不全，或者酒店反馈音箱有问题 存储：监听时间广播，整点会重新存储日志文件，进程设置adb命令存储文件 每次中断或者时间到了都会触发重新开辟文件存储和老文件删除（只存储72个文件，正常情况下对应72个小时的） 内存优化使用leakcanary检测内存泄漏，绑定生命周期，在onDestroy的时候创建弱引用，放置在弱引用队列中，手动gc，如果查到该Activity，就是造成了内存泄漏，会打印出dump栈堆信息 selinux权限配置ota中遇到的问题，ota升级失败后，再日志中分析问题，再对应的.te文件中添加权限配置，循环往复，最终关闭这个权限校验。 定义每个用户，进程，应用，文件的访问和转变的权限，使用安全策略组控制这些实体 启动优化如何检测？ AOP（AspectJ）打点 程序打点 TraceView 1234//开始收集Debug.startMethodTracing(&quot;app_trace&quot;);//结束收集Debug.stopMethodTracing(); 生成app_trace.trace文件，可以查看方法耗时 函数插桩（ASM） 具体的优化方案 替换主题中theme，保证不会出现闪屏 decroView.post执行延时任务 IdleHandler闲置时间进行任务执行 异步线程池处理 基于dex文件的异步加载，在编译期间对dex按模块进行拆分，把一级页面及配置放置在第一个dex中，二三级页面及配置放置在第二个dex中。 在app启动过程中，不启动odex转化进程，在app启动后，自己启动一个odex进程，将转化后文件放入odex文件 在app启动过程中，android虚拟机会启动一个odex转化进程，将dex转化为odex，避免这个odex进程对前台app的影响很重要 主旨核心 减法为主：尽量不影响主线程，能较少的启动就减少启动 异步为辅：耗时任务在异步调用 延迟为补：延迟加载增加全面性 优化方案在使用Aspect进行时间的监测时，发现Application和Activity中的初始化三方进程耗费了大量时间，在初始化时，我们开启了百度OTA服务，Bugly监测服务，咪咕音乐服务，阿里IOT服务，日志监测服务，Linphone语音服务，Ifly语音服务等，这些串行起来是比较耗时的。所以我们采用开启一个线程池的方案，在子线程启动这些服务，对于OTA，IOT，日志检测，Linphone等服务不需要在第一时间初始化，所以放到线程池中根据执行顺序分别初始化。但是对于咪咕、Ifly和bugly来说，需要第一时间初始化，才能进行后边的逻辑，所以我们将这些服务优先初始化，并联合CountDownLatch，当必须的服务初始化完成后，才进入下面的流程。对于必须要在主线程进行初始化的操作，可能会造成主线程繁忙卡顿，所以使用IdleHandler方法，在主线程空闲时执行， 具体优化了40%，由2.3s压缩到1.4s。 如果由任务A，B，C，D，要求C在A之后执行，D在B之后执行，那么直接将A,C合并为一个任务，放入线程池中运行，B、D合并为一个任务，放入线池程中执行，如需决定AC和BD的顺序，那么可以按照AC、BD的顺序依次放入子线程中。 通过异步线程池进行异步加载处理，使用有向无环图算法控制任务进入线程池的顺序，通过CountDownLatch控制线程的执行顺序，进行异步加载 如何对IDLEHandler进行顺序划分？比如先执行B，在执行A规划一个空闲队列，在Handler空闲时进行处理，每次出队优先级最高的，其他等到下次空闲在执行 2-5是怎么计算的？1Math.max(2, Math.min(CPU_COUNT - 1, 5)) CPU_COUNT - 1，是因为为了避免后台任务将 CPU 资源完全耗尽， 减掉的这个1 是留给我们 主线程 使用的。 cpu密集型的线程选择：n+1io密集型的线程选择： 2n+1 线程数 = CPU核心数/(1-阻塞系数)，一般情况下IO密集型的为0.8，0.9，可适当调整这个数值 在改启动器中，我们存在的大都是cpu密集型任务，理论上选择n+1，但是目前在2-5中间进行选择 在最新版本的AsyncTask中的线程池已经设置为了5 如何选择线程池最优线程数 如何看待app startUp？官方提供的启动优化方案，可以规定初始化模块的运行顺序，配合AndroidManifest+ContentProvider进行初始化。 在Application的生命周期中，application.attachBaseContext()—-&gt;contentProvider.onCreate()—–&gt;application.onCreate() 通过创建一个ContentProvider，在ContentProvider中执行初始化事件，减轻application的负担。 缺点： 只支持同步事件，没有线程池做异步处理 需要编写大量的xxInitializer类文件，配置AndroidManifest文 设计一个模块： 接口的易用性，从易用出发 命名规范 尽量不依赖第三方库，避免重复引用 多端使用的一致性，比如都开放同一个端口 sdk包保证小而精 保证老旧版本的兼容性 这类配置项一般就不需要提供 get 方法，防止接口太多 组件化构件布局优化view的布局ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别ConstraintLayout：约束布局，完美结合RelativeLayout和LinearLayout的属性，可以拖拽，可以放置在相对布局，也可以按比例设置view，很像flex，都是一层布局 FrameLayout：后一个布局会覆盖前一个布局，可以控制层级 RelativeLayout：相对位置的布局 LinearLayout：线性布局，水平，垂直，比例分配 include，viewstub，merge的区别include：复用布局 viewstub：可以显示网络布局，默认显示一次，更加省cpu和内存，只会构建一次， merge：去除不必要的节点嵌套（比如多个LinearLayout的嵌套） 尽量使用ConstraintLayout，RelativeLayout，使用include，viewstub加载网络异常界面显示，merge去掉不必要的节点 布局优化 针对复杂布局使用ConstraintLayout，减少层级，实现类Flex布局，后期也可拓展为MotionLayout，添加动画 针对简单布局，使用LinearLayout布局，不增加嵌套层级情况下，性能最优，onMeasure渲染一次 使用include布局对公共布局进行封装，便于统一修改和查看 使用merge标签作为根布局进行include内布局的封装，当其他布局引用时，会直接当作include布局的根布局使用，减少嵌套布局层级 使用viewStub标签，第一次展示时不会进行绘制，他是一个轻量级的view，没有尺寸，当需要使用布局时（调用inflate()方法），才会进行加载 使用开发者选项中的过度绘制进行检查并优化布局 apk体积优化使用apk Analyzer分析apk，体积主要在lib库，assets库，res库 从150M压缩到50M， lib库中存放着三方库，所以需要对三方库进行整理，剔除不需要的库，针对so库，剔除其他架构的so库，只留了armeabi-v7a包。 assets库和res库中主要是一些音频文件，帧动画图片，gif图片等 对图片进行压缩，使用tinypng进行图片压缩（支持png和jpg格式） 大部分图片可以使用webp格式替换，减少体积 帧动画和gif尽量换成lottie动画 使用lint删除无用资源和代码 大图换小图 代码优化整理复用 view整理复用 启动shrinkResources，移除不用的资源 大库换小库，能不用就不用 减小assets，raw的文件目录大小，尽量放置在网络上 调整需求，减少体量","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"茶道","slug":"随笔/茶道","date":"2021-05-31T12:39:47.000Z","updated":"2021-05-31T12:42:24.066Z","comments":true,"path":"2021/05/31/随笔/茶道/","link":"","permalink":"http://yoursite.com/2021/05/31/%E9%9A%8F%E7%AC%94/%E8%8C%B6%E9%81%93/","excerpt":"","text":"[TOC] 茶的分类根据茶的发酵程度去区分茶的种类，目前已知可以分为：绿茶、红茶、青茶、白茶、黄茶、黑茶。 绿茶发酵度：0%（未发酵） 品种高达3000多种 绿茶的茶汤多呈现翠绿色、黄绿色等等；茶汤清澈，滋味甘醇。较为出名的绿茶有：西湖龙井、黄山毛峰、碧螺春等。 冲泡绿茶时宜用80-90度左右的热水冲泡。 黄茶发酵度：10～20% 黄茶品种比较少 黄茶属微发酵的茶，其制作工艺和绿茶相似，只增加了一道“闷黄”的工艺，这是制作黄茶的关键，也是造就黄茶“黄叶黄汤”的主要工序。黄茶的茶汤橙中泛黄，没有绿茶的苦涩，更加香醇。 比较出名的有：君山银针、蒙顶黄芽、沩山毛尖等。 冲泡黄茶时宜用85-95度左右的热水冲泡。 白茶发酵度：10～30% 白茶可以说是福建独有，主要生产于福建的政和、福鼎、松溪等 白茶是轻度发酵的茶，发酵程度仅比黄茶稍多，其制法独特，不炒不揉，成茶外表满披白毫，色泽银白灰绿，故名“白茶“。 白茶的茶汤一般呈黄绿色，滋味清淡，有较强的回甘。 比较出名的白茶有：白毫银针、白牡丹、寿眉、福鼎大白茶等。 冲泡白茶时宜用90-100度左右的热水冲泡。 青茶发酵度：30～70% 最具代表性的就是“乌龙茶”，属于半发酵茶，介于不发酵茶（绿茶）和全发酵茶（红茶）之间。 青茶的茶汤呈蜜绿色，香气馥郁，回味甘鲜。 比较出名的有：铁观音、武夷岩茶（大红袍）、广东大叶青等。 冲泡青茶时宜用100度左右的热水冲泡。 红茶发酵度：95～100% 是绿茶后的第二大茶类，产区较为广泛，但比较多的省份为云南、安徽、福建、广东等 比较有名的品种有：正山小种、祁红、滇红、金骏眉等。 冲泡红茶时宜用80-85度左右的热水冲泡。 黑茶发酵度：80～100% 黑茶生产历史悠久，在历史上一直都是供给边疆少数民族地区，目的是为了帮助边疆人民消化食物和平衡营养。 比较出名的有：云南普洱茶、安化黑茶、广西六堡茶、四川边茶等。 冲泡黑茶时宜用100度左右的热水冲泡。 茶的制作流程主要制作流程采茶从茶树上采摘新鲜的茶叶。采摘茶枝顶端的茶尖部分，分为独芽、一芽一叶、一芽两叶。 独芽：采摘最顶端小芽，茶叶品级为极品，茶叶不耐泡，只能品茶叶的清香和甘醇。如龙井茶。 一芽一叶：采摘最顶端小芽+一片叶子，味道甘醇 一芽两叶：采摘最顶端小芽+两片叶子，较前两者味道更加浓郁些，少了飘逸感，但是价格亲民 摊晾（晾青、晾晒）就是将采摘下的茶鲜叶均匀地摊放在篾垫、摊青筛或摊青机上的作业过程。 使叶子失水（含水量下降5%=70%），变软，便于揉捻成条、球 萎凋（走水）是指鲜叶摊在一定的设备和环境条件下， 萎凋叶的含水率一般比摊晾后鲜叶的含水率更低，大多在60%~64%。 杀青主要目的是通过高温破坏和钝化鲜叶中的氧化酶活性，抑制鲜叶中的茶多酚等的酶促氧化，蒸发鲜叶部分水分，使茶叶变软，便于揉捻成形，同时散发青臭味，促进良好香气的形成。 主要有炒青、烘青、蒸青和晒青： 炒青用高温铁锅炒制（如龙井、碧螺春、雨花茶等）； 烘青用烘笼或烘干机直接高温烘焙（如黄山毛峰、太平猴魁、高桥银峰等）； 蒸青：采用蒸汽杀青工艺制作（如煎茶、玉露、抹茶等）； 晒青：靠太阳晒干或先晒后烘，先晒后炒干（如滇青、川青、陕青等）。 闷黄是黄茶类制造工艺的特点，是形成黄色黄汤的关键工序。从杀青到黄茶干燥结束，都可以为茶叶的黄变创造适当的湿热工艺条件，但作为一个制茶工序，有的茶在杀青后闷黄，有的则在毛火后闷黄，有的闷炒交替进行。 发酵（渥红）是红茶制作的独特阶段，经过发酵，叶色由绿变红，形成红茶红叶红汤的品质特点。 揉捻通过揉捻使茶叶的细胞壁破裂，是茶叶变得更加柔软，释放出更多的营养成分 干燥除去茶叶中的水分 覆火再次去除茶叶中的水分 紧压将茶叶制成茶饼 六大茶类的制作流程 绿茶：采茶—-&gt;晾晒—-&gt;杀青—-&gt;揉捻—-&gt;干燥 黄茶：采茶—-&gt;晾晒—-&gt;杀青—-&gt;揉捻—-&gt;闷黄—-&gt;干燥 白茶：采茶—-&gt;晾晒/萎凋—-&gt;杀青—-&gt;干燥 青茶：采茶—-&gt;萎凋—-&gt;杀青—-&gt;揉捻—-&gt;干燥 红茶：采茶—-&gt;萎凋—-&gt;揉捻—-&gt;干燥 黑茶：采茶—-&gt;萎凋—-&gt;炒青—-&gt;揉捻—-&gt;渥堆—-&gt;干燥—-&gt;覆火—-&gt;紧压","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"Butterknife源码解析","slug":"移动端/Android原生/Butterknife源码解析","date":"2020-06-04T08:48:12.000Z","updated":"2021-05-27T11:40:17.156Z","comments":true,"path":"2020/06/04/移动端/Android原生/Butterknife源码解析/","link":"","permalink":"http://yoursite.com/2020/06/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Butterknife%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"[TOC] 使用1234567891011121314@BindView(R.id.about_titleView)TitleView aboutTitleView;@BindView(R.id.view_about)LinearLayout viewAbout;Unbinder mBinder;onCreate()&#123; mBinder = ButterKnife.bind(this);&#125;onDestory()&#123; mBinder.unbind();&#125; 使用方法极其简单，减少findViewById的重复代码 BindView源码如下： 12345@Retention(CLASS) @Target(FIELD)public @interface BindView &#123; /** View ID to which the field will be bound. */ @IdRes int value();&#125; 源码解析1ButterKnife.bind(this); 进入bind方法： 12345@NonNull @UiThreadpublic static Unbinder bind(@NonNull Activity target) &#123; View sourceView = target.getWindow().getDecorView(); return createBinding(target, sourceView);&#125; 获取当前该activity的window上的decorView（获取最顶层view），创建绑定操作 12345678910111213private static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123; Class&lt;?&gt; targetClass = target.getClass(); if (debug) Log.d(TAG, &quot;Looking up binding for &quot; + targetClass.getName()); Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass); if (constructor == null) &#123; return Unbinder.EMPTY; &#125; ... // return constructor.newInstance(target, source); ...&#125; 进入findBindingConstructorForClass方法： 123456789101112131415161718192021222324252627282930313233343536@VisibleForTestingstatic final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;();@Nullable @CheckResult @UiThreadprivate static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123; //从缓存中获取绑定关系（key--class类,value--构造函数） Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls); if (bindingCtor != null) &#123; if (debug) Log.d(TAG, &quot;HIT: Cached in binding map.&quot;); return bindingCtor; &#125; //获取类名 String clsName = cls.getName(); //排除android系统类和java系统类 if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)) &#123; if (debug) Log.d(TAG, &quot;MISS: Reached framework class. Abandoning search.&quot;); return null; &#125; try &#123; //加载一个className_ViewBinding类 Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;); //noinspection unchecked //通过反射获取该类的构造函数 bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class); if (debug) Log.d(TAG, &quot;HIT: Loaded binding class and constructor.&quot;); &#125; catch (ClassNotFoundException e) &#123; if (debug) Log.d(TAG, &quot;Not found. Trying superclass &quot; + cls.getSuperclass().getName()); bindingCtor = findBindingConstructorForClass(cls.getSuperclass()); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(&quot;Unable to find binding constructor for &quot; + clsName, e); &#125; //将构造器信息放入缓存中 BINDINGS.put(cls, bindingCtor); return bindingCtor;&#125; 最终生成一个_ViewBinding类123456789101112131415161718192021222324252627public class AboutActivity_ViewBinding implements Unbinder &#123; private AboutActivity target; @UiThread public AboutActivity_ViewBinding(AboutActivity target) &#123; this(target, target.getWindow().getDecorView()); &#125; @UiThread public AboutActivity_ViewBinding(AboutActivity target, View source) &#123; this.target = target; target.aboutTitleView = Utils.findRequiredViewAsType(source, R.id.about_titleView, &quot;field &#x27;aboutTitleView&#x27;&quot;, TitleView.class); target.viewAbout = Utils.findRequiredViewAsType(source, R.id.view_about, &quot;field &#x27;viewAbout&#x27;&quot;, LinearLayout.class); &#125; @Override @CallSuper public void unbind() &#123; AboutActivity target = this.target; if (target == null) throw new IllegalStateException(&quot;Bindings already cleared.&quot;); this.target = null; target.aboutTitleView = null; target.viewAbout = null; &#125;&#125; 总结：bind方法后，新建一个ViewBinding类，用来做findviewById，onClick等操作，将注解节省的步骤在该类的构造方法中执行，当然这里的构造函数都是注解自动生成的，所以，是怎么样的操作实现这个类？ _ViewBinding类是怎么生成的？这里要介绍一个注解器，ButterKnifeProcessor，这个注解器是解析注解，生成ViewBinding类的具体代码。 init初始化调用 1234567891011121314151617181920212223242526272829303132333435363738@Override public synchronized void init(ProcessingEnvironment env) &#123; super.init(env); //获取viewBinding类 String sdk = env.getOptions().get(OPTION_SDK_INT); if (sdk != null) &#123; try &#123; this.sdk = Integer.parseInt(sdk); &#125; catch (NumberFormatException e) &#123; env.getMessager() .printMessage(Kind.WARNING, &quot;Unable to parse supplied minSdk option &#x27;&quot; + sdk + &quot;&#x27;. Falling back to API 1 support.&quot;); &#125; &#125; //是否是debug模式 debuggable = !&quot;false&quot;.equals(env.getOptions().get(OPTION_DEBUGGABLE)); typeUtils = env.getTypeUtils(); filer = env.getFiler(); try &#123; trees = Trees.instance(processingEnv); &#125; catch (IllegalArgumentException ignored) &#123; try &#123; // Get original ProcessingEnvironment from Gradle-wrapped one or KAPT-wrapped one. for (Field field : processingEnv.getClass().getDeclaredFields()) &#123; if (field.getName().equals(&quot;delegate&quot;) || field.getName().equals(&quot;processingEnv&quot;)) &#123; field.setAccessible(true); ProcessingEnvironment javacEnv = (ProcessingEnvironment) field.get(processingEnv); trees = Trees.instance(javacEnv); break; &#125; &#125; &#125; catch (Throwable ignored2) &#123; &#125; &#125; &#125; 该方法主要是获取注解所要生成的viewBing类并进行绑定，遍历java源代码，获取所有的Element元素 process实际处理方法 123456789101112131415161718@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123; //获取注解类型Element和程序代码对应关系 Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env); for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); JavaFile javaFile = binding.brewJava(sdk, debuggable); try &#123; javaFile.writeTo(filer); &#125; catch (IOException e) &#123; error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage()); &#125; &#125; return false; &#125; BindingSet：对应注解类型的绑定配置 通过findAndParseTargets获取注解类型Element和配置的相关信息 遍历Map，生成JavaFile 生成_ViewBinding文件，将javaFile写入 进入findAndParseTargets中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;(); Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;(); scanForRClasses(env); ...... // Process each @BindView element. //获取BindView注解修饰的Element对象 for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123; // we don&#x27;t SuperficialValidation.validateElement(element) // so that an unresolved View type can be generated by later processing rounds try &#123; parseBindView(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindView.class, e); &#125; &#125; ....... // Process each annotation that corresponds to a listener. //处理监听器注解类型 for (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123; findAndParseListener(env, listener, builderMap, erasedTargetNames); &#125; // Associate superclass binders with their subclass binders. This is a queue-based tree walk // which starts at the roots (superclasses) and walks to the leafs (subclasses). Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries = new ArrayDeque&lt;&gt;(builderMap.entrySet()); Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;(); while (!entries.isEmpty()) &#123; //从队列中取出第一个元素 Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst(); //获取对应的key和value TypeElement type = entry.getKey(); BindingSet.Builder builder = entry.getValue(); //查找当前元素的父类元素 TypeElement parentType = findParentType(type, erasedTargetNames); if (parentType == null) &#123; //没找到父类，重新放入队列 bindingMap.put(type, builder.build()); &#125; else &#123; //获取父类Element对应的BindingSet BindingSet parentBinding = bindingMap.get(parentType); if (parentBinding != null) &#123; //设置父类BindingSet并添加到Map中 builder.setParent(parentBinding); bindingMap.put(type, builder.build()); &#125; else &#123; // Has a superclass binding but we haven&#x27;t built it yet. Re-enqueue for later. //具有超类绑定，但我们尚未构建它。重新排队以便稍后使用 entries.addLast(entry); &#125; &#125; &#125; return bindingMap; &#125; 获取到所有的bind类注解的Element 并执行parseBindView()方法，绑定buildingSet和TypeElement的对应关系： 获取父类BindingSet对象，重新构建绑定关系，并返回该对应关系 进入parseBindView中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, Set&lt;TypeElement&gt; erasedTargetNames) &#123; //获取当前对象的父类，如果在Activity中使用，那么enclosingElement就是Activity类 TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); // Start by verifying common generated code restrictions. //校验对象，不能使用private和static修饰 boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, &quot;fields&quot;, element) || isBindingInWrongPackage(BindView.class, element); // Verify that the target type extends from View. TypeMirror elementType = element.asType(); if (elementType.getKind() == TypeKind.TYPEVAR) &#123; TypeVariable typeVariable = (TypeVariable) elementType; elementType = typeVariable.getUpperBound(); &#125; //获取类名（包名+类名） Name qualifiedName = enclosingElement.getQualifiedName(); //获取成员变量名称 Name simpleName = element.getSimpleName(); //判断当前对象是否为view的子类或者接口，不是的话抛出异常 if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123; if (elementType.getKind() == TypeKind.ERROR) &#123; note(element, &quot;@%s field with unresolved type (%s) &quot; + &quot;must elsewhere be generated as a View or interface. (%s.%s)&quot;, BindView.class.getSimpleName(), elementType, qualifiedName, simpleName); &#125; else &#123; error(element, &quot;@%s fields must extend from View or be an interface. (%s.%s)&quot;, BindView.class.getSimpleName(), qualifiedName, simpleName); hasError = true; &#125; &#125; if (hasError) &#123; return; &#125; // Assemble information on the field. //获取注解的value资源id（控件id值） int id = element.getAnnotation(BindView.class).value(); //获取父类的BindingSet.Builder BindingSet.Builder builder = builderMap.get(enclosingElement); //将id和对象进行绑定 QualifiedId qualifiedId = elementToQualifiedId(element, id); if (builder != null) &#123; //查询是否重复绑定 String existingBindingName = builder.findExistingBindingName(getId(qualifiedId)); if (existingBindingName != null) &#123; error(element, &quot;Attempt to use @%s for an already bound ID %d on &#x27;%s&#x27;. (%s.%s)&quot;, BindView.class.getSimpleName(), id, existingBindingName, enclosingElement.getQualifiedName(), element.getSimpleName()); return; &#125; &#125; else &#123; //将父类和BindingSet.Builder进行绑定并添加到builderMap中，并返回这个binder对象 builder = getOrCreateBindingBuilder(builderMap, enclosingElement); &#125; String name = simpleName.toString(); TypeName type = TypeName.get(elementType); //判断是否使用Nullable注解 boolean required = isFieldRequired(element); //将资源id，（对象名，对象类型，是否使用Nullable添加到builder中 builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required)); // Add the type-erased version to the valid binding targets set. //将父元素添加到集合中用来查找父元素信息 erasedTargetNames.add(enclosingElement);&#125; 校验对象修饰不能是private和static 校验View是否为对象的超类 获取资源id并进行绑定，添加到集合中 在上述分析过程中，生成一个BindingSet类再通过JavaFile生成对应文件123456JavaFile brewJava(int sdk, boolean debuggable) &#123; return JavaFile.builder(bindingClassName.packageName(), createType(sdk, debuggable)) //添加类头注释 .addFileComment(&quot;Generated code from Butter Knife. Do not modify!&quot;) .build(); &#125; 将java版本和是否为debug传入，传入包名+类名，根据类型创建不同代码，JavaFile属于javapoet包类，使用javapoet将实现类代码生成文件。 getSupportedAnnotationTypes获得要处理的注解 12345678910111213141516171819202122232425262728@Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123; types.add(annotation.getCanonicalName()); &#125; return types; &#125; private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123; Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;(); annotations.add(BindAnim.class); annotations.add(BindArray.class); annotations.add(BindBitmap.class); annotations.add(BindBool.class); annotations.add(BindColor.class); annotations.add(BindDimen.class); annotations.add(BindDrawable.class); annotations.add(BindFloat.class); annotations.add(BindFont.class); annotations.add(BindInt.class); annotations.add(BindString.class); annotations.add(BindView.class); annotations.add(BindViews.class); annotations.addAll(LISTENERS); return annotations; &#125; ButterknifeProcessor支持的所有注解类型 getSupportedSourceVersion指定java版本123@Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported();&#125;这个是基本写法，一般都这样写 总结Butterknife只是针对view的注入框架，在编译过程中，使用自定义注解器的方式解析注解，生成对应关系后，通过BindingSet+JavaFile的javapoet技术将程序类写入文件，生成Activity_ViewBinding文件，在bind方法中，反射获取Activity_ViewBinding类的构造函数，存入缓存，返回构造函数后实例化对象，完成视图的绑定","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"EventBus用法和源码解析","slug":"移动端/Android原生/EventBus用法和源码解析","date":"2020-04-16T03:03:49.000Z","updated":"2021-05-27T11:40:17.156Z","comments":true,"path":"2020/04/16/移动端/Android原生/EventBus用法和源码解析/","link":"","permalink":"http://yoursite.com/2020/04/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/EventBus%E7%94%A8%E6%B3%95%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"[TOC] 参照版本： EventBus 3.0以后 为什么选择EventBus 简化了 组件交流方式 对事件通信双方解耦 灵活指定线程（4种线程模式） 速度快，性能好 库比较小，不占内存 使用方便 使用指南 角色 Event：事件 Subscriber：事件订阅者 Publisher：事件发布者 五种线程模式 POSTING：默认，发布和订阅在同一个线程 MAIN：事件处理函数的线程在主线程（UI）线程。不能进行耗时操作，订阅者需快速返回以免阻塞主线程 MAIN_ORDERED:事件处理函数的线程在主线程（UI）线程。不能进行耗时操作，不会阻塞线程 BACKGROUND：处理函数在后台线程，不能进行UI操作。发布在主线程，订阅会开启一个新的后台线程。发布在后台线程，事件处理函数也在该后台线程 ASYNC：无论事件发布的线程是哪一个，都会重新开辟一个新的子线程运行，不能进行UI操作 MAIN和MAIN_ORDERED区别 在MAIN模式下，如果事件发布者post事件也是在主线程的话，会阻塞post事件所在的线程，意思是连续post多个事件，如果接收事件方法执行完，才能post下一个事件 ​ post(1) ——&gt; onReceiveMsg(1) ——&gt;post(2)——&gt;onReceiveMsg(2)——&gt;post(3)——&gt;onReceiveMsg(3) 如果事件发布者post事件不在主线程，连续post多个事件，同事在主线程是接收事件是耗时操作的话，执行的流程是非阻塞的 ​ post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(3)​ 或​ post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(2)——&gt;onReceiveMsg(3) MAIN_ORDERED模式下，无论什么场景都是非阻塞的 事件类型普通事件：注册和反注册后，发送EventBus.post()事件，在需要接收的地方使用@Subscribe方法，方法必须是public 粘性事件：注册和反注册后，发送EventBus.postSticky()黏性事件，在需要接收的地方使用@Subscribe方法，方法必须是public，添加sticky = true 普通事件是先订阅后发送，粘性事件支持先发送后订阅 优先级说明：优先级高的订阅者优先接收到任务 threadMode参数相同 只有走到threadMode参数为POSTING的时候才会停止该事件的继续分发，调用cancelEventDelivery(xx) 混淆12345678910-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125; 索引目的： 如何使用： 1234567891011121314android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ eventBusIndex : &#x27;com.example.myapp.MyEventBusIndex&#x27; ] ##这里要修改为你项目的包名 &#125; &#125; &#125;&#125;dependencies &#123; implementation &#x27;org.greenrobot:eventbus:3.1.1&#x27; annotationProcessor &#x27;org.greenrobot:eventbus-annotation-processor:3.1.1&#x27;&#125; 在\\app\\build\\generated\\source\\apt\\debug\\package\\下可查看生成的MyEventBusIndex文件 在Application中使用 12345678public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus(); &#125;&#125; 如果想在整个应用使用默认实例 123EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();// Now the default instance uses the given index. Use it like this:EventBus eventBus = EventBus.getDefault(); 源码解析 注册流程 1234567891011/** Convenience singleton for apps using a process-wide EventBus instance. */ public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; getDefault使用单例模式，保证整个app只有唯一实例。初次进入会进入无参构造中初始化 1234567/** * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a * central bus, consider &#123;@link #getDefault()&#125;. */public EventBus() &#123; this(DEFAULT_BUILDER);&#125; 1private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder(); 由此可以看出来DEFAULT_BUILDED是EventBusBuilder实例，具体的初始化在下面这个方法。 1234567891011121314151617181920EventBus(EventBusBuilder builder) &#123; logger = builder.getLogger(); subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadSupport = builder.getMainThreadSupport(); mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null; backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService;&#125; 初始化配置，部分配置从builder中获取，这是典型的建造者模式，查看EventBusBuilder类 1234/** Builds an EventBus based on the current configuration. */public EventBus build() &#123; return new EventBus(this);&#125; 查看EventBus类 123public static EventBusBuilder builder() &#123; return new EventBusBuilder();&#125; 所以用两种初始化的方法： EventBus.builder().build(); EventBus.getDefault() EventBusBuilder中配置如下 成员变量 logSubscriberExceptions :是否打印订阅者异常信息，默认开启 logNoSubscriberMessages :某个事件没有订阅者时，是否打印信息，默认开启 sendSubscriberExceptionEvent :出现订阅者异常时，是否发送异常事件，默认开启 sendNoSubscriberEvent :某个事件没有订阅者时，是否发送无订阅者的事件，默认开启 throwSubscriberException :是否抛出订阅者异常信息，默认关闭 eventInheritance :事件是否可以继承形式订阅，默认开启 ignoreGeneratedIndex :忽略索引生成，默认关闭 strictMethodVerification :是否开启方法严格验证，默认关闭 executorService :线程池，默认是newCachedThreadPool，即没有核心线程、但最大线程数是Integer.MAX_VALUE的线程池 skipMethodVerificationForClasses :跳过为订阅者类里面的方法进行校验，校验包括注解信息、修饰符是否是public且非static\\final的，默认为空 subscriberInfoIndexes :订阅者信息索引，由注解处理器生成 mainThreadSupport :专为Android的主线程定制，持有主线程looper引用 方法调用 addIndex(SubscriberInfoIndex index)：添加索引 eventInheritance(boolean eventInheritance)：是否支持事件继承 executorService(java.util.concurrent.ExecutorService executorService)：提供用于一部和后台时间传递的自定义线程池 ignoreGeneratedIndex(boolean ignoreGeneratedIndex)：强制使用反射，即使有生成的索引（默认值：false）。 skipMethodVerificationFor(java.lang.Class&lt;?&gt; clazz)：对以onEvent开头的方法进行方法名验证，以避免键入错误；使用此方法，可以从此检查中排除订阅服务器类。 logNoSubscriberMessages(boolean logNoSubscriberMessages)：当调用事件处理函数异常时是否打印异常信息 logSubscriberExceptions(boolean logSubscriberExceptions)：当没有订阅者订阅该事件时是否打印日志 sendNoSubscriberEvent(boolean sendNoSubscriberEvent)：当调用事件处理函数异常时是否发送 SubscriberExceptionEvent 事件，若此开关打开，订阅者可通过 1public void onEvent(SubscriberExceptionEvent event) 订阅该事件进行处理，默认为 true。 sendSubscriberExceptionEvent(boolean sendSubscriberExceptionEvent)：当没有事件处理函数对事件处理时是否发送 NoSubscriberEvent 事件，若此开关打开，订阅者可通过 1public void onEvent(NoSubscriberEvent event) 订阅该事件进行处理，默认为 true。 strictMethodVerification**(boolean strictMethodVerification)：启用严格的方法验证（默认值：false）。 throwSubscriberException**(boolean throwSubscriberException)：如果订阅服务器引发异常，则失败（默认值：false）。 1EventBus.builder().throwSubscriberException(true).installDefaultEventBus() 根据builder的默认配置统计得出： 当出现订阅者异常时，打印异常log 当事件没有订阅者时，打印没有订阅者log 当出现订阅者异常时，发送异常事件 当事件没有订阅者时，发送无订阅者事件 捕获异常信息，防止崩溃 事件可以继承 编译时生成索引 采用最大限制是Integer.MAX_VALUE的缓存线程池 为每个订阅者类都进行方法校验 当处于Android平台时，确保可以切换到主线程 自定义配置 123EventBus.builder().logNoSubscriberMessages(false) .logSubscriberExceptions(false).eventInheritance(false)... .installDefaultEventBus(); 123EventBus.builder().logNoSubscriberMessages(false) .logSubscriberExceptions(false).eventInheritance(false)... .build(); 12345678910public EventBus installDefaultEventBus() &#123; synchronized (EventBus.class) &#123; if (EventBus.defaultInstance != null) &#123; throw new EventBusException(&quot;Default instance already exists.&quot; + &quot; It may be only set once before it&#x27;s used the first time to ensure consistent behavior.&quot;); &#125; EventBus.defaultInstance = build(); return EventBus.defaultInstance; &#125; &#125; 123public EventBus build() &#123; return new EventBus(this); &#125; installDefaultEventBus调用的也是build（）方法，但是该方法多了一个单例，确保其全局的唯一性，所以使用build方法时需要自己维护其唯一性 注册1EventBus.getDefault().register(this); 进入register方法 123456789101112public void register(Object subscriber) &#123; //获取订阅者类 Class&lt;?&gt; subscriberClass = subscriber.getClass(); //获取该订阅类的所有订阅方法 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; //挨个订阅 for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; SubscriberMethod是什么？ 12345678910public class SubscriberMethod &#123; final Method method; //订阅方法 final ThreadMode threadMode; //线程模式 final Class&lt;?&gt; eventType; //事件类型（传递消息的对象） final int priority; //优先级 final boolean sticky; //是否为粘性事件 /** Used for efficient comparison */ String methodString; //该并非构造初始成员变量，只是用区分其他的SubscriberMethod。 ...&#125; 既然该事件是我们订阅方法的详细参数，那么他是从哪里来的，跟踪findSubscriberMethods 123456789101112131415161718192021222324252627private static final Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = new ConcurrentHashMap&lt;&gt;();......List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //从HashMap缓存中根据class获取对应的所有订阅方法 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); //不为空，返回 if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //存在索引（初始化的成员变量） if (ignoreGeneratedIndex) &#123; //使用反射技术查询（直译），具体功能，后续追踪 subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //使用索引查找（直译），具体功能，后续追踪 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; //为空，报错 throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; //不为空，将索引判断后查找的值更新到缓存中 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; 从缓存中根据订阅者的class对象获取对应的所有订阅方法，继续跟踪subscribe()方法 1234567891011121314151617181920212223242526272829303132333435363738394041private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; //获取订阅事件 Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; //获取该事件类型对应的所有订阅者信息（Subscription） CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; //如果信息为null，初始化subscription，将该订阅信息放入其中 subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; //如果信息不为null，map中包含该订阅信息，则报错，已经被注册了 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; //根据priority优先级插入订阅信息subscriptions中 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; // private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; //根据订阅者，从typeBySubscriber中取出订阅者事件类型 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; //创建一个空的事件类型集和放入typesBySubscriber subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; //将事件类型的class对象放入subscribedEvents subscribedEvents.add(eventType); ..... &#125; 12345678910final class Subscription &#123; final Object subscriber; final SubscriberMethod subscriberMethod; /** * Becomes false as soon as &#123;@link EventBus#unregister(Object)&#125; is called, which is checked by queued event delivery * &#123;@link EventBus#invokeSubscriber(PendingPost)&#125; to prevent race conditions. */ volatile boolean active; ...&#125; Subscription为记录每个订阅方法和其对应的订阅者类，active在解注册的时候会被置为false，详看解注册 继续讲subscribe()方法 123456789101112131415161718192021222324252627282930private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; ... //如果是粘性事件 if (subscriberMethod.sticky) &#123; //如果事件类型是可继承的 if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). //private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents; //stickyEvents存储具体的粘性事件 //map变化为set Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); //循环遍历 for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); //判断candidaetEventType是否为eventType的子类 if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 如果是粘性事件，进入checkPostStickyEventToSubscription()方法中： 1234567private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) &#123; if (stickyEvent != null) &#123; // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state) // --&gt; Strange corner case, which we don&#x27;t take care of here. postToSubscription(newSubscription, stickyEvent, isMainThread()); &#125; &#125; 跳转到postToSubscription()： 123456789101112131415161718192021222324252627282930313233343536373839404142private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; //判断该事件的线程模式，执行不同操作 switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: //isMainThread判断订阅方法是否在main线程 if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; //切换到主线程异步执行 mainThreadPoster.enqueue(subscription, event); &#125; break; case MAIN_ORDERED: //如果在主线程 if (mainThreadPoster != null) &#123; //主线程异步执行 mainThreadPoster.enqueue(subscription, event); &#125; else &#123; // temporary: technically not correct as poster not decoupled from subscriber //不在主线程 invokeSubscriber(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; //如果在主线程，切换到后台线程 backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: //开启异步执行方法 asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125; &#125; 最终的enqueue()方法都是调用的invokeSubscriber方法 总结：通过注解初始化订阅方法后，在register后，在缓存中获取所有该订阅者的方法，循环遍历订阅，新建newSubscription方法，根据priority优先级将newSubscription方法放入subscriptions中，判断如果是粘性事件，则执行其对应的订阅方法。 解注册1EventBus.getDefault().unregister(this); 进入unregister方法 12345678910111213public synchronized void unregister(Object subscriber) &#123; //注册时放入的typesBySubscriber，现在从其中根据订阅者类取出订阅者事件类型 List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; //遍历执行unsubscribeByEventType，并从typesBySubscriber中删除 for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType); &#125; typesBySubscriber.remove(subscriber); &#125; else &#123; logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass()); &#125; &#125; 进入unsubscribeByEventType(): 1234567891011121314151617private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; //从subscriptionsByEventType中获取所有的订阅者信息 List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; //将active置为false，并移除 subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125; &#125; 总结：从typesBySubscriber获取订阅事件类型，根据订阅事件类型从subscriptionsByEventType获取订阅者信息，将subscription的active置为false，并移除该subscription 明显看出时regist的逆过程 typesBySubscriber ：键是订阅者类，值是订阅事件类型的map subscriptionsByEventType：键是订阅事件类型，值是订阅者信息 subscription:订阅信息，封装了订阅者类型和订阅方法，还有判断是否已经注册的active 发布普通事件1EventBus.getDefault().post(EventType type); 进入post： 12345678910111213141516171819202122232425262728public void post(Object event) &#123; //从线程池中获取线程 PostingThreadState postingState = currentPostingThreadState.get(); //获取线程的事件队列，并将当前事件入队 List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); //如果事件没有发布 if (!postingState.isPosting) &#123; //isMainThread（）方法获取发布者当前线程 postingState.isMainThread = isMainThread(); //设置事件已发布状态 postingState.isPosting = true; //如果事件被取消，报错 if (postingState.canceled) &#123; throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); &#125; //轮询eventQueue发布事件，最后取消正在发布（设置为false） try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125; 详看PostingThreadState是什么？ 12345678final static class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList&lt;&gt;(); //object集合（队列） boolean isPosting; //是否正在发布 boolean isMainThread; //发布者是否在主线程 Subscription subscription; //订阅信息 Object event; //当前事件 boolean canceled; //发布的事件是否被取消了 &#125; PostingThreadState中包含了eventQueue和其他的标志位 进入postSingleEvent： 123456789101112131415161718192021222324252627282930313233private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; //获取事件类型 Class&lt;?&gt; eventClass = event.getClass(); //订阅是否被查找到 boolean subscriptionFound = false; //如果事件是可继承的 if (eventInheritance) &#123; //查找所有事件类型 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); //获取事件类型数量 int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); //是否有被订阅的，postSingleEventForEventTyper若为true，则subscriptionFound为true subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; //如果事件不是被继承的 //是否有被订阅的，postSingleEventForEventTyper若为true，则subscriptionFound为true subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; //没有发现订阅者 if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; //将他标记为没有订阅者的post post(new NoSubscriberEvent(this, event)); &#125; &#125; &#125; 进入lookupAllEventTypes： 1234567891011121314151617181920212223private static final Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = new HashMap&lt;&gt;();......private static List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123; //线程安全写法，访问事件类型缓存 synchronized (eventTypesCache) &#123; //根据事件类型获取所有其的超类 List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass); if (eventTypes == null) &#123; //初始化，并将事件类型存入 eventTypes = new ArrayList&lt;&gt;(); Class&lt;?&gt; clazz = eventClass; while (clazz != null) &#123; eventTypes.add(clazz); addInterfaces(eventTypes, clazz.getInterfaces()); //获取其超类 clazz = clazz.getSuperclass(); &#125; //加入缓存 eventTypesCache.put(eventClass, eventTypes); &#125; return eventTypes; &#125; &#125; 进入postSingleEventForEventType： 12345678910111213141516171819202122232425262728293031private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; //根据订阅事件类型获取订阅者信息（键-订阅事件类型，值-订阅者信息） subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; //循环遍历 for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; //是否被取消 boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; //始终会执行 postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; //如果被取消，跳出循环,后续不在执行 if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; 进入postToSubscription中，发送事件到订阅者，根据模式不同，不同处理 总结：事件可继承，获取事件所有超类，挨个发布信息，反之则发布信息，根据不同的模式，在不同线程中做处理。 发布粘性事件1EventBus.getDefault().postSticky(EventType type); 进入postSticky: 123456789public void postSticky(Object event) &#123; synchronized (stickyEvents) &#123; //将粘性事件放置在stickyEvents中 stickyEvents.put(event.getClass(), event); &#125; // Should be posted after it is putted, in case the subscriber wants to remove immediately //执行post方法 post(event); &#125; 在postSticky中将粘性事件放置在stickyEvents中，执行post事件，所以是先发送事件， 总结：在register中普通事件只是注册，而粘性事件多了一个步骤就是走了post的类似方法，在注册时会触发发布事件，这样在注册后就直接发布了。这就是粘性事件的原理。详看register源码","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"JAVA泛型整理","slug":"移动端/Android原生/JAVA泛型整理","date":"2019-12-25T10:51:47.000Z","updated":"2021-05-27T11:40:17.156Z","comments":true,"path":"2019/12/25/移动端/Android原生/JAVA泛型整理/","link":"","permalink":"http://yoursite.com/2019/12/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/JAVA%E6%B3%9B%E5%9E%8B%E6%95%B4%E7%90%86/","excerpt":"","text":"JAVA泛型整理[TOC] 概述泛型的本质是参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型） 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 特性123456789List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();if(classStringArrayList.equals(classIntegerArrayList))&#123; Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);&#125; 输出结果：D/泛型测试: 类型相同。 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上可以看成是多个不同的类型，实际上都是相同的基本类型。 类型与区别 ？表示不确定的java类型，是类通配符，代表所有类型。？不会进行类型推断 T(type)表示具体的一个java类型 K V(key value)分别代表java键值中的Key Value E(element)代表Element N（number）代表数值类型 List&lt;? extends T&gt;和List &lt;? super T&gt;有什么区别? List&lt;? extends T&gt;可以接受任何继承自T的类型的List List&lt;? super T&gt;可以接受任何T的父类构成的List 例如List&lt;? extends Number&gt;可以接受List或List Object和T的区别？ ​ Object是一个实打实的类，并没有泛指谁，只有指定的Object类的，而T可以泛指Object，指任何java类 型，范围更广 泛型的类型只能是类类型，不能是简单类型（简单八大数据类型） 如果有泛型方法和非泛型方法,都满足条件,会执行非泛型方法 泛型类123456class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123; private 泛型标识 /*（成员变量类型）*/ var; ..... &#125;&#125; 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 泛型接口1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 泛型方法123456789101112131415/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125; ​ 这不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? 12345//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类public void showKeyValue2(Generic&lt;?&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125; 泛型类的中的泛型方法 12345678910111213141516class GenerateTest&lt;T&gt;&#123; public void show_1(T t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t)&#123; System.out.println(t.toString()); &#125; &#125; 泛型方法和可变参数 12345public &lt;T&gt; void printMsg( T... args)&#123; for(T t : args)&#123; Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t); &#125;&#125; 1printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55); 静态方法与泛型 12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： &quot;StaticGenerator cannot be refrenced from static context&quot; */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。 Sun的文档 1234567List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed. Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException. 这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。 编译器：把源码交给编译器编译成计算机可以执行的文件的过程（把java代码编成class文件的过程，编译期只是做一些翻译的功能，并没有把代码放在内存中运行起来，而只是） 运行期：把编译后的文件交给计算机执行 以下是ok的 1234567List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type. Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Correct. Integer i = (Integer) lsa[1].get(0); // OK 泛型通配符形参和实参的区别 形参是形式参数，接收调用者传递的参数 实参是实体参数，调用时传递出的参数 T和？`的区别？ T主要用于声明泛型类或泛型方法 ？主要用于使用泛型类或泛型方法 T在同一个地方就代表一个具体的类型，而？就代表所有类型，可以理解为所有类型的父类","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"windows下使用adb命令tab无法补全","slug":"移动端/Android原生/windows下使用adb命令tab无法补全","date":"2019-12-17T06:33:53.000Z","updated":"2021-05-27T11:40:17.156Z","comments":true,"path":"2019/12/17/移动端/Android原生/windows下使用adb命令tab无法补全/","link":"","permalink":"http://yoursite.com/2019/12/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/windows%E4%B8%8B%E4%BD%BF%E7%94%A8adb%E5%91%BD%E4%BB%A4tab%E6%97%A0%E6%B3%95%E8%A1%A5%E5%85%A8/","excerpt":"","text":"windows下使用adb命令tab无法补全在windows中使用adb命令时，进入目录按tab没有自动补全，这样用起来很麻烦，不方便，所以做了一下整理： 查询更换10进制为9的方法不生效 感觉和adb的版本有关，所以着手去查看使用的adb是否是androidSdk下的platform-tools中的adb进程 打开一个adb窗口 在任务管理器中查看adb命令的所在位置 在环境变量中删除所配置的adb环境，替换为%ANDROID_HOME%\\platform-tools，即可","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"adb","slug":"adb","permalink":"http://yoursite.com/tags/adb/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"mysql必知必会","slug":"后端/mysql必知必会","date":"2019-07-01T07:34:26.000Z","updated":"2021-05-27T11:40:17.155Z","comments":true,"path":"2019/07/01/后端/mysql必知必会/","link":"","permalink":"http://yoursite.com/2019/07/01/%E5%90%8E%E7%AB%AF/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/","excerpt":"","text":"[TOC] mysql是不区分大小写的 查看数据表的列表 ==== 设计表1show columns from xxx;查看数据表的所有数据1select * from xxx; distinct （只返回不同的值）只返回不同vend_id的vend_id行12select distinct vend_id from products; limit （限制结果）返回前5行12select prod_name from products limit 5;返回从第5行开始的后4行12select prod_name from products limit 5,4;Mysql 5的语法12select prod_name from products limit 4 offset 3 ; order by（排序）按字母顺序排列123select prod_name from products order by prod_name;按两个列排序123select prod_id,prod_price,prod_name from products order by prod_proce,prod_name; desc （指定排序方向—逆序） asc（顺序）按字母逆序排 123select prod_id,prod_price,prod_name from products order by prod_price desc; 按价格逆序，产品名顺序排 123select prod_id,prod_price,prod_name from products order by prod_price desc,prod_name; where（过滤）只返回prod_price的值为2.50的行 1select prod_name,prod_price form products where prod_pricce = 2.50; 返回不是1003的行 123select vend_id,prod_name from products where vend_id != 1003; // != ====== &lt;&gt; between（之间）加载个5，10美元之间的所有产品 123select prod_name,prod_price from products where prod_price between 5 and 10; 检查具有NULL值的列 123select prod_name from products where prod_price is NULL; and（满足所有给定条件的行） or（满足任意给定条件的行）供应商1003制造且价格小于等于10美元的所有产品的名称和价格 123select prod_id,prod_price,prod_namefrom productswhere vend_id = 1003 and prod_price &lt;= 10; 供应商1003和1002制造的所有产品的产品名称和价格 123select prod_name,prod_pricefrom productswhere vend_id = 1002 or vend_id = 1003; 价格10美元以上且由1002或1003制造的产品 123select prod_name,prod_pricefrom productswhere vend_id = 1002 or vend_id = 1003 or prod_price &gt;= 10; in（制定条件范围）检索供应商1002和1003制造的所有产品 1234567891011select prod_name,prod_price from productswhere vend_id in (1002,1003)order by prod_name;等效于select prod_name,prod_price from productswhere vend_id = 1002 or vend_id == 1003order by prod_name; 优点： 在使用长的合法选项清单时，in操作符的语法更清楚更直观 在使用in时，计算的次序更容易管理（因为使用的操作符更少） in操作符一般比or操作符清单执行更快 in的最大有点事可以包含其他select语句，使得能够更加动态地建立where字句 not （否定where之后的所有的任何条件）列出1002和1003之外的所有供应商制造的产品 1234select prod_name,prod_pricefrom products where vend_id not in (1002,1003)order by prod_name; MySQL支持使用NOT对IN、BETWEEN和EXISTS字句取反 like（用来匹配值的一部分的特殊字符，由字面值、通配符或两者组合构成的搜索条件）通配符 ：%（任何字符出现的任意次数）检索任意以jet起头的词 123select prod_id,prod_namefrom productswhere prod_name like &#x27;jet%&#x27;; 在搜索模式中任意位置是用，并且可以使用多个通配符 包含anvil值的行 123select prod_id,prod_namefrom productswhere prod_name like &#x27;%anvil%&#x27;; 通配符 ：_ （与%用途一样，但只能匹配单个字符而不是多个字符）123select prod_id,prod_namefrom productswhere prod_name like &#x27;_ ton anvil&#x27;; 注意： 通配符的处理一般花费的时间更长。所以不要过度使用。 除非绝对必要，否则不要将它们用在搜索模式的开始处，搜索起来是最慢的。 注意通配符的使用位置 正则表达式nanixie检索prod_name包含文本1000的所有行 1234select prod_namefrom productswhere prod_name regexp &#x27;1000&#x27;order by prod_name; 1234select prod_namefrom productswhere prod_name like &#x27;1000&#x27;order by prod_name; xxxxxxxxxxxxxxxxxxxxxxxxxxxx like的不会返回数据，like匹配整个列。如果被匹配的文本在列值中出现，like将不会找到他，除非使用通配符。 Mysql正则表达式3.23.4后不区分大小写（即，大写和小写都匹配），为了区分可以使用binary关键字 如： 1where prod_name regexp binary &#x27;JetPack .000&#x27;; Concat()函数 （拼接两个列）合并vend_name和vend_country为一个新列 vend_name(vend_country) 123select Concat(vend_name,&#x27;(&#x27;,vend_country,&#x27;)&#x27;)from vendorsorder by vend_name; RTrim() （删除数据右侧多余的空格）LTrim() （删除数据左侧多余的空格）as（别名）字段命名为vend_title 123select Concat(RTrim(vend_name),&#x27;(&#x27;,RTrim(vend_country),&#x27;)&#x27;) as vend_titlefrom vendorsorder by vend_name; 数据表使用别名 12345select cust_name,cust_contactfrom customers as c,orders as o,orderitems as oiwhere c.cust_id = o.cust_id and oi.order_num = o.order_num and prod_id = &#x27;TNT2&#x27;; 创建计算字段1234select pro_id,quantity,item_price, quantity*item_price as expanded_pricefrom orderitemswhere order_num = 20005; Upper() （将文本转换为大写）本例子中每个供应商都列出两次，第一次为vendors表中存储的值，第二次作为列vend_name_upcase转换为大写 123select vend_name,Upper(vend_name) as vend_name_upcasefrom vendorsorder by vend_name; 常用文本处理函数 函数 说明 Left() 返回串左边的字符 Right() 返回串右边的字符 Length() 返回串的长度 Locate() 找出串的一个字串 Lower() 将串转换为小写 Upper() 将串转换为大写 RTrim() 删除数据右侧多余的空格 LTrim() 删除数据左侧多余的空格 Soundex() 返回串的SOUNDEX值（发音类似） SubString() 返回字串的字符 注意：不管是插入或更新表值还是用WHERE字句进行过滤，日期必须为格式yyyy-mm-dd DISTINCT （排除重复的值）从 Company” 列中仅选取唯一不同的值 12SELECT DISTINCT Company FROM Orders; 组合聚合函数12345select COUNT(*) as num_items MIN(prod_price) as price_min, MAX(prod_price) as price_max, AVG(prod_price) as price_avgfrom products; having（与where非常类似，where过滤行，having过滤组）group by 子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集group by和order by的羁绊 order by group by 排序产生的输出 分组行。但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 之坑内使用选择列或表达式列，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一期使用列（或表达式），则必须使用 一般在使用group by字句时，应该也给出order by字句。这是保证数据正确排序的唯一方法。千万不要仅依赖group by排序数据 检索总计订单价格大于等于50的订单的订单号和总计订单价格，按照ordertotal排序 12345select order_num,SUM(quantity*item_price) as ordertotalfrom orderitemsgroup by order_numhaving SUM(quantity*item_price) &gt;= 50;order by ordertotal; 子查询定义：是嵌套其他查询的查询 等价于 联结 联结inner join,left join,right join,full join的图 left join === left outer join right join === right outer join 内部联结外键：某个表中存在其他表的主键即为该表的外键 两个表的关系是inner join指定，on的意义和where相同 123select vend_name,prod_name,prod_pricefrom vendors inner join productson vendors.vend_id = products.vend_id; 笛卡儿积定义：由没有联结条件的表关系返回的结果为笛卡儿积 12345select prod_name,vend_name,prod_price,quantityfrom orderitems,products,vendorswhere products.vend_id = vendors.vend_id and orderitems.prod_id = products.prod_id and order_num = 20005; 联结的表越多，mysql的性能越差 自联结12345select prod_id,prod_namefrom productswhere vend_id = (select vend_id from products where prod_id = &#x27;DTNTR&#x27;) 自己的表和自己的表进行联结查询 1234select p1.prod_id,p1.prod_namefrom products as p1,products as p2where p1.vend_id = p2.vend_id and p2.prod_id = &#x27;DTNTR&#x27;; 有时候自联结比子查询查询的快得多 自然联结定义：排除多次出现，使每个列只返回一次 迄今为止我们建立的每个内部联结都是自然联结，很有可能我们永远都不会用到不是自然联结的内部联结 外部联结定义：相关表中没有关联行的行。这种类型的联结成为外部联结 123select customers.cust_id,orders.order_numfrom customers left outer join orderson customers.cust_id = orders.cust_id left outer join ,right outer join 所以存在左外部联结和右外部联结 mysql不支持简化字符=和=\\的使用 使用联结和联结条件 注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的 保证使用正确的联结条件，否则将返回不正确的数据 应该总是提供联结条件，否则会得出笛卡儿积 select的字句顺序select—–&gt;from—–&gt;where—–&gt;group by—–&gt;having—–&gt;order by—–limit 组合查询union操作符组合多条sql查询 1234567select vend_id,prod_id,prod_pricefrom productswhere prod_price &lt;= 5unionselect vend_id,prod_id,prod_pricefrom productswhere vend_id in (1001,1002) union规则： union必须由两条或两条以上的select语句组成，语句之间用关键字union分隔 union中的每个查询必须包含相同的列、表达式或聚集函数 列数据类型兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型 union自动去除重复的行，若不想去除重复行应该用union all 使用order by 会将返回的总结果集进行排序 搜索 性能——通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。 明确控制——使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配地情况下才可以匹配或者才可以不匹配 智能化地结果——虽然基于通配符和正则表达式地搜索提供了非常灵活地搜索，但他们都不能提供一种智能化的选择结果的方法。例如，一个特殊词的搜索将会返回包含该词的所有行，而不区分包含单个匹配的行和包含多个匹配的行（按照可能是最好的匹配来排列他们）。类似，一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。 123456789CREATE TABLE productnotes(note_id int NOT NULL AUTO_INCREMENT,prod_id char(10) NOT NULL,note_date datetime NOT NULL,note_text text NULL,PRIMARY KEY(note_id),FULLTEXT(note_text)) ENGINE=MyISAM; MySQL根据字句FULLTEXT(note_text)的指示对它进行索引。 123select note_textfrom productnoteswhere Macth(note_text) Against(&#x27;rabbit&#x27;); 查找productnotes中note_text中包含rabbit的note_text 等效于 123select note_textfrom productnoteswhere note_text like &#x27;%rabbit%&#x27;; ………………………………………………………… 插入数据 插入完整的行 插入行的一部分 插入多行 插入某些查询的结果 12insert into Customersvalues(NULL,&#x27;USA&#x27;,&#x27;zhangsan&#x27;); 12insert into Customers(cust_no,cust_country,cust_name) values(NULL,&#x27;USA&#x27;,&#x27;zhangsan&#x27;); 在很多索引需要更新时，insert的操作可能会很耗时，而且他可能降低等待处理的select语句的性能。 如果数据检索式最重要的，则你可以通过在insert和into之间添加关键字LOW_PRIORITY，指示MySQL降低insert语句的优先级，如下所示： INSERT LOW_PRIORITY INTO 顺便说一下，这也适用update和delete 多条insert语句，一次提交他们，每条语句用一个分号结束 12insert xxxxx;insert xxxxx; 只要insert中列名相同，则可以 12insert into A(xx)values(xx),(xx); 插入检索出的数据：把custnew中的数据参加到customers中,不会校验列名和类型 1234insert into customers(xxxx)select xxxxfrom custnewwhere xxx; 更新和插入数据 更新表中特定行 更新表中所有行 123update customersset cust_email = &#x27;xxx@163.com&#x27;where cust_id = 10005; update中可以使用子查询， 若更新多个数据，一旦出现一个错误，则整个update操作被取消（错误发生前更新的所有行被恢复到他们原来的值）。所以为了及时发生错误，也要继续进行更新，可以使用ignore关键字 1update ignore customers... delete删除整行，删除整列需要使用update语句 遵循的规则： 除非确实打算更新和删除每一行，否则绝对不要使用不带where字句的update或delete语句 保证每个表都有主键，尽可能像where字句那样使用它（可以指定各主键、多个值或值的范围）。 在对update或delete语句使用where子句前，应该先用select进行测试，保证它过滤的是正确的记录，以防编写的where字句不正确。 使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。 创建表123456789CREATE TABLE productnotes(note_id int NOT NULL AUTO_INCREMENT,prod_id char(10) NOT NULL,note_date datetime NOT NULL,note_text text NULL,PRIMARY KEY(note_id),FULLTEXT(note_text)) ENGINE=MyISAM; AUTO_INCREMENT 自增列 DEFAULT 默认值 MySQL引擎 InnoDB是一个可靠的事务处理引擎，他不支持全文本搜索 MEMORY在功能等同于MyISAM，但由于数据存储在内存中，速度很快（特别适合于临时表） MyISAM是一个性能极高的引擎，他支持全文本搜索，但不支持事务处理 更新表123456789101112//给表添加一个列alter table vendorsadd vend_phone char(20);//删除刚刚添加的列alter table vendorsdrop column vend_phone;//定义外键alter table orderitemsadd constraint fk_orderitems_ordersforeign key (order_num) references orders (order_num); 重命名表多个表的重命名 123rename table backup_customers to customers, backup_vendors to vendors, backup_products to products; 视图 重用SQL语句 简化复杂的SQL操作。在编写查询后，可以方便地重用他而不必知道他地基本查询细节 使用表的组成部分而不是整个表 保护数据。可以给用户授予表地特定部分地访问权限而不是整个表地访问权限。（我的理解————封装） 更改数据格式和表示。视图可返回于底层表地表示和格式不同地数据 视图本身并不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索 规则和限制： 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字） 对于可以创建的视图数目没有限制 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图 order by可以用在视图中，但如果从该视图检索数据select中也含有order by，那么该视图中的order by将被覆盖 视图不能索引，也不能有关联的触发器或默认值 视图可以和表一期使用。例如，编写一条联结表和视图的select语句 创建一个名为productcustomers的视图，他联结了3个表，以返回已订购了任意产品的所有客户的列表 12345create view productcustomers asselect cust_name,cust_contact,prod_idfrom customers,orders,orderitemswhere customers.cust_id = orders.cust_idand orderitems.order_num = orders.order_num; 为了检索订购了产品TNT2的客户，可如下进行： 123select cust_name,cust_contactfrom productcustomerswhere prod_id = &#x27;TNT2&#x27;; 视图极大地简化了复杂SQL语句地使用 视图重新格式化检索出地数据就是重新一直获取该数据，该数据可能随时变化 如果视图定义中存在以下操作，则不能进行视图地更新： 分组（使用group by和having） 联结 子查询 并 聚集函数 distinct 导出（计算）列 存储过程定义：为以后的使用而保存的一条或多条MySQL语句的集合 优势： 把处理封装在容易使用的单元中，简化复杂的操作 由于不要求反复建立一系列处理步骤，这保证了数据的完整性 简化对变动的管理（封装后的安全性，改动少） 提高性能，因为使用存储过程比使用单独的SQL语句要快 存在一些只能在单个请求中的MySQL元素和特性，存储过程可以使用他们来编写功能更强更灵活的代码 总结：简单、安全、高性能 缺陷： 存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验 你可能没有创建存储过程的访问安全权限 执行存储过程 函数式的mysql，存在参数 123call productprcing(@pricelow @pricehigh @priceaverage); 其中，执行名为productpricing的存储过程，他计算并返回产品的最低、最高和平均价格 创建存储过程 一个返回产品平均价格的存储过程 12345create procedure productpricing()begin select avg(prod_price) as priceaverage from products;end; mysql命令行客户机的分隔符123456789DELTMITER //create procedure productpricing()begin select avg(prod_price) as priceaverage from products;end //DELTMITER ; DELIMITER // 告诉命令行使用程序使用//作为新的语句结束分割符 删除存储过程 1drop procedure productpricing; 如果制定的过程不存在，则drop procedure将产生一个错误。当过程在想删除它时（如果过程不存在也不产生错误）可使用drop procedure if exists 12345678910111213141516CREARE PROCEDURE productpricing( OUT pl DECIMAL(8,2), OUT ph DECIMAL(8,2), OUT pa DECIMAL(8,2))BEGIN SELECT Min(prod_price) INTO pl FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products:END; IN（传递给存储过程）、OUT（从存储过程传出，如这里使用）、INOUT（对存储过程传入和传出） 变量：内存中一个特定的位置，用来临时存储数据 1234567891011121314151617181920CALL productpricing(@pricelow, @pricehigh, @proceaverage);SELECT @priceaverage;SELECT @pricehigh,@pricelow,@priceaverageCREAT PROCEDURE ordertotal( IN onumber INT, OUT ototal DECIMAL(8,2))BEGIN SELECT Sum(item_price * quantity) FROM orderitems WHERE order_num = onumber INTO ototal;END;CALL ordertotal(20005,@total); 智能存储过程 123456789101112131415161718192021222324252627282930313233-- NAME：ordertotal-- Parameters: onumber = order number-- texable = 0 if not taxable,l if taxable-- ototal = order total variable CREATE PROCEDURE ordertotal( IN onumber INT, IN taxable BOOLEAN, OUT ototal DECIMAL(8,2)) COMMENT &#x27;Obtain order total, optionlly adding tax&#x27;BEGIN -- Declare variable for total DECLARE total DECIMAL(8,2); -- Declare tax percentage DECLARE taxrate INT DEFAULT 6; -- GET the order total SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO total; -- IS this taxable? IF taxable THEN -- Yes, so add taxrate to the total SELECT total+(total/100*taxrate) INTO total; END IF; -- And finally, save to out variable SELECT total INTO ototal; END; COMMENT 他不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示 SHOW PROCEDURE STATUS 获得包括何时、由谁创建等详细信息的存储过程列表 为限制其输出，可使用LIKE制定一个过滤模式 1SHOW PROCEDURE STATUS LIKE &#x27;ordertotal&#x27;; 游标（cursor）只能用于存储过程（函数） 使用过程： 在能够使用游标前，必选声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句 一旦声明后，必须打开游标以供使用。这个过程用前面定义的select语句把数据实际检索出来 对于填有数据的游标，根据需要取出（检索）各行 在结束使用时，必须关闭游标 123456789CREATE PROCEDURE processorders()BEGIN DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders;END;OPEN ordernumbers;CLOSE ordernumbers; example： 1234567891011121314151617181920CREATE PROCEDURE processorders()BEGIN -- Declare local variables DECLARE o INT; -- Declare the cusor DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; -- Open the cursor OPEN ordernumbers; -- Get oder number FETCH ordernumbers INTO 0; -- Close the cursor CLOSE ordernumbers;END; 其中FETCH用来检索当前行的order_num列（将自动从第一行开始）到一个名为o的局部声明变量中。 将获取的结果存储在游标中。 触发器 DELETE、INSERT、UPDATE中触发，其他MySQL语句都不支持触发器 创建时： 唯一的触发器名 触发器关联的表 触发器应该响应的活动（ DELETE、INSERT或UPDATE） 触发器何时执行（处理之前或之后） 12CREATE TRIGGER newproduct AFTER INSERT ON productsFOR EACH ROW SELECT &#x27;Product added&#x27;; 创建名为newproduct的新触发器，此触发器将在INSERT语句成功执行后执行，还指定FOR EACH ROW，因此代码对每个插入行执行。 使用INSERT语句添加一行或多行到products中，你将看到对每个成功的插入，显示Product added消息 只有表才支持触发器，视图和临时表都不支持 每个表最多支持6个触发器 触发器失败： 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话） 删除触发器 1DROP TRIGGER newproduct; INSERT触发器（适用于UPDATE） 在INSERT触发器大麻中，可引用一个名为NEW的虚拟表，访问被插入的行 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值） 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值 12CREATE TRIGGER neworder AFTER INSERT ON ordersFOR EACH ROW SELECT NEW.order_num; 触发器名为neworder ，在orders的INSERT方法中返回NEW.order_num数值 BEFORE或AFTER？ 通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据） DELETE触发器 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行 OLD中的值全都是只读的，不能更新 123456CREATE TRIGGER deleteorder BEFORE DELETE ON ordersFOR EACH ROWBEGIN INSERT INTO archive_orders(order_num,order_date,cust_id) VALUES(OLD.order_num,OLD.order_date,OLD.cust_id);END; 在任意订单删除前将执行此触发器，它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表） 使用BEFORE EDLETE触发器的优点（相对于AFTER DELETE触发器来说）为，如果由于某种原因，订单不能存档，SELETE本身将被废弃 使用BEGIN和END语句标记触发器体。在这个例子中并不是必需的，不过也没有害处，使用BEGIN END块的好处是触发器能容纳多条SQL语句 UPDATE触发器 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值） OLD中的值全都是只读的，不能更新 12CREATE TRIGGER updatevendor BEFORE UPDATE ON vendorsFOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state); 每次更新一个行时，NEW.vend_state中的值（将用来更新表行的值）都用Upper（NEW.vend_state）替换 注意 与其他DBMS想比，MYSQL 5中支持的触发器相当初级。未来的MySQL版本中有一些改进和增强触发器支持的计划 创建触发器可能需要特殊的安全访问权限，但是，触发器的执行是自动的。如果INSERT、UPDATE或DELETE语句能够执行，则相关的触发器也能执行 应该用触发器来保证数据的一致性（大小写、格式等）。在触发器中执行这种类型的处理的有点是它总是进行这种处理，而且是透明地进行，与客户机应用无关 触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易 遗憾的是，MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。 事务定义：事务处理可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行 事务（transaction）指一组SQL语句 回退（rollback）指撤销指定SQL语句的过程 提交（commit）指将未存储的SQL语句结果写入数据库表 保留点（savepoint）指事务处理中设置的临时占位符（place-holder），你可以对它发布回退（与回退整个事务处理不同） 123456SELECT * FROM ordertotals;START TRANSACTION;DELETE FROM ordertotals;SELECT * FROM ordertotals;ROLLBACK;SELECT * FROM ordertotals; ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后） 事务处理用来管理INSERT、UPDATE和DELETE语句。SELECT、CREATE、DROP无法被回退 1234START TRANSACTION;DELETE FROM orderitems WHERE order_num = 20010;DELETE FROM orders WHERE order_num = 20010;COMMIT; 如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，他是被自动撤销的） 12345-- 新建保留点SAVEPOINT delete1；-- 回退到保留点ROLLBACK TO delete1； 保留点越多越好，就能案子的意愿灵活的进行回退 释放保留点，事务完成（执行一条ROLLBACK或COMMIT）后自动释放， ​ 也可用 RELEASE SAVEPORINT 明确地释放保留点 12-- 指示MySQL不自动提交更改SET autocommit=0; 全球化和本地化字符集：字母和符号地集合 编码：某个字符集成员地内部表示 校对：规定字符如何比较地指令 12345678910111213-- 显示所有可用地字符集以及每个字符集的描述和默认校对SHOW CHARACTER SET;-- 显示所有可用的校对，以及他们使用的字符集SHOW COLLATION;--CREATE TABLE mytable( columnn1 INT, columnn2 VARCHAR(10))DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; 此语句创建一个包含两列的表，并且指定一个字符集和一个校对顺序 这个例子中指定了CHARACTER SET和COLLATE两者。一般，MySQL如下确定使用什么样的字符集和校对 如果指定CHARACTER SET和COLLATE两者，则使用这些值。 如果只指定CHARACTER SET，则使用此字符集及其默认的校对 如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认 安全管理数据库维护改善性能数据库范式第一范式（1NF）数据库表的每一列都是不可分割的原子数据项，无重复的域 第二范式（2NF）满足第二范式，则必定符合第一范式。数据库表中的每个实例或记录必须可以被唯一的区分。 要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性 第三范式（3NF）在2NF的基础上，任何非主属性不依赖于其他非主属性，表中不能存在非其它表中非主键的字段。（排除冗余）","raw":null,"content":null,"categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"OAuth2.0简单理解","slug":"后端/OAuth2-0简单理解","date":"2019-07-01T07:19:45.000Z","updated":"2021-05-27T11:40:17.154Z","comments":true,"path":"2019/07/01/后端/OAuth2-0简单理解/","link":"","permalink":"http://yoursite.com/2019/07/01/%E5%90%8E%E7%AB%AF/OAuth2-0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/","excerpt":"","text":"[TOC] 一、定义一个关于授权的开放网络标准。 允许用户让第三方应用访问该用户在某一网站上存储的私密的资源，而无须将用户名和密码提供给第三方应用 二、授权方式四种授权方式： 授权码（authorization-code） 隐藏式（implicit） 密码式（password） 客户端凭证（client credentials） 1.授权码第三方应用先申请和一个授权码，然后再用该码获取令牌 最常用流程，安全性也高。授权码通过前端传送，令牌则是存储在后端，而且所有与资源服务器的通信都在后端完成。这样前后端分离，可以避免令牌泄露 （类似于微信登录） A跳转B，请求授权码。 B提示登录授权，授权后回跳到A，返回授权码 A拿到授权码，向B的后端请求令牌 A拿到令牌，正常访问B的资源 2.隐藏式允许直接向前端办法令牌，这中方式没有授权码这个中间步骤 A跳转B，请求令牌 A拿到令牌，正常访问B的资源 3.密码式允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌 A带上B的用户名和密码访问，返回令牌 A拿到令牌，正常访问B的资源 风险很大，除特殊情况一般不考虑吧使用，必须是用户高度信任的用户 4.凭证式没有前端的命令行应用，在命令下请求令牌 A在命令行请求B（client_id、client_secret） B验证通过，直接返回令牌，A正常请求B的资源 此方式不是针对用户的，二十针对第三方应用的，所以存在多用户共享同一令牌 三、更新令牌一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌。令牌到期前，用户使用refresh token发送一个请求，去更新令牌","raw":null,"content":null,"categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://yoursite.com/tags/OAuth2-0/"}]},{"title":"flask项目使用","slug":"前端/flask项目使用","date":"2019-05-29T05:51:08.000Z","updated":"2021-05-27T11:40:17.154Z","comments":true,"path":"2019/05/29/前端/flask项目使用/","link":"","permalink":"http://yoursite.com/2019/05/29/%E5%89%8D%E7%AB%AF/flask%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Flask简介Flask是一个使用 Python 编写的轻量级 Web 应用框架。 Flask环境配置1234567891011//添加flaskpip3 install Flask//添加python3的mysql支持pip3 install pymysql//添加Flask-SQLAlchemy链接mysqlpip3 install Flask-SQLAlchemy//添加tornado线上管理pip3 install tornado//python网络请求框架pip3 install requests FLask基本使用123456789from flask import Flaskapp = Flask(__name__) @app.route(&#x27;/&#x27;)def hello_world(): return &#x27;Hello World!&#x27; if __name__ == &#x27;__main__&#x27;: app.run() Flask项目的目录 其中 scss是进行屏幕适配的，使用vw进行适配 templates中存放的是html文件，前端界面 app中是网站的路由管理及后台处理 model是数据库的设置 tornado_sever是使用tornado进行线上部署管理 本项目连接的是mysql数据库 123456789DIALECT = &#x27;&#x27; # 要用的什么数据库DRIVER = &#x27;&#x27; # 连接数据库驱动USERNAME = &#x27;&#x27; # 用户名PASSWORD =&#x27;&#x27; # 密码HOST = &#x27;&#x27; # 服务器PORT =&#x27;&#x27; # 端口DATABASE = &#x27;&#x27; # 数据库名SQLALCHEMY_DATABASE_URI = &quot;&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8&quot;.format(DIALECT, DRIVER, USERNAME, PASSWORD, HOST, PORT, DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False 使用torndo进行线上管理 123456789101112131415# tornado_server.py# coding=utf-8from tornado.wsgi import WSGIContainerfrom tornado.httpserver import HTTPServerfrom tornado.ioloop import IOLoopfrom app import appif __name__ == &#x27;__main__&#x27;: http_server = HTTPServer(WSGIContainer(app)) http_server.listen(5000) IOLoop.instance().start() 问题总结 https网页中解决http请求 问题：在线上环境，本项目成为https的网页链接，其中牵扯到http的网络请求交互，在游览器 中，这种行为 是被禁止的，所以http请求都被终止 解决方案： 在前端js中的http请求映射到python后台接口中，通过python请求http请求后将结果返回给js前端页面进行交互 路由接口重定向 1redirect(url_for(&#x27;&#x27;)) 版本更新前端静态资源没有更新 问题：前端页面更新后，修改的样式，逻辑没有更新，是因为游览器存在缓存导致，加载的是上一个版本的静态资源。 解决方案：在必要的css和js文件在html中引用时，需要添加后缀，如下： 1&lt;script src=&quot;../static/js/city.js?v=&#123;&#123; version &#125;&#125;&quot;&gt;&lt;/script&gt; 通过统一处理，在开发环境中version为一个随机数，在正式环境中version为版本号，这样在上线后，直接可以查看本项目是否已经更新到最新版本 手机端网页适配 添加scss生成css的适配方案 ajax中多次请求后，需要获取最后一次的请求数据，请求频繁导致先请求的数据后面请求成功，则顺序被改变， 所以需要对请求的接口进行判断处理，在请求成功后，如果二次进入了，则关闭上次的请求，在返回成功和失败的接口处进行close的处理 微信pc端无法加载es6的js代码，需要转化为es5，去掉let =&gt;等es6标识，即可 Flask运行在生产环境中运行 1python app.py 在开发环境中运行 1python tornado_server.py Flask中默认启用的是5000端口，所以链接地址为localhost:5000/xxx如果不想使用5000端口，需要在app.run中进行设定 1234app.run( host=&#x27;0.0.0.0&#x27;, port=5000, )","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Android学习笔记","slug":"移动端/Android原生/Android学习笔记","date":"2019-05-24T08:20:48.000Z","updated":"2021-05-27T11:40:17.155Z","comments":true,"path":"2019/05/24/移动端/Android原生/Android学习笔记/","link":"","permalink":"http://yoursite.com/2019/05/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1. ViewStub的应用&emsp;&emsp;在不显示布局时我们会使用 View.GONE 和 View.VISIBLE 属性去控制View的布局显示，但是在该使用过程中，该View的对象还是会被建立（只要通过inflate就会创建对象），被实例化，所以会耗费内存。 &emsp;&emsp;这时候就会引入ViewStub这个控件，该控件是一个轻量级的View，它是一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。 &emsp;&emsp;其原理就是通过控制ViewStub来控制View的对象的创建和渲染 特点： ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了。 ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。 因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。 所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。ViewStub是能被使用一次。一旦被指定infate后，其存在的特性就会消失。 2. SurfaveView控件的理解3. AOSP(Android OPen Source Project)Android开源工程4.内存泄露： static所修饰的方法和变量拥有和app一样长的生命周期 静态变量导致的内存泄漏：静态变量（方法）中对context的使用，导致Activity不能被回收 单例模式导致的内存泄露：单例中同样使用了static方法，对context的使用不能被释放 上述两种的解决方法都为传入context.getApplicationContext()，其存在的生命周期和app生命周期一样长。 非静态内部类持有外部引用导致的内存泄漏：（非静态内部类和外部类相互绑定，而静态内部类与外部类相互分离）内部类持有外部类的引用，外部类无法正常回收（将其改为静态内部类） Handler引起的内存泄漏： 静态内部类+弱引用：static + WeakReference&lt;&gt;() Handler.Callback的方式 1234567891011 Handler mHandler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; switch (msg.what) &#123; case 200: mTV_incloud_merge.setText((String) msg.obj); break; &#125; return false; &#125;&#125;) 流文件打开后要close()，动画要cancel()，数据库的使用要关闭 Listview的优化，ViewHolder对item的复用 Bitmap的三级缓存和压缩技术 5. Android进阶——Android消息机制之Looper、Handler、MessageQueen 1. Handler涉及哪些类，各自功能是什么？ Handler：将Message对象发送到MessageQueue中去，同时将自己的引用赋值给Message#target. Lopper：将Message对象从MessageQueue中取出来，并交给Handler#dispatchMessage(Message)方法，不是调用Handler#handleMessage(Message)方法 MessageQueue：负责插入和取出Message Message：所传递的信息的载体 ThreadLocal: 2. 发送消息的方式12345678910//常用sendMessage(Message msg)sendMessageDelayed(Message msg, long uptimeMillis)post(Runnable r)postDelayed(Runnable r, long uptimeMillis)sendMessageAtTime(Message msg,long when)//不常用sendEmptyMessage(int what)sendEmptyMessageDelayed(int what, long uptimeMillis)sendEmptyMessageAtTime(int what, long when) 3. MessageQueue中的Message是有序的吗？根据什么排序? 是有序的，根据Message#when排序的 Message#when是一个时间，用于表示Message期望被分发的时间，该值是SystemClock#uptimeMillis()与delayMillis之和 因为System.currentTimemillis()可以被修改，所以不用此表示 4. 子线程可以创建Handler对象吗？ 不能直接调用Handler的无参构造方法 先要调用Looper.prepare()在当前线程初始化一个Looper 通过构造方法传入一个Looper 主线程调用Handler的无参构造会存在一个自动绑定的过程 5. Looper是如何与Thread关联的?通过ThreadLocal关联的 6.Handler有哪些构造方法123456789101112public Handler() &#123; this(null, false);&#125;public Handler(Callback callback) &#123; this(callback, false);&#125;public Handler(Looper looper) &#123; this(looper, null, false);&#125;public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125; 7. 子线程如何获取当前线程的Looper1Looper.myLooper() 内部原理就是同过上面提到的sThreadLocal#get()来获取Looper 1234// Looper.java:203public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 8. 如何在任意先成获取主线程的Looper1Looper.getMainLooper() 9. 如何判断当前线程是不是主线程方法一： 1Looper.myLooper() == Looper.getMainLooper() 方法二： 1Looper.getMainLooper().getThread() == Thread.currentThread() 方法三： 方法二的简化版 1Looper.getMainLooper().isCurrentThread() 10. Looper.loop()会退出吗？不会自动推出，通过调用Looper#quit()或者Looper#quitSafely()让他退出 两个方法都是调用了 MessageQueue#quit(boolean) 方法，当 MessageQueue#next() 方法发现已经调用过 MessageQueue#quit(boolean) 时会 return null 结束当前调用，否则的话即使 MessageQueue 已经是空的了也会阻塞等待。 11. Looper.loop() 方法是一个死循环为什么不会阻塞APP6. Http协议 HTTP 0.9 这个版本只有GET方法 1.0 这个版本有GET HEAD POST这三个方法 HTTP 1.1 这个版本是当前版本，包含GET HEAD POST OPTIONS PUT DELETE TRACE CONNECT这8个方法 报文：HTTP应用程序之间发送的数据块（起始行，首部，主体） Http请求所经历的过程 建立tcp连接（三次握手） &gt;&gt; 客户端向服务端发送请求命令 &gt;&gt; 客户端发送请求头信息 &gt;&gt; 服务器应答 &gt;&gt; 服务器应答头信息 &gt;&gt; 服务器向客户端发送数据 &gt;&gt; 服务器关闭tcp连接 请求方法（Method）：GET和POST、 不常用的有PUT，DELETE、HEAD、options HEAD 与 GET 的使用方式完全相同。区别在于，HEAD 请求的返回响应中没有 Body用途：比如下载需求，返回的 Headers 中有下载内容的大小，可以用于显示进度。 GET、PUT、DELETE 都是幂等操作，POST不是幂等的，不安全 PUT、DELETE除第一种方法外，只能通过先在服务端重写HTTP请求方法（自定义HttpMessageHandler来实现），然后再在客户端请求报文头指定“X-HTTP-Method-Override”值为PUT或DELETE来实现； PUT 请求，客户端方法与POST方法相同，只是TYPE指定为：PUT；服务器端与POST方法相同； DELETE请求，客户端方法与GET方法相同，只是TYPE指定为：DELETE；服务器端与GET方法相 PUT和POST的区别1、PUT请求时，如果用相同参数访问二次接口，Post 仅会产生一条记录 使用场合例如： 用户的账户二维码只和用户关联，而且是一一对应的关系，此时这个api就可以用PUT 2、POST请求时，如果用相同参数访问二次接口，Post 会产生多条记录 使用场合例如： 在我们的支付系统中，一个api的功能是创建收款金额二维码，它和金额相关，每个用户可以有多个二维码，如果连续调用则会创建新的二维码，这个时候就用POST Get请求添加body请求吗？在规定 HTTP 语义及内容的 RFC 7231 中，并未限制 GET 请求中是否允许携带交互数据！所以，有些 HTTP 服务允许这种行为，而另外一些（特别是缓存代理）则不允许这种行为。 Apache Http Client 和 OkHttpClient 都不支持 GET 请求发送 Body 数据，而 AsyncHttpClient 是可以的。 所以一般情况下，get请求不使用body进行数据传输，一般是拼接到url中实现 options的主要用途OPTIONS请求方法的主要用途有两个： 1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。 2、用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。 TRACETRACE方法被用于激发一个远程的，应用层的请求消息回路（译注：TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路，）。最后的接收者或者是接收请求里Max-Forwards头域值为0源服务器或者是代理服务器或者是网关。TRACE请求不能包含一个实体。 TRACE方法允许客户端知道请求链的另一端接收什么，并且利用那些数据去测试或诊断。Via头域值（见14.45）有特殊的用途，因为它可以作为请求链的跟踪信息。利用Max-Forwards头域允许客户端限制请求链的长度去测试一串代理服务器是否在无限回路里转发消息。 如果请求是有效的，响应应该在响应实体主体里包含整个请求消息，并且响应应该包含一个Content-Type头域值为”message/http”的头域。TRACE方法的响应不能不缓存。 CONNECT（连接）HTTP1.1协议规范保留了CONNECT方法，此方法是为了能用于能动态切换到隧道的代理服务器（proxy，译注：可以为代理，也可以是代理服务器）。 状态码： 1xx:临时性消息 12100：继续发送101：正在切换协议 2xx:成功 12200：OK (最常见) 201：创建成功 3xx:重定向 123301：域名永久移动302：暂时移动304：内容未改变，请求被重定向到客户端本地缓存 4xx:客户端错误 1234400：客户端请求错误，服务器不理解请求的语法。401：未授权，要求进行身份验证。403：被禁止，服务器拒绝请求。404：找不到内容，服务器找不到请求的网页。(最常见) 5xx:服务器错误 12500：服务器内部错误 (最常见)503：服务不可用 http协议osi七层协议和TCP/IP五层协议 HTTP使用80端口 HTTPS使用443端口 7.Https协议协议过程，中间人攻击缺点： 证书费用高 访问速度慢 Hypertext Transfer Protocol Secure 缩写：HTTPSHttps经Http进行通信，但利用SSL/TLS来加密数据包 TLS/SSL协议主要依赖于三类基本算法：散列函数Hash、对称加密和非对称加密。 非对称加密：身份认证和密钥协商（RSA） 对称加密：对数据进行加密（AES） 散列函数加密：验证信息的完整性（MD5,SHA1,SHA256） CA证书验证机制，解决中间人攻击的方式 https的SSL/TSL密钥是在应用层和传输层之间的 申请证书不需要提供私钥，确保私钥永远只能服务器掌握 证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名 内置CA对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书 证书=公钥+申请者与颁发者信息+签名 公钥放在数字证书中。只有证书是可信的，公钥就是可信的。 服务器证书server.pem的签发者为中间证书机构inter，inter根据证书inter.pem验证server.pem确实为自己签发的有效证书 中间证书inter.pem的签发CA为root,root根据root.pem验证inter.pem为自己签发的合法证书 客户端内置新人CA的root.pem证书，因此服务器证书server.pem的被信任 https的加密过程 8.Gradle12345678Ant: 长江后浪推前浪，前浪已经over了|---编译、测试、打包Maven:使用xml标记构建脚本|---依赖管理、编译、测试、打包、发布Gradle:使用Groovy语言构建脚本|---依赖管理、编译、测试、打包、发布、灵活的脚本 Gradle：是一个基于Groovy语言的开源项目自动化构建工具 Groovy: 基于java虚拟机的动态语言、面向对象/脚本，完全兼容Java语法 9. ClassLoader插件化技术的核心 作用：Android虚拟机运行的Dex字节码（将Class文件合并优化生成的产物），ClassLoader用来加载dex文件。 委托双亲机制：顶层（父类）无法加载这个类，则由由自己加载，如果还加载不到，则会报ClassNotFound错误。（可以用爸爸的钱就绝对不用自己的钱，如果爸爸没有钱，再用自己的， 如果自己还是没有钱，那么就classnotfound异常） 10. Android原生与js交互一、js调用Android方法方法一：通过 Webview 的 addJavascriptInterface() 进行对象映射 优点：使用简单，仅将Android对象和JS对象映射即可 缺点：存在漏洞问题 1）允许WebView加载JS 1webView.getSettings().setJavaScriptEnabled(true); 2）编写JS接口 123456789101112131415161718public class JsInterface &#123; private static final String TAG = &quot;JsInterface&quot;; private JsBridge jsBridge; public JsInterface(JsBridge jsBridge) &#123; this.jsBridge = jsBridge; &#125; /** * 这个方法由 JS 调用， 不在主线程执行 * * @param value */ @JavascriptInterface public void callAndroid(String value) &#123; Log.i(TAG, &quot;value = &quot; + value); jsBridge.setTextValue(value); &#125;&#125; 3）给WebView添加JS接口 12webView.addJavascriptInterface(new JsInterface(this), &quot;launcher&quot;);// 此处的 launcher 可以自定义，最终是 JS 中要使用的对象 4）js代码中调用java方法 12345678if (window.launcher)&#123; // 判断 launcher 对象是否存在 // 此处的 launcher 要和 第3步中定义的 launcher 保持一致 // JS 调用 Android 的方法 launcher.callAndroid(str);&#125;else&#123; alert(&quot;launcher not found!&quot;);&#125; 方法二：通过 WebViewClient 的 shouldOverrideUrlLoading() 方法回调拦截 url 优点：不存在方式一的漏洞 缺点：JS获取Android方法的返回值复杂 1）JS代码中，约定协议 12345function callAndroid()&#123; // 约定的 url 协议为：js://webview?arg1=111&amp;arg2=222 document.location = &quot;js://webview?arg1=&quot;+inputEle.value+&quot;&amp;arg2=222&quot;;&#125; 2）Android 代码中，通过设置 WebViewClient 对协议进行拦截处理 1234567891011121314151617181920212223242526webView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; // 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数） // 例如：url = &quot;js://webview?arg1=111&amp;arg2=222&quot; Uri uri = Uri.parse(url); // 如果url的协议 = 预先约定的 js 协议 if (uri.getScheme().equals(&quot;js&quot;)) &#123; // 拦截url,下面JS开始调用Android需要的方法 if (uri.getAuthority().equals(&quot;webview&quot;)) &#123; // 执行JS所需要调用的逻辑 Log.e(&quot;TAG&quot;, &quot;JS 调用了 Android 的方法&quot;); Set&lt;String&gt; collection = uri.getQueryParameterNames(); Iterator&lt;String&gt; it = collection.iterator(); String result = &quot;&quot;; while (it.hasNext()) &#123; result += uri.getQueryParameter(it.next()) + &quot;,&quot;; &#125; tv_result.setText(result); &#125; return true; &#125; return super.shouldOverrideUrlLoading(view, url); &#125;&#125;); 方法三：通过 WebChromeClient 的 onJsAlert() 、 onJsConfirm() 、 onJsPrompt（）方法回调拦截 JS 对话框 alert() 、 confirm() 、 prompt（） 消息1）JS代码中，约定协议 1234// 调用 prompt()var result=prompt(&quot;js://prompt?arg1=&quot;+inputEle.value+&quot;&amp;arg2=222&quot;);alert(&quot;prompt：&quot; + result); 2）Android 代码中，通过设置 WebChromeClient 对协议进行拦截处理 123456789101112131415161718192021222324252627282930313233343536373839webView.setWebChromeClient(new WebChromeClient() &#123; @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; // 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数） // 例如：url = &quot;js://webview?arg1=111&amp;arg2=222&quot; Uri uri = Uri.parse(message); Log.e(&quot;TAG&quot;, &quot;----onJsPrompt---&gt;&gt;&quot; + url + &quot;,&quot; + message); // 如果url的协议 = 预先约定的 js 协议 if (uri.getScheme().equals(&quot;js&quot;)) &#123; // 拦截url,下面JS开始调用Android需要的方法 if (uri.getAuthority().equals(&quot;prompt&quot;)) &#123; // 执行JS所需要调用的逻辑 Log.e(&quot;TAG&quot;, &quot;JS 调用了 Android 的方法&quot;); Set&lt;String&gt; collection = uri.getQueryParameterNames(); Iterator&lt;String&gt; it = collection.iterator(); String result2 = &quot;&quot;; while (it.hasNext()) &#123; result2 += uri.getQueryParameter(it.next()) + &quot;,&quot;; &#125; tv_result.setText(result2); &#125; return true; &#125; return super.onJsPrompt(view, url, message, defaultValue, result); &#125; @Override public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123; Log.e(&quot;TAG&quot;, &quot;----onJsAlert---&gt;&gt;&quot; + url+ &quot;,&quot; + message); return super.onJsAlert(view, url, message, result); &#125; @Override public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123; Log.e(&quot;TAG&quot;, &quot;----onJsConfirm---&gt;&gt;&quot; + url+ &quot;,&quot; + message); return super.onJsConfirm(view, url, message, result); &#125;&#125;); 二、Android调用JS方法方法一：通过WebView的loadUrl()1）编写JS方法 1234var callJS = function(str)&#123; inputEle.value = str;&#125; 2）使用webView.loadUrl()调用JS方法 123// Android 调用 JS 方法webView.loadUrl(&quot;javascript:if(window.callJS)&#123;window.callJS(&#x27;&quot; + str + &quot;&#x27;);&#125;&quot;); 方法二： 通过 WebView 的 evaluateJavascript() 该方法比第一种方法效率更高，使用更简洁； 该方法执行不会刷新页面，而第一种方法（ loadUrl ）则会； Android 4.4 以后才能使用。 123456789if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; webView.evaluateJavascript(&quot;javascript:if(window.callJS)&#123;window.callJS(&#x27;&quot; + str + &quot;&#x27;);&#125;&quot;, new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; Log.e(&quot;TAG&quot;, &quot;---------&gt;&gt;&quot; + value); &#125; &#125;);&#125; 11.RecyclerView缓存机制缓存优先级（从高到低） mAttachedScrap获取 mCachedViews获取 mRecyclerPool获取 在RecyclerView中，并不是每次绘制表项，都会重新创建ViewHolder对象，也不是每次都会重新绑定ViewHolder数据 RecyclerView通过Recycler获得下一个待绘制表项 Recycler有4个层次用于缓存ViewHolder对象、优先级从高到低依次为ArrayList mAttachedScrap、ArrayList mCachedViews、ViewCacheExtension mViewCacheExtension、RecycledViewPool mRecyclerPool。如果四层缓存都未命中，则重新创建饼绑定ViewHolder对象 RecyclerViewPool对ViewHolder按viewType分类存储（通过SparseArray），同类ViewHolder存储在默认大小为5的ArrayList中 葱mRecyclerPool中复用的ViewHolder需要重新绑定数据，从mAttachedScrap中复用的ViewHolder不需要重新创建也不需要重新绑定数据。 12.性能优化 启动速度 页面显示速度优化原因（即 页面显示速度慢的原因） a. 页面需绘制的内容（布局 &amp; 控件）太多，从而导致页面测量时间过长 b. 绘制效率过低，从而导致绘制时间过长 降低onDraw()方法的复杂度 避免过度绘制(Overdraw) 避免嵌套布局，复杂布局，简化布局，使用 &lt; viewStub/&gt; &lt; include/&gt; &lt; merge/&gt;等标签布局 布局属性 wrap_content 会增加布局测量时计算成本，应尽可能少用 响应速度 优化方案：使用多线程，将大量 &amp; 耗时操作放在工作线程中执行 多线程的方式 包括：AsyncTask、继承 Thread类、实现 Runnable接口、Handler消息机制、HandlerThread等 注：实际开发中，当一个进程发生了ANR后，系统会在 /data/anr目录下创建一个文件 traces.txt，通过分析该文件可定位出ANR的原因 稳定性 内存优化 优化原因 避免因不正确使用内存 &amp; 缺乏管理，从而出现 内存泄露（ML）、内存溢出（OOM）、内存空间占用过大 等问题，最终导致应用程序崩溃（Crash） 内存回收策略 内存分配策略 注：用1个实例讲解 内存分配 1234567891011121314151617public class Sample &#123; // 该类的实例对象的成员变量s1、mSample1 &amp; 指向对象存放在堆内存中 int s1 = 0; Sample mSample1 = new Sample(); // 方法中的局部变量s2、mSample2存放在 栈内存 // 变量mSample2所指向的对象实例存放在 堆内存 public void method() &#123; int s2 = 0; Sample mSample2 = new Sample(); &#125;&#125; // 变量mSample3的引用存放在栈内存中 // 变量mSample3所指向的对象实例存放在堆内存 // 该实例的成员变量s1、mSample1也存放在堆内存中 Sample mSample3 = new Sample(); 内存回收策略 GC垃圾回收机制 常见问题bitmap图片资源 内存抖动 优化方案： 尽量避免频繁创建大量、临时的小对象 代码质量&amp;数量 常见内存问题 总结","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"flutter listview和adapter","slug":"移动端/flutter/flutter-listview和adapter","date":"2019-05-24T08:18:16.000Z","updated":"2021-05-27T11:40:17.157Z","comments":true,"path":"2019/05/24/移动端/flutter/flutter-listview和adapter/","link":"","permalink":"http://yoursite.com/2019/05/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF/flutter/flutter-listview%E5%92%8Cadapter/","excerpt":"","text":"1. ListView.Builder()builder属性详细介绍 1234567891011121314151617181920//设置滑动方向 Axis.horizontal 水平 默认 Axis.vertical 垂直 scrollDirection: Axis.vertical, //内间距 padding: EdgeInsets.all(10.0), //是否倒序显示 默认正序 false 倒序true reverse: false, //false，如果内容不足，则用户无法滚动 而如果[primary]为true，它们总是可以尝试滚动。 primary: true, //确定每一个item的高度 会让item加载更加高效 itemExtent: 50.0, //内容适配 shrinkWrap: true, //item 数量 itemCount: list.length, //滑动类型设置 physics: new ClampingScrollPhysics(), //cacheExtent 设置预加载的区域 cacheExtent: 30.0, //滑动监听// controller , shrinkWrap特别推荐child 高度会适配 item填充的内容的高度,我们非常的不希望child的高度固定，因为这样的话，如果里面的内容超出就会造成布局的溢出。shrinkWrap多用于嵌套listView中 内容大小不确定 比如 垂直布局中 先后放入文字 listView （需要Expend包裹否则无法显示无穷大高度 但是需要确定listview高度 shrinkWrap使用内容适配不会有这样的影响） primaryIf the [primary] argument is true, the [controller] must be null.在构造中默认是false 它的意思就是为主的意思，primary为true时，我们的controller 滑动监听就不能使用了 physics这个属性几个滑动的选择AlwaysScrollableScrollPhysics() 总是可以滑动NeverScrollableScrollPhysics禁止滚动BouncingScrollPhysics 内容超过一屏 上拉有回弹效果ClampingScrollPhysics 包裹内容 不会有回弹 cacheExtent这个属性的意思就是预加载的区域设置预加载的区域 cacheExtent 强制设置为了 0.0，从而关闭了“预加载” controller 滑动监听，我们多用于上拉加载更多，通过监听滑动的距离来执行操作。 问题记录listview需要添加父布局，flex;1做到全屏拉伸，才会显示Expanded下的listview无法置顶，需要设置padding:EdgeInsets.only(top: 0)","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/tags/flutter/"},{"name":"listview","slug":"listview","permalink":"http://yoursite.com/tags/listview/"},{"name":"adapter","slug":"adapter","permalink":"http://yoursite.com/tags/adapter/"}]},{"title":"fish-redux和flutter-redux学习","slug":"移动端/flutter/fish-redux和flutter-redux学习","date":"2019-05-24T08:16:23.000Z","updated":"2021-05-27T11:40:17.157Z","comments":true,"path":"2019/05/24/移动端/flutter/fish-redux和flutter-redux学习/","link":"","permalink":"http://yoursite.com/2019/05/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF/flutter/fish-redux%E5%92%8Cflutter-redux%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"flutter-redux流程图 原理flutter_redux（0.5.2）作为工具类桥接Redux和Flutter，它提供了StoreProvider，StoreBuilder，StoreConnector这些组件，使我们在flutter中使用redux变的很简便。 fish-redux的数据流向 总处理页面 page中是最终形成的page页面，可以理解为index文件 page中绑定state,effect,reducer,view,middleware 基本用法 View布局中使用buildView搭建布局，关联store和触发dispatch事件，dispatch触发action事件 action事件中接受dispatch传过来的参数 触发effect事件，effect中绑定不同的action事件和副作用的函数（eg：TextEditingController），再次触发dispatch事件 触发reducer事件，根据action的类型去执行不同的逻辑，返回新的state，触发更新 view页面对改变的state数据页面进行重新渲染刷新 effect处理所有的数据处理，reducer只做数据的更新和生成新的state effect文件不生成新的state，如果有网络请求处理，需要在生命中其中dispatch网络请求action成功后，再次action传递数据，在reducer中生成新的state，从而时page页面获取的state数据改变 问题 fish-redux最终的页面处理是基于一个Component页面，该页面是一个StatefulWidget，所以，fish-redux的默认页面时StatefulWidget类型的，在需要StatelessWidget页面时，需要使用WidgetWrapper实现。 生命周期统一放置在effect中处理 fish-redux推荐使用函数式编程方式，也提供面向对象式的编程方式。（java转过来的同学，对面向对象式的编程方式比较亲切，但是推荐使用函数式编程，不妨试一试） fish-redux使用identical比较新旧数据去决定是否需要更新，如果对刷新有特殊要求，可以自己定义一个ShouldUpdate 123bool shouldUpdate(DetailState old, DetailState now) &#123; return old.message != now.message;&#125; 对Effect产生的业务进行统一异常处理，onError 12345678class MessageComponent extends Component&lt;String&gt; &#123; MessageComponent(): super( view: buildMessageView, effect: buildEffect(), reducer: buildMessageReducer(), onError: onMessageError, );&#125; page页面是继承于Component的，page的特色是可以配置Middleware，但是需要配置一个初始化页面数据的初始化函数initState，page页面可以接受一个参数，在创建页面时带参数进来 component独立使用时需要进行buildComponent（x,x）两个参数 12345678class TestComponent &#123; Widget test&lt;T&gt;(Component&lt;T&gt; component, T initState) &#123; final PageStore&lt;T&gt; store = createPageStore&lt;T&gt;( initState, component.reducer, ); return component.buildComponent(store, store.getState); &#125;&#125; 需要component的state和reducer 所以一般情况下都用page，参数问题 adapter的时候","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/tags/flutter/"},{"name":"fish-redux","slug":"fish-redux","permalink":"http://yoursite.com/tags/fish-redux/"}]},{"title":"flutter学习笔记","slug":"移动端/flutter/flutter学习笔记","date":"2019-05-24T08:00:59.000Z","updated":"2021-05-27T11:40:17.157Z","comments":true,"path":"2019/05/24/移动端/flutter/flutter学习笔记/","link":"","permalink":"http://yoursite.com/2019/05/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF/flutter/flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"编程库 intl: “&gt;=0.14.0” //国际化、日期格式化 url_launcher: ^4.0.1 //用于在移动平台中启动URL的Flutter插件 fluro // Flutter最亮，最时髦，最酷的路由器 event_bus //使用Dart Streams 进行解耦应用程序的简单事件总线 1.锁定手机的屏幕 不允许它随着用户旋转手机而改变 123456SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp]);SystemChrome.setPreferredOrientations([ DeviceOrientation.portraitUp, //竖屏 DeviceOrientation.portraitDown, //横屏 ]); 2. InheritedWidget类 小部件的基类，可以有效地在树中传播信息。 这允许子部件访问整个层次结构中的其他组件，而不需要传递这些引用。 具体使用Flutter知识点: InheritedWidget 定位为父组件，其中可以自定义方法和属性，每个子类新建一个父组件类，调用父类的方法实现刷新widget数据，这样包括父控件及其所有子控件都能实时获取到当前改变的值 3. Dart语法 使用?.来确认前操作数不为空, 常用来替代. , 避免左边操作数为null引发异常 ??=== 如果为空 4.Listview问题记录 listview需要添加父布局，flex;1做到全屏拉伸，才会显示 Expanded下的listview无法置顶，需要设置padding:EdgeInsets.only(top: 0) 5.image的填充属性 fit 6.colum中的显示Text文本溢出时设置父布局为Expanded7.（_）=&gt; const MyHomePage(); _的意思是不关心入参的信息8.build之后的回调12//在build函数中添加WidgetsBinding.instance.addPostFrameCallback(xxx)","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/tags/flutter/"}]},{"title":"CBB锻炼的真相","slug":"随笔/CBB锻炼的真相","date":"2019-05-24T07:59:54.000Z","updated":"2021-05-27T11:40:17.158Z","comments":true,"path":"2019/05/24/随笔/CBB锻炼的真相/","link":"","permalink":"http://yoursite.com/2019/05/24/%E9%9A%8F%E7%AC%94/CBB%E9%94%BB%E7%82%BC%E7%9A%84%E7%9C%9F%E7%9B%B8/","excerpt":"","text":"10000步&lt;3000步: 3000步的快走，高于身体强度30%，比平常走10000步更加锻炼身体，锻炼心肺 每周锻炼2分钟： HIIT单车，快速消耗肌糖原，有氧适应平均提升11%， HIIYT==1分钟张臂跳跃+1分钟深蹲+1分钟快跑+1分钟张臂跳跃+1分钟深蹲 举重物和轻物的锻炼效果没有差距： 但是都要达到肌肉疲劳，所以举重物的时间会缩短 跑步不会伤膝关节，甚至有益 锻炼使人快乐： 锻炼时会产生内源性大麻素，类似于大麻中的大麻醇，可以引发快感","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"名词缩写整理","slug":"随笔/名词缩写整理","date":"2019-05-24T07:58:34.000Z","updated":"2021-05-27T11:40:17.158Z","comments":true,"path":"2019/05/24/随笔/名词缩写整理/","link":"","permalink":"http://yoursite.com/2019/05/24/%E9%9A%8F%E7%AC%94/%E5%90%8D%E8%AF%8D%E7%BC%A9%E5%86%99%E6%95%B4%E7%90%86/","excerpt":"","text":"1、PM: Product Manager，产品经理，又称品牌经理。举凡产品从创意到上市，所有相关的研发、调研、生产、编预算、广告、促销活动等等，都由产品经理掌控。 2、RD: Research and Development engineer，研发工程师，对某种不存在的事物进行系统的研究和开发并具有一定经验的专业工作者,或者对已经存在的事物进行改进以达到优化目的的专业工作者。 3、QA: Quality Assurance，品质保证。QA的主要职责就是质量保证工作。 4、OP: Operator，操作员，管理员。","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"微信小程序开发","slug":"移动端/微信小程序开发","date":"2019-05-24T07:56:15.000Z","updated":"2021-05-27T11:40:17.157Z","comments":true,"path":"2019/05/24/移动端/微信小程序开发/","link":"","permalink":"http://yoursite.com/2019/05/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/","excerpt":"","text":"现状：微信分享图片需要在小程序中绘制图片并保存到手机目录后进行操作。 解决方法： 使用小程序内置的canvas进行绘制图片并保存。 缺点：canvas对版本的兼容性做的不是很好，可能会出现很多问题，在部分机型上显示不一样 使用Painter以第三方依赖的方法添加到小程序的开发中，支持很多类型的图像绘制。 使用mp_canvas_drawer以第三方以来的方法添加到小程序开发","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"wechat","slug":"wechat","permalink":"http://yoursite.com/tags/wechat/"}]},{"title":"metro打包分析及热更新初探","slug":"移动端/rn/metro打包分析及热更新初探","date":"2019-05-24T07:51:24.000Z","updated":"2021-05-27T11:40:17.157Z","comments":true,"path":"2019/05/24/移动端/rn/metro打包分析及热更新初探/","link":"","permalink":"http://yoursite.com/2019/05/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF/rn/metro%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%E5%8F%8A%E7%83%AD%E6%9B%B4%E6%96%B0%E5%88%9D%E6%8E%A2/","excerpt":"","text":"定义：打包工具 react-native在0.5版本以后引入metro-bundler工具打包 在对每个模块进行捆绑时，每个模块都会分配一个固定的id，意味着不能动态更新（导入组件的顺序发生变化，或者依赖版本做了更新），将id转化为module的路径 选项 描述 entry-file 根JS文件的绝对路径 output 文件名存储输出的位置，例如 /tmp/dependencies.txt platform 用于选择模块的平台扩展 transformer 指定要使用的自定义转换器 max-workers 指定工作池将为转换文件生成的最大工作器数。默认为计算机上可用的核心数。 dev 如果为false，则跳过所有dev-only代码路径 verbose 启用日志记录 高速缓存Metro具有多层缓存：您可以设置多个缓存供Metro使用而不是一个。这有几个优点，在这个页面上我们将解释缓存如何工作。 添加global.DEV变量区分打包的执行环境(release) __DEV__ = false bundle中使用Number(int)数值型以_d的方式定义了代码模块ID，并使用_r的方式进行依赖行。如果存在模块间的改变或者修改，都有可能导致模块ID发生改变，导致旧的bundle文件不能使用。所以在拆分公共部分与业务部分的过程中，需要我们解决模块间依赖的问题。 热更新拆包&gt;&gt;&gt;&gt;&gt;comm打diff包&gt;&gt;&gt;&gt;&gt;&gt;整合包 -d：define (简单理解为模块)包括RN框架源码 js 部分、自定义js代码部分、图片资源信息，供 require 引入使用-r：require 找到 __d 定义的代码块 并执行 拆包（基础包和业务包） 原先以moduleId作为参数传递，现在改为moduleName(module的路径) 0.5 &lt;= version &lt; 0.52 0.52 &lt;= version &lt;= 0.55 0.56 &lt;= version comm打出diff包 comm 可以用于两个文件之间的比较，它有一些选项可以用来调整输出，以便执行交集、求差、以及差集操作。 交集：打印出两个文件所共有的行。 求差：打印出指定文件所包含的且不相同的行。 差集：打印出包含在一个文件中，但不包含在其他指定文件中的行。 123-1：不显示在第一个文件出现的内容；-2：不显示在第二个文件中出现的内容；-3：不显示同时在两个文件中都出现的内容。 使用comm命令生成diff包 整合初始化RN环境时就加载基础包，后续添加模块功能时只需要添加模块功能的diff包即可，在任更新的应用是，在需要热更新时，下载最新diff包去替换原先diff包，重新启动后应用最新diff包即可 包的合并 diff包合并到diff包（重复的问题的处理） 为什么要使用路径代替moudleId进行引用metro-bundler 打包处理模块时，以递增的方式给每个模块一个 module ID，使得文件直接通过 require(module ID) 的方式引用其他模块；当然，一个项目的所有模块都在一个 bundle 中是没问题的，但进行 bundle 拆分后，当框架新增或删除一个依赖时，因为模块编号的方式使得在该状况下，后续的模块的 module ID 将会错位，这将造成升级框架 bundle 的难度，每次升级，其他业务 bundle 相应的需要回归测试，加大了开发测试成本。我们的选择是直接舍弃 module ID 的引用方式，直接使用模块路径进行引用，这样无论怎么增减模块，都不会出现模块引用错误的问题，做法也比较简单，重写了 resolutionResponse.getModuleId 方法，虽然会增大一点 bundle 的 size。 问题： LoadBridge 和 ReactActivity的重写需要在com.facebook.react的报名下，否则会报错 结论：metro例子实现，无法使用google-diff合并diff包，所以metro完全是一个拆包方案，配合使用google-diff的热更新方案可以实现rn的热更新。","raw":null,"content":null,"categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"react native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"web端的搭建和部署","slug":"前端/web端的搭建和部署","date":"2019-05-24T07:47:42.000Z","updated":"2021-05-27T11:40:17.154Z","comments":true,"path":"2019/05/24/前端/web端的搭建和部署/","link":"","permalink":"http://yoursite.com/2019/05/24/%E5%89%8D%E7%AB%AF/web%E7%AB%AF%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/","excerpt":"","text":"目录[TOC] 环境搭建 安装node npm install -g webpack 配置淘宝镜像 12npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm config set registry https://registry.npm.taobao.org 安装create-react-app 1cnpm install -g create-react-app 创建项目 1create-react-app hello_world 本地服务启动，运行项目 1npm run start 项目框架|-node_modules //项目包 |-public //一般用于存放静态文件，打包时会被直接复制到输出目录(./buidle) |-src //项目源代码 | |-asserts //用于存放静态资源，打包时会经过 webpack 处理 | |-components //组件 存放 React 组件，一般是该项目公用的无状态组件 | |-containers //页面视图 | |-routes //路由 存放需要 connect model 的路由组件 | |-App.js //入口文件 | |-index //注册路由与服务 | |- serviceWorker //开发配置 |-package.json //包管理代码 |-.gitignore //Git忽略文件 集成mobx npm run eject 弹出webpack配置 如果出错请运行如下命令 123git add .git commit -am &quot;Save before ejecting&quot; 安装依赖： 12npm i --save-dev babel-plugin-transform-decorators-legacynpm i --save-dev @babel/plugin-proposal-decorators 安装mobx和mobx-react 12npm install mbox --savenpm install mobx-react --save 配置package.json 12345678910111213&quot;babel&quot;: &#123; &quot;plugins&quot;: [ [ &quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125; ] ], &quot;presets&quot;: [ &quot;react-app&quot; ] &#125; 項目部署 运行 “npm run build” 将生成的build的文件夹拷贝到服务器tomcat目录下 服务器中进入build文件夹，启动“serve -s” 注：有时候项目目录下有dist文件夹，然后生成不了build文件夹，此文件夹等同于build，将此文件夹拷贝至想同目录下进行相同的后续步骤即可部署","raw":null,"content":null,"categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"高效程序员的45个习惯","slug":"随笔/高效程序员的45个习惯","date":"2019-05-24T07:00:19.000Z","updated":"2021-05-27T11:40:17.158Z","comments":true,"path":"2019/05/24/随笔/高效程序员的45个习惯/","link":"","permalink":"http://yoursite.com/2019/05/24/%E9%9A%8F%E7%AC%94/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF/","excerpt":"","text":"敏捷 敏捷开发就是在一个高度协作的环境中，不断地使用反馈进行自我调整和完善 先难后易。我们首先要解决困难的问题，把简单的问题留到最后。 态度决定一切 出了问题，第一重要的是确定元凶。找到那个白痴！一旦证实了他的错误，就可以保证这样的问题永远不会再发生了 欲速则不达。深入理解代码，理解问题，才可以更快速的解决问题。 不要坠入快速的简单修复之中。要投入时间和精力保持代码的整洁、敞亮 对事不对人。正确阐述自己的观点，礼貌待人。没有最好的答案，只有更合适的方案 学无止境 跟踪学习新的技术变化，了解最新行情，丰富自己 团队分享知识，共同进步 顺应时代潮流，改变思维，摒弃旧的过时的技术 打破砂锅问到底 把握开发节奏，懂得时间规划 交付用户想要的软件 甲方是老大，都听他们的 敏捷编码 代码清晰表达意图，可读性高 复杂代码写注释，文档 写代码过程中，需要一段时间后验证，构建一下，早一点发现问题 高内聚，低耦合 敏捷调试 警告就是错误，要都处理掉 敏捷协作 代码风格规定 代码复查 及时汇报问题和进展 wiki是WikiWikiWeb的简称，WikiWiki源自夏威夷语，本意是快点快点。","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}]}